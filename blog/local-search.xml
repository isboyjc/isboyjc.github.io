<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>让GIS三维可视化变得简单-Cesium地球初始化</title>
    <link href="/blog/2020/08/31/cesium/%E8%AE%A9GIS%E4%B8%89%E7%BB%B4%E5%8F%AF%E8%A7%86%E5%8C%96%E5%8F%98%E5%BE%97%E7%AE%80%E5%8D%95-Cesium%E5%9C%B0%E7%90%83%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <url>/blog/2020/08/31/cesium/%E8%AE%A9GIS%E4%B8%89%E7%BB%B4%E5%8F%AF%E8%A7%86%E5%8C%96%E5%8F%98%E5%BE%97%E7%AE%80%E5%8D%95-Cesium%E5%9C%B0%E7%90%83%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="让GIS三维可视化变得简单-Cesium地球初始化"><a href="#让GIS三维可视化变得简单-Cesium地球初始化" class="headerlink" title="让GIS三维可视化变得简单-Cesium地球初始化"></a>让GIS三维可视化变得简单-Cesium地球初始化</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>开发中我们通常会需要一个干净的三维地球实例，本文将介绍 <code>Cesium</code> 如何初始化一个地球，包括地图控件的显示隐藏以及一些常用影像和标注的加载</p><p><a href="https://isboyjc.top/cesiumdemo/cesium-init/index.html" target="_blank" rel="noopener">预览Demo</a> </p><p>Cesium 是一款面向三维地球和地图的，世界级的 <code>JavaScript</code> 开源产品，它提供了基于 <code>JavaScript</code> 语言的开发包，方便用户快速搭建一款零插件的虚拟地球 Web 应用，并在性能，精度，渲染质量以及多平台，易用性上都有高质量的保证</p><p>想了解更多 Cesium 的介绍请看 👉 <a href="https://juejin.im/post/6854573221191090189" target="_blank" rel="noopener">让GIS三维可视化变得简单-初识Cesium</a> </p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>本文及后续文章启动环境皆是基于 <code>Vue-CLI3.X+</code> </p><p>使用我自己写的 <code>CLI</code> 插件 <code>vue-cli-plugin-cesium</code> 零配置搭建 <code>Cesium</code> 环境</p><p>具体环境搭建可看 👉 <a href="https://juejin.im/post/6854899697661394951" target="_blank" rel="noopener">让GIS三维可视化变得简单-Vue项目中集成Cesium</a> </p><h2 id="地球初始化"><a href="#地球初始化" class="headerlink" title="地球初始化"></a>地球初始化</h2><h3 id="申请Token"><a href="#申请Token" class="headerlink" title="申请Token"></a>申请Token</h3><p>在正式开发之前，我们首先需要去注册一个免费的 <code>Cesium ion</code> 账户</p><p>步骤如下</p><p>首先，打开 <a href="https://cesium.com/ion/" target="_blank" rel="noopener">https://cesium.com/ion/</a> 然后注册一个新的账户</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20200901115736912.jpeg" srcset="/blog/img/loading.gif" alt=""></p><p>注册成功后登录，点击 <code>Access Token</code>，跳转到 <strong><em>Access Tokens page</em></strong> 页面</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/Xnip2020-09-01_11-59-41.jpeg" srcset="/blog/img/loading.gif" alt=""></p><p>如上所示，选择 <strong><em>Default</em></strong> 默认的 <code>access token</code> 拷贝到内容中</p><pre><code class="js">Cesium.Ion.defaultAccessToken = &#39;&lt;YOUR ACCESS TOKEN HERE&gt;&#39;</code></pre><p>当然，如果你只是写写demo，那不写 <code>Token</code> 也行</p><h3 id="默认初始化"><a href="#默认初始化" class="headerlink" title="默认初始化"></a>默认初始化</h3><p>环境准备就绪之后，我们就可以初始化Cesium实例了，也就是加载地球</p><pre><code class="vue">&lt;template&gt;  &lt;div class=&quot;map-box&quot;&gt;    &lt;div id=&quot;cesiumContainer&quot;&gt;&lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;var viewer = nullexport default {  name: &quot;No01Init&quot;,  data() {    return {}  },  mounted() {    Cesium.Ion.defaultAccessToken = &#39;&lt;YOUR ACCESS TOKEN HERE&gt;&#39;    // viewer = new Cesium.CesiumWidget(&#39;cesiumContainer&#39;)    viewer = new Cesium.Viewer(&quot;cesiumContainer&quot;)    console.log(viewer)  },}&lt;/script&gt;&lt;style scoped&gt;.map-box {  width: 100%;  height: 100%;}#cesiumContainer {  width: 100%;  height: 100%;}&lt;/style&gt;</code></pre><p>如上所示，我们可以使用 <code>new Cesium.CesiumWidget</code> 或者 <code>new Cesium.Viewer</code> 的方式进行初始化，都可以，给一个容器挂载即可，运行项目后效果如下</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20200827232433642.jpeg" srcset="/blog/img/loading.gif" alt=""></p><p>可能细心的小伙伴注意到了我们初始化的 <code>viewer</code> 实例并没有写在 <code>data</code> 里，这是因为Vue中会为 <code>data</code> 中的属性做数据劫持，如果属性是一个对象，将会递归进行数据劫持，<code>viewer</code> 这个实例中的属性数量非常多，如果将它放置 <code>data</code> 中。。。只有一个下场，浏览器崩溃</p><p>我们可以在组件上放直接声明一个 <code>viewer</code> 变量，也可以使用 <code>window.viewer</code> 把 <code>viewer</code> 挂载到 <code>window</code> 上面，都可以避免这个问题</p><p>在 <code>Vue + Cesium</code> 开发中和实例有关的数据都不要放在data中，这点一定需要注意</p><h3 id="控件隐藏"><a href="#控件隐藏" class="headerlink" title="控件隐藏"></a>控件隐藏</h3><p>上面我们可以看到，在默认初始化里，页面上有很多控件，开发时我们基本用不到，但是还是先来介绍下这些控件的作用</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20200830164028938.jpeg" srcset="/blog/img/loading.gif" alt=""></p><p>在创建 <code>Cesium</code> 实例时，<code>new Cesium.Viewer</code> 构造函数有两个参数</p><ul><li>实例挂载的元素 必选项</li><li>options 初始化配置对象 可选项</li></ul><p>在 <code>options</code> 对象中，我们可以配置初始化的一些控件显示隐藏以及一些渲染配置，这里列举出一些常用的配置</p><pre><code class="js">viewer = new Cesium.Viewer(&quot;cesiumContainer&quot;, {  animation: false, // 隐藏动画控件  baseLayerPicker: false, // 隐藏图层选择控件  fullscreenButton: false, // 隐藏全屏按钮  vrButton: false, // 隐藏VR按钮，默认false  geocoder: false, // 隐藏地名查找控件  homeButton: false, // 隐藏Home按钮  infoBox: false, // 隐藏点击要素之后显示的信息窗口  sceneModePicker: false, // 隐藏场景模式选择控件  selectionIndicator: true, // 显示实体对象选择框，默认true  timeline: false, // 隐藏时间线控件  navigationHelpButton: false, // 隐藏帮助按钮  scene3DOnly: true, // 每个几何实例将只在3D中呈现，以节省GPU内存  shouldAnimate: true, // 开启动画自动播放  sceneMode: 3, // 初始场景模式 1：2D 2：2D循环 3：3D，默认3  requestRenderMode: true, // 减少Cesium渲染新帧总时间并减少Cesium在应用程序中总体CPU使用率  // 如场景中的元素没有随仿真时间变化，请考虑将设置maximumRenderTimeChange为较高的值，例如Infinity  maximumRenderTimeChange: Infinity})</code></pre><p>我们使用上面 <code>options</code> 配置，即可把页面上的控件全部隐藏掉，如下图所示</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/48991-Xnip2020-08-30_18-33-57.jpg" srcset="/blog/img/loading.gif" alt=""></p><p>可以看到，虽然控件已经没有了，但是屏幕下方还有 <code>Cesium</code> 的 <code>logo</code> 信息，我们需要让它也不显示</p><pre><code class="js">// 隐藏下方Cesium logoviewer.cesiumWidget.creditContainer.style.display = &quot;none&quot;</code></pre><p>如上所示，只需再来一行额外的配置隐藏 <code>logo</code> 信息，即可获得一个干净的地球实例，最终效果图如下</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/Xnip2020-08-30_18-40-24.jpeg" srcset="/blog/img/loading.gif" alt=""></p><h3 id="加载影像"><a href="#加载影像" class="headerlink" title="加载影像"></a>加载影像</h3><p><code>Cesium</code> 支持多种服务来源的高精度影像（地图）数据的加载和渲染，图层支持排序和透明混合，每个图层的亮度（brightness），对比度（ contrast），灰度（gamma），色调（hue），饱和度（saturation）都是可以动态修改的</p><p>这里我们忽略细节，先简单介绍下影像相关的几个类，然后直接写代码去添加一些不同的常用影像图层</p><p><strong>PS：Cesium是一个构造函数，在这个构造函数上又有无数个静态属性，它们也是不同作用的构造函数，按照OOP的方式理解，Cesium是一个父类，而它又有很多子类用来做不同的事情</strong> </p><h4 id="Cesium-ImageryProvider类"><a href="#Cesium-ImageryProvider类" class="headerlink" title="Cesium.ImageryProvider类"></a>Cesium.ImageryProvider类</h4><p>说到影像这块儿，首先，我们要了解一下 <code>imageryProvider</code> 这个类，<code>Imagery</code> 可以翻译为图像、影像，这里就统一称之为影像</p><p><code>ImageryProvider</code> 类及其子类封装了加载各种影像图层的方法，其中 <code>Cesium.ImageryProvider</code> 类是抽象类、基类或者可将其理解为接口，它不能被直接实例化</p><p>可以将 <code>ImageryProvider</code> 看作是影像图层的数据源，我们想使用哪种影像图层数据或服务就用对应的 <code>ImageryProvider</code> 类型去加载即可</p><p><code>ImageryProvider</code> 类包含的类型</p><ul><li>ArcGisMapServerImageryProvider<ul><li>ArcGIS Online和Server的相关服务</li></ul></li><li>BinaMapsImageryProvider<ul><li>Bing地图影像，可以指定mapStyle，详见BingMapsStyle类</li></ul></li><li>GoogleEarthEnterpriselmageryProvider<ul><li>企业级服务</li></ul></li><li>GridImageryProvider<ul><li>渲染每一个瓦片内部的格网，了解每个瓦片的精细度</li></ul></li><li>IonImageryProvider<ul><li>Cesium ion REST API提供的影像服务</li></ul></li><li>MapboxImageryProvider<ul><li>Mapbox影像服务，根据 mapId 指定地图风格</li></ul></li><li>MapboxStyleImageryProvider<ul><li>Mapbox影像服务，根据 styleId 指定地图风格</li></ul></li><li>createOpenStreetMapImageryProvider<ul><li>OpenStreetMap提供的影像服务</li></ul></li><li>SingleTilelmageryProvider<ul><li>单张图片的影像服务，适合离线数据或对影像数据要求并不高的场景下</li></ul></li><li>TileCoordinatesImageryProvider<ul><li>渲染每一个瓦片的围，方便调试</li></ul></li><li>TileMapServicelmageryProvider<ul><li>根据MapTiler规范，可自己下载瓦片，发布服务，类似ArcGIS影像服务的过程</li></ul></li><li>UrlTemplateImageryProvider<ul><li>指定url的format模版，方便用户实现自己的Provider，比如国内的高德，腾讯等影像服务，url都是一个固定的规范，都可以通过该Provider轻松实现。而OSM也是通过该类实现的</li></ul></li><li>WebMapServiceImageryProvider<ul><li>符合WMS规范的影像服务都可以通过该类封装，指定具体参数实现</li></ul></li><li>WebMapTileServicelmageryProvider<ul><li>服务WMTS1.0.0规范的影像服务，都可以通过该类实现，比如国内的天地图</li></ul></li></ul><h4 id="Cesium-ImageryLayer类"><a href="#Cesium-ImageryLayer类" class="headerlink" title="Cesium.ImageryLayer类"></a>Cesium.ImageryLayer类</h4><p>要知道，一份 <code>GIS</code> 数据会被组织成图层符号化并渲染，数据相当于内在血液、内脏，信息量丰富，而图层相当于外在皮毛、衣服，用于呈现给外界</p><p><code>Cesium</code> 同样将数据源组织成图层符号化并渲染，<code>Cesium.ImageryLayer</code> 类就用于表示 <code>Cesium</code> 中的影像图层，它就相当于皮毛、衣服，将数据源包裹，它需要数据源为其提供内在丰富的地理空间信息和属性信息</p><h4 id="Cesium-ImageryLayerCollection类"><a href="#Cesium-ImageryLayerCollection类" class="headerlink" title="Cesium.ImageryLayerCollection类"></a>Cesium.ImageryLayerCollection类</h4><p><code>Cesium.ImageryLayerCollection</code> 类是 <code>ImageryLayer</code> 实例的容器，它可以装载、放置多个 <code>ImageryLayer</code> 实例，而且它内部放置的 <code>ImageryLayer</code> 实例是有序的</p><p><code>Cesium.Viewer</code> 类对象中包含的 <code>imageryLayers</code> 属性就是 <code>ImageryLayerCollection</code> 类的实例，它包含了当前 <code>Cesium</code> 应用程序所有的 <code>ImageryLayer</code> 类对象，即当前地球上加载的所有影像图层</p><p>知道了影像图层基础的体系结构，那么影像加载就简单了，上面我们也可以看到 <code>ImageryProvider</code> 类种类非常多，列举出来是为了给大家展示下它可以加载什么影像，但是一一演示不现实，所以接下来我们就来看几个常见影像加载</p><h4 id="加载天地图影像"><a href="#加载天地图影像" class="headerlink" title="加载天地图影像"></a>加载天地图影像</h4><p>按照上述所说，首先我们要加载影像图层的数据源，Cesium地球默认加载的是 <code>bing</code> 地图影像，所以我们要先从容器中删除这个默认影像</p><pre><code class="js">viewer.imageryLayers.remove(viewer.imageryLayers.get(0))</code></pre><p>然后，我们加载影像图层的数据源</p><pre><code class="js">let tianditu = new Cesium.WebMapTileServiceImageryProvider({  url:&quot;http://t0.tianditu.com/img_w/wmts?service=wmts&amp;request=GetTile&amp;version=1.0.0&amp;LAYER=img&amp;tileMatrixSet=w&amp;TileMatrix={TileMatrix}&amp;TileRow={TileRow}&amp;TileCol={TileCol}&amp;style=default&amp;format=tiles&amp;tk=ebf64362215c081f8317203220f133eb&quot;,  layer: &quot;tdtBasicLayer&quot;,  style: &quot;default&quot;,  format: &quot;image/jpeg&quot;,  tileMatrixSetID: &quot;GoogleMapsCompatible&quot;,  show: false,})</code></pre><p><code>url</code> 字段中的 <code>tk</code> 为天地图服务token，去天地图官网注册申请一个即可</p><p>随后，我们将数据源添加至 <code>ImageryLayer</code> 类容器进行符号化并渲染即可</p><p>将数据源添加至 <code>ImageryLayer</code> 类容器进行符号化并渲染有两种方法，第一种是在初始化 <code>viewer</code> 实例时的 <code>options</code> 配置中，你可以直接在 <code>options</code> 对象的 <code>imageryProvider</code> 属性中放置数据源即可</p><pre><code class="js">new Cesium.Viewer(&quot;cesiumContainer&quot;,{  imageryProvider: tianditu})</code></pre><p>第二种方法，使用 <code>viewer</code> 实例中 <code>imageryLayers</code> 属性的 <code>addImageryProvider</code> 方法来添加即可</p><pre><code class="js">let imagery = viewer.imageryLayers.addImageryProvider(tianditu)</code></pre><p>天地图影像预览如下</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/tianditu.jpeg" srcset="/blog/img/loading.gif" alt=""></p><h4 id="加载谷歌影像"><a href="#加载谷歌影像" class="headerlink" title="加载谷歌影像"></a>加载谷歌影像</h4><p>上面步骤已经知悉，我们就不一一叙说了，下面直接看代码就好</p><pre><code class="js">viewer.imageryLayers.remove(viewer.imageryLayers.get(0))let imagery = viewer.imageryLayers.addImageryProvider(  new Cesium.UrlTemplateImageryProvider({    url: &quot;http://mt1.google.cn/vt/lyrs=s&amp;hl=zh-CN&amp;x={x}&amp;y={y}&amp;z={z}&amp;s=Gali&quot;,    baseLayerPicker : false  }))</code></pre><p>谷歌影像预览如下</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/guge.jpeg" srcset="/blog/img/loading.gif" alt=""></p><h4 id="加载ArcGIS影像"><a href="#加载ArcGIS影像" class="headerlink" title="加载ArcGIS影像"></a>加载ArcGIS影像</h4><pre><code class="js">viewer.imageryLayers.remove(viewer.imageryLayers.get(0))let imagery = viewer.imageryLayers.addImageryProvider(  new Cesium.ArcGisMapServerImageryProvider({    url:&#39;https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer&#39;,    baseLayerPicker : false  }))</code></pre><p>ArcGIS影像预览如下</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/arcgis.jpeg" srcset="/blog/img/loading.gif" alt=""></p><h4 id="加载高德影像"><a href="#加载高德影像" class="headerlink" title="加载高德影像"></a>加载高德影像</h4><pre><code class="js">viewer.imageryLayers.remove(viewer.imageryLayers.get(0))let imagery = viewer.imageryLayers.addImageryProvider(  new Cesium.UrlTemplateImageryProvider({    maximumLevel:18,//最大缩放级别    url : &#39;https://webst02.is.autonavi.com/appmaptile?style=6&amp;x={x}&amp;y={y}&amp;z={z}&#39;,    style: &quot;default&quot;,    format: &quot;image/png&quot;,    tileMatrixSetID: &quot;GoogleMapsCompatible&quot;  }))</code></pre><p>高德影像预览如下</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/gaode.jpeg" srcset="/blog/img/loading.gif" alt=""></p><h4 id="加载天地图标注"><a href="#加载天地图标注" class="headerlink" title="加载天地图标注"></a>加载天地图标注</h4><p>上述影像的加载，可以看到，地图上是没有标注的，我们需要额外加载标柱，同样的，它也是图层</p><pre><code class="js">let label = viewer.imageryLayers.addImageryProvider(  new Cesium.WebMapTileServiceImageryProvider({    url: &quot;http://t0.tianditu.com/cia_w/wmts?service=wmts&amp;request=GetTile&amp;version=1.0.0&amp;LAYER=cia&amp;tileMatrixSet=w&amp;TileMatrix={TileMatrix}&amp;TileRow={TileRow}&amp;TileCol={TileCol}&amp;style=default.jpg&quot;+&quot;&amp;tk=&quot;+&quot;19b72f6cde5c8b49cf21ea2bb4c5b21e&quot;,    layer: &quot;tdtAnnoLayer&quot;,    style: &quot;default&quot;,    maximumLevel: 18, //天地图的最大缩放级别    format: &quot;image/jpeg&quot;,    tileMatrixSetID: &quot;GoogleMapsCompatible&quot;,    show: false,  }))</code></pre><p>同样的，和天地图影像一样，不要忘了替换 <code>tk</code> 哦</p><p>天地图标注预览如下</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/tianditubiaozhu.jpeg" srcset="/blog/img/loading.gif" alt=""></p><h4 id="影像亮度调整"><a href="#影像亮度调整" class="headerlink" title="影像亮度调整"></a>影像亮度调整</h4><p>我们加载影像拿到影像实例 <code>imagery</code> 后，可以通过其 <code>brightness</code> 属性调节亮度，取值 <code>0～1</code> ，默认为1</p><pre><code class="js">imagery.brightness = 0.9</code></pre><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>这次就到这了，其实不止是做Cesium开发的人群，做前端的同学学一学这些还是有些用处的，可以为你的页面或项目增色不少，后续内容请看暂定目录</p><ul><li><p><a href="https://juejin.im/post/6854573221191090189" target="_blank" rel="noopener">让GIS三维可视化变得简单-初识Cesium</a> </p></li><li><p><a href="https://juejin.im/post/6854899697661394951" target="_blank" rel="noopener">让GIS三维可视化变得简单-Vue项目中集成Cesium</a> </p></li><li><p><a href="">让GIS三维可视化变得简单-Cesium地球初始化</a> </p></li><li><p>暂定 - 让GIS三维可视化变得简单-Cesium坐标转换</p></li><li><p>暂定 - 让GIS三维可视化变得简单-Cesium球体自转</p></li><li><p>暂定 - 让GIS三维可视化变得简单-Cesium实体Entity及事件</p></li><li><p>暂定 - 让GIS三维可视化变得简单-Cesium模型数据之3DTiles</p></li><li><p>暂定 - 让GIS三维可视化变得简单-Cesium模型数据之gltf</p></li><li><p>暂定 - 让GIS三维可视化变得简单-Cesium模型数据之geojson</p></li><li><p>暂定 - 让GIS三维可视化变得简单-Cesium模型数据之czml</p></li><li><p>暂定 - 让GIS三维可视化变得简单-Cesium流动线绘制</p></li><li><p>暂定让GIS三维可视化变得简单-Cesium气泡弹窗</p></li><li><p>暂定 - 让GIS三维可视化变得简单-Cesium粒子系统(火灾、雪花、喷水)</p></li><li><p>暂定 - 让GIS三维可视化变得简单-Cesium鹰眼图</p></li><li><p>暂定 - 让GIS三维可视化变得简单-Cesium结合Echarts</p></li></ul><p>Cesium国内教程很少，文档也是英文的，不太好入手，所以此系列只是简单入门以及一些效果制作（说白了就是介绍一些简单使用和一些好玩的例子），每一篇介绍一个点，挺难涉及到Cesium核心原理，因为我也在学习中，看后期个人学习情况，我是觉得什么好玩就想学。。。</p><p>没有专业的 GIS 基础知识积累真的好难，此系列不定期更新，暂时先排这么多，不定期插入，不定期更新，敬请期待</p><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>原创不易，看完点赞、养成习惯，此文收录在 GitHub，更多精彩请看 👉 <a href="https://github.com/isboyjc/blog/issues" target="_blank" rel="noopener">isboyjc/blog/issues</a> </p><p>如有错误请指出，互相学习，先行谢过，一个前端的 <code>Cesium</code> 学习过程的积累分享，自知深度不够，不喜勿喷</p>]]></content>
    
    
    <categories>
      
      <category>Cesium系列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cesium</tag>
      
      <tag>数据可视化</tag>
      
      <tag>WebGIS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>让GIS三维可视化变得简单-Vue项目中集成Cesium</title>
    <link href="/blog/2020/07/29/cesium/%E8%AE%A9GIS%E4%B8%89%E7%BB%B4%E5%8F%AF%E8%A7%86%E5%8C%96%E5%8F%98%E5%BE%97%E7%AE%80%E5%8D%95-Vue%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%9B%86%E6%88%90Cesium/"/>
    <url>/blog/2020/07/29/cesium/%E8%AE%A9GIS%E4%B8%89%E7%BB%B4%E5%8F%AF%E8%A7%86%E5%8C%96%E5%8F%98%E5%BE%97%E7%AE%80%E5%8D%95-Vue%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%9B%86%E6%88%90Cesium/</url>
    
    <content type="html"><![CDATA[<h1 id="让GIS三维可视化变得简单-Vue项目中集成Cesium"><a href="#让GIS三维可视化变得简单-Vue项目中集成Cesium" class="headerlink" title="让GIS三维可视化变得简单-Vue项目中集成Cesium"></a>让GIS三维可视化变得简单-Vue项目中集成Cesium</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>市面上的前端框架中，Vue+Cesium 可谓是最佳搭档，一般做 Cesium B 端产品的公司都会使用 Vue，所以后续内容都将基于 Vue</p><p>通常情况下，我们要在 Vue 中使用 Cesium，首先要安装 Cesium，然后要在 vue-cli 的 webpack 配置很多东西，对一些有经验的人来说只不过麻烦些，但是对 Cesium 的初学者来说会很痛苦，因为没有使用过，也不知到要怎么配置，只能搜索网上的教程，一步一步踩坑</p><p>其实不管是有经验或是初学者，每次写项目重复配置这些东西都很麻烦</p><p><code>vue-cli-plugin-cesium</code> 就是为了解决这个问题</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><code>vue-cli-plugin-cesium</code> 是一款针对 Cesium 的 VueCLI 扩展插件，使用它将会让我们在 VueCLI 中零配置使用 Cesium，基于 VueCLI3.0+ </p><p>其实就是我开始做 Cesium 的时候，觉得每次配置太麻烦，就写了个插件免配置从而节约开发时间，后来就发到几个 Cesium 开发群里给大家体验了一波，效果还不错</p><p>它会在我们已经创建好的 VueCLI 项目中做基于 Cesium 的扩展，截止目前它的功能也可以说它解决的问题如下</p><ul><li><p>自动安装 Cesium 并追加至 <code>package.json</code> 依赖项(可自选版本)</p></li><li><p>自动扩展 VueCLI 中 Cesium 相关的 webpack 配置</p><ul><li>添加一个 <code>cesium</code> 别名，以便我们在项目中轻松的引入 Cesium 文件资源</li><li>使 Cesium 对象实例可在每个 Vue 模块中使用而无须 import 引入</li><li>使 webpack 可正常打包 Cesium</li><li>允许 webpack 友好地在 Cesium 中使用 require，解决 require 引入警告</li><li>开发环境生成 sourcemap，生产环境取消 sourcemap</li><li>生产环境抽取公共模块执行压缩</li><li>生产环境 loader 切换到优化模式</li></ul></li><li><p>自动在全局 main.js 中引入<code>Widgets.css</code>，可选</p></li><li><p>自动在 <code>components/</code> 文件夹下生成示例文件，可选</p></li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><code>vue-cli-plugin-cesium</code> 是基于 VueCLI 的扩展插件，所以在使用前要先使用 VueCLI 创建一个 Vue 项目</p><p>如果您不了解 VueCLI 的使用，请移步 <a href="https://cli.vuejs.org/zh/guide/" target="_blank" rel="noopener">VueCLI-官网</a></p><p>当前插件只支持 <code>VueCLI3.0+</code> 版本哦</p><p>创建好一个 Vue 项目后就可以按照以下步骤使用该插件了，同所有 VueCLI 插件一样，它有两种使用方式，推荐使用方式一</p><h3 id="使用方式一"><a href="#使用方式一" class="headerlink" title="使用方式一"></a>使用方式一</h3><p>推荐使用 <code>vue add</code> 这种方式安装，一步到位，简单便捷</p><pre><code class="js">vue add vue-cli-plugin-cesium// 非全局安装的vue-cli可以npx vue add vue-cli-plugin-cesium</code></pre><h3 id="使用方式二"><a href="#使用方式二" class="headerlink" title="使用方式二"></a>使用方式二</h3><p>首先安装 <code>vue-cli-plugin-cesium</code> 插件，推荐使用 yarn 安装，因为它更简洁</p><pre><code class="js">// npmnpm install --save-dev vue-cli-plugin-cesium// yarnyarn add vue-cli-plugin-cesium</code></pre><p>安装完成后我们要使用 <code>vue invoke</code> 来初始化这个插件</p><pre><code class="js">vue invoke vue-cli-plugin-cesium// 非全局安装的vue-cli可以npx vue invoke vue-cli-plugin-cesium</code></pre><h3 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h3><p>在 <code>vue invoke</code> 或 <code>vue add</code> 的过程中会有三个询问</p><p><strong>询问一</strong> </p><pre><code class="txt">Please choose a version of &#39;cesium&#39; from this list请在列表中选择 cesium 的版本</code></pre><p>在此选择想使用的 <code>Cesium</code> 版本</p><p><strong>询问二</strong> </p><pre><code class="txt">Whether to import styles globally. This operation will automatically import widgets.css in main.js是否全局引入样式,该操作将自动在main.js引入widgets.css？</code></pre><p>此项默认为 yes，该操作将自动在 main.js 引入 widgets.css，即全局引入 Cesium 的 css 样式</p><p>如果此项设置为 no，那么开发时我们要手动引入<code>widgets.css</code>样式文件，引入命令如下</p><pre><code class="txt">import &quot;cesium/Widgets/widgets.css&quot;</code></pre><p><strong>询问三</strong> </p><pre><code class="txt">Whether to add sample components to the project components directory是否添加示例组件到项目components目录?</code></pre><p>此选项默认为 yes，该操作会自动在 <code>src/components</code> 文件夹下生成 <code>CesiumExample</code> 文件夹，此文件夹中包含一些 Cesium 的使用示例供参考</p><p>如果此项设置为 no，则不生成示例文件</p><p>生成的示例中每个文件为一个模块，可直接模块引入至项目中查看，欢迎大家PR示例模块</p><h3 id="GUI-安装"><a href="#GUI-安装" class="headerlink" title="GUI 安装"></a>GUI 安装</h3><p>如果我们使用 <code>vue ui</code> 创建项目，也可以直接在项目创建后的插件选项里搜索 <code>vue-cli-plugin-cesium</code> 并安装</p><p>如下所示：</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/gui005.png" srcset="/blog/img/loading.gif" alt=""></p><p>选中插件点击安装</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/gui002.png" srcset="/blog/img/loading.gif" alt=""></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>开发时如下，直接在模块中使用 Cesium 对象即可</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/code01.png" srcset="/blog/img/loading.gif" alt=""></p><p>查看示例组件，模块引入即可，如下</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/code02.png" srcset="/blog/img/loading.gif" alt=""></p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><p>当你顺顺利利安装好了插件后开始开发，使用 Cesium 对象时，可能会遇到下面这种错误</p><pre><code class="js">Error：Cesium is no-undef</code></pre><p>前端小伙伴都应该知道，这好像是 Eslint 语法错误，没错，这是因为插件内部使用了 Webpack 的内置模块 <code>ProvidePlugin</code> 来做到使用 Cesium 对象时将不再需要 <code>import</code> 或 <code>require</code> 引入，而一般我们在使用 VueCLI 创建项目时会默认带上 Eslint，Eslint 语法检验会认为 Cesium 是一个未声明的变量，于是抛出了错误</p><p><strong>解决办法一</strong> </p><p><code>package.json</code> 中配置 Eslint 规则允许 <code>no-undef</code> ，如下所示，在 <code>package.json</code> 中 <code>eslintConfig</code> 字段下的 <code>rules</code> 配置 <code>&quot;no-undef&quot;: 0</code> ，在不关掉 Eslint 的情况下单独配置允许未声明的变量</p><pre><code class="js">{  &quot;dependencies&quot;: {},  &quot;devDependencies&quot;: {},  &quot;eslintConfig&quot;: {    &quot;root&quot;: true,    &quot;env&quot;: {      &quot;node&quot;: true    },    &quot;extends&quot;: [      &quot;plugin:vue/essential&quot;,      &quot;eslint:recommended&quot;    ],    &quot;parserOptions&quot;: {      &quot;parser&quot;: &quot;babel-eslint&quot;    },    &quot;rules&quot;: {      &quot;no-undef&quot;: 0    }  }}</code></pre><p><strong>解决办法二</strong> </p><p>我们可以通过在 <code>package.json</code> 中直接删除 <code>eslintConfig</code> 对象来直接关掉 Eslint</p><p>也可以在 <code>vue.config.js</code> 中配置关掉 Eslint，如下</p><pre><code class="js">module.exports = {  lintOnSave: false}</code></pre><p>修改之后重启服务即可，推荐使用第一种办法，Eslint 语法校验是一个极好的约束开发的工具，可以让我们同一个团队内的语法风格统一，最好还是不要关掉</p><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>安装完成后，就可以在 vue 项目中任意模块中使用 Cesium 了，你可以在每个 Vue 模块中直接使用 Cesium 对象实例而无须 import 引入，如果你想引入 cesium 包下的文件，我们为 Cesium 包的目录设置了别名，就叫 <code>cesium</code>，所以在引入 <code>Widgets.css</code> 时引入路径为 <code>cesium/Widgets/widgets.css</code> ，如果对您有所帮助，那么这将是我的荣幸</p><p>目前使用 VueCLI2.0 的应该很少了，当然如果你使用的脚手架 <code>&gt; VueCLI3.0</code> ，那么就不能使用这个插件了，不过不用担心，VueCLI2.0的配置也是有的，只不过需要你自己手动配置了，详情可以看 👉 <a href="https://mp.weixin.qq.com/s/DLnMMQqb8meMRXyKiUqUqA" target="_blank" rel="noopener">VueCLI2.0集成Cesium</a> </p><p>后期也会慢慢完善此插件，并不停迭代，也欢迎大家提出建议，欢迎 PR</p><p>插件地址 👉 <a href="https://github.com/isboyjc/vue-cli-plugin-cesium" target="_blank" rel="noopener">isboyjc/vue-cli-plugin-cesium</a> </p><p>文章收录在 GitHub，更多精彩请看 👉 <a href="https://github.com/isboyjc/blog/issues" target="_blank" rel="noopener">isboyjc/blog/issues</a> </p><p>是前端，又不只是前端，所以不正经，认真分享干货，公众号「不正经的前端」，欢迎关注</p>]]></content>
    
    
    <categories>
      
      <category>Cesium系列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cesium</tag>
      
      <tag>数据可视化</tag>
      
      <tag>WebGIS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>让GIS三维可视化变得简单-初识Cesium</title>
    <link href="/blog/2020/07/27/cesium/%E8%AE%A9GIS%E4%B8%89%E7%BB%B4%E5%8F%AF%E8%A7%86%E5%8C%96%E5%8F%98%E5%BE%97%E7%AE%80%E5%8D%95-%E5%88%9D%E8%AF%86Cesium/"/>
    <url>/blog/2020/07/27/cesium/%E8%AE%A9GIS%E4%B8%89%E7%BB%B4%E5%8F%AF%E8%A7%86%E5%8C%96%E5%8F%98%E5%BE%97%E7%AE%80%E5%8D%95-%E5%88%9D%E8%AF%86Cesium/</url>
    
    <content type="html"><![CDATA[<h1 id="让GIS三维可视化变得简单-初识Cesium"><a href="#让GIS三维可视化变得简单-初识Cesium" class="headerlink" title="让GIS三维可视化变得简单-初识Cesium"></a>让GIS三维可视化变得简单-初识Cesium</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20200715235121472.png" srcset="/blog/img/loading.gif" alt=""></p><p>从去年开始无脑接触 <code>Cesium</code> 三维 GIS 可视化，入坑之后一直到到现在，其实已经写了多个项目了，中间也遇到了很多坑点，很早就想分享其中所获了，只是觉得不太专业而且没有太多时间，拖到现在，从开始接触 <code>Cesium</code> ，加了一个QQ交流群，从刚开始的 200 人，到现在的 3000 人，好像使用 Cesium 做可视化方向的人越来越多了，并且其中很多人都是如我一样，从前端半路入坑</p><p>记得好像是公众号「Cesium中文网」曾发过一篇文章名叫「Cesium只剩可视化了吗」个人觉得写的很棒，虽然 Cesium 不止是可以做可视化这么简单，但是目前大部分选择投入其中的人是奔着可视化这个方向的，这点从 300 到 3000 足以证明</p><p>个人写作习惯篇幅很长，文章产出总是很慢，之所以还想要写这个系列的文章，大概有三点</p><ul><li>Cesium 毕竟是一个世界级 <code>JavaScript</code> 开源产品，做 CS 还好，但是做 BS，特别是可视化产品是需要扎实的前端基础的，相比较下专业的 GIS 对前端一些框架了解好像不太多，并不能很好的把自己丰富的 GIS 知识或者说一些很强大的功能在前端炫酷的展现出来，毕竟功能再强大，不经过雕琢和装饰总归还是不能被人推崇的</li><li>近两年前端同学半路入坑 Cesium 的人太多了，但是由于没有扎实的 GIS 基础，涉及深入一点的 GIS 核心的效果实现并不容易，一路上的磕磕绊绊实在是太多了，这个是亲身经历，且十分惨痛</li><li>关于 Cesium，一直是自己在摸索，项目也写不少了，但是肯定有很多地方在更为专业的人看来是闹着玩一样，所以水水文章看看进自己脑子的知识有哪些是炸弹，回顾一遍排排雷，查漏补缺</li></ul><p>其实我个人对 CS 方面完全没有经验，BS 做可视化有些项目经验，但是说实话，只懂皮毛，不过在前进的道路上爬了太多的坑，所以可以与大家分享些爬坑经验，也充实下自己，涉入 GIS 不会很深，不过一般的还是可以的，算带大家入入门吧，也希望可以和大家一起查漏补缺，正所谓山中无老虎，猴子称大王，没错，我就是那只猴子，谁让现在Cesium相关的技术帖辣么少呢</p><p>写的帖子目前想法是除了入门之外会更倾向于各种好玩炫酷的效果制作，所以它也会更倾向于实战系列，你也可以把它当作入门级教程，这个系列我尽量每文简短些，控制在5000字以内，让大家看着舒服 😄</p><p><strong>PS：</strong> </p><ul><li><p><strong>CS</strong> 指 <code>Client/Server</code>，客户端/服务器模式，桌面级应用，响应速度快，安全性强，个性化能力强，响应数据较快，兼容性差，不跨平台，开发成本高</p></li><li><p><strong>BS</strong> 指 <code>Browser/Server</code>，浏览器/服务器模式，Web应用，可以实现跨平台，客户端零维护，共享性强，但是个性化能力稍低，响应速度稍慢</p></li></ul><h2 id="得瑟一下"><a href="#得瑟一下" class="headerlink" title="得瑟一下"></a>得瑟一下</h2><p>看到这篇文章时，可能大家对 Cesium 有所了解，也可能一无所知，甚至不知道它能干什么，先给大家看一个我这边刚入坑时做的第一个基于 Cesium 的可视化产品，现在看其实挺一般的，不过当时刚做出来时确实是挺开心挺有成就感的，也让大家对 Cesium 加深下了解，当然这个项目中只是简单的运用了 Cesium，它远不止于此</p><ul><li><p><a href="http://villageapi.sdzhujialin.com/zjl_3d/index.html" target="_blank" rel="noopener">线上预览</a>  电脑配置低的话还是查看GIF吧</p></li><li><p><a href="https://gitee.com/IsboyJC/PictureBed/raw/master/other/20190929_175200.2020-07-2723_56_55.gif" target="_blank" rel="noopener">GIF预览</a>    压缩的比较厉害，高清预览视频可以到公众号「不正经的前端」查看</p></li></ul><p>那么接下来话不多说，赶紧来认识下 Cesium 吧</p><h2 id="Cesium简介"><a href="#Cesium简介" class="headerlink" title="Cesium简介"></a>Cesium简介</h2><h3 id="什么是Cesium"><a href="#什么是Cesium" class="headerlink" title="什么是Cesium"></a>什么是Cesium</h3><p>Cesium 是一款面向三维地球和地图的，世界级的 <code>JavaScript</code> 开源产品，它提供了基于 <code>JavaScript</code> 语言的开发包，方便用户快速搭建一款零插件的虚拟地球 Web 应用，并在性能，精度，渲染质量以及多平台，易用性上都有高质量的保证</p><p>Cesium是基于 <code>Apache2.0</code> 许可的开源程序，它可以免费的用于商业和非商业用途，它隶属于 AGI（Analytical Graphics Incorporation）公司，三位创始人曾在通用公司宇航部的供职工程师，提供 STK（System/Satellite Toolkit Kit）和 Cesium两款产品，该公司是航天分析软件的领导者，而 STK 则是该公司的旗舰产品，比如 <code>马航MH370</code> 搜救过程就采用了 STK 软件，经过多年来在时空数据的积累，AGI 公司逐渐掌握了大量 3D 可视化技术，也感受到各行各业对海量 3D 数据的强烈需求，因此于2011年创建了 CesiumJS 开源项目，围绕 Cesium 生态圈打造了一套安全可靠易扩展且平台独立的企业级解决方案</p><p>而 Chrome 也是在2011年2月份推出了支持 WebGL 的第一个版本，在这点上，Cesium算是第一个敢吃螃蟹的人，Cesium 原意是化学元素铯，铯是制造原子钟的关键元素，通过命名强调了 Cesium 产品专注于基于时空数据的实时可视化应用</p><p>至今，CesiumJS 的下载量超过 <code>1,000,000</code>，是一个为数百万用户提供了强大的应用程序</p><p>作为前端程序员，只是单纯做可视化，其实在我看来， Cesium 与 <code>Leaflet</code> 以及 <code>OpenLayer</code> 等没有本质的区别，只是Cesium支持三维场景等等，做的更漂亮</p><h3 id="Cesium可以做什么"><a href="#Cesium可以做什么" class="headerlink" title="Cesium可以做什么"></a>Cesium可以做什么</h3><p>支持全球级别的高精度的地形和影像服务</p><p>支持 <code>2D、2.5D、3D</code> 形式的地图展示，真正的二三维一体化</p><p>支持矢量、海量模型数据（倾斜，BIM，点云等）</p><p>支持基于时间轴的动态数据可视化展示</p><h3 id="Cesium的浏览器兼容性"><a href="#Cesium的浏览器兼容性" class="headerlink" title="Cesium的浏览器兼容性"></a>Cesium的浏览器兼容性</h3><p>学习和使用 Cesium 前，首先要检查一下你的浏览器是否支持 <code>WebGL</code>，目前，大多数平台和浏览器都支持WebGL，在这些环境下运行 Cesium 并没有太大的问题，但效果和性能是否能够满足不同的需求，就需要考虑很多细节和额外因素</p><p>大多数平台和浏览器都支持 <code>WebGL1.0</code> 标准，也就是 <code>OpenGL ES2.0</code> 规范，2017年年初，<code>Chrome</code> 新版本低调的支持 <code>WebGL2.0</code>，随着各硬件厂商 GPU 性能的提升和 <code>WebGL2.0</code> 规范的成熟，<code>WebGL</code> 技术会有更大的提升潜力，不过无论是 PC 还是移动端，<code>Chrome</code> 都是 <code>WebGL</code> 开发和应用的最佳平台，所以，如果没有特殊的硬性要求，建议大家使用 <code>Chrome</code> 学习和开发 Cesium</p><p>你可以在浏览器中访问 <a href="https://webglreport.com/" target="_blank" rel="noopener">WebGL Report</a> 来查看你的浏览器支持情况</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20200715000329348.png" srcset="/blog/img/loading.gif" alt=""></p><p>如上图红框中显示，这个浏览器支持 <code>WebGL 1</code>，你也可以点击 <code>WebGL 2</code> 查看自己的浏览器支持情况</p><p>清单中除了显示了你的浏览器是否支持 <code>WebGL</code> 标准，还有很多，比如</p><ul><li>是否支持深度纹理</li><li>顶点着色器的最大属性数</li><li>是否支持ANGLE 扩展</li><li>等等</li></ul><h2 id="一个HelloWorld程序"><a href="#一个HelloWorld程序" class="headerlink" title="一个HelloWorld程序"></a>一个HelloWorld程序</h2><p>其实上面的都是废话，但是你又必须要知道，其实对我们写程序是没有一点帮助的，只是提供数据为了给大家了解下 Cesium 的强大</p><p>有的人可能认为学习 Cesium 之前应该学习学习 GIS 基础架构、坐标系、投影、存储类型等等等等，其实我觉得如果你有这些常识，那自然是极好的，但是如果没这些知识储备，在刚开始学习 Cesium 的时候，学习这些乱七八糟的，完全没必要</p><p>因为这些基础知识学起来很容易打磨积极性，还不如先写几个 demo 程序来的实在，毕竟总得先体会下它的魅力，就像你走在路上，你看到前面有个坑，那肯定会绕过去，但是如果坑上有些草，还有些漂亮的花，那就不一样了</p><p>SO，我们先搞个地球出来，后面哪里有需要再穿插说一些常识</p><h3 id="编译器选择"><a href="#编译器选择" class="headerlink" title="编译器选择"></a>编译器选择</h3><p>实力推荐 <code>VS Code</code> 一把梭，当然实在用不习惯其他编译器也都行，看个人习惯，实力强用记事本都没得关系</p><h3 id="下载Cesium包"><a href="#下载Cesium包" class="headerlink" title="下载Cesium包"></a>下载Cesium包</h3><p>首先，我们要下载 Cesium 包，官网下载即可，Cesium 每个月都会更新一个版本，一直在迭代，这点就足以证明它的活跃性以及未来，地址如下 👇</p><ul><li><a href="https://cesium.com/cesiumjs/" target="_blank" rel="noopener">Cesium Download</a></li></ul><p>下载下来解压后你会发现有很多文件，如下图</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20200723003350308.png" srcset="/blog/img/loading.gif" alt=""></p><p>我们下载这个包里包括 Cesium API 源代码 Source 文件夹，以及编译后的 Build 文件夹，还有Demo、API文档、沙盒等等，这些都不用管</p><p>我们只需要 <code>Build</code> 文件夹下面的 <code>Cesium</code> 这个文件夹，它是编译后 Cesium 包的正式版本，开发的话只需要这个就完了</p><h3 id="初始化地球"><a href="#初始化地球" class="headerlink" title="初始化地球"></a>初始化地球</h3><p>首先，我们找地方新建一个目录，这里目录名为 <code>demo</code> ，我们把上面说的 Cesium 这个文件夹拖进来</p><p>接着，我们在 demo 目录下新建一个 <code>index.html</code> 文件，初始化一个地球，只需四步</p><p><strong>No.1</strong> 引入 <code>cesium.js</code>，该文件定义了 Cesium 对象，它包含了我们需要的一切</p><pre><code class="html">&lt;script src=&quot;./Cesium/Cesium.js&quot;&gt;&lt;/script&gt;</code></pre><p><strong>No.2</strong> 引入 <code>widgets.css</code>，为了能使用Cesium 各个可视化控件 </p><pre><code class="css">@import url(./Cesium/Widgets/widgets.css)</code></pre><p><strong>No.3</strong> 在 <code>HTML</code> 的 <code>body</code> 中我们创建一个 <code>div</code>，用来作为三维地球的容器</p><pre><code class="html">&lt;div id=&quot;cesiumContainer&quot;&gt;&lt;/div&gt;</code></pre><p><strong>No.4</strong> 在 JS 中初始化 <code>CesiumViewer</code> 实例</p><pre><code class="js">let viewer = new Cesium.Viewer(&#39;cesiumContainer&#39;)</code></pre><p>完整代码如下</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;script src=&quot;./Cesium/Cesium.js&quot;&gt;&lt;/script&gt;    &lt;style&gt;      @import url(./Cesium/Widgets/widgets.css);      html,body,#cesiumContainer {        width: 100%;        height: 100%;        margin: 0;        padding: 0;      }    &lt;/style&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div id=&quot;cesiumContainer&quot;&gt;&lt;/div&gt;    &lt;script&gt;      window.onload = function () {        let viewer = new Cesium.Viewer(&quot;cesiumContainer&quot;)      }    &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h3><p>平常我们写一个页面，浏览器打开 <code>html</code> 文件即可，在写 Cesium 程序的时候，不要本地双击浏览器运行，因为在实际工作中，它是需要运行在Web服务器上的</p><p>这里我们使用Node来搭建这个服务，首先你要在电脑装Node，这个不过多赘述，不了解自行百度安装即可</p><p>官网包括一般的教程里这个时候就要手写代码用 <code>express</code> 或者 <code>Koa</code> 简单的搭一个Web服务了，但是这也是没有必要的，这里我们只是写个 demo，没必要再去写后端代码什么的，太麻烦，我们装一个 <code>live-server</code> 就行了</p><p><code>live-server</code> 是一个具有实时加载功能的小型服务器，简单说，你装了它，直接在当前目录命令行运行命令这个服务就起来了</p><p>安装 <code>live-server</code> 命令如下</p><pre><code class="js">npm install -g live-server</code></pre><p>再次强调，这只是一个小 demo，一般来说正常项目开发中 <code>Vue+Cesium</code> 我觉得是最佳实践了，而使用 Vue 来开发的话  <code>Vue-CLI</code> 本身就是一个本地服务，我们如果要原生开发的话 <code>live-server</code> 就行了，虽然写个Web服务不难，但终归是浪费时间</p><p>当我们 Node 安装好了，也装上了 <code>live-server</code> 后，我们在终端  <code>cd</code> 到项目根目录下 ，执行下面命令</p><pre><code class="js">live-server</code></pre><p>默认启动的是8080端口，如下图</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20200723230404008.png" srcset="/blog/img/loading.gif" alt=""></p><p>紧接着，直接在浏览器输入 <code>http://127.0.0.1:8080</code> ，你的第一个 Cesium 程序就 👌 了</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/2020-07-27-cesiuminit-gif.gif" srcset="/blog/img/loading.gif" alt=""></p><p>如上所示，页面上就会呈现一个 3D 的地球了，是不是很简单，有没有勾起你入手的欲望呢？</p><p>这次就到这里，下次我们来说一说 Vue 里面使用 Cesium 开发以及一些注意事项，一步一步来，心急吃不了热豆腐，每篇文末会给大家列出我一些相关的学习地址</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>初识 Cesium 一定要知道的几个网站</p><ul><li><p><a href="https://cesium.com/docs/" target="_blank" rel="noopener">Cesium 官方教程</a> Cesium出的官方教程，英文的，可以翻译着看看</p></li><li><p><a href="https://cesium.com/docs/cesiumjs-ref-doc/" target="_blank" rel="noopener">Cesium API英文官方文档</a>  Cesium的API太多了，不过有遇到不知道API可以查一查，不过也是英文的</p></li><li><p><a href="http://cesium.xin/cesium/cn/Documentation1.62/" target="_blank" rel="noopener">Cesium API中文文档</a> Cesium中文网翻译的API文档，不太全，不过初步肯定是够用的</p></li><li><p><a href="https://sandcastle.cesium.com/" target="_blank" rel="noopener">Cesium Sandcastle 沙盒示例</a> Cesium官方的一些示例程序，没事可以多逛逛</p></li><li><p><a href="http://cesium.xin/" target="_blank" rel="noopener">Cesium 中文网</a> Cesium中文网，里面有系列教程，部分是免费的，可以学习很多知识</p></li></ul><p>如果是刚接触Cesium，这些网站无论如何都要点进去看一看，先简单过一遍即可，后期会用上的</p><p>文章收录在 GitHub，更多精彩请看 <a href="https://github.com/isboyjc/blog/issues" target="_blank" rel="noopener">isboyjc/blog/issues</a> </p><p>是前端，又不只是前端，所以不正经，认真分享干货，公众号「不正经的前端」，欢迎关注</p>]]></content>
    
    
    <categories>
      
      <category>Cesium系列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cesium</tag>
      
      <tag>数据可视化</tag>
      
      <tag>WebGIS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>努力、奋斗，写给自己、讲给你听</title>
    <link href="/blog/2020/07/26/else/%E5%8A%AA%E5%8A%9B%E3%80%81%E5%A5%8B%E6%96%97%EF%BC%8C%E5%86%99%E7%BB%99%E8%87%AA%E5%B7%B1%E3%80%81%E8%AE%B2%E7%BB%99%E4%BD%A0%E5%90%AC/"/>
    <url>/blog/2020/07/26/else/%E5%8A%AA%E5%8A%9B%E3%80%81%E5%A5%8B%E6%96%97%EF%BC%8C%E5%86%99%E7%BB%99%E8%87%AA%E5%B7%B1%E3%80%81%E8%AE%B2%E7%BB%99%E4%BD%A0%E5%90%AC/</url>
    
    <content type="html"><![CDATA[<h1 id="努力、奋斗，写给自己、讲给你听"><a href="#努力、奋斗，写给自己、讲给你听" class="headerlink" title="努力、奋斗，写给自己、讲给你听"></a>努力、奋斗，写给自己、讲给你听</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>好巧不巧又赶上了掘金征文，虽然是最后两天，还是凑一番热闹</p><p>日复一日的生活、日复一日的工作，时间久了，可能会有些厌恶，仿佛每天清晨起就在盼着黄昏来临，但每一天又是那样的漫长，有时候真的觉得度日如年四个字是那么中肯，所以现代社会才会有那么多的人想要放空自己、归于自然</p><p>日子虽然难熬，但不知不觉间无数个清晨和黄昏就过去了， 2020 年也已然过半，人生是很短暂也很漫长的，但很奇怪，没有人的内心里会认为在这段说长不长说短不短的人生中自己就是平庸的，相反，绝大多数的人在心中认为自己是生而不凡甚至不可或缺的，仿佛全世界都该为之驻足、为之瞩目，毕竟谁不希望自己是 SuperMan 呢</p><p>就像我们走在路上会不觉注意别人的眼神，生怕自己出糗而招人笑话、引人闲话一样，其实，我或者你并没有这么重要，就算是在大街上突然摔倒，也不会让人驻足，甚至他人都不会多看你一眼，这个世界多了你不多，少了你不少，所以做人，并不要把自己看的这么重要，会轻松许多，这算是前两天看「巴斯特·斯克鲁格斯的歌谣」带来的感悟，特此分享</p><h2 id="来碗鸡汤"><a href="#来碗鸡汤" class="headerlink" title="来碗鸡汤"></a>来碗鸡汤</h2><p>我们所有人都想在世间这片海中翻起朵哪怕小小的浪花，我亦是，但是说来惭愧，也很可惜，人海茫茫，我就是其中那一滴缺之无谓的水，平凡甚至平庸</p><p>是很平凡，一名前端，写博客时一般会用「isboyjc」这个ID，说到这个ID，也是年少轻狂时，现悔恨不已</p><p>是很平庸，没有硕士研究生、没有985或211，甚至没有双非本科，在当今这个硕士大把，本科遍地的年代，我只是一个小专科，家境堪忧、没车、没房、可以忽略不计的存款，在这个物质尤为重要的年代，我所剩的，好像只有 <strong>尚还年轻</strong> 四个字</p><p>小时候看电视总能看到人说北漂的苦和累、北漂的无奈心酸，没想到有一天，自己也成为了一个北漂，倒不觉得有多苦有多累，无奈可能会有一些吧，但是好像也不像别人说的那样，言语不能表达，只得自己体会</p><p>虽平凡没什么亮点，但好在我知道自己要干什么，知道自己想要什么</p><p>学历低，没必要抱怨，毕竟那是别人在年少时比你付出了更多努力换来的，也没必要气馁，付出加倍努力追赶上去就好了</p><p>缺乏物质，没有必要怨天不公，更没有必要羡慕富二代，想想未来你的儿子在和别人言谈时，可以自豪的说起我的父亲是靠着自己的努力白手起家，一步一步，做（zu）大做（zu）强，是不是也挺自豪的</p><h2 id="历程开始"><a href="#历程开始" class="headerlink" title="历程开始"></a>历程开始</h2><p>河南商丘的小愤青，之前在郑州工作了一段时间，19年二月份，怀揣着对一线大城市的高薪资、高品质生活的憧憬来到北京，到现在一年半了</p><p>我也还算幸运，先是投奔了在北京的好哥们儿，解决了住的地方，然后开始着手面试，刚开始的时候就傻了，本想着多投一投，像在郑州一天多时可以面3～4家，简直是异想天开，因为学历问题，其实接到的面试邀请不多，再加上北京这地方，每天跑两家面都够呛，时间全花在路上了</p><p>第一家面试的公司以失败告终，因为没多少工作经验，加上是第一次面试性格还内向的原因，整个面试过程比较忐忑，不过面试官问的技术问题不说回答的好不好，起码都答上来了，这让我下一次的面试多了一些信心，随后的几家面试，每成一家，下次面试薪资就会多要些，只能这样一家家试，因为不知道自己的水平和北京的行情 </p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20200725185126851.png" srcset="/blog/img/loading.gif" alt=""></p><p>上图是离开郑州时发的一个QQ空间截图，2.21号下午5点钟到的北京，22号开始正式投简历，抛去天安门玩了一天和中间有家公司去试岗了两天觉得公司技术实在是有些老就和领导提了下自己的观点然后撤了，一共面试了大概 10 来天，面了8家公司，由于学历问题面的都是一些中小公司，侥幸拿了 5 家 Offer，因为在哥们儿那一共住了半个月，挺不好意思的，所以在 3 月初选择入职了一家公司，一直做到了现在</p><p>之后开始租房，新公司、新环境、新同事、新住址，这一切都让我对未来充满希望、充满斗志</p><h2 id="认清自己"><a href="#认清自己" class="headerlink" title="认清自己"></a>认清自己</h2><p>这段有点俗，什么是认清自己，就是要想明白自己想要什么，该做什么，怎么来做</p><h3 id="想要什么"><a href="#想要什么" class="headerlink" title="想要什么"></a>想要什么</h3><p>想要什么，我想要钱，没错，很庸俗，但是也很现实，在这个物质的社会，钱不是万能的，但是没有钱是万万不能的</p><p>家里并不富裕甚至可以说很穷，我不是一个人，虽然在家排行老二，但是我是最先工作的，我需要养家，我还需要挣钱买房、买车，这些都只能靠自己，所以我需要钱</p><h3 id="该做什么"><a href="#该做什么" class="headerlink" title="该做什么"></a>该做什么</h3><p>该做什么，做前端，因为大学学的就是这个，除了这个我什么也不会，你可能会说，三百六十行、行行出状元，但是在当时的我可以选择的行业里，做前端，也就是 IT 行业，起码是一份比较体面的工作，况且我这个性格做其他的也做不来</p><p>有些人会把为了高薪入 IT 行业的人和所谓纯粹的技术人区分开，其实两者并不冲突，差异只是前者从一开始的目的就很明确，单纯是为了入行做几年 IT 攒点钱再转投它行，而纯粹的技术型人才，痴迷技术而不断学习、不断提升自己，那提升自己是为了什么的，升职加薪、为了更好的未来，说到底还是钱</p><p>我不是前者也不全是后者，我要做的是从各方面提升自己，因为喜欢又从事前端，所以我会更加侧重前端方面的提升，仅此而已</p><h3 id="怎么来做"><a href="#怎么来做" class="headerlink" title="怎么来做"></a>怎么来做</h3><p>怎么来做，从各方面提升自己，其实就是投资自己，说来惭愧，向往独居北京的品质生活，但是还是因为省钱选择了很多人的合租房，每天会为很多生活上的小事烦恼</p><p>来北京的一年多时间里，上班、下班、学习，也不怎么出去玩，没吃过王府井的小吃、没见过鼓楼的夜晚、没在景山公园看一看紫禁城、没体验过颐和园赏景的悠然自得、没看到过圆明园的断壁残垣、没有去十三陵看一眼皇家墓地、没有感受过南锣鼓巷的熙熙攘攘、更不知道三里屯的时尚繁华，哦对了，也没去看过儿时梦想的清华北大，可能几年后别人问起我在北京去过哪些地方，我也只能回答去过天安门、爬过长城</p><p>生活上不能说省吃俭用，但奢侈品、鞋子、表、衣服什么对我来说都无所谓，所以除了日常吃饭，换季买些衣服，没有其他大的开销</p><p>一年多来，对我来说开销最大的地方，电脑老旧换了台 Mac 花了上万元，为了能更好更快的提升自己，买了很多课程，花了上万元，不过这些在我认为都是值得的</p><p>前半年每天都是2～3点睡觉，明显感觉到身体素质日益渐下，所以后来就调整到每晚12点左右睡觉</p><p>坚持写博客，刚开始只是为了巩固自己所学的知识，因为我认为能用自己的理解把某个技术点写出来给别人看，并且让别也能看懂的东西自己才算真正学会，对自己对他人都是有利的</p><p>后来做公众号，因为网络上写一篇博客，不经同意被人拿走署名转发还好，比较搞笑的是有些人直接 <code>Copy</code> 后只在文末写一句文章来源网络，更气的是有些人直接 <code>Copy</code> 后写上自己名字，这种事情发生在自己头上感觉就是辛辛苦苦用心输出的成果被他人窃取了</p><p>做个人公众号，它算是一种渠道，一种可以树立起个人品牌的渠道，它可以为我慢慢积攒起流量，通过公众号交流群，也可以让我交到更多朋友积攒更多人脉，其实辛苦很久写的文章没人看是很无奈的，所以这是一种很好的方式，而且也正如 <a href="https://juejin.im/user/57bd1bdfd342d3006bf76a52" target="_blank" rel="noopener">@前端劝退师</a> 所说，树立个人品牌可以抵消一些学历上的不足</p><p>当然也有很多技术类博主做以公众号为主的自由职业者、用它来盈利，这没法子评价，我的公众号刚起步，只有区区几百粉丝，我不确定未来我是否拿它盈利，但是至少短期内是肯定不会的，提到这了，简单说下，原因有三</p><ul><li>如果有一天想通过公众号盈利，我想我不会选择技术类，因为技术文章产出很慢，拿我自己举例子，我几乎每篇技术文章都在万字以上，平均一个月产出1～2篇，这个产出是很低的，对我来说高产意味着质量不好，因为我只能利用业余时间分出的一小块时间写，而且毕竟不是特厉害的大佬，很多东西我不会，我想写，我就要学，学需要时间，学完之后写需要时间，写完还要细细揣摩几天，毕竟个人理解的技术文章，我允许自己理解有误，但那也必须是经过深思熟虑后的，这是为了自己的技术增长和让他人认同，同样也是为了不浪费他人时间，而技术文章产出慢使得很多博主只能频繁的转发文章来维持，其实偶尔转发还好，转发多了就丧失了作为个人公众号的初衷，个人不太喜欢</li><li>我也算过，我知道的公众号盈利方式有微信流量主的方式就是在文末加一个小广告，用户在文章中点进广告就会有些钱，但是靠这个盈利，很难的，实在是没多少钱，发文推广才是技术公众号最主要的盈利方式，但是首先技术类公众号的用户群体就那么多，再加上是技术领域的前端领域，又少了一部分，最后再加上技术类公众号推文合作方向比较单一，好像只有培训或者技术课程之类的，这也是当下很多技术博主盈利的方式，正常说公众号运营到10W+阅读量是超级大 V 了，各种类别公众号里其实都有不少这种大V，但据我所知的技术类公众号平均阅读量超过 10W 的寥寥无几，专注前端领域的公众号的平均阅读超过1W的都没几个好像，还有就是文末赞赏和文章付费的渠道，这些盈利也都是寥寥的，总之技术类公众号盈利是挺难的</li><li>盈利的话，文末加个小广告还好，一旦硬推广告，很容易流失流量，因为以一个技术人的心态来说，喜欢学习的人就那么一撮，看公众号的也就那么一撮，喜欢学习又看技术类公众号肯定不会只关注一个号，我自己就关注了很多前端公众号，有时看到广告推文哪怕知道是广告我也会点进去一下，哪怕只点不看，也为他们增加下阅读量，但是有时候看到关注的很多技术公众号发同一个广告推文刷屏时也挺难受的，不太想成为他们的一员，公众号方面，我更多的是想要慢慢的树立个人品牌，像阮一峰先生的个人博客一样，十分仰慕</li></ul><p>当然上面说的知识我自己的观点，并没有评判什么，因为我自己也就是佛系玩一下，也不怎么转文章，见识可能也比较浅显，不太懂其中的门道，如有冒犯到，不胜见谅，其实遇到的所有做公众号或是坚持写技术博客的都是非常努力非常自律的一群人，不管目的如何，都很钦佩</p><p>自媒体运营还挺好玩的，说不定有一天我想盈利了会做一个写鸡汤文的公众号，盈利渠道和受众都广嘛，甚至我都想做一个励志的视频号了，因为我发现自己码码字还行，但是口才方面一直是弱项，刚好做视频号可以弥补，哈哈，有这个想法</p><p>关于「不正经的前端」这个技术号，可能未来的某一天我会因为坚持不下去公众号就不做了，也可能未来的某一天积攒起了流量我也会同大多数人一样开始盈利，害，管他呢，想这么多干嘛，未来的事情谁知道呢</p><p>不管怎么说，写博客或者说做技术公众号也是学习的一种方式，并且和我的职业是相辅相成的，也确实，写文章促成了我很多好习惯，也让我认识了很多很多朋友，我觉得每个技术人都应该坚持写一写，至少在你转行的时候，网络上有你曾经为之奋斗留下过的痕迹</p><p>为了弥补儿时不努力带来的学历差距，只能不断学习，只能比他人更努力，还好作为一个技术人员，只要技术硬，学历的影响没有其他行业那么大，一切的努力都是值得的</p><p>技术在更新，学习永不止，看过大圣老师，也就是 <a href="https://juejin.im/user/59532176f265da6c317d8e14" target="_blank" rel="noopener">@蜗牛老湿</a> 的很多视频，也听他讲述了自己的一番经历，十分励志，很正的价值观，也正是因为他，我喜欢上了看书，也确实，书能给你无穷力量，书上的东西是经过很多人很长时间总结勘误后才形成的，很少有错误，每一本书都有值得观看的点，因为不可能有废话连篇还能写厚厚一本的书，不管是技术书籍还是其他的，没事多读没坏处</p><p>三八理论还是挺靠谱的，对于大多数正常人来说，每天8小时工作，8小时睡眠，那么剩下的8小时，决定的将是你人生走向，而我们这些在某一方面有缺陷（比如学历低的人），好好把握这8小时，甚至可以少睡2小时（睡眠不要低于6小时），长此以往，高低立判</p><h2 id="关于交流群"><a href="#关于交流群" class="headerlink" title="关于交流群"></a>关于交流群</h2><p>学习的方式其实挺多的，对我影响很大是技术交流群</p><p>刚入行时，我加了很多技术交流群，当我遇到一个深思熟虑后依然解决不了的技术问题时，我会百度、谷歌找答案，实在找不到了，会发到交流群里问别人</p><p>那时候在郑州，工作不忙，每当有空闲时我都会看看交流群，摸鱼？当然不是，我是在找各个交流群里大家发出的技术问题，有人发问题，我就看会不会，会的话给他解答发过去，不会的话百度谷歌一番，还是找不到答案的话我会把交流群1里人发的问题，转发到2、3、4、5等群，有人回答了，我再给1群的那个人转过去，当一个搬运工，你可能会觉得好贼啊，没错，我就是这么过来的</p><p>长此以往，我解决的问题，或者说我搬运的问题越来越多，各个方向，各种刁钻的问题都有，收获了什么？</p><ul><li><p>首先，给别人解决问题，收获了很多人情，那么我下次有问题时发群里他们也会乐意帮助我</p></li><li><p>其次，很多奇奇怪怪的问题，其实网上就有答案，只不过有些人拿捏不准关键词，搜不出来，搜索也是一门技术活，总能以最短时间找准问题的关键词搜索出来类似信息，这门儿不可言谈的功法好像被我练成了</p></li><li><p>最后，长期活跃于各个交流群，交流技术解决问题，这让我独立解决问题的能力蹭蹭蹭的上涨，企业为什么反感培训过、填鸭式学习的程序员，就是认为这部分人独立解决问题的能力不行，企业很看重这点技能，除此之外，技术面也在迅速扩张（因为好多问题都不是我擅长的，在寻找答案的过程中学习了很多各种各样的知识），还有就是最重要的一点，我交到了很多朋友，扩宽了人脉，这都是一些隐藏的财富，还是挺自豪的</p></li></ul><p>长期活跃在很多交流群，让我收获了很多友谊，认识了很多非常非常优秀的人，通过这些人我也学到了很多学习方法包括一些经验，没做公众号之前，我加了10来个前端交流群吧，做公众号之后，自己也建了交流群，更是数不清的群聊，最起码有50+，因为做公众号，加的好友比较多，有人发消息怕来不及回复忘掉，所以现在养成了不清理微信消息队列，现在基本上打开微信，划一划都是各种群聊，其实有一个很奇怪的现象，这些群聊中总是有那么一撮相同的人，何其优秀</p><h2 id="新的征途"><a href="#新的征途" class="headerlink" title="新的征途"></a>新的征途</h2><p>工作上，虽然通过自己的努力让公司技术负责人给予了认可，但是工作就是工作，工作中两点很重要，一是对自身成长，二是薪资，一年多过去，技术方面已经得不到太多的提升，薪资方面虽然也涨薪了，但是并不能达到我内心的要求，不管怎样，企业是不可能给某一个人大幅度涨薪的，一切还是要按照制度来，有个朋友说的挺对的，技术的增长，在你当前公司是看不到的，只能留给下家公司来评判，想离职很久了，也有些不舍，毕竟在公司交了几个好朋友，而且目前在职的这家公司对我的帮助挺大的，为此犹豫了很久很久，确实有些婆妈了</p><p>偶然间也发现有些朋友和我技术上应该差不多吧，有的甚至可能还不如我，但是薪资比我高很多，还不止一个，这一度令我很沮丧，自认为很努力了，事关自身成长，也会不计成本的砸钱买课学习等等来投资自己，可是生活总是那么爱开玩笑，这也是压死骆驼的最后一根稻草，所以疫情当下，我依然提出了离职，当然，我可能是我鼠目寸光，没有看到别人的努力，总而言之，我想试试看</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>你必须非常努力，才能看起来毫不费力，有时候，你努力得来的成果，在别人看来是运气好，随之而来的还有些讥讽，不要伤心、不要难过，因为他们不值得</p><p>你所赚的每一分钱，都是你对这个世界认知的变现，你所亏的每一分钱，都是因为对这个世界认知有缺陷，你永远赚不到超出你认知范围之外的钱，除非你靠运气，但是靠运气赚到的钱，最后往往又会靠实力亏掉，这是一种必然，这个社会最大的公平就在于：当一个人的财富大于自己认知的时候，这个社会有100个方法收割你，直到让你的认知和财富相匹配为止，这是我很喜欢也很坚信的一句话，也一直为之提升自己</p><p>知乎上曾有一个问题挺好的：为什么很多人在朋友圈假装努力？其实不管是朋友圈还是其他社交平台包括技术平台，都会有很多人分享努力奋斗史</p><p>而这个问题下的高赞评论中有一个是这样说的：因为你羡慕那些很努力的人，自己也想成为那样的人，决心下的很足，却在突然之间放弃之前的决心，内心还毫无波动，这就叫做懒惰与迷茫，望自己与屏幕前的你都不是</p><p>我是「isboyjc」，公众号「不正经的前端」，一个平凡无奇的前端开发程序员</p><p>正如此文的标题，努力、奋斗，写给未来的自己，也讲给当下的你听，多谢观看！</p><p><a href="https://juejin.im/post/5efc06715188252e7206ba07" target="_blank" rel="noopener">掘金年度征文 | 2020 与我的年中总结征文活动正在进行中……</a> </p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>励志</tag>
      
      <tag>努力</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Wechaty Plugin|实现一个微信机器人几行代码即可</title>
    <link href="/blog/2020/07/14/other/Wechaty%20Plugin%7C%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%BE%AE%E4%BF%A1%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%87%A0%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%8D%B3%E5%8F%AF/"/>
    <url>/blog/2020/07/14/other/Wechaty%20Plugin%7C%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%BE%AE%E4%BF%A1%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%87%A0%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%8D%B3%E5%8F%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="Wechaty-Plugin-实现一个微信机器人几行代码即可"><a href="#Wechaty-Plugin-实现一个微信机器人几行代码即可" class="headerlink" title="Wechaty Plugin|实现一个微信机器人几行代码即可"></a>Wechaty Plugin|实现一个微信机器人几行代码即可</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>晚到几个月的帖子，这几个月有些忙，没顾上，关于为什么要开发微信机器人、技术选型、Token申请、一期简单的开发可以看我4个月之前在掘金发布的文章</p><p><a href="https://juejin.im/post/5e5b2aeff265da5710438a1e" target="_blank" rel="noopener">Wechaty|NodeJS基于iPad协议手撸一个简单的微信机器人助手</a> </p><p>开发一个微信机器人难吗？真的很简单，看之前那篇文章就知道了，5月30号的「Wechaty Plugin conference」，<code>wechaty</code> 正式推出了 <code>plugin</code> 系统，<code>wechaty</code> 的作者 <a href="https://github.com/huan" target="_blank" rel="noopener">Huan (李卓桓)</a> 以及 <code>wechaty plugin</code> 系统的开发者同时也是开源项目 <code>Wepy</code> 作者 <a href="https://github.com/Gcaufy" target="_blank" rel="noopener">Gcaufy</a> 的一番演讲挺让人很兴奋的，因为在开发上一版机器人时，虽然简单，但是会感觉有些功能写着不难，就是比较琐碎，并且所有的业务逻辑代码都堆积在一块，很难受</p><p>但是 <code>wechaty plugin</code> 系统的上线，完美解决了这个问题，一个插件一个功能，基于配置，简洁明了，并且后期<code>plugin</code> 生态足够强大了，可以随时随地的为我们的机器人配置各种想要的功能，开发起来也会更加顺滑和简单</p><h2 id="申请免费Token？"><a href="#申请免费Token？" class="headerlink" title="申请免费Token？"></a>申请免费Token？</h2><p>了解 <code>wechaty</code> 或者看了之前那篇帖子的朋友可能知道，<code>wechaty</code> 使用 <code>pad</code> 协议是需要申请 <code>token</code> 的，可能有很多人看到需要 <code>token</code> 直接就撤了，这没办法，毕竟句子团队的研发也是需要成本的，没有必要吐槽，不过你也可以参与开源激励计划来获取长期 <code>token</code>，这个世界上大佬占有量总是少数，可能更多的人看到开源激励计划这几个字就觉得和自己没关系，事实上没有想象的那么难</p><p>这么说吧， <code>wechaty plugin</code> 推出前，你只需拿着试用的 <code>token</code> 开发一个产品（不要会错意，官方也说了是MVP产品，最小可行化产品，按照我的理解来说，最小可行产品就是刚好具备能够帮助你表达产品的核心概念的部分功能的产品，简单来说，你想用它做什么东西，你把这个东西核心功能做出来，并且放到 <code>github</code> 中开源即可，没有简单复杂之分，可行的产品就ok，就比如我做的产品核心就是为了管理微信群组和自动加好友，我就简单实现了这样一个东西，仅此而已），开发出产品后把代码开源到 <code>github</code> 并且写一篇帖子就行了</p><p>那么 <code>wechaty plugin</code> 推出后，你只需要开发一个插件就可以了，你可能会说开发一个插件很难吧，其实并不是，插件有很多种类，取决于开发者的奇思妙想，像我这种比较笨的，开发了几个常规插件，自动邀人、入群欢迎、自动踢人、群签到等等，每一个插件最少的可能只需要十几行代码，一般来说，只要有点开发基础就能开发出来，不管插件简单还是并不是太实用，句子团队肯定是来者不拒的，因为这有利于 <code>wechaty</code> 生态的发展，毕竟对于一个项目来说，有更多的开发者愿意参与进来，相信对这个项目的发展只会有利无害，对项目的发起团队来说，肯定也是非常值得开心的</p><p>可能还会有人怕代码写的烂被人吐槽，我觉得这也没什么，我就不是一个大佬，代码写的也挺烂的，个人觉得对一个程序员来说，脸皮厚很重要，就像写一篇帖子，如果有人吐槽，吐槽的对，我改了就是还能汲取一波知识，吐槽的不对技不如人那就要原谅我直接回怼了，怎么想都是对我百利无一害的，程序员，简简单单，挺好</p><p>看到这你可能我像个推销产品的人，当然你怎么想对我来说都只是陌生人的遐想罢了，不痛不痒，站在我的立场上，我只是对微信机器人比较感兴趣，觉得好玩实用，对 <code>wechaty plugin</code> 也很关注，奈何目前开发插件的人和插件数量实在不多，所以给大家打一波鸡血，好玩的插件多了，那机器人会越来越好玩</p><p>另外，我觉得微信机器人对一些知名博主或者公众号的作者会很有用，毕竟可以有效管理群聊提升群聊的活跃性，当然很多公众号大 V 们都有自己的机器人，也是各种渠道吧，但是能够免费接入的应该不多吧，免费的也会有各种各样的限制，<code>wechaty</code> 就不一样了，身为程序员嘛，自己开发适合自己的机器人岂不是更好</p><h2 id="开发需求"><a href="#开发需求" class="headerlink" title="开发需求"></a>开发需求</h2><p>还是来简单介绍下我的需求，我这边因为在做公众号嘛，也有一些微信交流群，有兴趣的朋友也可以关注下「不正经的前端」，有人加交流群什么的这一套流程人为操作真的是很痛苦，我需要一个机器人来自动通过好友，关键字自动邀请入群，便捷的一些群管理以及活跃下群氛围什么的，都是一些很普通的需求</p><p>上一版的开发其实已经足够我日常的需求了，不过后期扩展都需要我自己开发，还是比较麻烦的，所以我就把上一版的一些需要用到的功能封装成插件发包了，这样的话使用简单，代码简洁，如果别人有这个模块需求也可以直接安装使用插件，除了使用我自己开发的一些插件外，还使用了几个官方的插件来丰富我的机器人，总之，不算插件配置项的话，整体的代码量也就10来行吧</p><h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><p>其实没什么好介绍的了，因为改用了插件体制，每个功能都是一个插件，插件即功能，我就直接把用到的所有插件给大家一一介绍下吧，有自己开发的、官方开发的、其他人开发的，也期待可以用到大家开发的插件</p><p>当然如果你不想看这些插件介绍，也可以直接点开项目地址，直接看代码，跑一下即可，抛开配置也没几行代码</p><p>➡️  <a href="https://github.com/isboyjc/wechaty-plugin-robot" target="_blank" rel="noopener">isboyjc/wechaty-plugin-robot  - GitHub传送门</a> </p><h3 id="项目搭建-amp-插件使用"><a href="#项目搭建-amp-插件使用" class="headerlink" title="项目搭建 &amp; 插件使用"></a>项目搭建 &amp; 插件使用</h3><h4 id="初始化项目实例"><a href="#初始化项目实例" class="headerlink" title="初始化项目实例"></a>初始化项目实例</h4><pre><code class="js">const { Wechaty } = require(&quot;wechaty&quot;) // Wechaty核心包const { PuppetPadplus } = require(&quot;wechaty-puppet-padplus&quot;) // padplus协议包// 初始化const bot = new Wechaty({  puppet: new PuppetPadplus({    token: PUPPET_PADPLUS_TOKEN, // 你的token  }),  name: ROBOT_NAME, // 你的机器人名字})</code></pre><h4 id="使用插件并启动"><a href="#使用插件并启动" class="headerlink" title="使用插件并启动"></a>使用插件并启动</h4><pre><code class="js">const pluginTest = require(&quot;wechaty-plugin-test&quot;) // 引入插件// 使用插件 options为插件配置对象bot.use(pluginTest(options))// 启动机器人bot.start()</code></pre><h3 id="wechaty-plugin-contrib"><a href="#wechaty-plugin-contrib" class="headerlink" title="wechaty-plugin-contrib"></a>wechaty-plugin-contrib</h3><h4 id="重点介绍"><a href="#重点介绍" class="headerlink" title="重点介绍"></a>重点介绍</h4><p>当您发现自己在编写重复的代码时，就应该将其提取到插件中，通过调用 <code>Wechaty.use(WechatyPlugin())</code> ，我们可以很好地支持使用插件，微信插件是一个 <code>JavaScript</code> 函数，它返回一个接受微信实例的函数，第一个微信插件系统是由核心团队开发人员 <code>@gcaufy</code> 设计的，这个包是用来发布核心开发团队常用的微信插件的</p><p>上面这段话是官方对这个包的解释，简单来说，这个官方发布的包里有一些好玩的插件供我们大家使用，它是一个插件集合，我们直接安装这个包，就可以使用里面的所有插件，现在里面有十来个插件吧，大家也可以给这个包PR一些插件，但是要求每个功能插件代码量不超过100行代码，超过100行的插件官方是建议自己发包的</p><p>如果大家想要了解更多这个插件集合中的插件👇👇👇</p><p><a href="https://github.com/wechaty/wechaty-plugin-contrib" target="_blank" rel="noopener">wechaty/wechaty-plugin-contrib - GitHub传送门</a> </p><p>我使用了其中几个插件，给大家分别阐述下具体功能，当然我们要先安装这个包</p><pre><code class="js">npm install wechaty-plugin-contrib// oryarn add wechaty-plugin-contrib</code></pre><h4 id="QRCodeTerminal"><a href="#QRCodeTerminal" class="headerlink" title="QRCodeTerminal"></a>QRCodeTerminal</h4><p>在机器人登录的时候，终端显示扫描二维码，之前我们需要自己安装 <code>qrcode-terminal</code> 插件，然后监听 <code>scan</code> 事件，现在使用插件，除了引用依赖，一行代码即可</p><pre><code class="js">const { QRCodeTerminal } = require(&quot;wechaty-plugin-contrib&quot;)bot.use( QRCodeTerminal({ small: false }))</code></pre><p>诺，使用之后启动项目的时候就可以在终端打印二维码了，然后我们微信扫码登录即可</p><h4 id="EventLogger"><a href="#EventLogger" class="headerlink" title="EventLogger"></a>EventLogger</h4><p>官方解释是记录 “扫描”|“登录”|“消息”的微信事件…等，其实简单来说就是一个日志输出，登录之后的所有操作会在控制台打印日志，使用也很简单</p><p>提供事件日志：”dong” | “message” | “error” | “friendship” | “heartbeat” | “login” | “logout” | “ready” | “reset” | “room-invite” | “room-join” | “room-leave” | “room-topic” | “scan”</p><p>有一个参数 <code>options</code> ，数组类型，可自由选择打印事件日志，我没有填写此参数，默认就打印所有事件</p><pre><code class="js">const { EventLogger } = require(&quot;wechaty-plugin-contrib&quot;)bot.use(EventLogger())</code></pre><h4 id="RoomConnector"><a href="#RoomConnector" class="headerlink" title="RoomConnector"></a>RoomConnector</h4><p>这个插件比较有意思，连接房间，把任何房间的信息广播到所有其他房间，因为微信群的上限是500人，为此可能很多公众号大大会创建多个群聊，但是它们的消息是不互通的，该插件就是为此而生的</p><p>它支持三种模式</p><ul><li>OneToManyRoomConnector    可以广播消息在一个房间到其他房间</li><li>ManyToOneRoomConnector    可以将各个房间的信息汇总到一个房间</li><li>ManyToManyRoomConnector  将把任何房间的所有信息广播到所有其他房间</li></ul><p>我这里使用了它的 <code>ManyToManyRoomConnector</code>  模式，把任何房间的所有信息广播到所有其他房间</p><p>具体配置如下，当然，想要了解更多可以点击上文这个插件集合包的 <code>github</code> 地址查看官方文档</p><pre><code class="js">bot.use(  ManyToManyRoomConnector({    // 黑名单    blacklist: [async () =&gt; true],    // 多个群聊列表    many: [      &quot;10614174865@chatroom&quot;, // Web圈0x01      &quot;22825376327@chatroom&quot;, // Web圈0x02      &quot;24661539197@chatroom&quot;, // 微信机器人    ],    // 遍历并发送出的消息    map: async (message) =&gt; {      let roomName = await message.room().topic()      let name = await message.room().alias(message.from())      name ? null : (name = message.from().name())      return `来自群聊【${roomName}】的【${name}】说 \n\n ${message.text()}`    },    // 白名单    whitelist: [async (message) =&gt; message.type() === bot.Message.Type.Text],  }))</code></pre><h3 id="wechaty-voteout"><a href="#wechaty-voteout" class="headerlink" title="wechaty-voteout"></a>wechaty-voteout</h3><p><strong>简介</strong> </p><p>这个插件是 <code>Gcaufy</code> 开发的，它是一个微信投票插件，可以帮助您有一个投票和踢出功能为您的房间</p><p>就是说当你的群聊中有不当的发言者时，发送 <code>@用户 [关键字或表情]</code>，就可以发起投票了，可以设置数量，达到一定的数量会被移除群聊</p><p><strong>安装</strong> </p><pre><code class="js">npm install wechaty-voteout --save</code></pre><p><strong>使用</strong> </p><pre><code class="js">const VoteOut = require(&#39;wechaty-voteout&#39;)bot.use(VoteOut({ /* options */ }))</code></pre><p><code>options</code> 配置请参考下面示例配置</p><p><strong>示例</strong> </p><pre><code class="js">const options = {  //您希望机器人与哪个房间一起工作    //可以是RegExp（用于主题）或函数（过滤室实例）    //例如 室：函数（室）{room.topic（）。indexOf（&#39;我的&#39;）&gt; -1}  room: [/Room Topic 1/i, &#39;room_id@chatroom&#39;],  // 当达到目标时，就意味着他将被移出  threshold: 3,  // 白名单，永远不会被投票移除的人  // 使用RegEx表示联系人姓名，使用字符串表示联系人ID  whitelist: [],  // 不同的木偶得到不同的标志    // 我们运行更多的案例以查看它是什么符号，并在此处更新注释，就是表情符号  downEmoji: [    &#39;[弱]&#39;,    &#39;[ThumbsDown]&#39;,    &#39;&lt;img class=&quot;qqemoji qqemoji80&quot; text=&quot;[弱]_web&quot; src=&quot;/zh_CN/htmledition/v2/images/spacer.gif&quot; /&gt;&#39;,  ],  // 警告模板，设置为falsy以禁用警告消息  warn: [    &#39;可能是因为你的聊天内容不当导致被用户投票，当前票数为 {{ downNum }}，当天累计票数达到 {{ threshold }} 时，你将被请出此群。&#39;,  ]  // 弹出模板，设置为falsy来禁用消息  kick: &#39;经 {{ voters }} 几人投票，你即将离开此群。&#39;,  repeat: &#39;你已经投票过 {{ votee }} 了，无需再投。&#39;,}bot.use(VoteOut(options))</code></pre><p>来看一个运行中的图片</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20200712204804871.png" srcset="/blog/img/loading.gif" alt=""></p><p>插件其实用法很简单，但是由于不是我开发的，所以大家想查看更多详细介绍请猛戳👇👇👇</p><p><a href="https://github.com/Gcaufy/wechaty-voteout" target="_blank" rel="noopener">Gcaufy/wechaty-voteout  - GitHub传送门</a> </p><h3 id="wechaty-friend-pass"><a href="#wechaty-friend-pass" class="headerlink" title="wechaty-friend-pass"></a>wechaty-friend-pass</h3><p><strong>简介</strong> </p><p>此插件功能是，自动通过好友请求，或者设置一些关键字，通过好友申请时备注的关键字来校验是否要自动通过该好友申请，并且通过好友申请时自动回复一段话</p><p>当时没看到 <code>wechaty-plugin-contrib</code> 中有一个 <code>FriendshipAccepter</code> ，功能差不多，不过我还是使用了自己开发的， 大家也可以选择性使用</p><p><strong>安装</strong> </p><pre><code class="js">npm install wechaty-friend-pass// oryarn add wechaty-friend-pass</code></pre><p><strong>使用</strong> </p><pre><code class="js">const WechatyFriendPass = require(&quot;wechaty-friend-pass&quot;)bot.use(WechatyFriendPass(options))</code></pre><p>如上所示，使用插件只要按需传入配置对象 <code>options</code> 即可</p><table><thead><tr><th>Options 参数属性</th><th>类型</th><th>简介</th></tr></thead><tbody><tr><td>keyword</td><td>String|Array</td><td>好友请求时备注自动通过的关键字，只有一个可以使用字符串类型，多个关键字使用数组类型，全部通过不用校验传入字符串 “*” 即可，不传即都不自动通过</td></tr><tr><td>blackId</td><td>String|Array</td><td>用户黑名单 ID，该项可填写用户的 ID 来识别用户，让此用户不被自动通过，也可不填</td></tr><tr><td>reply</td><td>String</td><td>自动通过用户好友申请后自动回复一句话，为空或不填则通过后不回复</td></tr></tbody></table><p><strong>示例</strong> </p><pre><code class="js">const options = {  keyword: [&quot;加群&quot;, &quot;前端&quot;, &quot;后端&quot;, &quot;全栈&quot;],  blackId: [&quot;*******@id&quot;, &quot;*******@id&quot;],  reply: &quot;你好，我是机器人小助手圈子 \n 加入技术交流群请回复【加群】\n 联系小主请回复【123】&quot;,}bot.use(WechatyFriendPass(options))</code></pre><p>使用中如下图</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20200712200241111.png" srcset="/blog/img/loading.gif" alt=""></p><p>查看更多详细介绍请猛戳 👉 <a href="https://github.com/isboyjc/wechaty-friend-pass" target="_blank" rel="noopener">isboyjc/wechaty-friend-pass - GitHub传送门</a> </p><h3 id="wechaty-room-invite"><a href="#wechaty-room-invite" class="headerlink" title="wechaty-room-invite"></a>wechaty-room-invite</h3><p><strong>简介</strong> </p><p>向机器人发送某些关键字，机器人会通过这些关键字邀请你进入对应的房间，当然，可以管理多个房间</p><p><strong>安装</strong> </p><pre><code class="js">npm install wechaty-room-invite// oryarn add wechaty-room-invite</code></pre><p><strong>使用</strong> </p><pre><code class="js">const WechatyRoomInvite = require(&quot;wechaty-room-invite&quot;)bot.use(WechatyRoomInvite(options))</code></pre><p>如上所示，使用插件只要按需传入配置对象 <code>options</code> 即可</p><table><thead><tr><th>Options 参数属性</th><th>类型</th><th>简介</th></tr></thead><tbody><tr><td>keyword</td><td>String|Array</td><td>触发邀请该用户的关键字，只有一个可以使用字符串类型，多个关键字使用数组类型</td></tr><tr><td>roomList</td><td>Array</td><td>机器人管理的群聊列表，该项为必填项，数组对象中具体配置请看下面示例</td></tr><tr><td>reply</td><td>String</td><td>roomList 数组长度大于 1 时，视为管理多个群聊，那么 keyword 触发后会回复用户当前管理的群聊列表数据供用户选择进入某一个群，这个群聊数据列表为一段由 roomList 配置生成的话，roomList 数组长度等于 1 时，keyword 触发将会直接拉起群邀请，那么此字段也无用，reply 字段不是必选项，管理多个群聊时，建议直接使用默认文字，默认流程可看最后示例图片</td></tr></tbody></table><p>我们来看 <code>roomList</code> 数组的配置示例</p><pre><code class="js">roomList: [  {    // 群聊名字，管理多个群聊时用户可通过群聊名字选择某个群聊    name: &quot;微信机器人&quot;,    // 群聊id    roomId: &quot;22275855499@chatroom&quot;,    // 群聊别名，建议简短，管理多个群聊时用户可通过别名选择某个群聊，叫它[编号]可能更好    alias: &quot;A05&quot;,    // 标签，用于在管理多个群聊时给各个群聊做一个简单的标识，方便用户选择    label: &quot;新群&quot;,    // 是否关闭进入，如果为true，则触发该群时，会提示该群不可进入    close: true,  },  ...]</code></pre><p><strong>示例</strong> </p><pre><code class="js">const options = {  keyword: [&quot;加群&quot;, &quot;入群&quot;, &quot;群&quot;],  roomList: [    {      name: &quot;Web圈0x01&quot;,      roomId: &quot;10614174865@chatroom&quot;,      alias: &quot;A01&quot;,      label: &quot;推荐&quot;,    },    {      name: &quot;Web圈0x02&quot;,      roomId: &quot;22825376327@chatroom&quot;,      alias: &quot;A02&quot;,      label: &quot;新群&quot;,    },    {      name: &quot;微信机器人&quot;,      roomId: &quot;24661539197@chatroom&quot;,      alias: &quot;A04&quot;,      label: &quot;推荐&quot;,    },    {      name: &quot;男神开门群&quot;,      roomId: &quot;22275855499@chatroom&quot;,      alias: &quot;A05&quot;,      label: &quot;测试&quot;,      close: true,    }  ],  reply: &quot;&quot;,}bot.use(WechatyRoomInvite(options))</code></pre><p>管理多个群聊时，当用户给机器人发送【加群】，机器人默认会回复，当然你也可以自己设置</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20200712195955225.png" srcset="/blog/img/loading.gif" alt=""></p><p>查看更多详细介绍请猛戳 👉 <a href="https://github.com/isboyjc/wechaty-room-invite" target="_blank" rel="noopener">isboyjc/wechaty-room-invite - GitHub传送门</a> </p><h3 id="wechaty-room-welcome"><a href="#wechaty-room-welcome" class="headerlink" title="wechaty-room-welcome"></a>wechaty-room-welcome</h3><p><strong>简介</strong> </p><p>这是一个及其简单的插件，就是用于监听群聊中新人员的加入，随后回复一个入群欢迎，可管理多个群聊</p><p><strong>安装</strong> </p><pre><code class="js">npm install wechaty-room-welcome// oryarn add wechaty-room-welcome</code></pre><p><strong>使用</strong> </p><pre><code class="js">const WechatyRoomWelcome = require(&quot;wechaty-room-welcome&quot;)bot.use(WechatyRoomWelcome(options))</code></pre><p><code>options</code> 参数是一个对象，只有一个属性 <code>reply</code> </p><table><thead><tr><th>Options 参数属性</th><th>类型</th><th>简介</th></tr></thead><tbody><tr><td>reply</td><td>String|Array</td><td>reply参数为字符串时，机器人加入的所有群聊监听到新的加入都将回复此欢迎语，当为数组时，可自由配置管理的每个群聊要回复什么欢迎语，为数组类型的具体配置请看下文示例</td></tr></tbody></table><p><code>reply</code> 数组格式示例</p><pre><code class="js">reply: [  {    // 群聊名    name: &quot;微信机器人&quot;,    // 群聊id    roomId: &quot;24661539197@chatroom&quot;,    // 入群回复的欢迎词    reply: `\n 你好，欢迎你的加入，请自觉遵守群规则，文明交流，最后，请向大家介绍你自己！😊`,  },    ...]</code></pre><p><strong>示例</strong> </p><pre><code class="js">const options = {  reply: [    {      name: &quot;Web圈0x01&quot;,      roomId: &quot;10614174865@chatroom&quot;,      reply: `\n 你好，欢迎你的加入，请自觉遵守群规则，文明交流，最后，请向大家介绍你自己！ 😊`,    },    {      name: &quot;微信机器人&quot;,      roomId: &quot;24661539197@chatroom&quot;,      reply: `\n 你好，欢迎你的加入，请自觉遵守群规则，文明交流，最后，请向大家介绍你自己！😊`,    },    {      name: &quot;男神开门群&quot;,      roomId: &quot;22275855499@chatroom&quot;,      reply: `男神你好，欢迎加入`,    },  ],}bot.use(WechatyRoomWelcome(options))</code></pre><p>使用如下图</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20200712200643675.png" srcset="/blog/img/loading.gif" alt=""></p><p>查看更多详细介绍请猛戳 👉 <a href="https://github.com/isboyjc/wechaty-room-welcome" target="_blank" rel="noopener">isboyjc/wechaty-room-welcome - GitHub传送门</a> </p><h3 id="wechaty-room-remove"><a href="#wechaty-room-remove" class="headerlink" title="wechaty-room-remove"></a>wechaty-room-remove</h3><p><strong>简介</strong> </p><p>你可以在群聊中@一个违规的人并携带你所设置的关键字，机器人监听到后会帮你快捷的移除他并且给出提示，这比手动删除群聊中某一个人要方便的多</p><p><strong>安装</strong> </p><pre><code class="js">npm install wechaty-room-remove// oryarn add wechaty-room-remove</code></pre><p><strong>使用</strong> </p><pre><code class="js">const WechatyRoomRemove = require(&quot;wechaty-room-remove&quot;)bot.use(WechatyRoomRemove(options))</code></pre><p>如上所示，使用插件只要按需传入配置对象 <code>options</code> 即可</p><table><thead><tr><th>Options 参数属性</th><th>类型</th><th>简介</th></tr></thead><tbody><tr><td>keyword</td><td>String|Array</td><td>触发移除该用户的关键字，只有一个可以使用字符串类型，多个关键字使用数组类型，默认为 [“飞机”, “踢”]</td></tr><tr><td>time</td><td>Number</td><td>触发移除后的延时/ms，默认3000，即3s</td></tr><tr><td>adminList</td><td>Array</td><td>可触发命令的管理员列表，一个数组对象，单个数组对象属性请看下面配置示例</td></tr><tr><td>replyInfo</td><td>String|Function</td><td>移除前@提示该用户的一句话，可为字符串类型，也可以是函数类型，函数类型时，有一个参数msg，即当前消息实例，函数最终需返回一个字符串function(msg){return …}，此项有默认值，请看下文示例</td></tr><tr><td>replyDone</td><td>String</td><td>移除成功提示，字符串类型，默认成功时返回done</td></tr><tr><td>replyNoPermission</td><td>String</td><td>无权限移除成员时机器人的回复，即当一个不在adminList配置中的用户发出命令时回复，默认不做出回复</td></tr></tbody></table><p>我们来看 <code>adminList</code> 数组的配置示例</p><pre><code class="js">adminList: [  {    // 管理员昵称，用以区分，可选    name: &quot;isboyjc&quot;,    // 管理员id，必填    id: &quot;wxid_nrsh4yc8yupm22&quot;,  },  {    name: &quot;工具人小杨&quot;,    id: &quot;wxid_vkovzba0b0c212&quot;,  },  ...]</code></pre><p><strong>示例</strong> </p><pre><code class="js">const options = {  // 触发关键字数组  keyword: [&quot;飞机&quot;, &quot;踢&quot;, &quot;慢走&quot;, &quot;不送&quot;],  // 管理员列表  adminList: [    {      name: &quot;isboyjc&quot;,      id: &quot;wxid_nrsh4yc8yupm22&quot;,    },    {      name: &quot;便便&quot;,      id: &quot;wxid_4mnet5yeqo5d21&quot;,    },    {      name: &quot;工具人小杨&quot;,      id: &quot;wxid_vkovzba0b0c212&quot;,    }  ],  // 延时  time: 3000,  // 移除前提示，以下配置是默认配置，这里用来展示函数类型配置  // 可根据函数回调中msg消息实例参数自由发挥，也可直接填写一段字符串  replyInfo: function (msg) {    return `您可能违反了社群规则，并收到举报，${this.time / 1000}s后将您移出群聊，如有问题请联系管理！！！🚀\n\n移除原因：违反社群规则\n操作时间：${dateTimeFormat()}\n操作管理员：${msg.from().name()}\n\nYou may have violated the community rules and received a report. After ${this.time / 1000}S, you will be removed from the group chat. If you have any questions, please contact the management！！！🚀\n\nReason for removal：Violation of community rules\nOperation time：${dateTimeFormat()}\nOperation administrator：${msg.from().name()}`  },  // 移除成功后提示  replyDone: &quot;移除成功&quot;,  // 无权限人员触发命令后回复，可选项，默认不进行回复  replyNoPermission: &quot;您暂时没有权限哦，联系管理员吧😊&quot;,}bot.use(WechatyRoomRemove(options))</code></pre><p>如下图</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20200712202937488.png" srcset="/blog/img/loading.gif" alt=""></p><p>查看更多详细介绍请猛戳 👉 <a href="https://github.com/isboyjc/wechaty-room-remove" target="_blank" rel="noopener">isboyjc/wechaty-room-remove  - GitHub传送门</a> </p><h3 id="wechaty-room-clock"><a href="#wechaty-room-clock" class="headerlink" title="wechaty-room-clock"></a>wechaty-room-clock</h3><p><strong>简介</strong> </p><p>在群聊中打卡签到，每次打卡签到后累计打卡签到次数+1，积分+1，每日只可打卡一次，打卡总数/积分总数/打卡日志等等，可以用于积分赠送小礼品提升群活跃度什么的</p><p>你可能觉得这些操作需要用到数据库，但是在我的理解中，微信机器人越简单越便捷越好，而微信群聊的数据量不是很大，一个插件的使用，需要额外配置很多东西是很麻烦的，所以，此插件采用了本地存储，用了一个三方轻量化的基于 <code>Node</code> 的 <code>JSON</code> 文件数据库 <code>LOWDB</code>，避免了数据库这一繁琐的配置</p><p>插件会自动在项目根目录创建一个 <code>[机器人名字].clock-logs</code> 的文件夹，用以存放数据</p><p>其中 <code>clock-logs-[年份].json</code> 文件存储的是打卡日志，为避免读写操作数据量过大产生的负荷，所以每年会生成对应的 <code>json</code> 文件，这样每个群聊上限是 500 人，以5个群聊为基础，一年的打卡数据量也不会太大</p><p>其中 <code>clock-logs-main.json</code> 文件为主文件，存储的是对应群聊/对应用户的打卡签到数据等等</p><p>当然，如果你有更好的想法，请务必告知哦</p><p><strong>安装</strong> </p><pre><code class="js">npm install wechaty-room-clock// oryarn add wechaty-room-clock</code></pre><p><strong>使用</strong> </p><pre><code class="js">const WechatyRoomClock = require(&quot;wechaty-room-clock&quot;)bot.use(WechatyRoomClock(options))</code></pre><p>如上所示，使用插件只要按需传入配置对象 <code>options</code> 即可</p><table><thead><tr><th>Options 参数属性</th><th>类型</th><th>简介</th></tr></thead><tbody><tr><td>keyword</td><td>String|Array</td><td>触发签到的关键字，只有一个可以使用字符串类型，多个关键字使用数组类型，默认为 [“签到”, “打卡”]</td></tr><tr><td>success</td><td>String|Function</td><td>打卡成功提示该用户的一句话，可为字符串类型，也可以是函数类型，函数类型时，有一个参数data，即当前群成员在本地数据库中的数据对象，函数最终需返回一个字符串function(data){return …}，此项默认值请看下文示例</td></tr><tr><td>repeat</td><td>String|Function</td><td>重复打卡时提示该用户的一句话，可为字符串类型，也可以是函数类型，函数类型时，有一个参数data，即当前群成员在本地数据库中的数据对象，函数最终需返回一个字符串function(data){return …}，此项默认值为 “今日已签到，请勿重复签到”</td></tr></tbody></table><p>参数 <code>success</code> 和 <code>repeat</code> 为函数类型时形参 <code>data</code> 示例</p><pre><code class="js">{  // 该用户微信id  &quot;CONTACTID&quot;: &quot;wxid_nrsh4yc8yupm22&quot;,  // 该用户昵称  &quot;CONTACTNAME&quot;: &quot;isboyjc&quot;,  // 该用户打卡总数  &quot;CLOCKNUM&quot;: 170,  &quot;CLOCKINFO&quot;: {    // 该用户2020年打卡总数    &quot;2020&quot;: 69,    // 该用户2019年打卡总数    &quot;2019&quot;: 101  },  // 该用户积分  &quot;INTEGRALNUM&quot;: 170}</code></pre><p><strong>示例</strong> </p><pre><code class="js">let options = {  // 此处为默认项配置，也可为一个字符串  keyword: [&quot;签到&quot;, &quot;打卡&quot;],  // 此处为默认项配置，也可为一个字符串  success: (data) =&gt; {    let str = &quot;\n签到成功\n&quot;    Object.keys(data.CLOCKINFO).map(      (v) =&gt; (str += `${v}年累计签到${data.CLOCKINFO[v]}次\n`)    )    return str + `共累计签到${data.CLOCKNUM}次\n拥有${data.INTEGRALNUM}积分`  },  // 此处为默认项配置，也可为一个字符串  repeat: (data) =&gt; `今日已签到，请勿重复签到`,}bot.use(WechatyRoomClock(options))</code></pre><p>使用如下图</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20200712201619049.png" srcset="/blog/img/loading.gif" alt=""></p><p>查看更多详细介绍请猛戳 👉 <a href="https://github.com/isboyjc/wechaty-room-clock" target="_blank" rel="noopener">isboyjc/wechaty-room-clock  - GitHub传送门</a> </p><h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h3><p>看到这其实你可能回发现这个项目功能并不多，是的，所以 <code>plugin</code> 生态需要时间来发展，文中后面几个插件是我开发的，都是些简单的小插件，因为我的需求并不复杂，不过还是很希望接下来能自己做或者是说用上点好玩的插件 ，如果你有什么奇思妙想，可以直接在 <code>wechaty</code> 官方这个仓库的 <code>issuse</code> 中提出 👉  <a href="https://github.com/wechaty/wechaty-plugin-contrib/issues" target="_blank" rel="noopener">wechaty/wechaty-plugin-contrib/issues</a> ，可能会有人帮你写插件来实现哦，当然你也可以在其中寻找插件创意来自己实现</p><p>后面想做的几个好玩的小插件，当然只是谋划阶段，因为要上班，业余时间不多</p><ul><li>黑名单<ul><li>最近老遇到有些人在群里大量加好友推销课程，所以寻思着做一个黑名单插件，通过记录微信ID来监听入群的人，校验是否在黑名单中，如果在的话直接移出，同时开放一个公共黑名单列表，大家一块来搞</li></ul></li><li>群数据推送<ul><li>每天有新人加群，有人退群，特别是退群的时候察觉不到，所以做一个插件每天定时推送群数据，这个数据可能包括日内新入群数量、退群数量、聊天人数量及聊天数、聊天最积极人及数量、群成员邀请好友入群数量等等</li></ul></li><li>QA问答<ul><li>技术交流群免不了的提问，所以准备开一个 <code>Github</code> 仓库，使用 <code>issuse</code> 管理每个问答，每个成功解决的问题将被收录其中，使用 <code>webhook</code> 每个 <code>issuse</code> 在提交的时候将会被监听到存放到列表中，在群聊中监听消息作为关键字，触发列表中标题关键字或相似，返回对应链接或解答</li></ul></li><li>可视化管理面板<ul><li>目前对机器人所有的更改都是直接在代码中，想做一个可视化的管理系统，管理机器人并拥有可视化的数据页面方便我们随时随地查看群数据，支持Web端和H5</li><li>现在已经有一个类似的了 👉 <a href="https://github.com/gengchen528/wechaty-web-panel" target="_blank" rel="noopener">WebPanel</a>，大家也可以体验一下，我是想开发一个更简单便捷的，顺带做几个数据统计的页面，所以放到 TODO 里了，有时间再说</li></ul></li></ul><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>欢迎大家关注公众号「不正经的前端」，是前端，又不只是前端，所以叫不正经的前端</p><p>也可以加机器人助手「圈子」体验一波哦，同时也可以加入技术交流群</p><p>我们不应该只是为了工作和赚钱而敲代码，最后祝大家工作之余，玩得开心</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20200713201421436.png" srcset="/blog/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>Web相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Wechaty</tag>
      
      <tag>NodeJS</tag>
      
      <tag>微信机器人</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>你真的了解跨域吗</title>
    <link href="/blog/2020/07/10/other/%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%E8%B7%A8%E5%9F%9F%E5%90%97/"/>
    <url>/blog/2020/07/10/other/%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%E8%B7%A8%E5%9F%9F%E5%90%97/</url>
    
    <content type="html"><![CDATA[<h1 id="你真的了解跨域吗"><a href="#你真的了解跨域吗" class="headerlink" title="你真的了解跨域吗"></a>你真的了解跨域吗</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>相信每个前端对于跨域这两个字都不会陌生，在实际项目中应用也很多，但跨域方法的多种多样让人目不暇接，前段时间公司同事出现了跨域问题，又一时找不到问题所在，所以在此总结下跨域知识，一篇由浅入深的万字Web基操文</p><p>其实很早就开始写了，只不过刚开始写的时候理解不够深刻，后来慢慢就写其他觉得较高大尚较内涵的了，然后就又是觉得不够完美不够深刻又写一半，就此陷入强迫症患者明知不可为而为的死循环，SO，产出少，周期长（不过大家能看到的文章都是准备良久又反复斟酌后自认为还不错的）。。。</p><p>总之又是一篇由于各种原因半途而废的积压文，这里终于收尾了，长出一口气，哎，还是太年轻，吐槽结束，进入正文</p><p>文章收录地址： <a href="https://github.com/isboyjc/blog/issues/18" target="_blank" rel="noopener">isboyjc/blog 传送门</a> </p><h2 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域"></a>什么是跨域</h2><p>简单来说跨域是指一个域下的文档或脚本想要去去请求另一个域下的资源</p><p>其实一些像A链接、重定向、表单提交的资源跳转，像 <code>&lt;link&gt;、&lt;script&gt;、&lt;img&gt;、&lt;frame&gt;</code> 等dom标签，还有样式中 <code>background:url()、@font-face()</code> 等嵌入的文件外链，又比如一些像  js 发起的ajax请求、dom 和 js 对象的跨域操作等等都是跨域</p><p>我们通常所说的跨域，大多是由浏览器同源策略限制引起的一类请求场景，这里你可能注意到了同源策略，那么浏览器的同源策略是什么呢？</p><h2 id="浏览器同源策略"><a href="#浏览器同源策略" class="headerlink" title="浏览器同源策略"></a>浏览器同源策略</h2><p>同源策略/SOP（Same origin policy）是一种约定，由 <code>Netscape</code> 公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到 <a href="https://developer.mozilla.org/en-US/docs/Web/Security/Types_of_attacks#Cross-site_request_forgery_CSRF" target="_blank" rel="noopener">XSS、CSFR</a> 等攻击</p><p>同源同源，什么是源呢？源指的是 <code>协议、域名、端口</code> ，那么同源即三者相同，即便是不同的域名指向同一个ip地址，也不同源</p><p>我们来看一个域名组成，我们以 <code>http://www.hahaha.com/abc/a.js</code> 为例</p><ul><li>http://            –&gt;    协议</li><li>www              –&gt;    子域名</li><li>hahaha.com –&gt;    主域名</li><li>80                   –&gt;     端口（<code>http://</code> 默认端口是80）</li><li>abc/a.js         –&gt;     请求资源路径</li></ul><p>那么我们以这个域名的源为例，来与下面这些做下对比</p><table><thead><tr><th>URL</th><th>结果</th><th>原因</th></tr></thead><tbody><tr><td><code>http://www.hahaha.com/abc/b.js</code></td><td>同源</td><td>只有路径不同</td></tr><tr><td><code>http://www.hahaha.com/def/b.js</code></td><td>同源</td><td>只有路径不同</td></tr><tr><td><code>https://www.hahaha.com/abc/a.js</code></td><td>不同源</td><td>协议不同</td></tr><tr><td><code>http://www.hahaha.com:8081/abc/a.js</code></td><td>不同源</td><td>端口不同</td></tr><tr><td><code>http://aaa.hahaha.com/abc/a.js</code></td><td>不同源</td><td>主机不同</td></tr></tbody></table><p>而在不同源的情况下，同源策略限制了我们</p><ul><li>Cookie、LocalStorage、IndexedDB 等存储性内容无法读取</li><li>DOM 节点和 Js对象无法获得</li><li>AJAX 请求发送后，结果被浏览器拦截（注意是 <strong>请求发送出去了，也拿到结果了，只是被浏览器截胡了</strong>）</li></ul><p>到了这里，相信你对跨域已经有所了解了，那么我们如何有效的规避跨域呢，应该说如何解决跨域问题，因为我们在开发过程中免不了要跨域，针对不同的类型，解决跨域的方式也有很多</p><h2 id="不同类型的跨域解决方案"><a href="#不同类型的跨域解决方案" class="headerlink" title="不同类型的跨域解决方案"></a>不同类型的跨域解决方案</h2><h3 id="No-1-document-domain-iframe跨域"><a href="#No-1-document-domain-iframe跨域" class="headerlink" title="No.1 document.domain+iframe跨域"></a>No.1 document.domain+iframe跨域</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p><code>document.domain</code> 的方式实现跨域，适用场景仅在 <strong>主域名相同，子级域名不同</strong> 的情况下</p><p>例如，下面这两个页面</p><pre><code class="txt">http://aaa.hahaha.com/a.htmlhttp://bbb.hahaha.com/b.html</code></pre><p>那么它可以做到什么呢</p><ul><li>两个页面设置相同的 <code>document.domain</code> ，共享Cookie</li><li>两个页面设置相同的 <code>document.domain</code> ，通过 <code>iframe</code> 实现两个页面的数据互通</li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><h5 id="共享Cookie"><a href="#共享Cookie" class="headerlink" title="共享Cookie"></a>共享Cookie</h5><p>首先，两个页面都设置相同的 <code>document.domain</code> </p><pre><code class="js">document.domain = &#39;hahaha.com&#39;;</code></pre><p>页面 a 通过脚本设置一个 Cookie</p><pre><code class="js">document.cookie = &quot;test=a&quot;;</code></pre><p>网页 b 读这个 Cookie</p><pre><code class="js">let cookieA = document.cookie;console.log(cookieA)</code></pre><p>服务器也可以在设置Cookie的时候，指定Cookie的所属域名为一级域名，比如<code>.hahaha.com</code></p><pre><code class="js">Set-Cookie: key=value; domain=.hahaha.com; path=/</code></pre><p>这样的话，二级域名和三级域名不用做任何设置，都可以读取这个Cookie</p><h5 id="共享数据"><a href="#共享数据" class="headerlink" title="共享数据"></a>共享数据</h5><pre><code class="html">&lt;!--a页面--&gt;&lt;iframe src=&quot;http://bbb.hahaha.com/b.html&quot; onload=&quot;load()&quot; id=&quot;frame&quot;&gt;&lt;/iframe&gt;&lt;script&gt;  document.domain = &#39;hahaha.com&#39;;  let a = &quot;this is a&quot;;  // 获取b页面数据  function load(){    let frame = document.getElementById(&quot;frame&quot;)    console.log(frame.contentWindow.b) // this is b  }&lt;/script&gt;</code></pre><pre><code class="html">&lt;!--b页面--&gt;&lt;script&gt;  document.domain = &#39;hahaha.com&#39;;  let b = &quot;this is b&quot;  // 获取a页面数据  console.log(window.parent.a); // this is a&lt;/script&gt;</code></pre><h4 id="局限"><a href="#局限" class="headerlink" title="局限"></a>局限</h4><ul><li>首先，仅在主域名相同，子级域名不同的情况下</li><li>只适用于 Cookie 和 iframe 窗口，LocalStorage 和 IndexDB 数据无法通过这种方法共享</li></ul><h3 id="No-2-location-hash-iframe跨域"><a href="#No-2-location-hash-iframe跨域" class="headerlink" title="No.2 location.hash + iframe跨域"></a>No.2 location.hash + iframe跨域</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>两个页面不同源，是无法拿到对方DOM的，典型的例子就是 <code>iframe</code> 窗口和 <code>window.open</code> 方法打开的窗口，它们与父窗口是无法通信的</p><p>比如，不同源的页面a和页面b，如果我们直接获取对方数据</p><p>页面a：<code>http://www.hahaha0.com/a.html</code></p><pre><code class="html">&lt;iframe src=&quot;http://www.hahaha1.com/b.html&quot; onload=&quot;load()&quot; id=&quot;frame&quot;&gt;&lt;/iframe&gt;&lt;script&gt;  let a = &quot;this is a&quot;  // 获取b页面数据  function load(){    console.log(document.getElementById(&quot;frame&quot;).contentWindow.b)     // Uncaught DOMException: Blocked a frame from accessing a cross-origin frame.  }&lt;/script&gt;</code></pre><p>页面b：<code>http://www.hahaha1.com/b.html</code></p><pre><code class="html">&lt;!--b--&gt;&lt;script&gt;  let b = &quot;this is b&quot;  // 获取a页面数据  console.log(window.parent.a); // 报错&lt;/script&gt;</code></pre><p>显而易见，都是获取不到的，因为都跨域了，上面我们讲到的 <code>document.domain</code>，只能在同主域名的情况下使用才能规避同源政策，而在主域名不相同的情况下是没有办法做到的</p><p>我们来了解另一种办法 <code>window.location.hash</code>，它拿到的是 URL 的<code>#</code>号后面的部分，它叫片段标识符（fragment identifier）</p><p>比如 <code>http://hahaha.com/a.html#fragment</code> 的 <code>#fragment</code> ，如果只是改变片段标识符，页面是不会重新刷新的，就像大名鼎鼎的Vue中的hash路由就是用的这种方式</p><p>通过 <code>location.hash</code> + <code>iframe</code> 我们可以做到在不同主域下也可以拿到对方的数据</p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><p>首先，我们要实现页面a和页面b的跨域相互通信，因为不同域所以利用 <code>iframe</code> 加上 <code>location.hash</code> 传值，但是这个传值是单向的，只能由一方向另一方传值，不同域时子页面并不能获取到父页面，也就不能相互通信，所以我们需要一个中间人页面c来帮忙</p><p>不同域之间利用 <code>iframe</code> 的<code>location.hash</code> 传值，相同域之间直接 JS 访问来通信</p><p>那么我们的逻辑就变成了下面这样</p><blockquote><p>a 与 b 不同域只能通过hash值单向通信，b 与 c 也不同域也只能单向通信，但 c 与 a 同域，所以 c 可通过parent.parent 访问 a 页面所有对象</p></blockquote><p>页面a：<code>http://www.hahaha0.com/a.html</code></p><pre><code class="html">&lt;!--a中通过iframe引入了b--&gt;&lt;iframe id=&quot;frame&quot; src=&quot;http://www.hahaha1.com/b.html&quot;&gt;&lt;/iframe&gt;&lt;script&gt;  let frame = document.getElementById(&#39;frame&#39;);  // 向b传hash值  frame.src = frame.src + &#39;#a=我是a&#39;;  // 给同域c使用的回调方法  function cb(data) {    console.log(data) // 打印 我是a+b  }&lt;/script&gt;</code></pre><p>页面b：<code>http://www.hahaha1.com/b.html</code></p><pre><code class="html">&lt;!--b中通过iframe引入了中间人c--&gt;&lt;iframe id=&quot;frame&quot; src=&quot;http://www.hahaha0.com/c.html&quot;&gt;&lt;/iframe&gt;&lt;script&gt;  let frame = document.getElementById(&#39;frame&#39;);  // 监听a传来的hash值，传给c.html  window.onhashchange = function () {    frame.src = frame.src + location.hash + &#39;+b&#39;;  };&lt;/script&gt;</code></pre><p>页面c：<code>http://www.hahaha0.com/c.html</code></p><pre><code class="html">&lt;script&gt;  // 监听 b 的hash值变化  window.onhashchange = function () {    // c调用父亲的父亲，来操作同域a的js回调，将结果传回    window.parent.parent.cb(location.hash.replace(&#39;#a=&#39;, &#39;&#39;));  };&lt;/script&gt;</code></pre><h3 id="No-3-window-name-iframe跨域"><a href="#No-3-window-name-iframe跨域" class="headerlink" title="No.3 window.name + iframe跨域"></a>No.3 window.name + iframe跨域</h3><h4 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h4><p><code>window</code> 对象有一个 <code>name</code> 属性，该属性有一个特征，即在一个窗口的生命周期内，窗口载入所有的页面都是共享一个 <code>window.name</code> 的，每一个页面对 <code>window.name</code> 都有读写的权限</p><p><code>window.name</code> 是持久的存在于一个窗口载入的所有页面中的，并不会因为新的页面的载入而被重置，比如下例</p><p>页面a</p><pre><code class="html">&lt;script&gt;  window.name = &#39;我是a&#39;;  setInterval(function(){    window.location = &#39;b.html&#39;; // 两秒后把一个新页面b.html载入到当前的window中  },2000) &lt;/script&gt;</code></pre><p>页面b</p><pre><code class="html">&lt;script&gt;  console.log(window.name); // 我是a&lt;/script&gt;</code></pre><p>通过上面这个例子，我们可以很直观的看到，a 页面载入2s后，跳转到 b 页面，b 会在控制台输出 <code>我是a</code></p><p>不过 <code>window.name</code> 的值只能是字符串的形式，最大允许2M左右，具体取决于不同的浏览器，但是一般是够用了</p><p>那么我们就可以利用它这一特性来实现跨域，看标题就知道是使用 <code>window.name</code> 和 <code>iframe</code> ，那么你能想到要如何投机取巧，哦不，是巧妙的规避跨域而不留痕迹吗？</p><p>经历过上文的摧残我们知道，不同域情况下的 a 页面和 b 页面，使用 <code>iframe</code> 嵌入一个页面，数据也是互通不了的，因为会跨域，这里我们要使用 <code>window.name</code> + <code>iframe</code> 来实现跨域数据互通，显然我们不能直接在 a 页面中通过改变 <code>window.location</code> 来载入b 页面，因为我们现在需要实现的是 a 页面不跳转，但是也能够获取到 b 中的数据</p><blockquote><p>究竟要怎么实现呢？其实还是要靠一个中间人页面 c </p><p>首先中间人 c 要和 a 是同域</p><p>a 页面中通过 <code>iframe</code> 加载了 b ，在 b 页面中把数据留在了当前 <code>iframe</code> 窗口的  <code>window.name</code> 属性里</p><p>这个时候 a 是读取不了 <code>iframe</code> 的，因为不同域，但是我们可以在 a 中动态的把 <code>iframe</code> 的 <code>src</code> 改为 c </p><p>中间人 c 什么都不用写，因为它直接继承了 b 留下的 <code>window.name</code> </p><p>因为c 和 a因为是同域，所以 a 可以正常拿到子页面 c 中的 <code>window.name</code> 属性值</p><p>不得不说，这种做法还真挺让人叹为观止的，致敬前辈们</p></blockquote><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><p>页面a：<code>http://www.hahaha1.com/abc/a.html</code></p><pre><code class="html">&lt;iframe src=&quot;http://www.hahaha2.com/abc/b.html&quot; id=&quot;frame&quot; onload=&quot;load()&quot;&gt;&lt;/iframe&gt;&lt;script&gt;    let flag = true  // onload事件会触发2次  // 第1次onload跨域页b成功后，留下数据window.name，后切换到同域代理页面  // 第2次onload同域页c成功后，读取同域window.name中数据  function load() {    if(flag){      // 第1次      let frame = document.getElementById(&#39;frame&#39;)      frame.src = &#39;http://www.hahaha1.com/abc/c.html&#39;      flag = false    }else{      // 第二次      console.log(frame.contentWindow.name) // 我是b    }  }&lt;/script&gt;</code></pre><p>页面b：<code>http://www.hahaha2.com/abc/b.html</code></p><pre><code class="html">&lt;script&gt;  window.name = &#39;我是b&#39;  &lt;/script&gt;</code></pre><h3 id="No-4-window-postMessage跨域"><a href="#No-4-window-postMessage跨域" class="headerlink" title="No.4 window.postMessage跨域"></a>No.4 window.postMessage跨域</h3><h4 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h4><p>我们上面说的几种窗口跨域做法是可以适用相应场景且安全可靠的，但是它们都是属于投机取巧，不对，是另辟捷径，但是<code>HTML5 XMLHttpRequest Level 2</code>中为了解决这个问题，引入了一个全新的API：跨文档通信 API（Cross-document messaging）</p><p>这个API为 <code>window</code> 对象新增了一个 <code>window.postMessage</code> 方法，可以允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递</p><p>主流浏览器的兼容情况也非常可观</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20200708230157729.png" srcset="/blog/img/loading.gif" alt=""></p><p>我们来看下它的使用，先来看看它怎么发送数据</p><pre><code class="js">otherWindow.postMessage(message, targetOrigin, [transfer]);</code></pre><ul><li><strong>otherWindow</strong><ul><li>窗口的一个引用，比如 <code>iframe</code> 的 <code>contentWindow</code> 属性，执行 <code>window.open</code> 返回的窗口对象，或者是命名过的或数值索引的 <code>window.frames</code> </li></ul></li><li><strong>message</strong><ul><li>要发送到其他窗口的数据，它将会被 <a href="https://developer.mozilla.org/en-US/docs/DOM/The_structured_clone_algorithm" target="_blank" rel="noopener">结构化克隆算法 </a> 序列化，这意味着你可以不受什么限制的将数据对象安全的传送给目标窗口而无需自己序列化</li></ul></li><li><strong>targetOrigin</strong><ul><li>通过窗口的 <code>origin</code> 属性来指定哪些窗口能接收到消息事件，指定后只有对应 <code>origin</code> 下的窗口才可以接收到消息，设置为通配符 <code>*</code> 表示可以发送到任何窗口，但通常处于安全性考虑不建议这么做，如果想要发送到与当前窗口同源的窗口，可设置为 <code>/</code> </li></ul></li><li><strong>transfer | 可选属性</strong> <ul><li>是一串和 <code>message</code> 同时传递的 <strong>Transferable</strong> 对象，这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权</li></ul></li></ul><p>它也可以监听 <code>message</code> 事件的发生来接收数据</p><pre><code class="js">window.addEventListener(&quot;message&quot;, receiveMessage, false)function receiveMessage(event) {  let origin= event.origin  console.log(event)}</code></pre><p>接下来我们实战下跨域情况下，通过 <code>window.postMessage</code> 来互通数据</p><h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><p>还是以不同域的页面 a 和 b 为例子</p><p>页面a：<code>http://www.hahaha1.com/abc/a.html</code>，创建跨域 <code>iframe</code> 并发送信息</p><pre><code class="html">&lt;iframe src=&quot;http://www.hahaha2.com/abc/b.html&quot; id=&quot;frame&quot; onload=&quot;load()&quot;&gt;&lt;/iframe&gt;&lt;script&gt;  function load() {    let frame = document.getElementById(&#39;frame&#39;)    // 发送    frame.contentWindow.postMessage(&#39;哈喽，我是a&#39;, &#39;http://www.hahaha2.com/abc/b.html&#39;)    // 接收    window.onmessage = function(e) {      console.log(e.data) // 你好，我是b    }  }&lt;/script&gt;</code></pre><p>页面b：<code>http://www.hahaha2.com/abc/b.html</code>，接收数据并返回信息</p><pre><code class="html">&lt;script&gt;  // 接收  window.onmessage = function(e) {    console.log(e.data) // 哈喽，我是a    // 返回数据    e.source.postMessage(&#39;你好，我是b&#39;, e.origin)  }&lt;/script&gt;</code></pre><h3 id="No-5-JSONP跨域"><a href="#No-5-JSONP跨域" class="headerlink" title="No.5 JSONP跨域"></a>No.5 JSONP跨域</h3><h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p>对于 <code>JSONP</code> 这块，虽然不常用，我们好好的提一下，因为遇到过一些初学者，把 <code>AJAX</code> 和 <code>JSONP</code> 混为一谈了，提起 <code>JSONP</code> ，会说很 easy，就是在 <code>AJAX</code> 请求里设置一下字段就行了，可能你用过 <code>JQuery</code> 封装后的 <code>JSONP</code> 跨域方式，确实只是在请求里加个字段，但是，那是 JQ 封装好的一种使用方式而已，可不能被表象迷惑，你真的懂它的原理吗（JQ：我可不背锅！！！）</p><h4 id="AJAX工作原理"><a href="#AJAX工作原理" class="headerlink" title="AJAX工作原理"></a>AJAX工作原理</h4><p><code>Ajax</code> 的原理简单来说通过浏览器的 <code>javascript</code> 对象 <code>XMLHttpRequest</code> （Ajax引擎）对象向服务器发送异步请求并接收服务器的响应数据，然后用 <code>javascript</code> 来操作 DOM 而更新页面</p><p>这其中最关键的一步就是从服务器获得请求数据，即用户的请求间接通过 <code>Ajax</code> 引擎发出而不是通过浏览器直接发出，同时 <code>Ajax</code> 引擎也接收服务器返回响应的数据，所以不会导致浏览器上的页面全部刷新</p><p>使用方式也很简单</p><pre><code class="js">一：创建XMLHttpRequest对象,也就是创建一个异步调用对象二：创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息三：设置响应HTTP请求状态变化的函数四：发送HTTP请求五：获取异步调用返回的数据</code></pre><h4 id="JSONP，JSON？"><a href="#JSONP，JSON？" class="headerlink" title="JSONP，JSON？"></a>JSONP，JSON？</h4><p><code>JSON（JavaScript Object Notation）</code> 大家应该是很了解，就是一种轻量级的数据交换格式，不了解的同学可以去<a href="http://www.json.org/json-zh.html" target="_blank" rel="noopener">json.org </a> 上了解下，分分钟搞定</p><p>而 <code>JSONP（JSON with Padding）</code> ，它是一个 <strong>非官方</strong> 的协议，它允许在服务器端集成 <code>Script tags</code> 返回至客户端，通过 <code>javascript callback</code> 的形式实现跨域访问，这就是简单的JSONP实现形式，这么说可能不太明白，那我们来看下它到底是怎么个原理</p><h4 id="JSONP工作原理"><a href="#JSONP工作原理" class="headerlink" title="JSONP工作原理"></a>JSONP工作原理</h4><p>先来看个小例子，还是不同域的 a 和 b 两页面</p><p>页面a：<code>http://www.hahaha1.com/abc/a.html</code></p><pre><code class="html">&lt;html&gt;&lt;head&gt;    &lt;title&gt;test&lt;/title&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;http://www.hahaha2.com/abc/b.html&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;  &lt;script&gt;      console.log(b) // 我是b  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>页面b：<code>http://www.hahaha2.com/abc/b.js</code></p><pre><code class="js">var b = &quot;我是b&quot;</code></pre><p>可以看到，虽然不同域，但是 a 页面中还是可以访问到并打印出了 b 页面中的变量</p><p>这个小例子我们可以很直观的看到 <code>&lt;script&gt;</code> 标签的 src 属性并不被同源策略所约束，所以可以获取任何服务器上脚本并执行它，这就是 <code>JSONP</code> 最核心的原理了，至于它如何传递数据，我们来简单实现一个</p><h4 id="JSONP的CallBack实现"><a href="#JSONP的CallBack实现" class="headerlink" title="JSONP的CallBack实现"></a>JSONP的CallBack实现</h4><p>刚才的例子说了跨域的原理，而且我们之前有讲到 <code>javascript callback</code> 的形式实现跨域访问，那我们就来修改下代码，如何实现 <code>JSONP</code> 的 <code>javascript callback</code> 的形式</p><p>页面a：<code>http://www.hahaha1.com/abc/a.html</code></p><pre><code class="html">&lt;script type=&quot;text/javascript&quot;&gt;  //回调函数  function cb(res) {      console.log(res.data.b) // 我是b  }&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;http://www.hahaha2.com/abc/b.js&quot;&gt;&lt;/script&gt;</code></pre><p>页面b：<code>http://www.hahaha2.com/abc/b.js</code></p><pre><code class="js">var b = &quot;我是b&quot;// 调用cb函数，并以json数据形式作为参数传递cb({  code:200,   msg:&quot;success&quot;,  data:{    b: b  }})</code></pre><p>创建一个回调函数，然后在远程服务上调用这个函数并且将JSON 数据形式作为参数传递，完成回调，就是 <code>JSONP</code> 的简单实现模式，或者说是 <code>JSONP</code> 的原型，是不是很简单呢</p><p>将 <code>JSON</code> 数据填充进回调函数，现在懂为什么 <code>JSONP</code> 叫 <code>JSON with Padding</code> 了吧</p><p>上面这种实现很简单，通常情况下，我们希望这个 <code>script</code> 标签能够动态的调用，而不是像上面因为固定在 <code>HTML</code> 里面加载时直接执行了，很不灵活，我们可以通过 <code>javascript</code> 动态的创建 <code>script</code> 标签，这样我们就可以灵活调用远程服务了，那么我们简单改造下页面 a 如下</p><pre><code class="html">&lt;script type=&quot;text/javascript&quot;&gt;  function cb(res) {    console.log(res.data.b)  // 我是b  }  // 动态添加 &lt;script&gt; 标签方法  function addScriptTag(src){    let script = document.createElement(&#39;script&#39;)    script.setAttribute(&quot;type&quot;,&quot;text/javascript&quot;)    script.src = src    document.body.appendChild(script)  }  window.onload = function(){    addScriptTag(&quot;http://www.hahaha2.com/abc/b.js&quot;)  }&lt;/script&gt;</code></pre><p>如上所示，只是些基础操作，就不解释了，现在我们就可以优雅的控制执行了，再想调用一个远程服务的话，只要添加 <code>addScriptTag</code> 方法，传入远程服务的 src 值就可以</p><p>接下来我们就可以愉快的进行一次真正意义上的 <code>JSONP</code> 服务调取了</p><p>我们使用 <code>jsonplaceholder</code> 的 <code>todos</code> 接口作为示例，接口地址如下</p><pre><code class="txt">https://jsonplaceholder.typicode.com/todos?callback=?</code></pre><p><code>callback=?</code> 这个拼在接口后面表示回调函数的名称，也就是将你自己在客户端定义的回调函数的函数名传送给服务端，服务端则会返回以你定义的回调函数名的方法，将获取的 <code>JSON</code> 数据传入这个方法完成回调，我们的回调函数名字叫 <code>cb</code>，那么完整的接口地址就如下</p><pre><code class="txt">https://jsonplaceholder.typicode.com/todos?callback=cb</code></pre><p>那么话不多说，我们来试下</p><pre><code class="html">&lt;script type=&quot;text/javascript&quot;&gt;  function cb(res) {    console.log(res)  }  function addScriptTag(src){    let script = document.createElement(&#39;script&#39;)    script.setAttribute(&quot;type&quot;,&quot;text/javascript&quot;)    script.src = src    document.body.appendChild(script)  }  window.onload = function(){    addScriptTag(&quot;https://jsonplaceholder.typicode.com/todos?callback=cb&quot;)  }&lt;/script&gt;</code></pre><p>可以看到，页面在加载完成后，输出了接口返回的数据，这个时候我们再来看 JQ 中的 JSONP 实现</p><h4 id="JSONP的JQuery实现"><a href="#JSONP的JQuery实现" class="headerlink" title="JSONP的JQuery实现"></a>JSONP的JQuery实现</h4><p>还是用上面的接口，我们来看 JQ 怎么拿数据</p><pre><code class="js">$.ajax({  url:&quot;https://jsonplaceholder.typicode.com/todos?callback=?&quot;,     dataType:&quot;jsonp&quot;,  jsonpCallback:&quot;cb&quot;,  success: function(res){    console.log(res)  }});</code></pre><p>可以看到，为了让 JQ 按照 <code>JSONP</code> 的方式访问，<code>dataType</code> 字段设置为 <code>jsonp</code> ， <code>jsonpCallback</code> 属性的作用就是自定义我们的回调方法名，其实内部和我们上面写的差不多</p><h4 id="JSONP和AJAX对比"><a href="#JSONP和AJAX对比" class="headerlink" title="JSONP和AJAX对比"></a>JSONP和AJAX对比</h4><ul><li><p>调用方式上</p><ul><li><code>AJAX</code> 和 <code>JSONP</code> 很像，都是请求url，然后把服务器返回的数据进行处理</li><li>所以类 <code>JQuery</code> 的库只是把 <code>JSONP</code> 作为 <code>AJAX</code> 请求的一种形式进行封装，不要搞混</li></ul></li><li><p>核心原理上</p><ul><li><code>AJAX</code> 的核心是通过 <code>xmlHttpRequest</code> 获取非本页内容</li><li><code>JSONP</code>的核心是动态添加 <code>script</code> 标签调用服务器提供的 JS 脚本，后缀 <code>.json</code> </li></ul></li><li><p>两者区别上，</p><ul><li><code>AJAX</code> 不同域会报跨域错误，不过也可以通过服务端代理、<code>CORS</code> 等方式跨域，而 <code>JSONP</code> 没有这个限制，同域不同域都可以</li><li><code>JSONP</code> 是一种方式或者说非强制性的协议，<code>AJAX</code> 也不一定非要用 <code>json</code> 格式来传递数据　</li><li><code>JSONP</code> 只支持 <code>GET</code> 请求，<code>AJAX</code> 支持 <code>GET</code> 和 <code>POST</code> </li></ul></li></ul><p>最后，JSONP是很老的一种跨域方式了，现在基本没什么人用，所以，我们了解懂它即可</p><p>一般情况下，我们希望这个script标签能够动态的调用，而不是像上面因为固定在html里面所以没等页面显示就执行了，很不灵活。我们可以通过javascript动态的创建script标签，这样我们就可以灵活调用远程服务了</p><h3 id="No-6-CORS跨域资源共享"><a href="#No-6-CORS跨域资源共享" class="headerlink" title="No.6 CORS跨域资源共享"></a>No.6 CORS跨域资源共享</h3><h4 id="什么是CORS？"><a href="#什么是CORS？" class="headerlink" title="什么是CORS？"></a>什么是CORS？</h4><p>在出现 <code>CORS</code> 之前，我们都是使用 <code>JSONP</code> 的方式实现跨域，但是这种方式仅限于 <code>GET</code> 请求，而 <code>CORS</code> 的出现，为我们很好的解决了这个问题，这也是它成为一个趋势的原因 </p><p><code>CORS</code> 是一个W3C标准，全称是 <code>跨域资源共享（Cross-origin resource sharing）</code></p><p>它允许浏览器向跨源服务器，发出 <code>XMLHttpRequest</code> 请求，从而克服了 <code>AJAX</code> 只能同源使用的限制</p><p><code>CORS</code> 需要浏览器和服务器同时支持，目前基本所有浏览器都支持该功能，IE浏览器不低于 IE10 即可</p><p>整个 <code>CORS</code> 通信过程，都是浏览器自动完成，是不需要用户参与的，对于我们开发者来说，<code>CORS</code> 通信与同源的 <code>AJAX</code> 通信没有差别，代码完全一样，浏览器一旦发现 <code>AJAX</code> 请求跨源，就会自动添加一些附加的头信息，有的时候还会多出一次附加的请求，但这个过程中用户是无感的 </p><p>因此，实现 <code>CORS</code> 通信的关键是服务器，只要服务器设置了允许的 <code>CORS</code> 接口，就可以进行跨源通信，要了解怎么实现 <code>CORS</code> 跨域通信，我们还要先了解浏览器对每个请求都做了什么</p><p>浏览器会将 <code>CORS</code> 请求分成两类，简单请求（simple request）和非简单请求（not-so-simple request），浏览器对这两种请求的处理，是不一样的</p><h4 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h4><p>什么是简单请求，其实很好理解记住两条就好了</p><ul><li>请求方法是 <code>HEAD、GET、POST</code> 三种方法之一</li><li>HTTP的头信息不超出以下几种字段<ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Last-Event-ID</li><li>Content-Type（只限于三个值<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code>）</li></ul></li></ul><p>只要同时满足这两个条件，那么这个请求就是一个简单请求</p><p>对于简单请求来说，浏览器会直接发出CORS请求，就是在这个请求的头信息中，自动添加一个 <code>Origin</code> 字段来说明本次请求的来源（协议 + 域名 + 端口），而后服务器会根据这个值，决定是否同意这次请求</p><h4 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h4><p>知道了简单请求的定义，非简单请求就比较简单了，因为只要不是简单请求，它就是非简单请求</p><p>浏览器应对非简单请求，会在正式通信之前，做一次查询请求，叫预检请求（preflight），也叫 <code>OPTIONS</code> 请求，因为它使用的请求方式是 <code>OPTIONS</code> ，这个请求是用来询问的</p><p>浏览器会先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段，只有得到肯定答复，浏览器才会发出正式的 <code>XMLHttpRequest</code> 请求，否则就会报跨域错误</p><p>在这个预检请求里，头信息除了有表明来源的 <code>Origin</code> 字段外，还会有一个 <code>Access-Control-Request-Method</code> 字段和 <code>Access-Control-Request-Headers</code> 字段，它们分别表明了该浏览器 <code>CORS</code> 请求用到的 <code>HTTP</code> 请求方法和指定浏览器 <code>CORS</code> 请求会额外发送的头信息字段，如果你看的云里雾里，不要着急，我们看个例子</p><p>如下为一个 AJAX 请求示例</p><pre><code class="js">let url = &#39;http://www.hahaha.com/abc&#39;let xhr = new XMLHttpRequest()xhr.open(&#39;POST&#39;, url, true)xhr.setRequestHeader(&#39;X-Token&#39;, &#39;YGJHJHGJAHSGJDHGSJGJHDGSJHS&#39;)xhr.setRequestHeader(&#39;X-Test&#39;, &#39;YGJHJHGJAHSGJDHGSJGJHDGSJHS&#39;)xhr.send()</code></pre><p>这个例子中，我们发送了一个POST请求，并在它的请求头中添加了一个自定义的 <code>X-Token</code> 和 <code>X-Test</code> 字段，因为添加了自定义请求头字段，所以它是一个非简单请求</p><p>那么这个非简单请求在预检请求头信息中就会携带以下信息</p><pre><code class="txt">// 来源Origin: http://www.hahaha.com// 该CORS请求的请求方法Access-Control-Request-Method: POST// 额外发出的头信息字段Access-Control-Request-Headers: X-Token, X-Test</code></pre><h4 id="withCredentials属性"><a href="#withCredentials属性" class="headerlink" title="withCredentials属性"></a>withCredentials属性</h4><p>CORS 请求默认不发送 Cookie 和 HTTP 认证信息</p><p>如果要把 Cookie 发到服务端，首先要服务端同意，指定<code>Access-Control-Allow-Credentials</code> 字段</p><pre><code class="txt">Access-Control-Allow-Credentials: true</code></pre><p>其次，客户端必须在发起的请求中打开 <code>withCredentials</code> 属性</p><pre><code class="js">xhr = new XMLHttpRequest()xhr.withCredentials = true</code></pre><p>不然的话，服务端和客户端有一个没设置，就不会发送或处理Cookie</p><p>虽说浏览器默认不发送 Cookie 和 HTTP 认证信息，但是有的浏览器，还是会一起发送Cookie，这时你也可以显式关闭 <code>withCredentials</code> </p><pre><code class="js">xhr.withCredentials = false</code></pre><p>注意，如要发送 <code>Cookie</code>，<code>Access-Control-Allow-Origin</code> 字段就不能设为星号，必须指定明确的、与请求网页一致的域名，同时，<code>Cookie</code> 依然遵循同源政策，只有用服务器域名设置的 <code>Cookie</code> 才会上传，其他域名的 <code>Cookie</code> 并不会上传，且（跨源）原网页代码中的 <code>document.cookie</code> 也无法读取服务器域名下的 <code>Cookie</code> ，下面还会提到</p><h4 id="服务端CORS跨域配置"><a href="#服务端CORS跨域配置" class="headerlink" title="服务端CORS跨域配置"></a>服务端CORS跨域配置</h4><p>上面的东西只是为了让我们理解CORS，但是要解决它还是需要服务端配置的，不同语言的配置项语法上可能有差异，但是内容肯定都是一样的</p><p><strong>配置允许跨域的来源</strong> </p><pre><code class="txt">Access-Control-Allow-Origin: *</code></pre><p><code>CORS</code> 跨域请求中，最关键的就是 <code>Access-Control-Allow-Origin</code> 字段，是必需项，它表示服务端允许跨域访问的地址来源，你可以写入需要跨域的域名，也可以设为星号，表示同意任意跨源请求</p><p>注意，将此字段设置为 <code>*</code> 是很不安全的，建议指定来源，并且设置为 <code>*</code> 号后，游览器将不会发送 <code>Cookie</code>，即使你的 <code>XHR</code> 设置了 <code>withCredentials</code>，也不会发送 <code>Cookie</code> </p><p><strong>配置允许跨域请求的方法</strong> </p><pre><code class="txt">Access-Control-Allow-Methods: GET, POST, OPTIONS, PUT...</code></pre><p>该字段也是必需项，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法</p><p><strong>配置允许的请求头字段</strong> </p><pre><code class="txt">Access-Control-Allow-Headers: x-requested-with,content-type...</code></pre><p>如果你的请求中有自定义的请求头字段，那么此项也是必须的，它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在预检中请求的字段</p><p><strong>配置是否允许发送Cookie</strong> </p><pre><code class="txt">Access-Control-Allow-Credentials: true</code></pre><p>该字段可选，它的值是一个布尔值，表示是否允许发送Cookie，默认情况下，Cookie不包括在CORS请求之中</p><p>设为<code>true</code>，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器</p><p>该字段只能设为<code>true</code>，如果服务器不要浏览器发送Cookie，删除该字段即可</p><p><strong>配置本次预检请求的有效期</strong> </p><pre><code class="txt">Access-Control-Max-Age: 1728000</code></pre><p>该字段可选，用来指定本次预检请求的有效期，单位为秒，上面结果中，有效期是20天（1728000秒），即允许缓存该条回应20天，在此期间如果你再次发出了这个接口请求，就不用发预检请求了，节省服务端资源</p><h4 id="常见的跨域预检请求抛错"><a href="#常见的跨域预检请求抛错" class="headerlink" title="常见的跨域预检请求抛错"></a>常见的跨域预检请求抛错</h4><p>对于我们开发时，在跨域中最容易碰钉子的地方就是预检请求，所以列举几个预检请求错误的原因，知道哪错了可以直接找后端同学理论，关于预检请求，最终目的只有一个，客户端发送预检，服务端允许并返回200即可</p><p><strong>OPTIONS 404</strong> </p><pre><code class="txt">No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource且 The response had HTTP status code 404</code></pre><p>服务端没有设置允许 <code>OPTIONS</code> 请求，那么在发起该预检请求时响应状态码会是404，因为无法找到对应接口地址</p><p>那么你可能需要找到后端，优雅的告诉他，请允许下 <code>OPTIONS</code> 请求</p><p><strong>OPTIONS 405</strong> </p><pre><code class="txt">No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource且 The response had HTTP status code 405</code></pre><p>服务端已经允许了 <code>OPTIONS</code> 请求，但是一些配置文件中（如安全配置）阻止了 <code>OPTIONS</code> 请求</p><p>那么你可能需要找到后端，优雅的告诉他，请关闭对应的安全配置</p><p><strong>OPTIONS 200</strong> </p><pre><code class="txt">No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource且 OPTIONS 请求 status 为 200</code></pre><p>服务器端允许了 <code>OPTIONS</code> 请求，配置文件中也没有阻止，但是头部匹配时出现不匹配现象</p><p>所谓头部匹配，就比如 <code>Origin</code> 头部检查不匹配，或者少了一些头部的支持（如 <code>X-Requested-With</code> 等）,然后服务端就会将 <code>Response</code> 返回给前端，前端检测到这个后就触发 <code>XHR.onerror</code> ，从而导致报错</p><p>那么你可能需要找到后端，优雅的告诉他，请增加对应的头部支持</p><p><strong>OPTIONS 500</strong> </p><p>这个就更简单了，服务端针对 <code>OPTIONS</code> 请求的代码出了问题，或者没有响应</p><p>那么你可能需要找到后端，将 <code>Network</code> 中的错误信息截一图发给他，优雅的告诉他，检测到预检请求时，请把它搞成200</p><h3 id="No-7-Nginx代理跨域"><a href="#No-7-Nginx代理跨域" class="headerlink" title="No.7 Nginx代理跨域"></a>No.7 Nginx代理跨域</h3><h4 id="iconfont跨域解决"><a href="#iconfont跨域解决" class="headerlink" title="iconfont跨域解决"></a>iconfont跨域解决</h4><p>浏览器跨域访问 <code>js/css/img</code> 等常规静态资源时被同源策略许可的，但 <code>iconfont</code> 字体文件比如 <code>eot|otf|ttf|woff|svg</code> 例外，此时可在 <code>Nginx</code> 的静态资源服务器中加入以下配置来解决</p><pre><code class="txt">location / {  add_header Access-Control-Allow-Origin *;}</code></pre><h4 id="反向代理接口跨域"><a href="#反向代理接口跨域" class="headerlink" title="反向代理接口跨域"></a>反向代理接口跨域</h4><p>我们知道同源策略只是 <strong>浏览器</strong> 的安全策略，不是 <code>HTTP</code> 协议的一部分， 服务器端调用 <code>HTTP</code> 接口只是使用 <code>HTTP</code> 协议，不会执行 JS 脚本，不需要同源策略，也就不存在跨越问题</p><p>通俗点说就是客户端浏览器发起一个请求会存在跨域问题，但是服务端向另一个服务端发起请求并无跨域，因为跨域问题归根结底源于同源策略，而同源策略只存在于浏览器</p><p>那么我们是不是可以通过 <code>Nginx</code> 配置一个代理服务器，反向代理访问跨域的接口，并且我们还可以修改 <code>Cookie</code> 中 <code>domain</code> 信息，方便当前域 <code>Cookie</code> 写入</p><p><code>Nginx</code> 其实就是各种配置，简单易学，就算没接触过，也很好理解，我们来看示例</p><p>首先假如我们的页面 a 在 <code>http://www.hahaha.com</code> 域下，但是我们的接口却在 <code>http://www.hahaha1.com:9999</code> 域下</p><p>接着我们在页面 a 发起一个 <code>AJAX</code> 请求时，就会跨域，那么我们就可以通过 <code>Nginx</code> 配置一个代理服务器，域名和页面 a 相同，都是 <code>http://www.hahaha.com</code> ，用它来充当一个跳板的角色，反向代理访问  <code>http://www.hahaha1.com</code>  接口</p><pre><code class="nginx"># Nginx代理服务器server {  listen       80;  server_name  www.hahaha.com;  location / {    # 反向代理地址    proxy_pass   http://www.hahaha1.com:9999;      # 修改Cookie中域名    proxy_cookie_domain www.hahaha1.com www.hahaha.com;     index  index.html index.htm;    # 前端跨域携带了Cookie，所以Allow-Origin配置不可为*    add_header Access-Control-Allow-Origin http://www.hahaha.com;      add_header Access-Control-Allow-Credentials true;  }}</code></pre><p>没错，这个代理配置相信没接触过 <code>Nginx</code> 也能看明白，大部分都是我们上文提到过的，是不是很简单呢</p><h3 id="No-8-Node代理跨域"><a href="#No-8-Node代理跨域" class="headerlink" title="No.8 Node代理跨域"></a>No.8 Node代理跨域</h3><p><code>Node</code> 实现跨域代理，与 <code>Nginx</code> 道理相同，都是启一个代理服务器，就像我们常用的 <code>Vue-CLI</code> 配置跨域，其实也是 <code>Node</code> 启了一个代理服务，接下来我们来看看是如何做的</p><h4 id="Vue-CLI中代理的多种配置"><a href="#Vue-CLI中代理的多种配置" class="headerlink" title="Vue-CLI中代理的多种配置"></a>Vue-CLI中代理的多种配置</h4><p>Vue-CLI 是基于 <code>webpack</code> 的，通过 <code>webpack-dev-server</code> 在本地启动脚手架，也就是在本地启动了一个 <code>Node</code> 服务，来实时监听和打包编译静态资源，由于都是封装好的，只需要配置即可，我们在 <code>vue.config.js</code> 中配置代理如下，写法很多，列几个常见的自行选择</p><p><strong>使用一</strong> </p><pre><code class="js">module.exports = {  //...  devServer: {    proxy: {      &#39;/api&#39;: &#39;http://www.hahaha.com&#39;    }  }}</code></pre><p>如上所示时，当你请求 <code>/api/abc</code> 接口时就会被代理到 <code>http://www.hahaha.com/api/abc</code> </p><p><strong>使用二</strong> </p><p>当然，你可能想将多个路径代理到同一个 <code>target</code> 下，那你可以使用下面这种方式</p><pre><code class="js">module.exports = {  //...  devServer: {    proxy: [{      context: [&#39;/api1&#39;, &#39;/api2&#39;, &#39;/api3&#39;],      target: &#39;http://www.hahaha.com&#39;,    }]  }}</code></pre><p><strong>使用三</strong> </p><p>正如我们第一种使用方式代理时，代理了 <code>/api</code> ，最终的代理结果是 <code>http://www.hahaha.com/api/abc</code> ，但是有时我们并不想代理时传递 <code>/api</code>，那么就可以使用下面这种方式，通过 <code>pathRewrite</code> 属性来进行路径重写</p><pre><code class="js">module.exports = {  //...  devServer: {    proxy: {      &#39;/api&#39;: {        target: &#39;http://www.hahaha.com&#39;,        pathRewrite: {&#39;^/api&#39; : &#39;&#39;}      }    }  }}</code></pre><p>这个时候，<code>/api/abc</code> 接口就会被代理到 <code>http://www.hahaha.com/abc</code>  </p><p><strong>使用四</strong> </p><p>默认情况下，我们代理是不接受运行在 <code>HTTPS</code> 上，且使用了无效证书的后端服务器的</p><p>如果你想要接受，需要设置 <code>secure: false</code> ，如下</p><pre><code class="js">module.exports = {  //...  devServer: {    proxy: {      &#39;/api&#39;: {        target: &#39;https://www.hahaha.com&#39;,        secure: false      }    }  }}</code></pre><p><strong>使用五</strong> </p><p>配置一个字段 <code>changeOrigin</code> ，当它为 <code>true</code> 时，本地就会虚拟一个服务器接收你的请求并且代你发送该请求，所以如果你要代理跨域，这个字段是必选项</p><pre><code class="js">module.exports = {  // ...  devServer: {    proxy: {      &quot;/api&quot;: {        target: &#39;http://www.hahaha.com&#39;,        changeOrigin: true,      }    }  }}</code></pre><p><strong>使用六</strong> </p><p>如果你想配置多个不同的代理，也简单，如下所示，可以在任意代理中设置对应的代理规则</p><pre><code class="js">module.exports = {  // ...  devServer: {    proxy: {      &quot;/api1&quot;: {        target: &#39;http://www.hahaha1.com&#39;,        changeOrigin: true      },      &quot;/api2&quot;: {        target: &#39;http://www.hahaha2.com&#39;,        pathRewrite: {&#39;^/api2&#39; : &#39;&#39;}      },      &quot;/api3&quot;: {        target: &#39;http://www.hahaha3.com&#39;,        changeOrigin: true,        pathRewrite: {&#39;^/api3&#39; : &#39;&#39;}      }      // ...    }  }}</code></pre><p>注意，在本地配置代理跨域，只是解决开发时的跨域问题，当你的项目上线时，前端静态文件和后端在一个域下没有问题，如果并不在一个域下，依然会报跨域错误，这个时候还得需要后端配置跨域</p><h4 id="Node实现代理服务器"><a href="#Node实现代理服务器" class="headerlink" title="Node实现代理服务器"></a>Node实现代理服务器</h4><p>这里我们使用 <code>express + http-proxy-middleware</code> 来搭建一个代理服务器，使用 <code>http-proxy-middleware</code> 这个中间件没有别的意思，只是因为 <code>webpack-dev-server</code> 里就是使用的它</p><pre><code class="js">let express = require(&#39;express&#39;)let proxy = require(&#39;http-proxy-middleware&#39;)let app = express()app.use(&#39;/&#39;, proxy({    // 代理跨域目标接口    target: &#39;http://www.hahaha1.com:9999&#39;,    changeOrigin: true,    // 修改响应头信息，实现跨域并允许带cookie    onProxyRes: function(proxyRes, req, res) {        res.header(&#39;Access-Control-Allow-Origin&#39;, &#39;http://www.hahaha.com&#39;)        res.header(&#39;Access-Control-Allow-Credentials&#39;, &#39;true&#39;)    },    // 修改响应信息中的cookie域名，为false时，表示不修改    cookieDomainRewrite: &#39;www.hahaha.com&#39;}))app.listen(3000)</code></pre><h3 id="No-9-WebSocket跨域"><a href="#No-9-WebSocket跨域" class="headerlink" title="No.9 WebSocket跨域"></a>No.9 WebSocket跨域</h3><h4 id="WebSocket简介"><a href="#WebSocket简介" class="headerlink" title="WebSocket简介"></a>WebSocket简介</h4><p><code>WebSocket</code> 是一种在单个 TCP 连接上进行全双工通信的协议，2008年诞生，2011年被 IETF 定为标准 <code>RFC 6455</code>，并由 <code>RFC7936</code> 补充规范，<code>WebSocket API</code> 也被 W3C 定为标准</p><p><code>WebSocket</code> 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据， 在 <code>WebSocket API</code> 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输，同时，它也是跨域的一种解决方案</p><h4 id="WebSocket特点"><a href="#WebSocket特点" class="headerlink" title="WebSocket特点"></a>WebSocket特点</h4><ul><li><p>建立在 TCP 协议之上，服务器端的实现比较容易</p></li><li><p>与 HTTP 协议有着良好的兼容性，默认端口也是 80 和 443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器</p></li><li><p>数据格式比较轻量，性能开销小，通信高效</p></li><li><p>可以发送文本，也可以发送二进制数据</p></li><li><p>没有同源限制，客户端可以与任意服务器通信</p></li><li><p>协议标识符是 <code>ws</code>（如果加密，则为 <code>wss</code> ），服务器网址就是 URL</p></li></ul><p>如下</p><pre><code class="txt">ws://www.hahaha.com:80/abc/def</code></pre><h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h4><p>每个服务端语言对 <code>websocket</code> 有相应的支持，写法不同罢了，这里我们使用 <code>Node</code> 做示例</p><p>在客户端我们可以直接使用 HTML5 的 <code>websocket API</code> ，服务端也可以使用 <code>nodejs-websocket</code> 实现 <code>websocket server</code> ，但是不建议这样做，因为原生 <code>WebSocket API</code> 使用起有些复杂，在浏览器的兼容性上还不够理想，所以我们使用 <code>Socket.io</code>，它很好地封装了 <code>webSocket</code> 接口，提供了更简单、灵活的接口，也对不支持 <code>webSocket</code> 的浏览器提供了向下兼容，使用 <code>Socket.io</code> 库实现 <code>websocket</code>，在发送数据时可以直接发送可序列化的对象，也可以自定义消息，利用事件字符串来区分不同消息，整个开发过程会舒服很多</p><p>想要了解更多看官网即可 <a href="https://socket.io/" target="_blank" rel="noopener">Socket.io - 传送门</a> ，我们来看示例</p><p>客户端：<code>http://www.hahaha.com/a.html</code> </p><pre><code class="html">&lt;script src=&quot;/socket.io/socket.io.js&quot;&gt;&lt;/script&gt;&lt;script&gt;  let socket = io.connect(&#39;http://www.hahaha1.com:3000&#39;)  socket.on(&#39;my event&#39;, (data) =&gt; {    console.log(data) // { hello: &#39;world&#39; }    socket.emit(&#39;my other event&#39;, { my: &#39;data&#39; })  })&lt;/script&gt;</code></pre><p>服务端：<code>http://www.hahaha1.com:3000</code> </p><pre><code class="js">const app = require(&#39;express&#39;).createServer()const io = require(&#39;socket.io&#39;)(app)app.listen(3000)io.on(&#39;connection&#39;, (socket) =&gt; {  socket.emit(&#39;my event&#39;, { hello: &#39;world&#39; })  socket.on(&#39;my other event&#39;, (data) =&gt; {    console.log(data) // { my: &#39;data&#39; }  })})</code></pre><p>如上所示，使用了 <code>Socket.io</code> 之后的 <code>websocket</code> 连接是不是超级简单呢，跟着文档自己动手试试吧</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>欢迎大家关注公众号「不正经的前端」，时不时发一篇文章，也没有花里胡哨的推广和广告，希望可以让大家随意点开一篇文章，都可以看到满满的干货，也可以直接加机器人好友备注「加群 | 前端 | 后端 | 全栈」自动通过，通过后回复「加群」加入Web圈交流群，闲聊、吐槽、解决问题、交朋友都可以，当然技术为主</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20200713004935853.png" srcset="/blog/img/loading.gif" alt=""></p><p>按照时间线贴下了总结的比较全的几个帖子，还有其他的琐碎的文章，比较多就不贴了，这些文章都写的差不多，可能之间有互相抄袭，有互相借鉴，这些都是避免不了的，此文写的时候也借鉴了这些文章，只不过我手敲了一遍例子，又用我自己的理解码下来了，为此花了1周的业余时间，内容上与下面作者写的有些许雷同，那实属无奈，可以说是知识点就那么多，大家的总结稍有不同的地方就剩表达的语法，我也难受，还特意找了工具鉴别了下相似度，以免被误会，毕竟我也特别反感搬运工，嗯，又是一个深夜，终于收工了，睡觉喽</p><blockquote><p>参考文章</p><p><a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html" target="_blank" rel="noopener">浏览器同源政策及其规避方法 - 阮一峰</a> - 2016.04</p><p><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">跨域资源共享 CORS 详解 - 阮一峰 </a> - 2016.04</p><p><a href="https://segmentfault.com/a/1190000007326671" target="_blank" rel="noopener">前端跨域整理 - 思否 damonare</a> - 2016.10</p><p><a href="https://segmentfault.com/a/1190000011145364" target="_blank" rel="noopener">前端常见跨域解决方案（全）- 思否 安静de沉淀</a>  - 2017.07</p><p><a href="https://juejin.im/post/5a2f92c65188253e2470f16d#heading-18" target="_blank" rel="noopener">正确面对跨域，别慌 - 掘金 Neal_yang </a> - 2017.12</p><p><a href="https://juejin.im/post/5c23993de51d457b8c1f4ee1" target="_blank" rel="noopener">九种跨域方式实现原理（完整版）- 掘金 浪里行舟 </a> - 2019.01</p><p><a href="https://juejin.im/post/5d1ecb96f265da1b6d404433" target="_blank" rel="noopener">9种常见的前端跨域解决方案（详解）- 掘金 小铭子</a> - 2019.07</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Web相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浏览器</tag>
      
      <tag>JavaScript</tag>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「一道面试题」输入URL到渲染全面梳理下-总结篇</title>
    <link href="/blog/2020/05/08/Interview/%E3%80%8C%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98%E3%80%8D%E8%BE%93%E5%85%A5URL%E5%88%B0%E6%B8%B2%E6%9F%93%E5%85%A8%E9%9D%A2%E6%A2%B3%E7%90%86%E4%B8%8B-%E6%80%BB%E7%BB%93%E7%AF%87/"/>
    <url>/blog/2020/05/08/Interview/%E3%80%8C%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98%E3%80%8D%E8%BE%93%E5%85%A5URL%E5%88%B0%E6%B8%B2%E6%9F%93%E5%85%A8%E9%9D%A2%E6%A2%B3%E7%90%86%E4%B8%8B-%E6%80%BB%E7%BB%93%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="「一道面试题」输入URL到渲染全面梳理下-总结篇"><a href="#「一道面试题」输入URL到渲染全面梳理下-总结篇" class="headerlink" title="「一道面试题」输入URL到渲染全面梳理下-总结篇"></a>「一道面试题」输入URL到渲染全面梳理下-总结篇</h1><h2 id="要知道"><a href="#要知道" class="headerlink" title="要知道"></a>要知道</h2><p>此文是一道面试题，又不仅仅是一道面试题，你会发现，这题不论大厂小厂，都会问，为什么</p><p>因为它足够经典，连续写了三篇帖子，每篇都上万字，依然感觉不够细，涉及的点真的很考验一个人的知识覆盖率，还是多方面的考验，如果让我来面试的话，我觉得完全可以通过这一道题挖掘出面试者的基础知识储备量，延展性更是超强</p><p>SO，答好它可以让面试官眼前一亮，让你与众不同</p><p>此文是总结篇，没有看过前两篇的小伙伴建议先看看，然后自己总结总结，再来看这篇，因为前两文是为了能够看懂此文才写的</p><p><a href="https://juejin.im/post/5e9c48b2f265da47c558566b" target="_blank" rel="noopener">「一道面试题」输入URL到渲染全面梳理上-网络通信篇</a> </p><p><a href="https://juejin.im/post/5e9f1db86fb9a03c85463560" target="_blank" rel="noopener">「一道面试题」输入URL到渲染全面梳理中-页面渲染篇</a> </p><p>如果你都看过了，那就来一块总结吧，首先，还请为我的疯狂码字点个赞再看哦，最近打字速度都快了不少 😄</p><h2 id="回顾？"><a href="#回顾？" class="headerlink" title="回顾？"></a><del>回顾</del>？</h2><p>本来这块儿会简单回顾下前两文知识点再进行总结的，还有一个思维导图，原本已经写的差不多了，大概有个1万字了，后来写着写着被我删了大半重新写了</p><p>因为某天心血来潮，想把整篇文章换成一面试的问答帖，写帖嘛，我比较喜欢 <code>认真且随心所欲</code> ，就删了重来了，所以此文才会慢了些</p><p>下文会以一个面试官和面试者问答的过程来描述这些个问题，主体问题答完之后还会有一些比较常见的主体发散的问题，最近得空看完了电视剧 <code>鬓边不是海棠红</code> ，看的说话都有点被带跑偏了，用剧中 <code>老北京腔</code> 来说就是 <code>得，您瞧好吧！😄</code> ，好了，调侃完毕，开始正经了，干巴巴的万字小文来了，做好准备哦</p><p>首先请带入你自己，你就是一个面试者，仔细看每道题，先静心想一会，然后在心中回答，最后再看总结的答案 ( <strong>此答案也不一定对，个人感悟，只给大家做参考，也望大家给予补充或指正</strong> ) </p><h2 id="问-主体-：输入URL到页面渲染都经历了什么？"><a href="#问-主体-：输入URL到页面渲染都经历了什么？" class="headerlink" title="问(主体)：输入URL到页面渲染都经历了什么？"></a>问(主体)：输入URL到页面渲染都经历了什么？</h2><p><code>个人觉得</code> ，不要急着回答，先思考30秒，在心中形成一个大致步骤的轮廓，先概括，然后再慢慢道来，注意节奏，中间也可以短暂停顿思考，面试官不会因为你想了一会就 <code>pass</code> 掉你，相反，你直接脱口而出一堆内容，会让面试官觉得你像是背课文</p><p>对于主体问题，写了两种回答，觉得需要注意两点来选择性回答，至少我这么觉得</p><p><strong>面试官的状态</strong> </p><p>大致判断面试官是一个什么样的人，注意面试官这个人的状态，这很重要，通过对面试官当时状态的判断来决定精简回答或是轰炸式回答，这里的轰炸式回答不是说越多越好，说的是我们在回答的时候顺带牵出一些知识点来证明我们的知识量，但是不管怎样回答都要回答在点上，不要认为答得越多越好就扯一些有的没的，这大概就是察言观色吧</p><p><strong>你的状态</strong> </p><p>你的状态就比较容易理解了，如果你对一些知识点掌握不牢靠或有些紧张，这个时候就不要死撑还争取回答的面面俱到了 (面试官面前不太懂硬装做什么都懂，容易引起些许反感)，尽量精简，把你熟的地方多说一点，这样可以对面试官进行一个暗示引导，然后等待让面试官发散问你，通常你哪里说的多，面试官就会往哪个方向发散，如果你足够自信，那就尽情说好了，不在意他的发散，只要不说没用的就👌，绝大多数面试官对于这种情况应该都会喜欢</p><h3 id="一本正经的轰炸式回答"><a href="#一本正经的轰炸式回答" class="headerlink" title="一本正经的轰炸式回答"></a>一本正经的轰炸式回答</h3><p>面试官你好，这个问题是一个经典问题，我业余时间也有仔细阅读过一些相关书籍，做过一些总结，因为涉及到的知识点很多，所以可能会花一些时间，如果中间您有什么问题或者我的回答有不正确，还请您随时打断我，为我指出错误，谢谢</p><p>我觉得从URL输入到页面渲染大体上可以分为<code>网络通信</code> 和 <code>页面渲染</code> 两个阶段</p><p>首先是网络通信阶段，在互联网中网络设备之间的通信都会遵循 <code>TCP/IP四层协议</code>，通过 <code>TCP/IP</code> 网络分层顺序与对方进行通信，分层由高到低分别为：应用层、传输层、网络层、数据链路层，我们浏览器输入URL也就是发送端会从 <code>应用层</code> 往下走，接收端也就是服务器会从 <code>数据链路层</code> 往上走，通常我们会用五层协议来解释，数据链路层这一层会分成物理层和数据链路层两层</p><h4 id="浏览器输入URL"><a href="#浏览器输入URL" class="headerlink" title="浏览器输入URL"></a>浏览器输入URL</h4><p>输入URL按下回车后，就进入了 <code>应用层</code> 开始往下走，浏览器会开一个线程来处理，先对URL进行解析，一般包括 ( 协议头、主机域名或IP地址、端口号、请求路径、查询参数、hash等等 )，然后打开网络线程发出一个完整的请求</p><h4 id="应用层DNS解析域名"><a href="#应用层DNS解析域名" class="headerlink" title="应用层DNS解析域名"></a>应用层DNS解析域名</h4><p>这其中DNS解析，也就是 <code>域名或IP解析</code> 是因为我们输入的URL通常都是一个域名，计算机不认识域名只知道IP，所以需要DNS解析通过域名查询得到对应IP，对于DNS解析时</p><ul><li>首先会查看浏览器DNS缓存</li><li>没有的话就查询计算机本地DNS缓存</li><li>还没有就询问递归式DNS服务器（就是网络提供商，一般这个服务器都会有自己的缓存，所以IP查询大多都在这里完成）</li><li>如果依然没有缓存，那就需要通过 根域名服务器 和 TLD域名服务器 再到对应的 权威DNS服务器 找记录，并缓存到 递归式服务器，然后 递归服务器 再将记录返回给本地</li></ul><h4 id="应用层客户端发送HTTP请求"><a href="#应用层客户端发送HTTP请求" class="headerlink" title="应用层客户端发送HTTP请求"></a>应用层客户端发送HTTP请求</h4><p>IP地址有了，应用层的客户端想看页面，就会发一个 <code>HTTP</code> 请求，<code>HTTP</code> 请求分为 <code>请求报头</code> 和 <code>请求主体</code> ，请求主体就是客户端要发送给服务器或者服务器返回给客户端的内容，请求报头比较重要，包含通信方式也就是请求方法 (POST / GET / INPUT / DELETE等)、URI、协议版本号以及请求头部方法（Accept、Cache-Control…）</p><h4 id="传输层TCP传输报文"><a href="#传输层TCP传输报文" class="headerlink" title="传输层TCP传输报文"></a>传输层TCP传输报文</h4><p><code>应用层</code> 发送了一个请求后，为了传输方便，在 <code>传输层</code> 会把从 <code>应用层</code> 接收到的数据 ( 就是那个HTTP请求报文 ) 进行分割，并为每个报文编号后再转发给 <code>网络层</code>，编号就是方便服务器接收时能准确地还原报文信息，这里用到了我们常说的 <code>TCP协议</code> </p><p><code>TCP协议</code> 会通过 <code>三次握手</code> 保证传输的安全可靠，也可以这样说，客户端在 <code>传输层</code> 开始和服务器通过 <code>三次握手</code> 建立 <code>TCP/IP</code> 连接</p><p>所谓的 <code>三次握手</code> ，就是发送端先发送一个带有 <code>SYN</code> ( synchronize ) 标志的数据包给接收端，在一定的延迟时间内等待接收端的回复，接收端收到数据包后，传回一个带有 <code>SYN / ACK</code> 标志的数据包以表示传达确认信息，接收方收到后再发送一个带有 <code>ACK</code> 标志的数据包给接收端以表示握手成功，在这个过程中，如果发送端在规定延迟时间内没有收到回复则默认接收方没有收到请求，而再次发送，直到收到回复为止</p><p>也就是上一文说的</p><ul><li><p>小李 (客户端)：您好，您是xx的面试官吗？</p></li><li><p>面试官 (服务端)：嗯嗯，是的，你是昨天投简历的小李吗？</p></li><li><p>小李 (客户端)：嗯嗯，是的，我是</p></li></ul><h4 id="网络层IP协议查询MAC地址"><a href="#网络层IP协议查询MAC地址" class="headerlink" title="网络层IP协议查询MAC地址"></a>网络层IP协议查询MAC地址</h4><p>建立连接后 <code>网络层</code> IP协议会查询 <code>MAC地址</code> 进行数据包的传输</p><p>通俗来说，<code>IP协议</code> 负责把各种数据包传送给接收方，因为要保证确实能传输到对方，所以需要确定接收方的 <code>MAC地址</code> 也就是我们说的物理地址，<code>IP地址</code> 可以和 <code>MAC地址</code> 通过映射表一一配对上，一个网络设备的IP地址可以更换，但是MAC地址一般是固定不变的，而 <code>IP</code> 到 <code>MAC</code> 的解析过程则依赖于 <code>ARP协议</code>，它可以根据通信方的 <code>IP地址</code> 反查出对应的 <code>MAC地址</code> </p><p>因为一般通信双方是无法直接进行通信的（除非在同一局域网），会经过多台计算机或路由器来进行中转，所以也就需要 <code>ARP</code> 来一路确认下一个中转站，协助数据包的传输</p><h4 id="数据到达数据链路层"><a href="#数据到达数据链路层" class="headerlink" title="数据到达数据链路层"></a>数据到达数据链路层</h4><p>找到对方的 <code>MAC地址</code> 后，就会将数据发送到 <code>数据链路层</code>传输，到此客户端发送请求阶段就结束了</p><h4 id="服务器接收数据"><a href="#服务器接收数据" class="headerlink" title="服务器接收数据"></a>服务器接收数据</h4><p>而后接收端的服务器在 <code>数据链路层</code> 接收到数据包，再通过相反的方式将数据一层一层的还原回 <code>应用层</code> ，这过程中包括在运输层那里通过TCP协议将分段的数据包重新组成原来的HTTP请求报文</p><p>请求到了后台服务器，一般来说会有统一的验证，如安全验证、跨域验证等，验证未通过就直接返回相应的HTTP报文，验证通过后，就会进入后台代码，此时程序收到请求，然后会执行对应的操作</p><p>如果浏览器访问过，且缓存上有对应的资源，就会与服务器最后修改时间对比，一致便返回304，告诉浏览器可使用本地缓存</p><h4 id="服务器响应请求"><a href="#服务器响应请求" class="headerlink" title="服务器响应请求"></a>服务器响应请求</h4><p>服务器接收到客户端发送的HTTP请求后，会查找客户端请求的资源，并返回响应报文</p><p>另外现在很多网站都会有重定向功能，比如请求域名省去了 <code>www.</code>，它会给你重定向来添加上，这也就意味着第一次请求 <code>HTML</code> 的过程中我们是需要发起两次请求的</p><p>这样做的原因在于搜索引擎会认为 <code>www.xxx.com</code> 和 <code>xxx.com</code> 是两个网站，从而造成网站排名下降，还有如果两个地址都有打开过，会造成多余 ( 双倍 ) 的浏览器缓存</p><h4 id="服务器返回相应文件"><a href="#服务器返回相应文件" class="headerlink" title="服务器返回相应文件"></a>服务器返回相应文件</h4><p>请求成功后，服务器会返回相应的网页，浏览器接收到响应成功的报文后便开始下载网页，至此，网络通信结束</p><h4 id="解析HTML构建DOM-Tree"><a href="#解析HTML构建DOM-Tree" class="headerlink" title="解析HTML构建DOM Tree"></a>解析HTML构建DOM Tree</h4><p>拿到服务器返回的网页后，首先，根据顶部定义的DTD类型进行对应的解析方式，网页的解析将会被交给内部的GUI渲染线程处理</p><p>渲染线程中的HTML解释器，将HTML网页和资源从字节流解释转换成字符流，再通过词法分析器将字符流解释成词，之后经过语法分析器根据词构建成节点，最后通过这些节点组建一个DOM树</p><p>这个过程中，如果遇到的节点是 JS 代码，就会调用 <code>JS引擎</code> 对 JS代码进行解释执行，此时由于 <code>JS引擎</code> 和 <code>GUI渲染线程</code> 的互斥，<code>GUI渲染线程</code> 就会被挂起，渲染过程停止，如果 JS 代码的运行中对DOM树进行了修改，那么DOM的构建需要从新开始</p><p>如果节点需要依赖其他资源，图片/CSS等等，就会调用网络模块的资源加载器来加载它们，它们是异步的，不会阻塞当前DOM树的构建</p><p>如果遇到的是 JS 资源URL（没有标记异步），则需要停止当前DOM的构建，直到 JS 的资源加载并被 <code>JS引擎</code> 执行后才继续构建DOM</p><h4 id="解析CSS构建CSSOM-Tree"><a href="#解析CSS构建CSSOM-Tree" class="headerlink" title="解析CSS构建CSSOM Tree"></a>解析CSS构建CSSOM Tree</h4><p>CSS解释器会将CSS文件解释成内部表示结构，生成CSS规则树，这个过程也是和DOM解析类似的，<code>CSS</code> 字节转换成字符，接着词法解析与法解析，最后构成 <code>CSS对象模型(CSSOM)</code> 的树结构</p><p>构建的过程中浏览器得递归 <code>DOM</code> 树来确定元素到底是什么样式，为了 <code>CSSOM</code> 的完整性，只有等构建完毕才能进入到下一个阶段，所以就算 <code>DOM</code> 已经构建完了，也得等 <code>CSSOM</code>，然后才能进入下一个阶段</p><h4 id="构建渲染树-Render-Tree"><a href="#构建渲染树-Render-Tree" class="headerlink" title="构建渲染树 (Render Tree)"></a>构建渲染树 (Render Tree)</h4><p>接着 <code>CSSOM 树</code>和 <code>DOM 树</code> 合并成渲染树，也叫呈现树，<code>渲染树</code> 只包含渲染网页所需的节点，然后用于计算每个可见元素的布局，并输出给绘制流程，将像素渲染到屏幕上</p><h4 id="布局-Layout"><a href="#布局-Layout" class="headerlink" title="布局 (Layout)"></a>布局 (Layout)</h4><p><code>渲染树</code> 同时包含了屏幕上的所有可见内容及其样式信息，有了渲染树，再接着就会进入布局 ( layout ) 阶段了，到目前为止，浏览器计算了哪些节点应该是可见的以及它们的计算样式，但还没有计算它们在设备视口内的确切位置和大小，这就是 <code>布局</code> ( Layout ) 阶段，也称为 <code>自动重排</code> 或 <code>回流</code> ( Reflow )</p><p>此阶段一般意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树</p><h4 id="绘制-Painting"><a href="#绘制-Painting" class="headerlink" title="绘制 (Painting)"></a>绘制 (Painting)</h4><p>经由前几步我们知道了哪些节点可见、它们的计算样式以及几何信息，将这些信息及渲染树中的每个节点转换成屏幕上的实际像素，也就是俗称的 <code>绘制</code> 或 <code>栅格化</code> 阶段</p><h4 id="合成-Composite"><a href="#合成-Composite" class="headerlink" title="合成(Composite)"></a>合成(Composite)</h4><p>最后一步合成( <code>composite</code> )，这一步骤浏览器会将各层信息发送给GPU，GPU将各层合成，显示在屏幕上</p><p>至此上述的内容就是我理解的一个URL从解析到渲染的生命历程了</p><h3 id="干净简洁的概括式回答"><a href="#干净简洁的概括式回答" class="headerlink" title="干净简洁的概括式回答"></a>干净简洁的概括式回答</h3><p>PS：这里大体的点我觉得还是要答出来的，可以根据自己的了解进行某些方面的扩展，至少我觉得是这样子的，也是个人理解，欢迎探讨</p><p>面试管你好，URL输入到页面渲染，这是一个经典的话题，涉及的知识点也很多，我按照我的个人理解给您简单概括下，有不对的地方还请您指出</p><p>首先，客户端浏览器输入URL，由于是域名，应用层DNS开始解析域名</p><p>接着，应用层客户端发送一个HTTP请求，把拿到的应用层HTTP请求报文数据分割编号，为了方便安全的传输，传输层会通过TCP三次握手建立TCP/IP链接</p><p>建立连接后 <code>网络层</code> IP协议会查询服务器 <code>MAC地址</code> 也就是物理地址进行数据包的传输</p><p>找到对方的 <code>MAC地址</code> 后，将数据发送到 <code>数据链路层</code>传输，到此客户端发送请求阶段结束</p><p>接收端的服务器在 <code>数据链路层</code> 接收到数据包，再通过相反的方式将数据一层一层的还原回 <code>应用层</code> </p><p>服务器接收到客户端发送的HTTP请求后，会查找客户端请求的资源，并返回响应报文</p><p>请求成功后，服务器会返回相应的网页，浏览器接收到响应成功的报文后便开始下载网页，至此，网络通信结束</p><p>浏览器拿到网页文件后，首先根据顶部定义的DTD类型进行对应解析方式，网页解析会交给内部GUI渲染线程处理</p><p>接着构建DOM树和CSSOM树，过程中，如果遇到节点是 JS ，就会调用 <code>JS引擎</code> 对 JS代码进行解释执行，此时由于 <code>JS引擎</code> 和 <code>GUI渲染线程</code> 互斥，<code>GUI渲染线程</code> 会被挂起，渲染过程停止，如果 JS 代码的运行中对DOM树进行了修改，那么DOM构建要从新开始，然后DOM树和CSSOM树构建为渲染树</p><p>然后进入布局阶段，计算渲染树节点在设备视口内的确切位置和大小</p><p>再接着将渲染树中每个节点转换成屏幕上的实际像素，也就是绘制阶段</p><p>最后的合成阶段浏览器会将各层信息发送给GPU，GPU将各层合成，显示在屏幕上</p><h2 id="问：TCP-IP四、五层，OSI七层模型有什么区别？"><a href="#问：TCP-IP四、五层，OSI七层模型有什么区别？" class="headerlink" title="问：TCP/IP四、五层，OSI七层模型有什么区别？"></a>问：TCP/IP四、五层，OSI七层模型有什么区别？</h2><p>网络层次可划分为 <code>四层因特网协议栈</code> 和 <code>七层因特网协议栈</code> ，起初网络分层是标准的七层，也就是我们所说的 <code>OSI 七层模型</code> ，参考模型是国际标准化组织 <code>ISO</code> 制定的一个用于计算机或通信系统间互联的标准体系，一般称为 <code>OSI参考模型</code> 或 <code>七层模型</code> </p><p>所谓的 <code>TCP/IP 四层模型</code> 和 <code>TCP/IP 五层模型</code> 是以 <code>OSI 七层</code> 优化而来，把某些层进行合并了，本质上还是相同的，<code>OSI七层模型</code> 太过细化，有一定的参考意义，但实现起来比较繁琐，相比较而言，<code>TCP/IP模型</code> 比较简洁，具有较强的实际应用价值</p><p><code>TCP/IP</code> 将计算机网络分成了四个层次，一般资料或教程里都是结合 <code>OSI7层模型</code> 和 <code>TCP/IP4层模型</code>，将计算机网络按照5层的模型来讲，5层模型只是为了方便介绍计算机网络原理而设计的，而在实际应用中还是 <code>TCP/IP四层模型</code> </p><p>各层对应关系如下</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20200507215523088.png" srcset="/blog/img/loading.gif" alt=""></p><h2 id="问：DNS解析可优化吗，为什么优化又怎样优化？"><a href="#问：DNS解析可优化吗，为什么优化又怎样优化？" class="headerlink" title="问：DNS解析可优化吗，为什么优化又怎样优化？"></a>问：DNS解析可优化吗，为什么优化又怎样优化？</h2><h3 id="是否"><a href="#是否" class="headerlink" title="是否"></a>是否</h3><p>可以优化</p><h3 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h3><p>用户打开网站的整个流程中，DNS解析是第一环，当用户输入域名并敲回车后，系统调用 <code>DNS客户端</code>，寻找到用户配置或者自动分配的<code>DNS IP</code>，之后就开始整个解析过程，<code>DNS服务器</code> 完成解析到此域名的 <code>数字IP服务器</code>，一般情况下返回给定域名对应的IP地址会花费 <code>20~120毫秒</code> 的时间，而且在这个过程中浏览器什么都不会做直到DNS查询完毕</p><p>一旦解析完成，连接建立并保持，也就是顺利的访问以后，网页以后的下载速度就和DNS没关系了，直到下一次重新解析和发起访问请求</p><p>很多小型网站，DNS解析时间都接近 <code>0.5s</code>，有些甚至需要 <code>1s</code> 左右才可以解析出结果，一般网站用户的等待时间超过 <code>8s</code> 就会放弃访问，而对于电子商务网站，<code>4s</code> 就是用户忍耐极限，而一般经过优化的小型网站，DNS解析时间都可以控制在 <code>200ms</code> 左右，而带宽在 <code>100M</code> 左右的网站，经过优化，DNS解析时间可以控制在 <code>50~100ms</code> ，所以DNS优化还是很有必要的</p><h3 id="怎样"><a href="#怎样" class="headerlink" title="怎样"></a>怎样</h3><p><strong>DNS解析优化-善用缓存之TTL</strong> </p><p>DNS存在着多级缓存，每次找这么多级，很定耗时间，我们要尽量多的让用户直接从运营商的DNS缓存中拿到解析记录，这样就不需要走根域名服务器以下的这些过程，自然就节省了一些时间</p><p>购买域名做域名解析时，有一个 <code>TTL</code> 值，它指的是域名解析的生命周期 ( 秒为单位 )，简单来说它表示DNS服务器解析域名时记录在DNS服务器上的缓存时间，这个值的大小设置也是很有学问的，我们要在尽可能快的情况下又要保证当服务器出问题时能够尽快切换</p><ul><li>我们自己肯定清楚自己的服务器有没有多台或备份，若无备份，那服务器宕机时只能生抗，所以，<code>TTL</code> 时间对于你来说是越长越好，因为 <code>TTL</code> 短的目的是服务器发生问题时，可以及时切换，这个对于没有备份的网站基本利用不上，所以这时你的 <code>TTL</code> 设置就越长越好，当然了，也不能太长，一般设置 <code>TTL 3600</code> 即可</li><li>若有备份或多台服务器，会发生由于服务器宕机需要及时做切换，<code>TTL</code> 时间越短切换越及时，但是 <code>TTL</code> 时间越短，也就意味着运营商DNS经常缓存不住，一般用户，设置为 <code>TTL 600</code> 即可，如果对及时切换，要求特别苛刻的网站，设置 <code>TTL 120</code> 就行</li></ul><p><strong>DNS解析优化-负载均衡</strong> </p><p>在DNS服务器中为同一个主机名配置多个IP地址，在应答DNS查询时，DNS服务器对每个查询将以DNS文件中主机记录的IP地址按顺序返回不同的解析结果，将客户端的访问引导到不同的机器上去，使得不同的客户端访问不同的服务器，从而达到负载均衡的目的，可以根据每台机器的负载量或该机器离用户地理位置的距离入手</p><p>就像我们使用CDN厂商做域名解析，它也是利用DNS的重定向技术，DNS服务器会返回一个跟用户最接近的点的IP地址给用户，CDN节点的服务器负责响应用户的请求，提供所需的内容，CDN厂商的域名解析服务器用户量多被访问的次数也多，域名解析服务器的A记录基本上会被各地运营商的DNS一直缓存着，所以服务效果也是最好的</p><h2 id="问：TCP-IP协议与UDP协议优缺点及区别？"><a href="#问：TCP-IP协议与UDP协议优缺点及区别？" class="headerlink" title="问：TCP/IP协议与UDP协议优缺点及区别？"></a>问：TCP/IP协议与UDP协议优缺点及区别？</h2><p>首先请注意，这题目本身就是一个坑</p><p><code>TCP/IP协议</code> 是一个协议簇，它包括很多协议，<code>UDP协议</code> 只是其中的一个，之所以命名为 <code>TCP/IP协议</code>，是因为TCP和IP协议是两个很重要的协议，就用它两命名了，仅此而已，SO，这个题目是不正确的，正确的问法应该是TCP协议和UDP协议优缺点及区别 </p><p>你可能会说有面试官这样问吗？别说这抠字眼的题，还真有人因为忽略了这点被安排过 😄 </p><h2 id="问：TCP协议和UDP协议优缺点及区别？"><a href="#问：TCP协议和UDP协议优缺点及区别？" class="headerlink" title="问：TCP协议和UDP协议优缺点及区别？"></a>问：TCP协议和UDP协议优缺点及区别？</h2><p><strong>优缺点</strong> </p><p><code>TCP</code> 的优点： 稳定可靠， 这体现在TCP传递数据之前，会有三次握手来建立连接，且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约一些系统资源</p><p><code>TCP</code>的缺点：占用系统资源高，慢且效率低，TCP在传递数据之前，要先建连接，会消耗时间，在数据传递时，确认机制、重传机制、拥塞控制机制等都会消耗大量的时间，而且要在每台设备上维护所有的传输连接，每个连接都会占用系统的CPU、内存等硬件资源</p><p><code>UDP</code> 的优点： 快，UDP是一个无状态的传输协议，所以它在传递数据时非常快</p><p><code>UDP</code> 的缺点： 不可靠，不稳定，因为UDP没有TCP那些可靠的机制，在数据传递时，如果网络质量不好，就会很容易丢包</p><p>一般当我们对网络通讯质量有要求的时候，就应该使用TCP，要把整个数据准确无误的传递给对方，比如HTTP、HTTPS、FTP等协议，当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用UDP，如语音，视频等</p><p><strong>区别</strong> </p><ul><li><p>TCP协议基于连接UDP协议无连接</p></li><li><p>TCP协议面向字节流，简单说TCP把数据看成一连串无结构的字节流而UDP协议面向报文</p></li><li><p>TCP协议传送数据，无差错不丢失不重复，且按序到达，UDP不保证可靠交付和顺序，可能丢包</p></li><li><p>TCP首部开销20字节，UDP的首部开销较小，只有8个字节</p></li><li><p>TCP协议连接只能是点到点的，UDP支持一对一，一对多，多对一和多对多的交互通信</p></li></ul><h2 id="问：简单介绍下TCP三次握手四次挥手？"><a href="#问：简单介绍下TCP三次握手四次挥手？" class="headerlink" title="问：简单介绍下TCP三次握手四次挥手？"></a>问：简单介绍下TCP三次握手四次挥手？</h2><p><strong>三次握手 ( 网图侵删 )</strong></p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20200508171840510.png" srcset="/blog/img/loading.gif" alt=""></p><p><strong>PS：</strong>请认真看图并配合下面文字理解</p><p>开始时，双端处于 <code>CLOSE (关闭状态)</code>，服务端要提供服务，会主动监听某个端口，进入 <code>LISTEN (监听状态)</code></p><p>客户端主动发送连接的SYN包，之后进入 <code>SYN-SENT (同步已发送状态)</code> </p><p>服务端在收到客户端发来的SYN包后，回复SYN/ACK包，之后进入 <code>SYN-RCVD (同步收到状态)</code></p><p>客户端收到服务端发来的SYN/ACK包后，确认对方后回复ACK包，并进入 <code>ESTABLISHED (已建立连接状态)</code></p><p>当服务器收到客户端的确认后也进入 <code>ESTABLISHED (已建立连接状态)</code> ，此后双方就可以开始通信了</p><p><strong>四次挥手 ( 网图侵删 )</strong></p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20200508172006324.png" srcset="/blog/img/loading.gif" alt=""></p><p><strong>PS：</strong>请认真看图并配合下面文字理解</p><p>开始时双端还都处于 <code>ESTABLISHED (已建立连接状态)</code> 并传输数据，某一端可以主动发起 FIN 包准备断开连接，上图为客户端发起 FIN 请求，在发出FIN后，客户端进入 <code>FIN-WAIT-1 (终止等待状态1)</code></p><p>服务端收到 FIN 消息后，回复 ACK 表示知道了，并从<code>ESTABLISHED (已建立连接状态)</code>进入 <code>CLOSED-WAIT (关闭等待状态)</code>，开始做一些断开连接前的准备工作</p><p>客户端收到之前FIN的回复 ACK 消息后，进入 <code>FIN-WAIT-2  (终止等待状态2)</code>，当服务端做好断开前的准备工作后，也会发送一个 FIN/ACK 的消息給客户端，表示我也好了，请求断开连接，并在发送消息后，服务端进入 <code>LAST-ACK (最后确认状态)</code></p><p>客户端在收到 FIN/ACK 消息后，会立即回复 ACK ，表示知道了，并进入 <code>TIME_WAIT ( 时间等待状态)</code>，为了稳定和安全考虑，客户端会在 <code>TIME-WAIT ( 时间等待状态)</code> 等待 2MSL ( 最长报文段寿命 ) 的时长，最终进入 <code>CLOSED ( 关闭状态 )</code></p><p>服务端收到客户端回复的 ACK 消息后，直接从 <code>LAST-ACK (最后确认状态)</code> 状态进入 <code>CLOSED ( 关闭状态 )</code></p><p>四次挥手之后，双端都进入 <code>CLOSED ( 关闭状态 )</code>，在此之后，双端正式断开了连接</p><p><strong>PS：</strong>  MSL ( Maximum Segment Lifetime ) 为 <code>最长报文段寿命</code>，它指的是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃，TCP允许不同的实现可以设置不同的 MSL 值</p><h2 id="问：为什么建立连接是三次握手，关闭连接确是四次挥手？"><a href="#问：为什么建立连接是三次握手，关闭连接确是四次挥手？" class="headerlink" title="问：为什么建立连接是三次握手，关闭连接确是四次挥手？"></a>问：为什么建立连接是三次握手，关闭连接确是四次挥手？</h2><p>建立连接的时候， 服务器在  <code>LISTEN (监听状态)</code> ，收到建立连接请求的 SYN 报文后，把 ACK 和 SYN 放在一个报文里发送给客户端就可以了</p><p>而关闭连接时，服务器收到对方的 FIN 报文时，仅代表对方不再发送数据了但是还能接收数据，而自己未必全部数据都发送给对方了，所以自己可以立即关闭，也可以发送一些数据给对方后，再发送 FIN 报文给对方来表示同意现在关闭连接，因此，己方 ACK 和 FIN 一般都会分开发送，从而导致多了一次</p><h2 id="问：为什么要三次握手创建链接，最后一次确认有必要吗？"><a href="#问：为什么要三次握手创建链接，最后一次确认有必要吗？" class="headerlink" title="问：为什么要三次握手创建链接，最后一次确认有必要吗？"></a>问：为什么要三次握手创建链接，最后一次确认有必要吗？</h2><p>防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误</p><p>如果使用两次握手建立连接，假如客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于 TCP 的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，然后客户端和服务器经过两次握手完成连接，传输数据后关闭连接，此时之前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手机制就会让客户端和服务器再次建立连接，会导致不必要的错误和资源的浪费</p><p>采用三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认，由于服务器收不到确认，就会知道客户端并没有请求连接</p><p>为什么不用四次握手就更简单了，三次就可以创建安全无误的连接为什么用四次，那不是浪费资源嘛</p><h2 id="问：三次握手过程中可以携带数据吗？"><a href="#问：三次握手过程中可以携带数据吗？" class="headerlink" title="问：三次握手过程中可以携带数据吗？"></a>问：三次握手过程中可以携带数据吗？</h2><p>第一次、第二次握手不可以携带数据，因为一握二握时还没有建立连接，会让服务器容易受到攻击</p><p>而第三次握手，此时客户端已经处于 <code>ESTABLISHED (已建立连接状态)</code> ，对于客户端来说，已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据也是没问题的</p><h2 id="问：四次挥手为什么客户端最后还要等待2MSL？"><a href="#问：四次挥手为什么客户端最后还要等待2MSL？" class="headerlink" title="问：四次挥手为什么客户端最后还要等待2MSL？"></a>问：四次挥手为什么客户端最后还要等待2MSL？</h2><p>第一，保证客户端发送的最后一个 ACK 报文能够到达服务器，因为这个 ACK 报文可能丢失，站在服务器的角度看来，我已经发送了 <code>FIN+ACK</code> 报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个 2MSL 时间段内收到这个重传的报文，接着给出回应报文，并且会重启 2MSL 计时器</p><p>第二，比如上面提到了的 <code>已经失效的连接请求报文段</code> 出现在连接中这种状况，客户端发送完最后一个确认报文后，在这个 2MSL 时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，这样新连接中就不会出现旧连接的请求报文</p><h2 id="问：如果已经建立了连接，但客户端突然故障怎么办？"><a href="#问：如果已经建立了连接，但客户端突然故障怎么办？" class="headerlink" title="问：如果已经建立了连接，但客户端突然故障怎么办？"></a>问：如果已经建立了连接，但客户端突然故障怎么办？</h2><p>TCP 还设有一个保活计时器，客户端如果出现故障，服务器总不能一直等下去，白白浪费资源啊，服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时</p><p>若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，然后每隔75秒就会再发送一次，10次探测报文后仍然没反应的话，服务器就认为客户端出了故障，接着就关闭连接</p><h2 id="问：HTTP-的请求方法？"><a href="#问：HTTP-的请求方法？" class="headerlink" title="问：HTTP 的请求方法？"></a>问：HTTP 的请求方法？</h2><p>HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD方法</p><p>HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法</p><table><thead><tr><th align="left">序号</th><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">GET</td><td align="left">请求指定的页面信息，并返回实体主体</td></tr><tr><td align="left">2</td><td align="left">HEAD</td><td align="left">类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头</td></tr><tr><td align="left">3</td><td align="left">POST</td><td align="left">向指定资源提交数据进行处理请求 ( 例如提交表单或者上传文件 )，数据被包含在请求体中，POST 请求可能会导致新的资源的建立和/或已有资源的修改</td></tr><tr><td align="left">4</td><td align="left">PUT</td><td align="left">从客户端向服务器传送的数据取代指定的文档的内容</td></tr><tr><td align="left">5</td><td align="left">DELETE</td><td align="left">请求服务器删除指定的页面</td></tr><tr><td align="left">6</td><td align="left">CONNECT</td><td align="left">HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器</td></tr><tr><td align="left">7</td><td align="left">OPTIONS</td><td align="left">允许客户端查看服务器的性能</td></tr><tr><td align="left">8</td><td align="left">TRACE</td><td align="left">回显服务器收到的请求，主要用于测试或诊断</td></tr><tr><td align="left">9</td><td align="left">PATCH</td><td align="left">是对 PUT 方法的补充，用来对已知资源进行局部更新</td></tr></tbody></table><h2 id="问：HTTP-状态码分别代表什么？"><a href="#问：HTTP-状态码分别代表什么？" class="headerlink" title="问：HTTP 状态码分别代表什么？"></a>问：HTTP 状态码分别代表什么？</h2><p>状态码有五类分别代表</p><ul><li><strong>1xx</strong>: 协议处理中状态，还需后续操作</li><li><strong>2xx</strong>: 成功状态</li><li><strong>3xx</strong>: 重定向状态，资源位置发生变动，需要重新请求</li><li><strong>4xx</strong>: 请求报文有误</li><li><strong>5xx</strong>: 服务器端错误</li></ul><p>详细状态码就不啰嗦了，直接 copy 菜鸟教程了一份，看一看吧，心中有个印象</p><table><thead><tr><th>状态码</th><th>英文名称</th><th>描述</th></tr></thead><tbody><tr><td>100</td><td>Continue</td><td>继续。客户端应继续其请求</td></tr><tr><td>101</td><td>Switching Protocols</td><td>切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</td></tr><tr><td></td><td></td><td></td></tr><tr><td>200</td><td>OK</td><td>请求成功。一般用于GET与POST请求</td></tr><tr><td>201</td><td>Created</td><td>已创建。成功请求并创建了新的资源</td></tr><tr><td>202</td><td>Accepted</td><td>已接受。已经接受请求，但未处理完成</td></tr><tr><td>203</td><td>Non-Authoritative Information</td><td>非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</td></tr><tr><td>204</td><td>No Content</td><td>无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td></tr><tr><td>205</td><td>Reset Content</td><td>重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</td></tr><tr><td>206</td><td>Partial Content</td><td>部分内容。服务器成功处理了部分GET请求</td></tr><tr><td></td><td></td><td></td></tr><tr><td>300</td><td>Multiple Choices</td><td>多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</td></tr><tr><td>301</td><td>Moved Permanently</td><td>永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td></tr><tr><td>302</td><td>Found</td><td>临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td></tr><tr><td>303</td><td>See Other</td><td>查看其它地址。与301类似。使用GET和POST请求查看</td></tr><tr><td>304</td><td>Not Modified</td><td>未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td></tr><tr><td>305</td><td>Use Proxy</td><td>使用代理。所请求的资源必须通过代理访问</td></tr><tr><td>306</td><td>Unused</td><td>已经被废弃的HTTP状态码</td></tr><tr><td>307</td><td>Temporary Redirect</td><td>临时重定向。与302类似。使用GET请求重定向</td></tr><tr><td></td><td></td><td></td></tr><tr><td>400</td><td>Bad Request</td><td>客户端请求的语法错误，服务器无法理解</td></tr><tr><td>401</td><td>Unauthorized</td><td>请求要求用户的身份认证</td></tr><tr><td>402</td><td>Payment Required</td><td>保留，将来使用</td></tr><tr><td>403</td><td>Forbidden</td><td>服务器理解请求客户端的请求，但是拒绝执行此请求</td></tr><tr><td>404</td><td>Not Found</td><td>服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</td></tr><tr><td>405</td><td>Method Not Allowed</td><td>客户端请求中的方法被禁止</td></tr><tr><td>406</td><td>Not Acceptable</td><td>服务器无法根据客户端请求的内容特性完成请求</td></tr><tr><td>407</td><td>Proxy Authentication Required</td><td>请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</td></tr><tr><td>408</td><td>Request Time-out</td><td>服务器等待客户端发送的请求时间过长，超时</td></tr><tr><td>409</td><td>Conflict</td><td>服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突</td></tr><tr><td>410</td><td>Gone</td><td>客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</td></tr><tr><td>411</td><td>Length Required</td><td>服务器无法处理客户端发送的不带Content-Length的请求信息</td></tr><tr><td>412</td><td>Precondition Failed</td><td>客户端请求信息的先决条件错误</td></tr><tr><td>413</td><td>Request Entity Too Large</td><td>由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</td></tr><tr><td>414</td><td>Request-URI Too Large</td><td>请求的URI过长（URI通常为网址），服务器无法处理</td></tr><tr><td>415</td><td>Unsupported Media Type</td><td>服务器无法处理请求附带的媒体格式</td></tr><tr><td>416</td><td>Requested range not satisfiable</td><td>客户端请求的范围无效</td></tr><tr><td>417</td><td>Expectation Failed</td><td>服务器无法满足Expect的请求头信息</td></tr><tr><td></td><td></td><td></td></tr><tr><td>500</td><td>Internal Server Error</td><td>服务器内部错误，无法完成请求</td></tr><tr><td>501</td><td>Not Implemented</td><td>服务器不支持请求的功能，无法完成请求</td></tr><tr><td>502</td><td>Bad Gateway</td><td>作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</td></tr><tr><td>503</td><td>Service Unavailable</td><td>由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</td></tr><tr><td>504</td><td>Gateway Time-out</td><td>充当网关或代理的服务器，未及时从远端服务器获取请求</td></tr><tr><td>505</td><td>HTTP Version not supported</td><td>服务器不支持请求的HTTP协议的版本，无法完成处理</td></tr></tbody></table><h2 id="问：HTTP与HTTPS的区别？"><a href="#问：HTTP与HTTPS的区别？" class="headerlink" title="问：HTTP与HTTPS的区别？"></a>问：HTTP与HTTPS的区别？</h2><p>HTTP协议传输的数据都是未加密的，也就是明文的，所以使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了 <code>SSL（Secure Sockets Layer）</code> 协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS</p><p>简单来说，HTTPS协议是由 <code>SSL+HTTP</code> 协议构建的可进行加密传输、身份认证的网络协议，要比 HTTP 协议安全，更多HTTP和HTTPS内容请自行百度，这里就不长篇大论了</p><p>那么简单总结下有区别</p><ul><li><p>HTTPS协议需要到 CA 申请证书，一般免费证书较少，因而需要一定费用</p></li><li><p>HTTP是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 SSL 加密传输协议</p></li><li><p>HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443</p></li><li><p>HTTP的连接很简单，是无状态的，HTTPS协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比HTTP协议安全</p></li></ul><h2 id="问：什么是简单请求和非简单请求？"><a href="#问：什么是简单请求和非简单请求？" class="headerlink" title="问：什么是简单请求和非简单请求？"></a>问：什么是简单请求和非简单请求？</h2><p>CORS（cross-origin resource sharing），跨源资源共享，就是广大前端同学所说的跨域，想必大家都了解，不了解这也不做介绍了，不了解可以看 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="noopener">HTTP访问控制（CORS）- MDN传送门</a>  😄</p><p>CORS中把请求定义为了两类</p><ul><li>简单请求</li><li>非简单请求</li></ul><p>那么什么是简单请求什么是非简单请求呢？其实也很简单，我们只需要知道什么是简单请求，其余的就都是非简单的了，而简单请求需要满足的条件是</p><ul><li>请求方式只能是GET、POST、HEAD三种</li><li>HTTP头部信息不超过一下几种字段<ul><li>无自定义头部字段</li><li>Accept、Accept-Language、Content-Language、Last-Event-ID</li><li>Content-Type只有三个值 application/x-www-form-urlencoded、multipart/form-data、text/plain</li></ul></li></ul><p>简单请求需要满足上面的条件，其实平常也就是传统的表单请求了，看了上面的简单请求条件，那么非简单请求是不是就呼之欲出了呢，比如下面这些只要满足一个就是非简单请求</p><ul><li><p>请求方式是PUT、DELETE</p></li><li><p>自定义头部字段</p></li><li><p>发送JSON格式数据等等</p></li></ul><p>非简单请求的 CORS 请求，会在正式通信之前，增加一次 HTTP 查询请求，请求方式为 OPTIONS，称为 <code>预检请求 (preflight)</code> </p><p>浏览器会先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些 HTTP 方法和头信息字段，得到肯定答复，浏览器才会发出正式的 <code>XMLHttpRequest</code> 请求，否则就会报错，这是为了防止这些新增的请求，对传统的没有 CORS 支持的服务器形成压力，给服务器一个提前拒绝的机会，防止服务器收到大量 DELETE 和 PUT请求，这些传统的表单不可能跨域发出的请求</p><h2 id="问：CSS-资源加载会阻塞渲染怎样优化？"><a href="#问：CSS-资源加载会阻塞渲染怎样优化？" class="headerlink" title="问：CSS 资源加载会阻塞渲染怎样优化？"></a>问：CSS 资源加载会阻塞渲染怎样优化？</h2><p>优化DOM树，DOM尽可能的小</p><p>CSS尽量用 <code>id</code> 和 <code>class</code> 少直接用标签，因为标签节点样式是可以继承的，所以在构建的过程中浏览器得递归 <code>DOM</code> 树来确定元素到底是什么样式</p><p>对于首屏渲染需要用到的CSS代码加入Inline CSS ( 内联样式 ) </p><p>对于首屏渲染不需要用到的CSS，可以使用文件形式并在页面内容渲染完成后再加载</p><h2 id="问：什么是回流和重绘以及区别？"><a href="#问：什么是回流和重绘以及区别？" class="headerlink" title="问：什么是回流和重绘以及区别？"></a>问：什么是回流和重绘以及区别？</h2><p>要知道，生成DOM树时是包括 <code>display:none</code> 的节点的，DOM树和CSSOM树的基础上根据节点的集合属性 <code>margin/padding/width/height等</code> 生成渲染树 ( render ) ，渲染树不包括 <code>display:none</code> 的节点和 <code>head</code> 等节点，但是包括 <code>visibility:hidden</code> 的节点</p><p>当渲染树节点因为大小边距等问题发生改变而需要重建的过程，叫做 <code>回流 (Reflow)</code> </p><p>元素发生的改变只是影响了元素的一些外观之类的时候 ( 例如，背景色，边框颜色，文字颜色等 )，此时只需要应用新样式绘制这个元素就可以了，称之为 <code>重绘 (Repaint)</code> </p><p>回流必将引起重绘，而重绘不一定会引起回流，很明显 <code>回流</code> 代价较大</p><h2 id="问：什么会引起回流？"><a href="#问：什么会引起回流？" class="headerlink" title="问：什么会引起回流？"></a>问：什么会引起回流？</h2><ul><li><p>页面渲染初始化</p></li><li><p>DOM结构改变，比如删除了某个节点</p></li><li><p>render树变化，比如减少了 padding ( 内边距 )</p></li><li><p>窗口 <code>resize</code> 事件触发时</p></li><li><p>某些 JS 属性，引发回流，很多浏览器会对回流做优化，等到数量足够时做一次批处理回流， 但除了 <code>render树</code> 的直接变化，当获取一些属性时，浏览器为了获得正确的值也会触发回流，这样使得浏览器优化无效</p><ul><li>offset ( Top/Left/Width/Height )</li><li>scroll ( Top/Left/Width/Height )</li><li>cilent ( Top/Left/Width/Height )</li><li>width, height</li><li>调用了 <code>getComputedStyle()</code> 或者IE的 <code>currentStyle</code></li></ul></li></ul><h2 id="问：如何减少和避免回流重绘？"><a href="#问：如何减少和避免回流重绘？" class="headerlink" title="问：如何减少和避免回流重绘？"></a>问：如何减少和避免回流重绘？</h2><p>减少逐项更改样式，最好一次性更改 <code>style</code>，或者将样式定义为 <code>class</code> 并一次性更新</p><p>避免循环操作DOM，让DOM离线后再修改</p><ul><li>创建一个 <code>documentFragment</code> ，在它上面应用所有DOM操作，最后再把它添加到 <code>window.document</code></li><li>先把DOM节点 <code>display:none</code> ( 会触发一次 <code>reflow</code>)，然后做修改后，再把它显示出来</li><li>克隆一个DOM节点在内存里，修改之后，与在线的节点相替换</li></ul><p>避免多次读取offset等属性，无法避免则将它们缓存到变量</p><p>将复杂的元素绝对定位或固定定位，使得它脱离文档流，否则回流代价会很高</p><p>改变字体大小也会引发回流，所以尽可能减少这种操作</p><p>table布局，一个小改动会造成整个table的重新布局，所以，少用为好</p><h2 id="问：你了解普通图层和复合图层吗？"><a href="#问：你了解普通图层和复合图层吗？" class="headerlink" title="问：你了解普通图层和复合图层吗？"></a>问：你了解普通图层和复合图层吗？</h2><p>浏览器渲染的图层一般包含两大类：<code>普通图层</code> 以及 <code>复合图层</code></p><p>普通文档流可以理解为一个复合图层，我们叫它<code>默认复合层</code>，因为里面不管添加多少元素，其实都是在同一个复合图层中，<code>absolute</code> 布局、 <code>fixed</code> 也一样，虽然可以脱离普通文档流，但它仍然属于 <code>默认复合层</code></p><p>复合图层，可以独立于普通文档流中，改动后可以避免整个页面重绘，从而提升性能，但也不能大量使用复合图层，否则由于资源消耗过度，页面反而会变的更卡，因小失大</p><p>GPU中，各个复合图层是单独绘制的，所以也互不影响，通过 <code>硬件加速</code> 的方式，会声明一个 <code>新的复合图层</code> ，它会单独分配资源，当然也会脱离普通文档流，这样一来，不管这个复合图层中怎么变化，也不会影响 <code>默认复合层</code> 里的回流重绘</p><p><strong>PS：</strong> 硬件加速技术是指使用 GPU 的硬件能力来帮助渲染网页</p><h2 id="问：浏览器页面渲染优化？"><a href="#问：浏览器页面渲染优化？" class="headerlink" title="问：浏览器页面渲染优化？"></a>问：浏览器页面渲染优化？</h2><ul><li><p>HTML文档结构层次尽量少，最好不深于六层</p></li><li><p>JS 脚本尽量后放</p></li><li><p>样式结构层次尽量简单</p></li><li><p>少量首屏样式使用内联方式放在标签内</p></li><li><p>在脚本中尽量减少DOM操作，尽量访问离线DOM样式信息，避免过度触发回流</p></li><li><p>减少通过 JS 代码修改元素样式，尽量使用修改 <code>class</code> 名方式操作样式或动画</p></li><li><p>尽量减少浏览器重排和重绘的一些情况发生</p></li><li><p>2020年了！就不要使用 <code>table</code> 布局了</p></li><li><p>CSS 动画中尽量只使用 <code>transform</code> 和 <code>opacity</code> ，不会发生重排和重绘</p></li><li><p>隐藏在屏幕外，或在页面滚动时，尽量停止动画</p></li><li><p>尽可能只使用 CSS 做动画，CSS动画肯定比 JS 动画要好很多</p></li><li><p>避免浏览器的隐式合成</p></li><li><p>改变复合层的尺寸</p></li></ul><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>对您有帮助的话，动动小手，点个赞鼓励下吧，当然，个人理解，本文因为比较忙，写的时间较长，断断续续的写，所以可能有些地方衔接的不好，不太通顺或者有不正的地方，欢迎指出，不胜感激</p><p>哦，还有，可以加个好友加下群一起交流噻，公众号【不正经的前端】也欢迎关注呦 😄 </p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20200512231111406.png" srcset="/blog/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>一道面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>网络</tag>
      
      <tag>浏览器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「一道面试题」输入URL到渲染全面梳理中-页面渲染篇</title>
    <link href="/blog/2020/04/22/Interview/%E3%80%8C%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98%E3%80%8D%E8%BE%93%E5%85%A5URL%E5%88%B0%E6%B8%B2%E6%9F%93%E5%85%A8%E9%9D%A2%E6%A2%B3%E7%90%86%E4%B8%AD-%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E7%AF%87/"/>
    <url>/blog/2020/04/22/Interview/%E3%80%8C%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98%E3%80%8D%E8%BE%93%E5%85%A5URL%E5%88%B0%E6%B8%B2%E6%9F%93%E5%85%A8%E9%9D%A2%E6%A2%B3%E7%90%86%E4%B8%AD-%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="「一道面试题」输入-URL-到渲染全面梳理中-页面渲染篇"><a href="#「一道面试题」输入-URL-到渲染全面梳理中-页面渲染篇" class="headerlink" title="「一道面试题」输入 URL 到渲染全面梳理中-页面渲染篇"></a>「一道面试题」输入 URL 到渲染全面梳理中-页面渲染篇</h1><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>此文是一道面试题，又不仅仅是一道面试题，不同的是这道题分了三篇来说，嗯。。可想而知</p><p>接上文，上文我们讲了网络通信的部分，那么该说说页面渲染的流程了，也就是当输入一个 URL 拿到了页面后，浏览器怎么解析，怎么呈现</p><p>首先要了解这块内容，需要对下面这些知识点有一个简单认知</p><ul><li>线程/进程概念及区别</li><li>多线程/多进程概念</li><li>浏览器的主要进程</li><li>浏览器为什么是多进程</li><li>渲染进程 Renderer 的主要线程<ul><li>GUI 渲染线程</li><li>JS 引擎线程</li><li>事件触发线程</li><li>定时触发线程</li><li>异步 http 请求线程</li></ul></li><li>渲染进程的各个线程之间关系及配合</li></ul><p>之前写的一篇帖子 <a href="https://juejin.im/post/5e22b391f265da3e204d8c14" target="_blank" rel="noopener">「硬核 JS」一次搞懂 JS 运行机制 - 传送门</a> 里有介绍到，下面我们还是重新来一遍吧，花不了多长时间，全当复习一遍，大家也可以自行去看下来了解了解，当然如果你都清楚的话可以直接去看渲染过程</p><h3 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h3><h4 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程"></a>什么是进程</h4><p>我们都知道，<code>CPU</code>是计算机的核心，承担所有的计算任务</p><p>官方说法，<code>进程</code>是<code>CPU</code>资源分配的最小单位</p><p>字面意思就是进行中的程序，我将它理解为一个可以独立运行且拥有自己的资源空间的任务程序</p><p><code>进程</code>包括运行中的程序和程序所使用到的内存和系统资源</p><p><code>CPU</code> 可以有很多进程，我们的电脑每打开一个软件就会产生一个或多个 <code>进程</code> ，为什么电脑运行的软件多就会卡，是因为 <code>CPU</code> 给每个 <code>进程</code> 分配资源空间，但是一个 <code>CPU</code> 一共就那么多资源，分出去越多，越卡，每个<code>进程</code>之间是相互独立的， <code>CPU</code> 在运行一个 <code>进程</code> 时，其他的进程处于非运行状态，<code>CPU</code> 使用 <a href="[https://baike.baidu.com/item/时间片轮转调度](https://baike.baidu.com/item/时间片轮转调度)">时间片轮转调度算法</a> 来实现同时运行多个进程</p><h4 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h4><p><code>线程</code> 是 <code>CPU</code> 调度的最小单位</p><p><code>线程</code> 是建立在 <code>进程</code> 的基础上的一次程序运行单位，通俗点解释 <code>线程</code> 就是程序中的一个执行流，一个 <code>进程</code> 可以有多个 <code>线程</code></p><p>一个 <code>进程</code> 中只有一个执行流称作 <code>单线程</code> ，即程序执行时，所走的程序路径按照连续顺序排下来，前面的必须处理好，后面的才会执行</p><p>一个 <code>进程</code> 中有多个执行流称作 <code>多线程</code>，即在一个程序中可以同时运行多个不同的 <code>线程</code> 来执行不同的任务， 也就是说允许单个程序创建多个并行执行的 <code>线程</code> 来完成各自的任务</p><h4 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h4><p>进程是操作系统分配资源的最小单位，线程是程序执行的最小单位</p><p>一个 <code>进程</code> 由一个或多个 <code>线程</code> 组成，<code>线程</code> 可以理解为是一个进程中代码的不同执行路线</p><p><code>进程</code> 之间相互独立，但同一进程下的各个 <code>线程</code> 间共享程序的内存空间 (包括代码段、数据集、堆等) 及一些进程级的资源 (如打开文件和信号)</p><p>调度和切换：线程上下文切换比进程上下文切换要快得多</p><h4 id="多进程和多线程"><a href="#多进程和多线程" class="headerlink" title="多进程和多线程"></a>多进程和多线程</h4><p><strong>多进程：</strong> 多进程指的是在同一个时间里，同一个计算机系统中如果允许两个或两个以上的进程处于运行状态。多进程带来的好处是明显的，比如大家可以在网易云听歌的同时打开编辑器敲代码，编辑器和网易云的进程之间不会相互干扰</p><p><strong>多线程：</strong> 多线程是指程序中包含多个执行流，即在一个程序中可以同时运行多个不同的线程来执行不同的任务，也就是说允许单个程序创建多个并行执行的线程来完成各自的任务</p><h3 id="JS-为什么是单线程"><a href="#JS-为什么是单线程" class="headerlink" title="JS 为什么是单线程"></a>JS 为什么是单线程</h3><p>JS 的单线程，与它的用途有关，作为浏览器脚本语言，JavaScript 的主要用途是与用户互动，以及操作 DOM，这决定了它只能是单线程，否则会带来很复杂的同步问题</p><p>比如，假定 <code>JavaScript</code> 同时有两个线程，一个线程在某个 DOM 节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？</p><p>还有人说 <code>js</code> 还有 <code>Worker</code> 线程，对的，为了利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 <code>JavaScript</code> 脚本创建多个线程，但是子线程是完 全受主线程控制的，而且不得操作 DOM</p><p>所以，这个标准并没有改变 JavaScript 是单线程的本质</p><p>了解了进程和线程之后，接下来看看浏览器解析，浏览器之间也是有些许差距的，不过大致是差不多的，下文我们皆用市场占有比例最大的 Chrome 为例</p><h3 id="浏览器相关"><a href="#浏览器相关" class="headerlink" title="浏览器相关"></a>浏览器相关</h3><h4 id="浏览器是多进程的"><a href="#浏览器是多进程的" class="headerlink" title="浏览器是多进程的"></a>浏览器是多进程的</h4><p>作为前端，免不了和浏览器打交道，浏览器是多进程的，拿 <code>Chrome</code> 来说，我们每打开一个 Tab 页就会产生一个进程，我们使用 <code>Chrome</code> 打开很多标签页不关，电脑会越来越卡，不说其他，首先就很耗 CPU</p><h4 id="浏览器包含哪些进程"><a href="#浏览器包含哪些进程" class="headerlink" title="浏览器包含哪些进程"></a>浏览器包含哪些进程</h4><ul><li>Browser 进程<ul><li>浏览器的主进程(负责协调、主控)，该进程只有一个</li><li>负责浏览器界面显示，与用户交互。如前进，后退等</li><li>负责各个页面的管理，创建和销毁其他进程</li><li>将渲染(Renderer)进程得到的内存中的 Bitmap(位图)，绘制到用户界面上</li><li>网络资源的管理，下载等</li></ul></li><li>第三方插件进程<ul><li>每种类型的插件对应一个进程，当使用该插件时才创建</li></ul></li><li>GPU 进程<ul><li>该进程也只有一个，用于 3D/动画绘制等等</li></ul></li><li>渲染进程(重)<ul><li>即通常所说的浏览器内核(Renderer 进程，内部是多线程)</li><li>每个 Tab 页面都有一个渲染进程，互不影响</li><li>主要作用为页面渲染，脚本执行，事件处理等</li></ul></li></ul><h4 id="为什么浏览器要多进程"><a href="#为什么浏览器要多进程" class="headerlink" title="为什么浏览器要多进程"></a>为什么浏览器要多进程</h4><p>我们假设浏览器是单进程，那么某个 Tab 页崩溃了，就影响了整个浏览器，体验有多差</p><p>同理如果插件崩溃了也会影响整个浏览器</p><p>当然多进程还有其它的诸多优势，不过多阐述</p><p>浏览器进程有很多，每个进程又有很多线程，都会占用内存</p><p>这也意味着内存等资源消耗会很大，有点拿空间换时间的意思</p><p>到此可不只是为了让我们理解为何 Chrome 运行时间长了电脑会卡，哈哈，第一个重点来了</p><h4 id="简述渲染进程-Renderer-重"><a href="#简述渲染进程-Renderer-重" class="headerlink" title="简述渲染进程 Renderer(重)"></a>简述渲染进程 Renderer(重)</h4><p>页面的渲染，JS 的执行，事件的循环，都在渲染进程内执行，所以我们要重点了解渲染进程</p><p>渲染进程是多线程的，我们来看渲染进程的一些常用较为主要的线程</p><h4 id="渲染进程-Renderer-的主要线程"><a href="#渲染进程-Renderer-的主要线程" class="headerlink" title="渲染进程 Renderer 的主要线程"></a>渲染进程 Renderer 的主要线程</h4><h5 id="GUI-渲染线程"><a href="#GUI-渲染线程" class="headerlink" title="GUI 渲染线程"></a>GUI 渲染线程</h5><ul><li>负责渲染浏览器界面，解析 HTML，CSS，构建 DOM 树和 RenderObject 树，布局和绘制等<ul><li>解析 html 代码(HTML 代码本质是字符串)转化为浏览器认识的节点，生成 DOM 树，也就是 DOM Tree</li><li>解析 css，生成 CSSOM(CSS 规则树)</li><li>把 DOM Tree 和 CSSOM 结合，生成 Rendering Tree(渲染树)</li></ul></li><li>当我们修改了一些元素的颜色或者背景色，页面就会重绘(Repaint)</li><li>当我们修改元素的尺寸，页面就会回流(Reflow)</li><li>当页面需要 Repaing 和 Reflow 时 GUI 线程执行，绘制页面</li><li>回流(Reflow)比重绘(Repaint)的成本要高，我们要尽量避免 Reflow 和 Repaint</li><li>GUI 渲染线程与 JS 引擎线程是互斥的<ul><li>当 JS 引擎执行时 GUI 线程会被挂起(相当于被冻结了)</li><li>GUI 更新会被保存在一个队列中等到 JS 引擎空闲时立即被执行</li></ul></li></ul><h5 id="JS-引擎线程"><a href="#JS-引擎线程" class="headerlink" title="JS 引擎线程"></a>JS 引擎线程</h5><ul><li>JS 引擎线程就是 JS 内核，负责处理 Javascript 脚本程序(例如 V8 引擎)</li><li>JS 引擎线程负责解析 Javascript 脚本，运行代码</li><li>JS 引擎一直等待着任务队列中任务的到来，然后加以处理<ul><li>浏览器同时只能有一个 JS 引擎线程在运行 JS 程序，所以 js 是单线程运行的</li><li>一个 Tab 页(renderer 进程)中无论什么时候都只有一个 JS 线程在运行 JS 程序</li></ul></li><li>GUI 渲染线程与 JS 引擎线程是互斥的，js 引擎线程会阻塞 GUI 渲染线程<ul><li>就是我们常遇到的 JS 执行时间过长，造成页面的渲染不连贯，导致页面渲染加载阻塞(就是加载慢)</li><li>例如浏览器渲染的时候遇到``标签，就会停止 GUI 的渲染，然后 js 引擎线程开始工作，执行里面的 js 代码，等 js 执行完毕，js 引擎线程停止工作，GUI 继续渲染下面的内容。所以如果 js 执行时间太长就会造成页面卡顿的情况</li></ul></li></ul><h5 id="事件触发线程"><a href="#事件触发线程" class="headerlink" title="事件触发线程"></a>事件触发线程</h5><ul><li>属于浏览器而不是 JS 引擎，用来控制事件循环，并且管理着一个事件队列(task queue)</li><li>当 js 执行碰到事件绑定和一些异步操作(如 setTimeOut，也可来自浏览器内核的其他线程，如鼠标点击、AJAX 异步请求等)，会走事件触发线程将对应的事件添加到对应的线程中(比如定时器操作，便把定时器事件添加到定时器线程)，等异步事件有了结果，便把他们的回调操作添加到事件队列，等待 js 引擎线程空闲时来处理。</li><li>当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待 JS 引擎的处理</li><li>因为 JS 是单线程，所以这些待处理队列中的事件都得排队等待 JS 引擎处理</li></ul><h5 id="定时触发器线程"><a href="#定时触发器线程" class="headerlink" title="定时触发器线程"></a>定时触发器线程</h5><ul><li><code>setInterval</code> 与 <code>setTimeout</code> 所在线程</li><li>浏览器定时计数器并不是由 JavaScript 引擎计数的 (因为 JavaScript 引擎是单线程的，如果处于阻塞线程状态就会影响记计时的准确)</li><li>通过单独线程来计时并触发定时(计时完毕后，添加到事件触发线程的事件队列中，等待 JS 引擎空闲后执行)，这个线程就是定时触发器线程，也叫定时器线程</li><li>W3C 在 HTML 标准中规定，规定要求<code>setTimeout</code>中低于 4ms 的时间间隔算为 4ms</li></ul><h5 id="异步-http-请求线程"><a href="#异步-http-请求线程" class="headerlink" title="异步 http 请求线程"></a>异步 http 请求线程</h5><ul><li>在 XMLHttpRequest 在连接后是通过浏览器新开一个线程请求</li><li>将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中再由 JavaScript 引擎执行</li><li>简单说就是当执行到一个 http 异步请求时，就把异步请求事件添加到异步请求线程，等收到响应 (准确来说应该是 http 状态变化)，再把回调函数添加到事件队列，等待 js 引擎线程来执行</li></ul><p>了解了上面这些基础后，接下来我们开始进入今天的正题，输入 URL 拿到资源之后，如何渲染，又经历了那些过程？</p><h2 id="渲染过程"><a href="#渲染过程" class="headerlink" title="渲染过程"></a>渲染过程</h2><h3 id="Webkit-渲染流程图"><a href="#Webkit-渲染流程图" class="headerlink" title="Webkit 渲染流程图"></a>Webkit 渲染流程图</h3><p>我们都知道，浏览器之间的渲染流程是有些细微差别的，我们这里介绍的一些知识点是基于 Chrome 的，也就是 Webkit，毕竟它是主流，先来看一下 Webkit 的渲染流程图</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20200421232942705.png" srcset="/blog/img/loading.gif" alt=""></p><p>大家如果第一次看到这张图，可能会有点迷茫，不知从哪看起，别急，先大致过一眼，我们下面会慢慢介绍，一步步的分析，如果大家完整的阅读完此文，不妨回过头来再看一遍这张图，会清晰很多</p><h3 id="解析-HTML-构建-DOM-树"><a href="#解析-HTML-构建-DOM-树" class="headerlink" title="解析 HTML 构建 DOM 树"></a>解析 HTML 构建 DOM 树</h3><p>浏览器渲染，那么浏览器肯定就拿到页面内容了，肯定要先解析 HTML 的</p><p>话不多说，我们直接来看 HTML 解析的图 ( 网图侵删 )</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20200408224734313.png" srcset="/blog/img/loading.gif" alt="image-20200408224734313"></p><p>如果是第一次看到这张图可能看不懂，没关系，慢慢道来</p><p>先来看图中解析 DOM 的这几个大过程</p><pre><code class="js">Bytes(字节) -&gt; Characters(字符) -&gt; Tokens(词) -&gt; Nodes(节点) -&gt; DOM(DOM树)</code></pre><p>首先，发起请求拿到页面 HTML 内容，这个内容它是 0/1 这样的原始 <code>字节流</code></p><p>接着，浏览器拿到这些 HTML 的原始字节，根据文件的指定编码 (例如 UTF-8) 将它们转换成各个 <code>字符</code></p><p>现在字节流变成了 <code>字符流</code> ，也就是一大串字符串</p><p>为了把 <code>字符流</code> 解析成正确的 <code>DOM</code> 结构，浏览器还要继续努力</p><p>接着进行 <code>词法解析</code> ，把字符流初步解析成我们可理解的 <code>词</code>，学名叫 <code>token</code></p><p><strong>嗯？什么是词 (Token)？</strong></p><p><code>词</code> 是编译原理中的最小单元，如标签开始、属性、标签结束、注释、CDATA 节点</p><p><code>Token</code> 会标识出当前 <code>Token</code> 的种类，有点绕，怎么说方便理解呢，举个例子</p><pre><code class="html">&lt;div class=&quot;haha&quot;&gt;haha&lt;/div&gt;</code></pre><p>如上，这是一个标签它有一个 class 属性 (废话)，但是浏览器拿到的只是字符串，它不知道这都是什么标签有啥属性要做什么，那么得给它一点一点拆开读，就是词法解析，怎么解析，就像下面这样</p><pre><code class="js">1. &lt;div                    # 哦，看到了&lt;div，这是一个div标签的开始2. class=&quot;haha&quot; # 这是一个class属性3. &gt;                        # 哦，到这儿是一个完整的div开始标签4. haha                    # 嗯，这是一个文本5. &lt;/div&gt;                # 奥，看到了&lt;/div&gt;，整个div标签结束了</code></pre><p><code>词法解析</code> 是编译原理中的概念，上面是极度简化版本 (防大佬死磕)，只是为了方便大家理解</p><p>现在理解了吗，<code>Tokens</code> 这个阶段中会标识出当前 <code>Token</code> 是 <code>开始标签</code> 或是 <code>结束标签</code> 亦或是 <code>文本</code> 等信息</p><p>那么我们收回思路，接着上面的步骤，经历 <code>词法解析</code> 我们把字符流解析成了 词 (Token)</p><p>接着在每个 <code>Token</code> 被生成后，会立刻消耗这个 <code>Token</code> 创建出节点对象，就是 节点 (Nodes) 阶段</p><p>把开始结束标签配对、属性赋值好、父子关系这些都连接好了，最终就构成了 <code>DOM</code> 树</p><p>后面这两小步也可称为 <code>语法解析</code> ，到此 <code>DOM Tree</code> 就解析完了</p><p>另外多嘴一句，<code>DOM树(DOM Tree) | 文档对象模型</code> ，这些东西说的都是 <code>DOM树</code></p><h3 id="解析-CSS-构建-CSSOM-树"><a href="#解析-CSS-构建-CSSOM-树" class="headerlink" title="解析 CSS 构建 CSSOM 树"></a>解析 CSS 构建 CSSOM 树</h3><p>有 <code>HTML</code> 解析，那肯定有 <code>CSS</code> 解析，比如我们构建 <code>DOM</code> 的时候遇到了 <code>link</code> 标记，该标记引用一个外部 <code>CSS</code> 样式表，那么浏览器会认为它需要这个外部样式资源，就会立即发出对该资源的请求，并返回样式内容，也是字节流</p><p>与处理 <code>HTML</code> 时一样，将收到的 <code>CSS</code> 规则转换成某种浏览器能够理解和处理的东西，基本步骤重复 <code>HTML</code> 过程，不过是构建 CSS 而不是 HTML</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20200408234346575.png" srcset="/blog/img/loading.gif" alt="image-20200408234346575"></p><p><code>CSS</code> 字节转换成字符，接着词法解析与法解析，最后构成 <code>CSS对象模型(CSSOM)</code> 的树结构</p><p>我们都知道，节点样式是可以继承的，所以在构建的过程中浏览器得递归 <code>DOM</code> 树来确定元素到底是什么样式，为了 <code>CSSOM</code> 的完整性，只有等构建完毕才能进入到下一个阶段，所以就算 <code>DOM</code> 已经构建完了，也得等 <code>CSSOM</code>，然后才能进入下一个阶段</p><p>所以 <code>CSS</code> 的加载速度与构建 <code>CSSOM</code> 的速度会影响首屏渲染速度，这就是我们常说的 <code>CSS</code> 资源的加载会阻塞渲染</p><p>怎么优化？DOM 树要小，CSS 尽量用 <code>id</code> 和 <code>class</code> 少直接用标签 😄</p><h3 id="解析-JavaScript-脚本"><a href="#解析-JavaScript-脚本" class="headerlink" title="解析 JavaScript 脚本"></a>解析 JavaScript 脚本</h3><p>这个解析 <code>JS</code> 的步骤是不固定的，因为在构建 DOM 树的过程中，当 <code>HTML</code> 解析器遇到一个 <code>script</code> 标记时，即遇到了 js，立即阻塞 DOM 树的构建，就会将控制权移交给 <code>JavaScript</code> 引擎，等到 <code>JavaScript</code> 引擎运行完毕，浏览器才会从中断的地方恢复 DOM 树的构建</p><p>为什么上面也说了，<strong>JS 会对 DOM 节点进行操作，浏览器无法预测未来的 DOM 节点的具体内容，为了防止无效操作，节省资源，只能阻塞 DOM 树的构建</strong></p><p>例如，若不阻塞 DOM 树的构建，若 JS 删除了某个 DOM 节点 A，那么浏览器为构建此节点 A 花费的资源就是无效的</p><p>若在 HTML 头部加载 JS 文件，由于 JS 阻塞，会推迟页面的首绘，所以为了加快页面渲染，一般将 JS 文件放到 HTML 底部进行加载，或是对 JS 文件执行 <code>async</code> 或 <code>defer</code> 加载</p><ul><li><code>async</code> 是异步执行，异步下载完毕后就会执行，不确保执行顺序，一定在 <code>onload</code> 前，但不确定在 <code>DOMContentLoaded</code> 事件的前或后</li><li><code>defer</code> 是延迟执行，在浏览器看起来的效果像是将脚本放在了 <code>body</code> 后面一样（虽然按规范应该是在 <code>DOMContentLoaded</code> 事件前，但实际上不同浏览器的优化效果不一样，也有可能在它后面）</li></ul><h3 id="构建渲染树-呈现树-Render-Tree"><a href="#构建渲染树-呈现树-Render-Tree" class="headerlink" title="构建渲染树/呈现树(Render Tree)"></a>构建渲染树/呈现树(Render Tree)</h3><p>渲染树 ( Render Tree ) 由 <code>DOM树</code>、<code>CSSOM树</code> 合并而成，但并不是必须等 <code>DOM树</code> 及 <code>CSSOM树</code> 加载完成后才开始合并构建 <code>渲染树</code>，三者的构建并无先后条件，也并非完全独立，而是会有交叉，并行构建，因此会形成一边加载，一边解析，一边渲染的工作现象</p><p><code>CSSOM 树</code>和 <code>DOM 树</code> 合并成渲染树，<code>渲染树</code> 只包含渲染网页所需的节点，然后用于计算每个可见元素的布局，并输出给绘制流程，将像素渲染到屏幕上</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20200418220809467.png" srcset="/blog/img/loading.gif" alt="image-20200418220809467"></p><p>如上图 ( 网图侵删 ) ，为了构建渲染树，我们看看浏览器都做了什么</p><ul><li>浏览器首先会从 DOM 树的根节点开始遍历每个可见节点<ul><li>例如脚本标记、元标记等有些节点不可见，因为它们不会体现在渲染输出中，所以会被忽略</li><li>某些节点通过 CSS 隐藏，因此在渲染树中也会被忽略，例如上图的其中一个 <code>span</code> 标签有 <code>display: none</code> 属性，也会被忽略</li></ul></li><li>对于每个可见节点，找到其对应的的 CSSOM 规则并应用它们</li><li>输出可见节点，连同其内容和计算的样式</li></ul><h3 id="布局-Layout"><a href="#布局-Layout" class="headerlink" title="布局(Layout)"></a>布局(Layout)</h3><p><code>渲染树</code> 同时包含了屏幕上的所有可见内容及其样式信息，有了渲染树，再接着就要进入布局 ( layout ) 阶段了，到目前为止，我们计算了哪些节点应该是可见的以及它们的计算样式，但我们还没有计算它们在设备 <a href="https://developers.google.com/web/fundamentals/design-and-ux/responsive?hl=zh-cn#set-the-viewport" target="_blank" rel="noopener">视口</a> 内的确切位置和大小，这就是 <code>布局</code> ( Layout ) 阶段，也称为 <code>自动重排</code> 或 <code>回流</code> ( Reflow )</p><p>此阶段一般意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树</p><p>简单举个例子，我们看下面这段代码</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;head&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot; /&gt;    &lt;title&gt;hahaha&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div style=&quot;width: 50%&quot;&gt;      &lt;div style=&quot;width: 50%&quot;&gt;Hello world&lt;/div&gt;    &lt;/div&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><p>上面代码网页的正文包含两个嵌套 div：第一个父 div 将节点的显示尺寸设置为视口宽度的 50%，父 div 包含的第二个 div 将其宽度设置为其父项的 50%，即视口宽度的 25% （网图侵删）</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20200418223841109.png" srcset="/blog/img/loading.gif" alt="image-20200418223841109"></p><p>布局流程的输出是一个 <code>盒模型</code>，它会精确地捕获每个元素在视口内的确切位置和尺寸，当然，所有相对测量值都转换为屏幕上的绝对像素</p><p>我们先往下看，稍后还会给大家介绍</p><h3 id="绘制-Painting"><a href="#绘制-Painting" class="headerlink" title="绘制(Painting)"></a>绘制(Painting)</h3><p>经历了以上种种步骤，终于来到了 <code>绘制</code> ，这一步听名字就能想到其作用了</p><p>经由前几步我们知道了哪些节点可见、它们的计算样式以及几何信息，我们将这些信息传递给最后一个阶段将渲染树中的每个节点转换成屏幕上的实际像素，也就是俗称的 <code>绘制</code> 或 <code>栅格化</code></p><p><code>绘制</code> 过程中有一种绘制叫 <code>重绘</code>，也就是下我们要说的</p><h4 id="重绘-Repaint"><a href="#重绘-Repaint" class="headerlink" title="重绘(Repaint)"></a>重绘(Repaint)</h4><p>元素发生的改变只是影响了元素的一些外观之类的时候（例如，背景色，边框颜色，文字颜色等），此时只需要应用新样式绘制这个元素就可以了，这叫做 <code>重绘</code> ( Repaint )</p><h4 id="回流-Reflow"><a href="#回流-Reflow" class="headerlink" title="回流 (Reflow)"></a>回流 (Reflow)</h4><p>上面我们已经说过了 <code>回流</code> ，当然也叫 <code>重排</code> ，要知道，<code>回流</code> 一定伴随着 <code>重绘</code> ，<code>重绘</code> 却可以单独出现，对比来看，显然回流的成本开销要高于重绘，而且一个节点的回流往往还会导致子节点以及同级节点的回流，所以优化方案中一般都包括，尽量避免 <code>回流</code></p><h4 id="什么会引起回流"><a href="#什么会引起回流" class="headerlink" title="什么会引起回流"></a>什么会引起回流</h4><ul><li><p>页面渲染初始化</p></li><li><p>DOM 结构改变，比如删除了某个节点</p></li><li><p>render 树变化，比如减少了 padding</p></li><li><p>窗口 <code>resize</code></p></li><li><p>某些 JS 属性，引发回流，很多浏览器会对回流做优化，等到数量足够时做一次批处理回流，<br>但除了 <code>render树</code> 的直接变化，当获取一些属性时，浏览器为了获得正确的值也会触发回流，这样使得浏览器优化无效</p></li><li><p>offset ( Top/Left/Width/Height )</p><ul><li>scroll ( Top/Left/Width/Height )</li><li>cilent ( Top/Left/Width/Height )</li><li>width, height</li><li>调用了 <code>getComputedStyle()</code> 或者 IE 的 <code>currentStyle</code></li></ul></li></ul><h4 id="如何减少和避免回流重绘"><a href="#如何减少和避免回流重绘" class="headerlink" title="如何减少和避免回流重绘"></a>如何减少和避免回流重绘</h4><p>上面我们说到，回流开销太大了，那么我们肯定是要优化的，接着看，其实就是尽量避免上面那些操作</p><ul><li>减少逐项更改样式，最好一次性更改 <code>style</code>，或者将样式定义为 <code>class</code> 并一次性更新</li><li>避免循环操作 DOM，让 DOM 离线后再修改<ul><li>创建一个 <code>documentFragment</code> ，在它上面应用所有 DOM 操作，最后再把它添加到 <code>window.document</code></li><li>先把 DOM 节点 <code>display:none</code> ( 会触发一次 <code>reflow</code>)，然后做修改后，再把它显示出来</li><li>克隆一个 DOM 节点在内存里，修改之后，与在线的节点相替换</li></ul></li><li>避免多次读取 offset 等属性，无法避免则将它们缓存到变量</li><li>将复杂的元素绝对定位或固定定位，使得它脱离文档流，否则回流代价会很高</li><li>改变字体大小也会引发回流，所以尽可能减少这种操作</li><li>table 布局，一个小改动会造成整个 table 的重新布局，所以，少用为好</li></ul><p>总之，说来说去，回流重绘，特别是回流，特别耗费资源，尽量避免就好，关于一些 CSS 属性会引起的回流重绘，可以去这个网站查查看 <a href="https://csstriggers.com/" target="_blank" rel="noopener">https://csstriggers.com/</a></p><h3 id="合成-Composite"><a href="#合成-Composite" class="headerlink" title="合成(Composite)"></a>合成(Composite)</h3><p>终于来到了最后一个点 <code>合成</code> ，我们先来总结一下上面的步骤，到目前我们经历渲染过程如下</p><ul><li>首先解析 <code>HTML</code> 文档，形成 DOM 树</li><li>接着解析 <code>CSS</code>，产生 CSSOM 树</li><li>在 DOM 和 CSSOM 树解析过程中，遇到 JS，会立即阻塞 DOM 树的构建，JS 解析完成，接着走上面两步</li><li>再接着，浏览器通过 DOM 和 CSSOM 树构建渲染树 ( Render 树 )<ul><li>这个过程中，DOM 中不可见标签元素不会放到渲染树中，就像<code>&lt;head&gt;&lt;/head&gt; 或 display:none</code></li><li>CSSOM 树规则会附加给渲染树的每个元素上</li></ul></li><li>渲染树构建完成，浏览器会对这些元素进行定位和布局，这一步也叫 重排/回流 ( <code>Reflow</code>) 或 布局(<code>Layout</code> )</li><li>接下来绘制这些元素的样式，颜色，背景，大小及边框等，这一步也叫做 重绘 (<code>Repaint</code>)</li><li>再接下来是我们这最后一步合成( <code>composite</code> )，浏览器会将各层信息发送给 GPU，GPU 将各层合成，显示在屏幕上</li></ul><p>关于合成这一步骤，准备细聊一下子，让大家对其有个基本概念，因为刚开始忽略了它</p><p>首先，我们需要简单了解一些基本概念</p><h4 id="浏览器渲染方式"><a href="#浏览器渲染方式" class="headerlink" title="浏览器渲染方式"></a>浏览器渲染方式</h4><p>浏览器在渲染图形的时候，有一个绘图上下文，绘图上下文又分成两种类型</p><ul><li>第一种是用来绘制 2D 图形的上下文，称之为 2D 绘图上下文（GraphicsContext）</li><li>第二种是绘制 3D 图形的上下文，称之为 3D 绘图上下文（GraphicsContext3D）</li></ul><p>网页也有三种渲染方式</p><ul><li>软件渲染（CPU 内存）</li><li>使用软件绘图的合成化渲染（GPU 内存）CSS3D、WebGL</li><li>硬件加速的合成化渲染（GPU 内存）</li></ul><p>当然，这些我们也不需要深入理解，知道它们的存在即可</p><h4 id="软件渲染技术"><a href="#软件渲染技术" class="headerlink" title="软件渲染技术"></a>软件渲染技术</h4><p>Webkit 在不需要硬件加速内容的时候（包括但不限于 <code>CSS3 3D变形</code>、<code>CSS3 3D变换</code> 、 <code>WebGL</code> 和 <code>视频</code>），它就可以使用 <code>软件渲染技术</code> 来完成页面绘制</p><p>上面我们看到了软件渲染技术，它是什么呢？我们接着看</p><p>对于每个渲染对象，需要三个阶段绘制自己</p><ul><li>第一阶段是绘制该层中所有块的背景和边框</li><li>第二阶段是绘制浮动内容</li><li>第三阶段是前景 ( Foreground ) ，也就是内容部分、轮廓、字体颜色、大小等 ( 内嵌元素的背景、边框等发生在这一阶段 )</li></ul><h4 id="硬件加速技术"><a href="#硬件加速技术" class="headerlink" title="硬件加速技术"></a>硬件加速技术</h4><p>硬件加速技术是指使用 GPU 的硬件能力来帮助渲染网页 ( GPU 的作用主要是用来绘制 3D 图形并且性能很 nice )</p><h4 id="普通图层和复合图层"><a href="#普通图层和复合图层" class="headerlink" title="普通图层和复合图层"></a>普通图层和复合图层</h4><p>浏览器渲染的图层一般包含两大类：<code>普通图层</code> 以及 <code>复合图层</code></p><p>普通文档流大家就可以理解为一个复合图层，我们叫它<code>默认复合层</code>，因为里面不管添加多少元素，其实都是在同一个复合图层中，<code>absolute</code> 布局、 <code>fixed</code> 也一样，虽然可以脱离普通文档流，但它仍然属于 <code>默认复合层</code></p><p>复合图层，可以独立于普通文档流中，改动后可以避免整个页面重绘，提升性能，但也不要大量使用复合图层，否则由于资源消耗过度，页面反而会变的更卡，因小失大</p><p>GPU 中，各个复合图层是单独绘制的，所以也互不影响，通过 <code>硬件加速</code> 的方式，会声明一个 <code>新的复合图层</code> ，它会单独分配资源，当然也会脱离普通文档流，这样一来，不管这个复合图层中怎么变化，也不会影响 <code>默认复合层</code> 里的回流重绘</p><h4 id="何为复合图层-硬件加速"><a href="#何为复合图层-硬件加速" class="headerlink" title="何为复合图层/硬件加速"></a>何为复合图层/硬件加速</h4><p>复合图层或者说硬件加速，其实就是仅触发合成 <code>composite</code> ，那么也就必须符合以下三个条件</p><ul><li>不影响文档流</li><li>不依赖文档流</li><li>不会造成重绘</li></ul><p>寻思一下，可以做到这种情况得还真的不多 ( Chrome )</p><ul><li>最常用的方式是 <code>transform</code></li><li><code>opacity</code> 属性 / 过渡动画 (需要动画执行的过程中才会创建合成层，动画没有开始或结束后元素还会回到之前的状态)</li><li><code>will-chang</code> 属性 (这个比较偏僻)，一般配合 <code>opacity</code> 与 <code>translate</code> 使用，除了上述可以引发硬件加速的属性外，其它属性并不会变成复合层，作用是提前告诉浏览器要变化，这样浏览器会开始做一些优化工作 (最好用完后就释放)</li><li><code>&lt;canvas&gt; &lt;webgl&gt;</code> 等元素</li><li>还有以前的 <code>flash</code> 插件等等</li></ul><p>通俗一点，假如我们给一个元素加了 <code>transform</code> 属性吧，那么该元素就不会影响也不会依赖文档流，也不会造成重绘，就变成了一个复合图层，也就可以说我们对它使用了传说中的 <code>硬件加速技术</code></p><h4 id="absolute？"><a href="#absolute？" class="headerlink" title="absolute？"></a>absolute？</h4><p>到了这里，大家可能有些迷惑，我们不是常说 <code>absolute</code> 是脱离文档流吗，为什么上面复合图层或者说硬件加速中没有 <code>absolute</code> 呢</p><p>其实，<code>absolute</code> 虽然可以脱离普通文档流，但是无法脱离默认复合层，就像它的 <code>left</code> 属性可以使用百分比的值，依赖于它的 <code>offset parent</code></p><p>所以，就算 <code>absolute</code> 中信息改变时不会改变普通文档流中的 <code>渲染树</code> ，但浏览器最终绘制时，是整个复合层绘制的，所以 <code>absolute</code> 中信息改变，仍会影响整个复合层的绘制，浏览器还是会重绘它，如果复合层中内容多，<code>absolute</code> 带来的绘制信息变化过大，资源消耗也非常严重</p><p>而我们上面说的硬件加速，那直接就是在另一个复合层了，所以它的信息改变不会影响默认复合层，当然内部肯定会影响属于自己的复合层，仅仅是引发最后的合成渲染</p><h2 id="页面渲染优化"><a href="#页面渲染优化" class="headerlink" title="页面渲染优化"></a>页面渲染优化</h2><p>浏览器对上文介绍的关键渲染步骤进行了很多优化，针对每一次变化产生尽量少的操作，还有优化判断重新绘制或布局的方式等等，据上文所述，总结下页面渲染这块的优化实践，不分先后，大家也可一块来补充</p><ul><li><p>HTML 文档结构层次尽量少，最好不深于六层</p></li><li><p>JS 脚本尽量后放</p></li><li><p>样式结构层次尽量简单</p></li><li><p>少量首屏样式使用内联方式放在标签内</p></li><li><p>在脚本中尽量减少 DOM 操作，尽量访问离线 DOM 样式信息，避免过度触发回流</p></li><li><p>减少通过 JS 代码修改元素样式，尽量使用修改 <code>class</code> 名方式操作样式或动画</p></li><li><p>尽量减少浏览器重排和重绘的一些情况发生</p></li><li><p>2020 年了！就不要使用 <code>table</code> 布局了</p></li><li><p>CSS 动画中尽量只使用 <code>transform</code> 和 <code>opacity</code> ，不会发生重排和重绘</p></li><li><p>隐藏在屏幕外，或在页面滚动时，尽量停止动画</p></li><li><p>尽可能只使用 CSS 做动画，CSS 动画肯定比 JS 动画要好很多</p></li><li><p>避免浏览器的隐式合成</p></li><li><p>改变复合层的尺寸</p></li></ul><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>上面讲的有些随意，最后再来波官方点的总结吧</p><p>发起一个请求，我们拿到了页面，下载完的网页将被交给浏览器内核（渲染进程）进行处理</p><ul><li>首先，根据顶部定义的 DTD 类型进行对应的解析方式</li><li>渲染进程内部是多线程的，网页的解析将会被交给内部的 GUI 渲染线程处理</li><li>渲染线程中的 HTML 解释器，将 HTML 网页和资源从字节流解释转换成字符流</li><li>再通过词法分析器将字符流解释成词</li><li>之后经过语法分析器根据词构建成节点，最后通过这些节点组建一个 DOM 树</li><li>这个过程中，如果遇到的 DOM 节点是 JS 代码，就会调用 <code>JS引擎</code> 对 JS 代码进行解释执行，此时由 <code>JS引擎</code> 和 <code>GUI渲染线程</code> 的互斥，<code>GUI渲染线程</code> 就会被挂起，渲染过程停止，如果 JS 代码的运行中对 DOM 树进行了修改，那么 DOM 的构建需要从新开始</li><li>如果节点需要依赖其他资源，图片/CSS 等等，就会调用网络模块的资源加载器来加载它们，它们是异步的，不会阻塞当前 DOM 树的构建</li><li>如果遇到的是 JS 资源 URL（没有标记异步），则需要停止当前 DOM 的构建，直到 JS 的资源加载并被 <code>JS引擎</code> 执行后才继续构建 DOM</li><li>对于 CSS，CSS 解释器会将 CSS 文件解释成内部表示结构，生成 CSS 规则树</li><li>然后合并 CSS 规则树和 DOM 树，生成 Render 渲染树，也叫呈现树</li><li>最后对 Render 树进行布局和绘制，并将结果通过 IO 线程传递给浏览器控制进程进行显示</li></ul><p>页面渲染篇到此就结束了，又是上万字，好像也没讲太多东西，大家还是只能以庞观的方式去了解，私下想深入的话还是要多看些相关资料，此文也是我看了很多资料输出的，看完本文，再去看资料或深入应该也会容易了解一些吧，这几篇帖子的核心都脱离不了那道经典面试题，那么看到了这里基本的一些知识点都已经给大家阐述过了，可以自己尝试总结一番了，一定要自己总结再看下文总结篇，这样大家也算没白浪费时间</p><p>下一文「一道面试题」输入 URL 到渲染全面梳理下-总结篇，待续哦。。</p><p>对您有帮助的话，动动小手，点个赞鼓励下吧，当然，个人理解，如有不正，欢迎指出，不胜感激</p><p>哦，还有，可以加个好友加下群一起交流噻，公众号【不正经的前端】也欢迎关注呦 😄</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20200508193235095.png" srcset="/blog/img/loading.gif" alt=""></p><blockquote><p>参考 ( 参考了很多帖子，贴了三个认为比较好的，推荐大家看一看 )</p><ol><li><p><a href="https://segmentfault.com/a/1190000013662126" target="_blank" rel="noopener">从输入 URL 到页面加载的过程？如何由一道题完善自己的前端知识体系</a></p></li><li><p><a href="https://segmentfault.com/a/1190000012925872" target="_blank" rel="noopener">从浏览器多进程到 JS 单线程，JS 运行机制最全面的一次梳理</a></p></li><li><p><a href="https://segmentfault.com/a/1190000008015671" target="_blank" rel="noopener">一篇文章说清浏览器解析和 CSS（GPU）动画优化</a></p></li></ol></blockquote>]]></content>
    
    
    <categories>
      
      <category>一道面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>网络</tag>
      
      <tag>浏览器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「一道面试题」输入 URL 到渲染全面梳理上-网络通信篇</title>
    <link href="/blog/2020/04/15/Interview/%E3%80%8C%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98%E3%80%8D%E8%BE%93%E5%85%A5URL%E5%88%B0%E6%B8%B2%E6%9F%93%E5%85%A8%E9%9D%A2%E6%A2%B3%E7%90%86%E4%B8%8A-%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E7%AF%87/"/>
    <url>/blog/2020/04/15/Interview/%E3%80%8C%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98%E3%80%8D%E8%BE%93%E5%85%A5URL%E5%88%B0%E6%B8%B2%E6%9F%93%E5%85%A8%E9%9D%A2%E6%A2%B3%E7%90%86%E4%B8%8A-%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="「一道面试题」输入-URL-到渲染全面梳理上-网络通信篇"><a href="#「一道面试题」输入-URL-到渲染全面梳理上-网络通信篇" class="headerlink" title="「一道面试题」输入 URL 到渲染全面梳理上-网络通信篇"></a>「一道面试题」输入 URL 到渲染全面梳理上-网络通信篇</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>此文是一道面试题，又不仅仅是一道面试题</p><p>从输入 <code>URL</code> 到页面渲染发生了什么？比如在浏览器输入了 <code>www.qq.com</code> 后浏览器是怎么把最终的页面呈现，这是一个非常经典的面试题，不管是大公司还是小公司甚至前端或后端的面试中命中率都极高，因为涉及到的知识点和可挖掘的地方比较多，而且这中间几乎每一步都是可以优化的</p><p>既然大家刷到了这篇帖子，希望大家花点时间耐心看完，不会让你失望的，此文从网络五层模型详解析及浏览器页面渲染机制等多方面来认识 URL 从输入到页面渲染的整个过程，内容还是满充实的</p><p>写着写着发现有点长，就分成三篇了 😄</p><p>前两篇文章都是帮助大家理解整个过程，所以并没有直接给出答案，而是给大家梳理解释一些相关琐碎的知识，目的不是答题，而是彻底理解此间流程，大家只要认真看到最后一篇就可以骄傲的回答这道题了，自己心中给自己一个答案，再看最后一篇我个人通过这些知识总结的答案 ( 如果你的总结更加充实/细致，请在评论区分享出来，我们一起查漏补缺 ) ，先看后思考，再总结相互讨论，效果最佳</p><p>URL 从输入到页面渲染这整个过程可以分为 <code>网络通信</code> 和 <code>页面渲染</code> 两个方面，一般后端程序猿回答这个问题侧重网络通信就行了，但是前端页面渲染也得了解，总之回答的越详细分值越高</p><p>那么开始吧，这篇文章我们先来看网络通信方面，可能前端同学大家对网络方面的认知应该没有后端同学强，其实这道面试题最能突出自己的也是网络方面，因为它涉及到了很多网络通信原理的知识，所以这块咱们慢慢梳理</p><h2 id="网络分层的由来"><a href="#网络分层的由来" class="headerlink" title="网络分层的由来"></a>网络分层的由来</h2><p>不晓得大家知不知道网络分层，网络其实有很多层，层与层之间又有好多协议存在，还有各种各样的数据包，这玩意干巴巴的，很没意思，这么多层太麻烦了，为什么有这么多层呢？为什么不直接一层呢？</p><p>起初计算机与计算机之间的通信只需要一根线就可以完成通信，但是世界那么大，那么多计算机，距离太远了，而且这线还老容易被无良的人偷偷剪断</p><p>后来就出来了无线网，虽然其中网关、路由之间也需要连线，但不是让每台计算机两两连接，而是一个区域为单位计算机相互连接通信</p><p>后来发现计算机之间的连线只能传送 0/1 信号，另一台计算并不知道那么多 0/1 代表什么，就像 <code>010101010101111000111011010</code> 你知道这一大串是什么意思吗，计算机也不知道，不同厂商生产的计算机连线实现通信也是很麻烦的，干脆定义一套规则吧，不管是哪个牌子的计算机，都必须遵守这套规则，这套规则就是我们经常说的 <code>网络协议</code></p><p>哦哦，是在说 <code>网络分层</code> ，不是讲 <code>网络协议</code> ，继续继续，接着我们上面的话题，问题来了，计算机之间通过连线传送 0/1 信号的问题虽然规定了通信规则，但是除了像 0/1 这种无意义的信号之外，网络中还存在着其他各种各样的问题</p><ul><li>两个计算机之间怎么进行识别？</li><li>怎么才能知道对方的地址？</li><li>不同计算机应用程序怎么知道是给自己传递的数据？</li><li>不同的通信数据格式怎么来规定等等一系列的问题</li></ul><p>如果各种问题都写成一套协议来规定双方通信的规则，但是万一其中哪些规则通信中出现问题，影响到了其他规则，最常见的就是数据包，一个数据包中如果包含各种各样的协议，呀呀呀</p><p>如果我们对网络进行分层，每一层负责一项具体的工作，然后把数据传送到下一层，那么往来通信和网络互联这一复杂的问题是不是就变得较为简单化了呢</p><p>可能大家没有太明白，没关系，接着看</p><h2 id="TCP-IP-五层模型"><a href="#TCP-IP-五层模型" class="headerlink" title="TCP/IP 五层模型"></a>TCP/IP 五层模型</h2><p>既然要分层，那么分为几层才好呢？</p><p>目前的网络层次可划分为 <code>四层因特网协议栈</code> 和 <code>七层因特网协议栈</code> ，其实起初网络分层是标准的七层，也就是我们所说的 <code>OSI 七层模型</code> ，参考模型是国际标准化组织 <code>ISO</code> 制定的一个用于计算机或通信系统间互联的标准体系，一般称为 <code>OSI参考模型</code> 或 <code>七层模型</code></p><p>可能对网络有些了解的同学知道还有 <code>TCP/IP 四层模型</code> 和 <code>TCP/IP 五层模型</code> ，这又是怎么出来的呢？</p><p>其实所谓的 <code>TCP/IP 四层模型</code> 和 <code>TCP/IP 五层模型</code> 是以 <code>OSI 七层</code> 优化而来，把某些层进行合并了，本质上还是相同的，<code>OSI七层模型</code> 太过细化，有一定的参考意义，但实现起来比较繁琐，相比较而言，<code>TCP/IP模型</code> 比较简洁，具有较强的实际应用价值</p><p>我们来看一个模型的图片 ( 网图侵删 )</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20200407141628775.png" srcset="/blog/img/loading.gif" alt="image-20200407141628775"></p><p><code>TCP/IP</code> 将计算机网络分成了四个层次，一般资料或教程里都是结合 <code>OSI7层模型</code> 和 <code>TCP/IP4层模型</code>，将计算机网络按照 5 层的模型来讲，5 层模型只是为了方便介绍计算机网络原理而设计的，而在实际应用中还是 <code>TCP/IP四层模型</code> ，这点大家要明白</p><p>这里我们同样用五层来解释，比较好理解些，当然，这里只能让大家脑海里有一个具体的网络分层结构的认知，作为面试回答了解这些足够，而后推荐大家继续深入，可以看相关的书籍和资料，此文也能够起到一个引导的作用</p><p><strong>PS：</strong> 作为一个前端或者是后端，我们都是软件开发，所以侧重点放在网络层以上就可以了，物理层和数据链路层都是硬件相关的，所以这两个层下面不会过多叙述，了解即可</p><h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><p>物理层，顾名思义，通过物理手段 ( 网线，光纤，无线 ) 将设备连接在一起，传输 0/1 电信号 ( 也叫比特流 ) ，就像我们上边讲到的计算机之间的物理连线</p><p>主要用来传输 0/1 信号，因为 0/1 信号没有任何的现实意义，所以用另一层用来规定不同 0/1 组合的意义</p><h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><p>还是上面说的，<code>010101010101111000111011010</code> ，像这么一串数据计算机并不知道是什么意思</p><p>下层的物理层不能规定不同 0/1 组合的信号代表什么意义，所以在数据链路层规定了一套协议，专门给 0/1 信号进行分组，规定不同的组代表的是什么意思，从而让双方计算机都能够进行识别，这个协议就是我们常说的 <code>以太网协议</code></p><h4 id="以太网协议"><a href="#以太网协议" class="headerlink" title="以太网协议"></a>以太网协议</h4><p>以太网协议规定一组电信号构成一个数据包，我们把这个数据包称为 <code>帧</code> ，每一个帧由 <code>标头</code> 和 <code>数据</code> 两部分组成</p><p>帧的大小一般为 <code>64 - 1518</code> 个字节 较大的数据则需要分成多个桢</p><p>标头 <code>Head</code> ，18 个字节组成，标头中包含这个 <code>桢</code> 是由谁发送、发送给谁这些信息，所以标头主要是一些说明数据 例如发送者/接受者等信息</p><p>数据 <code>Data</code> ，46-1500 个字节组成，里面主要是发送者想给接收者的内容</p><p>把一台计算机的数据通过物理层和数据链路层发送给另外一台计算机，怎么标识对方以及怎么知道对方的地址呢？ 唯一标示 <code>MAC地址</code> 出现了</p><h4 id="MAC-地址"><a href="#MAC-地址" class="headerlink" title="MAC 地址"></a>MAC 地址</h4><p>进入网络的每一台计算机，都会有网卡接口，每一个网卡都会有一个唯一的地址，就是所谓的 <code>MAC地址</code> ，它就是网络中每台计算机设备的唯一标识，是一串由 48 个字节组成的十六进制数，每台计算机在厂商生产出来的时候就标识好了，所以我们用 <code>MAC地址</code> 来标识对方</p><p>再来看一个图 ( 网图侵删 )</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20200407141654052.png" srcset="/blog/img/loading.gif" alt="image-20200407141654052"></p><p>如上图所示，如计算机 A 知道了计算机 B 的 MAC 地址，然后计算机 A 想要给计算机 B 传送数据，虽然计算机 A 知道了计算机 B 的 MAC 地址，可是 A 要怎么给 B 传送数据呢？</p><p>计算机 A 不仅连着计算机 B，而且计算机 A 也连接着计算机 C 和 D，虽然计算机 A 知道计算机 B 的 MAC 地址，但是却不知道 B 是在哪一路上，所以为了解决这个问题，<code>广播</code> 这个概念就出现了</p><h4 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h4><p>在同一子网络，就是我们常说的局域网中，计算机通过广播来通信，即向同子网中全部计算机发送数据包，其它计算机根据数据包中接收者的 <code>MAC地址</code> 来判断是否接收数据包</p><p>通俗来讲，就是 A 会同时给 B/C/D 发送数据包，这个数据包中会包含着接收者的 <code>MAC地址</code> 信息，当 B/C/D 接收到了数据包，会取出数据包中的 <code>MAC地址</code> 与自身的 <code>MAC地址</code> 对比，如相同就接收这个数据包，否则就丢弃这个数据包 ( 丢包 )，这种方式我们称之为 <code>广播</code></p><p>就像，你和女友在人群中走散了，你大喊一声她的名字，听到的人会自己匹配，是自己就会理会，不是自己就当你是傻子不理你</p><p>那么到了目前，我们知道了计算机之间的标示和如何通信，但是还有一个问题，要怎么知道对方的 <code>MAC地址</code> 呢 ？这又牵出了 <code>ARP协议</code> ，通过 <code>ARP协议</code> 来得知对方的 <code>MAC地址</code> ，这个协议是网络层的一个协议，所以我们暂且搁置，先接着往下看</p><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>看了物理层和数据链路层的作用，可能大家会觉得好像已经可以完成正常通信了，那么网络层又是做什么的呢？</p><p>其实我们所处的网络，是由无数个子网络 ( 局域网 ) 构成的，广播的时候，也只有同一个子网里的计算机能够收到，如过没有子网这种东西，计算机 A 通过广播的方式发一个数据包给计算机 B，那么全世界所有的计算机都能收到这个数据包，然后进行对比再舍弃，那么多台计算机后果可想而知，子网也因此而产生</p><p>那么问题又来了，我们要怎么区分 <code>Mac地址</code> 是属于同一个子网的呢？假如是同一个子网，我们就用广播的形式把数据传送给对方，如果不是同一个子网的，我们就会把数据发给网关，让网关进行转发</p><p>怎么判断两台计算机是否在同一个子网中呢，这就是网络层干的事情，为了解决这个问题，就有了 <code>IP协议</code> 的概念</p><h4 id="IP-协议"><a href="#IP-协议" class="headerlink" title="IP 协议"></a>IP 协议</h4><p><code>IP协议</code>所定义的地址，就是我们常说的 <code>IP地址</code> ，<code>IP协议</code> 有两个版本，<code>ipv4 / ipv6</code>，目前用的最多的还是 ipv4，这个地址由 32 位的二进制数组成，我们一般把它分成 4 段的十进制表示，地址范围在 <code>0.0.0.0 ~ 255.255.255.255</code> ，这个我们应该都很常见</p><p>每一台想要联网的计算机都会有一个 <code>IP地址</code> ，这个 <code>IP地址</code> 分为两部分，前面一部分代表网络，后面一部分代表主机，但是网络部分和主机部分所占用的二级制位数是不固定的</p><p>假如两台计算机的网络部分是一模一样的，我们就说这两台计算机是属于同一个子网 ( 局域网 ) 中，例如 <code>192.168.17.1</code> 和 <code>192.168.17.2</code> ， 假如这两个 <code>IP地址</code> 的网络部分为 24 位，主机部分为 8 位，那么他们的网络部分都为 <code>192.168.43</code> ， 所以我们说这两台计算机处于同一个子网中</p><p>问题又随之而来了，给我们两个 <code>IP地址</code> ，鬼知道网络部分占几位，主机部分又占几位呢？</p><p>这就又引出了我们另一个关键词 <code>子网掩码</code></p><h4 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h4><p><code>子网掩码</code> 和 <code>IP地址</code> 一样也是 32 位二进制数，但是它的网络部分规定全部为 1，主机部分规定全部为 0，也就是说假如上面那两个 IP 地址 的网络部分为 24 位，主机部分为 8 位的话，那他们的子网掩码为</p><p><code>11111111.11111111.11111111.00000000</code> ，也就是 <code>255.255.255.0</code></p><p>有了子网掩码，怎么来判断 <code>IP地址</code> 是否处于同一个子网中呢？</p><p>显然，知道了子网掩码，相当于我们知道了网络部分是几位，主机部分是几位，我们只需要把 <code>IP地址</code> 与他的子网掩码做一个 ( and ) 运算，然后把各自的结果进行比较就行了，如果比较的结果相同，则代表的是同一子网，否则不是同一子网</p><p>也就是说有了两台计算机的 <code>IP地址</code> 和 <code>子网掩码</code> ，我们就可以判断他们是否处在同一子网当中了</p><p>假设他们处在同一子网当中，计算机 A 要和计算机 B 发送数据时，我们通过是 <code>ARP协议</code> 来得到计算机的 <code>MAC地址</code></p><h4 id="ARP-协议"><a href="#ARP-协议" class="headerlink" title="ARP 协议"></a>ARP 协议</h4><p><code>ARP协议</code> 也是通过广播的形式，给同一个子网中每个电脑发送一个数据包，这个数据包会包含接收者的 <code>IP地址</code>，对方收到这个数据之后，会取出 <code>IP地址</code> 与自身的对比，相同则会把自己的 <code>MAC地址</code> 回复给对方，否则就丢弃这个数据包，这样计算机 A 就知道计算机 B 的 <code>MAC地址</code> 了</p><p>可能大家会问，知道了 <code>MAC地址</code> 后，发送数据是通过广播的形式发送，询问对方的 <code>MAC地址</code> 也是通过广播的形式来发送，那其他计算机怎么知道你是要传输数据还是询问 <code>MAC地址</code> 呢？</p><p>其实在询问 <code>MAC地址</code> 的数据包里，在对方的 <code>MAC地址</code> 这儿填的是一个特殊的 <code>MAC地址</code> ，其他计算机看到这个特殊的 <code>MAC地址</code> 后，就知道广播是在询问了</p><p>如果两台计算机的 IP 不是处于同一个子网之中，这个时候我们就会把数据包发送给网关，然后让网关帮我们进行转发</p><h3 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h3><p>通过 <code>物理层</code> / <code>数据链路层</code> 以及 <code>网络层</code> 的互相协调，我们成功的把数据从计算机 A 传到了计算机 B，可是计算机 B 里面有各式各样的应用程序，计算机是如何知道这个数据是发给哪个应用程序的呢？</p><p>这个时候，<code>端口</code> 就上场了，当计算机 A 传输给计算机 B 的时候，还得指定一个端口，以供特定的应用程序来接收处理，作为程序员的我们对端口就更熟悉了，端口范围：<code>0~65535</code>，其中前 1023 个端口被系统占用</p><p>那么也就是说，传输层的功能就是建立端口到端口的通信，而相比之下网络层的功能是建立主机到主机的通信</p><p>有了 <code>IP</code> 和 <code>端口</code> ，我们才能准确通信，我们输入的 IP 有些并没有指定端口号，其实是有些传输协议，设定了一些默认端口，例如 <code>HTTP</code> 默认是 80，<code>HTTPS</code> 默认 443，这些端口信息也会包含在数据包里面</p><p>传输层最常见了两大协议就是 <code>TCP协议</code> 和 <code>UDP协议</code></p><h4 id="UDP-协议"><a href="#UDP-协议" class="headerlink" title="UDP 协议"></a>UDP 协议</h4><p><code>UDP协议</code> 全称是用户数据报协议，是一种无连接的协议，与 TCP 协议一样用于处理数据包</p><p>UDP 数据包分 <code>标头</code> (8 个字节) 和 <code>数据</code> (加标头不超过 65535 个字节)， UDP 数据包放在 IP 数据包的 <code>数据</code> 中，标头主要包括发出端口和接收端口</p><p>UDP 有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的</p><h4 id="UDP-协议特点"><a href="#UDP-协议特点" class="headerlink" title="UDP 协议特点"></a>UDP 协议特点</h4><ul><li><p>面向无连接</p><ul><li>UDP 想发数据就可以开始发送了，不需要连接，它只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作</li><li>在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了</li><li>在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作</li></ul></li><li><p>有单播、多播、广播</p><ul><li>UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能</li></ul></li><li><p>面向报文</p><ul><li>发送方的 UDP 对应用程序交下来的报文，在添加首部后就向下交付 IP 层</li><li>UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界</li><li>因此，应用程序必须选择合适大小的报文</li></ul></li><li><p>不可靠性</p><ul><li>不可靠性首先体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠</li><li>收到什么数据就传什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了</li><li>网络环境时好时坏，但 UDP 没有拥塞控制，一直会以恒定的速度发送数据，即使网络条件不好，也不会对发送速率进行调整，这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景 ( 比如电话会议 ) 就需要使用 UDP 而不是 TCP</li></ul></li><li><p>头部开销小，传输数据报文高效</p><ul><li>UDP 头部包含了以下几个数据<ul><li>两个十六位的端口号，分别为发出端口和接收端口</li><li>整个数据报文的长度</li><li>整个数据报文的检验和（IPv4 可选字段），该字段用于发现头部信息和数据中的错误</li></ul></li><li>所以 UDP 的头部开销小，只有 8 字节，相比 TCP 的至少 20 字节要少得多，在传输数据报文时是很高效的</li></ul></li></ul><h4 id="TCP-协议"><a href="#TCP-协议" class="headerlink" title="TCP 协议"></a>TCP 协议</h4><p>当一台计算机想要与另一台计算机通讯时，两台计算机之间的通信需要畅通且可靠，这样才能保证正确收发数据</p><ul><li><p>例如你想查看网页或查看电子邮件时，希望完整且按顺序查看网页，而不丢失任何内容</p></li><li><p>又例如当你下载文件时，希望获得的是完整的文件，而不仅仅是文件的一部分</p></li></ul><p>如果数据丢失或乱序，都不是你希望得到的结果，于是就用到了 <code>TCP</code></p><p><code>TCP协议</code> 全称是传输控制协议是一种面向连接的、可靠的、基于字节流的传输层通信协议，<code>TCP</code> 是面向连接的、可靠的流协议，什么是流？流就是指不间断的数据结构，可以把它想象成排水管中的水流</p><p>TCP 三次握手建立连接，四次挥手断开连接又是一个话题，接下来我们就简单说一下</p><h4 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h4><p>三次握手建立链接，为方便理解，仿一次电面</p><ul><li><p>小李 (客户端)：您好，您是 xx 的面试官吗？</p></li><li><p>面试官 (服务端)：嗯嗯，是的，你是昨天投简历的小李吗？</p></li><li><p>小李 (客户端)：嗯嗯，是的，我是</p></li></ul><p>接着，小李和面试官开始愉快的侃起了大山</p><p>根据上面的内容，我们再来看下图 (网图侵删)</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/tcpip3.jpg" srcset="/blog/img/loading.gif" alt="tcpip3"></p><p>按正规流程来说建立连接的三次握手如下</p><ul><li><strong>第一次握手</strong> 客户端向服务端发送连接请求报文段，该报文段中包含自身的数据通讯初始序号，请求发送后，客户端便进入 <code>SYN-SENT</code> 状态</li><li><strong>第二次握手</strong> 服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 <code>SYN-RECEIVED</code> 状态</li><li><strong>第三次握手</strong> 当客户端收到连接同意的应答后，还要向服务端发送一个确认报文，客户端发完这个报文段后便进入 <code>ESTABLISHED</code> 状态，服务端收到这个应答后也进入 <code>ESTABLISHED</code> 状态，此时连接建立成功</li></ul><p>可能大家会有疑惑，为什么 TCP 建立连接需要三次握手，而不是两次？</p><p>其实这是为了防止出现失效的连接请求报文段被服务端接收的情况，从而产生错误</p><h4 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a>TCP 四次挥手</h4><p>四次挥手断开链接，接着仿电面 😄</p><ul><li><p>面试官 (主动方)：嗯，你的情况我这边了解了，等通知吧 ( 我想挂了 )</p></li><li><p>小李 (被动方)：嗯嗯，好的 ( 这就想挂了？我还没侃够 )</p></li><li><p>小李 (被动方)：那希望有机会能和您一块共事 ( 拜拜吧您嘞 )</p></li><li><p>面试官 (主动方)：嘀…嘀…嘀…嘀</p></li></ul><p>再看正经的过程图 (网图侵删)</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/tcpip4.jpg" srcset="/blog/img/loading.gif" alt="tcpip4"></p><p>TCP 是双向的，所以在断开连接时两端都需要发送 FIN 和 ACK</p><ul><li><p><strong>第一次握手</strong> 若客户端 A 认为数据发送完成，则它需要向服务端 B 发送连接释放请求</p></li><li><p><strong>第二次握手</strong> B 收到连接释放请求后，会告诉应用层要释放 TCP 链接，然后会发送 <code>ACK</code> 包，并进入 <code>CLOSE_WAIT</code> 状态，此时表明 A 到 B 的连接已经释放，不再接收 A 发的数据了，但是因为 TCP 连接是双向的，所以 B 仍旧可以发送数据给 A</p></li><li><p><strong>第三次握手</strong> B 如果此时还有没发完的数据会继续发送，完毕后会向 A 发送连接释放请求，然后 B 便进入 <code>LAST-ACK</code> 状态</p></li><li><p><strong>第四次握手</strong> A 收到释放请求后，向 B 发送确认应答，此时 A 进入<code>TIME-WAIT</code> 状态，该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃）时间，若该时间段内没有 B 的重发请求的话，就进入 <code>CLOSED</code> 状态，当 B 收到确认应答后，也便进入 <code>CLOSED</code> 状态</p></li></ul><h4 id="为何客户端最后还等待-2MSL"><a href="#为何客户端最后还等待-2MSL" class="headerlink" title="为何客户端最后还等待 2MSL"></a>为何客户端最后还等待 2MSL</h4><p>客户端需要保证最后一次发送的 <code>ACK</code> 报文到服务器，如果服务器未收到，可以请求客户端重发，这样客户端还有时间再发，重启 2MSL 计时</p><h4 id="TCP-IP-的并发限制"><a href="#TCP-IP-的并发限制" class="headerlink" title="TCP/IP 的并发限制"></a>TCP/IP 的并发限制</h4><p>其实浏览器对同一域名下并发的 TCP 连接是有限制的（2-10 个不等）</p><p>而且在 <code>HTTP1.0</code> 中往往一个资源下载就需要对应一个 TCP/IP 请求</p><h4 id="TCP-协议特点"><a href="#TCP-协议特点" class="headerlink" title="TCP 协议特点"></a>TCP 协议特点</h4><ul><li><p>面向连接</p><ul><li>面向连接，是指发送数据之前必须在两端建立连接，建立连接的方法就是 <code>三次握手</code>，这样能建立可靠的连接，为数据的可靠传输打下了基础</li></ul></li><li><p>仅支持单播传输</p><ul><li>每条 TCP 传输连接只能有两个端点，只能进行点对点的数据传输，不支持多播和广播传输方式</li></ul></li><li><p>面向字节流</p><ul><li>TCP 不像 UDP 一样那样一个个报文独立传输，而是在不保留报文边界的情况下以字节流方式进行传输</li></ul></li><li><p>可靠传输</p><ul><li>对于可靠传输，判断丢包，误码靠的是 TCP 的段编号以及确认号，TCP 为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收</li><li>然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)，如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传</li></ul></li><li><p>提供拥塞控制</p><ul><li>当网络出现拥塞的时候，TCP 能够减小向网络注入数据的速率和数量，缓解拥塞</li></ul></li><li><p>TCP 提供全双工通信</p><ul><li>TCP 允许通信双方的应用程序在任何时候都能发送数据，因为 TCP 连接的两端都设有缓存，用来临时存放双向通信的数据</li><li>当然，TCP 可以立即发送一个数据段，也可以缓存一段时间以便一次发送更多的数据段（最大的数据段大小取决于 MSS）</li></ul></li></ul><h4 id="UDP-协议和-TCP-协议区别"><a href="#UDP-协议和-TCP-协议区别" class="headerlink" title="UDP 协议和 TCP 协议区别"></a>UDP 协议和 TCP 协议区别</h4><p>到了现在，大家应该对 UDP 和 TCP 都有些了解了，我们直接对比其作用再进行总结</p><table><thead><tr><th align="left">对比</th><th align="left">UDP</th><th align="left">TCP</th></tr></thead><tbody><tr><td align="left">是否连接</td><td align="left">无连接</td><td align="left">面向连接</td></tr><tr><td align="left">是否可靠</td><td align="left">不可靠传输，不使用流量控制和拥塞控制</td><td align="left">可靠传输，使用流量控制和拥塞控制</td></tr><tr><td align="left">连接个数</td><td align="left">支持一对一，一对多，多对一和多对多通信</td><td align="left">只能一对一通信</td></tr><tr><td align="left">传输方式</td><td align="left">面向报文</td><td align="left">面向字节流</td></tr><tr><td align="left">首部开销</td><td align="left">首部开销小，仅 8 字节</td><td align="left">首部最小 20 字节，最大 60 字节</td></tr><tr><td align="left">适用场景</td><td align="left">适用于实时应用 ( IP 电话、视频会议、直播等 )</td><td align="left">适用于要求可靠传输的应用，例如文件传输</td></tr></tbody></table><ul><li>TCP 向上层提供面向连接的可靠服务 ，UDP 向上层提供无连接不可靠服务</li><li>虽然 UDP 并没有 TCP 传输来的准确，但是也能在很多实时性要求高的地方有所作为</li><li>对数据准确性要求高，速度可以相对较慢的，可以选用 TCP</li></ul><p>TCP 我们就简单说到这里，接下来我们接着来看应用层</p><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>应用层是最接触用户的，上面几层我们收到了传输层收到的数据，TCP/UDP 协议可以传递各种程序的数据包，就像邮箱/网页/FTP 等等，所以就需要不同的协议来规定数据的格式，收到后才能渲染解读，应用层就是由这些协议构成，它的数据包放在 UDP 包/TCP 包的 <code>数据</code> 中</p><p>我们遨游网络时经常用到的 HTTP 协议、文件传输用的 FTP 协议、电子邮件发送的 SMTP、域名解析的 DNS 协议、远程登录的 Telnet 协议等等都是属于应用层的</p><p>还有 Socket，它是在应用层和传输层之间的一个抽象层，它把 TCP/IP 层复杂的操作封装成几个简单的接口供应用层调用，从而实现进程在网络中的通信</p><p>上面我们已经基本了解到了计算机的一些通信基础，可以说到目前为止从一个 IP 到通信结束都已经知道了，但是我们输入的是域名不是 IP，那么它是怎么变成 IP 通信的呢？这就要详细说说 <code>DNS</code> 了</p><h4 id="DNS-是什么"><a href="#DNS-是什么" class="headerlink" title="DNS 是什么"></a>DNS 是什么</h4><p><code>Domain Name System</code> 简写 <code>DNS</code> ，翻译过来就是域名系统的意思，它是一种组织成域层次结构的计算机和网络服务命名系统，用于 <code>TCP/IP</code> 网络，作为将域名和 IP 地址相互映射的一个分布式数据库，它所提供的服务是用来将 <code>主机名</code> 和 <code>域名</code> 转换为 <code>IP地址</code> 的工作</p><p>简单来说，<code>IP地址</code> 就像门牌号一样，我们在输入域名访问网站时，数据服务器是不认识你这个域名的，它只认识 IP，你的域名会通过 <code>DNS服务器</code> 解析成 IP 值，通过这个门牌号 (IP 值) 向数据服务器查找你的网站数据并给你返回到浏览器上</p><h4 id="为什么需要-DNS"><a href="#为什么需要-DNS" class="headerlink" title="为什么需要 DNS"></a>为什么需要 DNS</h4><p>上面我们说，网络通讯大部分是基于 TCP/IP 的，而 TCP/IP 是基于 IP 地址的，所以计算机在网络上进行通讯时只能识别如 <code>252.94.131.12</code> 之类的 IP 地址，而不能认识域名</p><p>我们没办法记住 10 个以上 IP 地址的网站 ( 你要说记性好那俺就乖乖闭嘴了 😄 )，一般我们访问网站时，更多的是在浏览器地址栏中输入域名，就能看到所需要的页面，这是因为有一个叫 <code>DNS服务器</code> 的计算机自动把我们的域名 <code>翻译</code> 成了相应的 IP 地址，然后通过 <code>IP地址</code> 返回所对应的网页</p><h4 id="域名结构"><a href="#域名结构" class="headerlink" title="域名结构"></a>域名结构</h4><p>先来简单介绍下域名结构，有些前端同学可能不太了解，域名是在 <code>Internet</code> 上用于解决 IP 地址的一种方法，一个完整的域名由 2 个或 2 个以上的部分组成，各部分之间用英文的句号 <code>.</code> 来分隔</p><p>拿 <code>www.qq.com.</code> 来说，等等，是不是多打了一个点，当然不是多打，这个最后的 <code>.</code> 代表的是根域名，默认情况下所有的网址的最后一位都是 <code>.</code>，只不过为了方便用户，通常都会省略，浏览器在 <code>DNS解析</code> 时会自动加上的，<code>com</code>是顶级域名，<code>qq</code> 是二级域名，<code>www</code> 是三级域名，如果 <code>www</code> 前还有，那就四级等等</p><p>那么我们在解析时的顺序就是</p><pre><code class="js">.  -&gt; .com -&gt; qq.com -&gt; www.qq.com</code></pre><h4 id="DNS-获取流程"><a href="#DNS-获取流程" class="headerlink" title="DNS 获取流程"></a>DNS 获取流程</h4><p>DNS 是应用层协议，用于将用户提供的主机名解析为 ip 地址，它的获取流程大致分为下面这五步</p><ul><li><p>用户主机上运行着 DNS 客户端，就是我们的 PC 机或者手机客户端运行着 DNS 客户端</p></li><li><p>浏览器将接收到的 URL 中抽取出域名字段，就是访问的主机名，例如 <code>http://www.qq.com</code></p></li><li><p>DNS 客户机端向 DNS 服务器端发送一份查询报文，报文中包含着要访问的主机名字段，中间还包括一些列缓存查询以及分布式 DNS 集群的工作</p></li><li><p>该 DNS 客户机最终会收到一份回答报文，其中包含有该主机名对应的 IP 地址</p></li><li><p>一旦该浏览器收到来自 DNS 的 IP 地址，就可以向该 IP 地址定位的 HTTP 服务器发起 TCP 连接</p></li></ul><h4 id="DNS-解析过程"><a href="#DNS-解析过程" class="headerlink" title="DNS 解析过程"></a>DNS 解析过程</h4><p>假如我们要访问 <code>www.qq.com</code> ，那么要经历什么呢，先来看一张图 ( 网图侵删 )</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other//image-20200407141726887.png" srcset="/blog/img/loading.gif" alt=""></p><p>先简单的瞄一眼这张图，看不懂也没关系，结合文字再看</p><p>上图主要分为三个段</p><ul><li>DNS 客户机，就是我们主机上运行的 DNS 客户端，PC 机或者手机客户端都有</li><li>客户机到服务器，这个服务器可以简单理解为我们当前所处网络环境的路由器</li><li>服务器到服务器，最后这个服务器指的是 <code>互联网服务提供商服务器/根域名服务器/顶级域名服务器/主域名服务器</code></li></ul><p>DNS 获取流程有很多步骤，这个过程中存在多个请求，如果每次都经过这么多步骤，那就太耗时间了，所以 DNS 有多级缓存的概念，接下来我们来简单描述下这个过程</p><ul><li><p>浏览器缓存</p><ul><li>当用户通过浏览器访问 <code>www.qq.com</code> 时，浏览器首先会在自己缓存中查找是否有该域名对应的 IP 地址</li><li>若曾经访问过该域名且没有清空缓存便存在，不存在则继续下一步</li></ul></li><li><p>系统缓存</p><ul><li>当浏览器缓存中无域名对应 IP 则会自动检查用户计算机系统 <code>Hosts</code> 文件 DNS 缓存是否有该域名对应 IP</li></ul></li><li><p>路由器缓存</p><ul><li>当浏览器及系统缓存中均无域名对应 IP 则进入路由器缓存中检查，以上三步均为客服端的 DNS 缓存</li></ul></li><li><p>互联网服务提供商 ( ISP ) DNS 缓存</p><ul><li>当在用户客服端查找不到域名对应 IP 地址，则将进入互联网服务提供商 ( ISP ) DNS 缓存中进行查询</li><li>比如你用的是电信的网络，则会进入电信的 DNS 缓存服务器中进行查找</li></ul></li><li><p>根域名服务器</p><ul><li>当以上均未完成，则进入根服务器进行查询</li><li>根域名服务器收到请求后会查看区域文件记录，若无则将其管辖范围内顶级域名 ( <code>.com</code> ) 服务器 IP 告诉本地 DNS 服务器</li></ul></li><li><p>顶级域名服务器</p><ul><li>顶级域名服务器收到请求后查看区域文件记录，若无则将其管辖范围内主域名（ <code>qq.com</code> ）服务器的 IP 地址告诉本地 DNS 服务器</li></ul></li><li><p>主域名服务器</p><ul><li>主域名服务器接受到请求后查询自己的缓存，如果没有则进入下一级域名服务器（ <code>www.qq.com</code> ）进行查找，并重复该步骤直至找到正确纪录</li></ul></li><li><p>保存结果至缓存</p><ul><li>本地域名服务器把返回的结果保存到缓存，以备下一次使用，同时将该结果反馈给客户端，客户端通过这个 IP 地址与 Web 服务器建立链接</li></ul></li></ul><p>DNS 客户机可通过从以前查询获得的缓存信息就地应答查询，DNS 服务器可使用其自身的资源记录信息缓存来应答查询，也可代表请求客户机来查询或联系其他 DNS 服务器，以完全解析该名称，并随后将应答返回至客户机，这个过程称为 <code>递归查询</code></p><p>客户机自己尝试联系其他的 DNS 服务器来解析名称，如果客户机这么做，它会使用基于服务器应答的独立和附加的查询，该过程称作迭代，即 DNS 服务器之间的交互查询就是 <code>迭代查询</code></p><p>这就是 DNS 的整个过程了，是这道面试题的第一步，面试官可能还会问 DNS 解析要怎么优化，不急，慢慢来</p><h4 id="为什么要优化-DNS-解析"><a href="#为什么要优化-DNS-解析" class="headerlink" title="为什么要优化 DNS 解析"></a>为什么要优化 DNS 解析</h4><p>用户打开网站的整个流程中，DNS 解析是第一环，当用户输入域名并敲回车后，系统调用 <code>DNS客户端</code>，寻找到用户配置或者自动分配的<code>DNS IP</code>，之后就开始整个解析过程，<code>DNS服务器</code> 完成解析到此域名的 <code>数字IP服务器</code>，一般情况下返回给定域名对应的 IP 地址会花费 <code>20~120毫秒</code> 的时间，而且在这个过程中浏览器什么都不会做直到 DNS 查询完毕</p><p>一旦解析完成，连接建立并保持，也就是顺利的访问以后，网页以后的下载速度就和 DNS 没关系了，直到下一次重新解析和发起访问请求</p><p>很多小型网站，DNS 解析时间都接近 <code>0.5s</code>，有些甚至需要 <code>1s</code> 左右才可以解析出结果，一般网站用户的等待时间超过 <code>8s</code> 就会放弃访问，而对于电子商务网站，<code>4s</code> 就是用户忍耐极限，而一般经过优化的小型网站，DNS 解析时间都可以控制在 <code>200ms</code> 左右，而带宽在 <code>100M</code> 左右的网站，经过优化，DNS 解析时间可以控制在 <code>50~100ms</code></p><p>那么，你现在知道为什么要优化 DNS 解析了吧，怎么优化呢？我们接着看</p><h4 id="DNS-解析优化-善用缓存之-TTL"><a href="#DNS-解析优化-善用缓存之-TTL" class="headerlink" title="DNS 解析优化-善用缓存之 TTL"></a>DNS 解析优化-善用缓存之 TTL</h4><p>上买我们也看了，DNS 存在着多级缓存，每次找这么多级，很定耗时间，我们要尽量多的让用户直接从运营商的 DNS 缓存中拿到解析记录，这样就不需要走根域名服务器以下的这些过程，自然就节省了一些时间</p><p>我们购买域名做域名解析时，有一个 <code>TTL</code> 值 ( 如下图阿里云域名解析中所示 )</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20200407201056309.png" srcset="/blog/img/loading.gif" alt=""></p><p>它指的是域名解析的生命周期 ( 秒为单位 )，简单来说它表示 DNS 服务器解析域名时记录在 DNS 服务器上的缓存时间，这个值的大小设置也是很有学问的，我们要在尽可能快的情况下又要保证当服务器出问题时能够尽快切换</p><ul><li>大家自己肯定清楚自己的服务器有没有多台或备份，若无备份，那服务器宕机时只能生抗，所以，<code>TTL</code> 时间对于你来说是越长越好，因为 <code>TTL</code> 短的目的是服务器发生问题时，可以及时切换，这个对于没有备份的网站基本利用不上，所以这时你的 <code>TTL</code> 设置就越长越好，当然了，也不能太长，一般设置 <code>TTL 3600</code> 即可</li><li>若有备份或多台服务器，会发生由于服务器宕机需要及时做切换，<code>TTL</code> 时间越短切换越及时，但是 <code>TTL</code> 时间越短，也就意味着运营商 DNS 经常缓存不住，一般用户，设置为 <code>TTL 600</code> 即可，如果对及时切换，要求特别苛刻的网站，设置 <code>TTL 120</code> 就行</li></ul><h4 id="DNS-解析优化-负载均衡"><a href="#DNS-解析优化-负载均衡" class="headerlink" title="DNS 解析优化-负载均衡"></a>DNS 解析优化-负载均衡</h4><p>在 DNS 服务器中为同一个主机名配置多个 IP 地址，在应答 DNS 查询时，DNS 服务器对每个查询将以 DNS 文件中主机记录的 IP 地址按顺序返回不同的解析结果，将客户端的访问引导到不同的机器上去，使得不同的客户端访问不同的服务器，从而达到负载均衡的目的，可以根据每台机器的负载量或该机器离用户地理位置的距离入手</p><p>就像我们使用 CDN 厂商做域名解析，它也是利用 DNS 的重定向技术，DNS 服务器会返回一个跟用户最接近的点的 IP 地址给用户，CDN 节点的服务器负责响应用户的请求，提供所需的内容，CDN 厂商的域名解析服务器用户量多被访问的次数也多，域名解析服务器的 A 记录基本上会被各地运营商的 DNS 一直缓存着，所以服务效果也是最好的</p><h4 id="HTTP-amp-HTTPS"><a href="#HTTP-amp-HTTPS" class="headerlink" title="HTTP &amp; HTTPS"></a>HTTP &amp; HTTPS</h4><p>说完 DNS，本来还想写段 HTTP 和 HTTPS，这块也能说好久，但是后来又感觉写在这有些不太合适，那就下次有机会单独写吧</p><h2 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h2><p>网络通信篇到此结束，虽然此文写了上万字，但只能说整合了内容讲了个大概，怎么说呢，网络通信相关的一些知识都有提到，但并未深入，所以面试前临阵磨枪或查漏补缺可以，不要妄想通过看此文或者某一篇帖子就认为自己懂了网络通信，TCP/IP/DNS/HTTP/HTTPS 这些内容随便挑出来一个都可以长篇大论</p><p>当然，和大多数帖子一样，此文庞观的为大家梳理了一下网络通信的内容，并用通俗易懂的语气为大家描述，这也是为了大多数非科班出身的小伙伴，有错误的地方望海涵也望提出</p><p>如果大家想进一步了解网络通信，也可以此文为引子，深入看一些相关知识，第三文总结也为大家整理出来了网络和浏览器方面知识的思维导图，哪里不会自己去查资料找答案即可</p><p>下一文「一道面试题」输入 URL 到渲染全面梳理中-页面渲染篇，待续哦。。</p><p>哦，还有，可以加个好友加下群一起交流噻，公众号【不正经的前端】也欢迎关注呦 😄</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20200508193235095.png" srcset="/blog/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>一道面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>网络</tag>
      
      <tag>浏览器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「一道面试题」小程序与H5的区别</title>
    <link href="/blog/2020/03/29/Interview/%E3%80%8C%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98%E3%80%8D%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%8EH5%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/blog/2020/03/29/Interview/%E3%80%8C%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98%E3%80%8D%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%8EH5%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="「一道面试题」小程序与-H5-的区别"><a href="#「一道面试题」小程序与-H5-的区别" class="headerlink" title="「一道面试题」小程序与 H5 的区别"></a>「一道面试题」小程序与 H5 的区别</h1><h2 id="抛砖"><a href="#抛砖" class="headerlink" title="抛砖"></a>抛砖</h2><p>此文是一道面试题，又不仅仅是一道面试题</p><p>面试题，在各个技术社区里都是一个永不落伍的话题，好像大多数人临面试前都会狂刷面试题，恨不得把所有面试题都看一遍，要说有用没，当然有用，因为大部分面试题确实可以助力面试者，而且刷面试题对技术积累和视野提升也是有真实帮助的，可不只是面试有用</p><p>其实大家面试前都刷面试题，可能几个人去面试前刷的面试题题解都是一样的，这种情况无疑增加了面试者筛选的难度，同样的，这也是为什么不仅仅是大公司，中小公司面试题也越来难，甚至严重不符合岗位水准的原因之一，大家每次面试回来都会感叹一句 <code>俺可能配不上这个职位，这道题太难了！</code></p><p>也不能全怪那些出面试题的人，因为市面上面试题越来越多，想要鉴别一个人的真本事还是有些难度的，所以面的时候只能往深了问，借此筛掉一些人</p><p>这种情况是我们不能避免的，除非从此网上再无面试题解，可能面试时问题难度系数就会相对降低了</p><p>SO，大家看的都差不多，回答也差不多，怎么突出 <code>我们不一样呢</code> ，还是要从面试题下手</p><h2 id="引玉"><a href="#引玉" class="headerlink" title="引玉"></a>引玉</h2><p>首先，大家面试喜欢找什么样的题解？肯定是各个博主统一收集整理的面试题库了，看着方便、种类多、不用网上反复找零碎的面试题</p><p>其实这样好也不好，好处是可以快速了解市面上常见面试题，坏处嘛，各个博主其实碍于篇幅，给出的题解都是最精简的(此处意思是，一道面试题，给出对应的经典题解，并无太多相关知识点，而面试过程中是需要发散思维的)</p><p>想要突出和别人的不一样也简单，不能只刷面试题，每一个面试题都有它独特的考察意义，每刷一个面试题，不管它的难易程度，都认真看一看这道面试题相关技术的帖或文档，这样在问到这个面试题的时候起码不会被面试官随意一发散思维就 Pass 掉，在回答的时候也能从多个角度回答，而不仅限于此道面试题</p><p>还有就是大家方向都在研究各种复杂的题，这种题能答出来，面试官可能会觉得不错，但简单的题就不一样了</p><p>千万不要小瞧那些简单的面试题，简单的题大家回答都简单，但是你要能回答的很复杂，高低立判</p><p>说不得太开，需要自己理解，嘿嘿</p><p>我平常也会刷一刷面试题，提升提升视野，看看大前端行业内的水又深了多少 ( 着实怕呛水 )</p><p>这两天看一些博主发的阿里面试帖里都会看到一个题，就是本文标题，其实它就可以算一个例子</p><p>你说它难？刚入行的前端都能说出来几条</p><p>那它不难？刚看到的时候我认真想了想，如果我去面试被问到这个题了，显然我心中的答案并不能突出我比别人强</p><p>所以好好想了下怎么回答后就写了此文</p><h2 id="回归正题"><a href="#回归正题" class="headerlink" title="回归正题"></a>回归正题</h2><p>小程序与 H5 有什么区别？</p><h3 id="解析题目"><a href="#解析题目" class="headerlink" title="解析题目"></a>解析题目</h3><p>小程序与 H5 的区别，首先我们要看这道题问的侧重点在哪 ( 通俗讲就是先想一下这个题要考的是什么 )？</p><p>如果想挖你对 H5 的理解，我觉得不需要这么问，而问两者区别小程序在前，两者相对来说小程序是比较新的，很明显侧重点在小程序这块，通过与 H5 的对比来挖你对小程序的了解，那么回答的时候就要侧重小程序这块发散，要让面试官觉得，嗯，这小伙子对小程序还是有些了解的</p><p>接下来就侧重小程序尝试从各个方面对比来解答这个问题</p><h3 id="运行环境方面"><a href="#运行环境方面" class="headerlink" title="运行环境方面"></a>运行环境方面</h3><p>从运行环境方面开看，<code>H5</code> 的宿主环境是浏览器，只要有浏览器，就可以使用，包括 APP 中的 <code>web-view</code> 组件，以及小程序提供的 <code>web-view</code> 组件</p><p>小程序就不一样了，它运行于特定的移动软件平台 (Wechat / 支付宝 / 字节跳动 / 百度 / QQ 等)</p><p>拿微信小程序来说，它是基于浏览器内核重构的内置解析器，它并不是一个完整的浏览器，官方文档中重点强调了脚本内无法使用浏览器中常用的 <code>window</code> 对象和 <code>document</code> 对象，就是没有 <code>DOM</code> 和 <code>BOM</code> 的相关的 <code>API</code>，这一条就干掉了 <code>JQ</code> 和一些依赖于 <code>BOM</code> 和 <code>DOM</code> 的 NPM 包</p><h3 id="运行机制方面"><a href="#运行机制方面" class="headerlink" title="运行机制方面"></a>运行机制方面</h3><p><code>H5</code> 的运行就是一个网页的运行，这里不过多叙述</p><p>小程序还是以微信小程序举例</p><p>启动</p><ul><li><p>如果用户已经打开过某小程序，在一定时间内再次打开该小程序，此时无需重新启动，只需将后台态的小程序切换到前台，整个过程就是所谓的 <code>热启动</code></p></li><li><p>如果用户首次打开或小程序被微信主动销毁后再次打开的情况，此时小程序需要重新加载启动，就是 <code>冷启动</code></p></li></ul><p>销毁</p><ul><li>当小程序进入后台一定时间，或系统资源占用过高，或者是你手动销毁，才算真正的销毁</li></ul><h3 id="系统权限方面"><a href="#系统权限方面" class="headerlink" title="系统权限方面"></a>系统权限方面</h3><p>H5 最被诟病的地方在哪？系统权限不够，比如网络通信状态、数据缓存能力、通讯录、或调用硬件的，如蓝牙功能等等一些 APP 有的功能，H5 就没有这些系统权限，因为它重度依赖浏览器能力</p><p>依旧是微信小程序举例，微信客户端的这些系统级权限都可以和微信小程序无缝衔接，官方宣称拥有 <code>Native App</code> 的流畅性能</p><h3 id="开发语言方面"><a href="#开发语言方面" class="headerlink" title="开发语言方面"></a>开发语言方面</h3><p><code>H5</code> 开发大家都知道，标准的 <code>HTML、CSS、JavaScript</code> ，万变不离其三剑客</p><p>小程序不同， (Wechat / 支付宝 / 字节跳动 / 百度 / QQ 等)不同的小程序都有自己定义独特的语言</p><p>最常用的微信小程序，自定义的 <code>WXML</code>、<code>WXSS</code>，<code>WXML</code> 中全部是微信自定义的标签，<code>WXSS</code>、<code>JSON</code> 和 <code>JS</code> 文件中的写法都稍有限制，官方文档中都有明确的使用介绍，虽容易上手，但还是有区别的</p><blockquote><p>不同系小程序的开发语言都有些区别，说到这，来个题外话</p><p>随着微信小程序越来越火百度阿里字节这些大厂都出了对应的小程序，但是问题来了，小程序技术标准越来越碎片化，去年 9 月，万维网联盟 ( <code>World Wide Web Consortium</code>，简称 W3C ) 针对这一行业问题，正式对外发布由阿里巴巴主导发起并联合 W3C 中国及国内外厂商起草的《小程序国际标准化白皮书》( <a href="https://w3c.github.io/mini-app-white-paper/#graphics-and-media" target="_blank" rel="noopener">链接</a> )</p><p>其实就是阿里准备牵头搞小程序标准了，阿里百度字节这些企业都有参与，但是一说小程序都是微信小程序，微信才是大头啊，腾讯好像并没有理它们，哈哈 (题外话，适当皮一下，如觉不妥请联系我删掉 😂)</p></blockquote><p>从开发语言的不同，就引出了开发成本这个问题了</p><h3 id="开发成本方面"><a href="#开发成本方面" class="headerlink" title="开发成本方面"></a>开发成本方面</h3><p>还是先说 <code>H5</code>，开发一个 <code>H5</code> ，我们要考虑什么，首先开发工具 ( <code>vscode/webstorm/atom/sublim</code>等 )，其次是开发框架 ( <code>Vue/React/Angular</code>等 )， 接着考虑模块化工具 ( <code>Webpack/Gulp/Parcel</code>等 )，再然后 UI 库、各种包的选择，更是数不胜数，还要考虑兼容问题，成本还是比较高的</p><p>这块小程序的话不用再去考虑浏览器兼容性，拿微信小程序举例子，没有兼容性问题后，只需要看着文档在微信开发工具里写就行了，小程序独还立出来了很多原生 APP 的组件，在 H5 需要模拟才能实现的功能，小程序里可以直接调用组件，都是封装好的，你也可以使用转译框架来写小程序，也有很多 UI 库选择，单论开发成本的话，小程序应该是胜出的</p><p>不过小程序再简单也是需要学习过程的，坑肯定也多，因为它还在逐步变强的过程中嘛，毕竟是和 H5 不一样的东西</p><h3 id="更新机制方面"><a href="#更新机制方面" class="headerlink" title="更新机制方面"></a>更新机制方面</h3><p><code>H5</code> 的话想怎么更新就怎么更新，更新后抛开 CDN/浏览器缓存啥的，基本上更新结束刷新就可以看到效果</p><p>小程序不同，还是微信举例，嘿嘿，微信小程序更新啥的是需要通过审核的</p><p>而且开发者在发布新版本之后，无法立刻影响到所有现网用户，要在发布之后 24 小时之内才下发新版本信息到用户</p><p>小程序每次 <code>冷启动</code> 时，都会检查有无更新版本，如果发现有新版本，会异步下载新版本代码包，并同时用客户端本地包进行启动，所以新版本的小程序需要等下一次 <code>冷启动</code> 才会应用上，当然微信也有 <code>wx.getUpdateManager</code> 可以做检查更新</p><h3 id="渲染机制方面"><a href="#渲染机制方面" class="headerlink" title="渲染机制方面"></a>渲染机制方面</h3><p>H5 就是 <code>web</code> 渲染，浏览器渲染</p><p>微信小程序的宿主环境是微信，宿主环境为了执行小程序的各种文件：<code>wxml</code>文件、<code>wxss</code>文件、<code>js</code>文件，提供了<code>双线模型</code> ，什么是双线程模型呢，先看一张官方图</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20200327233031052.png" srcset="/blog/img/loading.gif" alt="image-20200327233031052"></p><p>小程序的渲染层和逻辑层分别由 2 个线程管理</p><ul><li>渲染层：界面渲染相关的任务全都在 <code>WebView</code> 线程里执行，一个小程序存在多个界面，所以渲染层存在多个 <code>WebView</code>线程</li><li>逻辑层：一个单独的线程执行 JavaScript，在这个环境下执行的都是有关小程序业务逻辑的代码，就是通过图中的 <code>JsCore</code> 线程来运行 <code>JS</code> 脚本</li><li>这两个线程都会经过微信客户端( <code>Native</code> )中的 <code>WeixinJsBridage</code> 进行中转通信，逻辑层把数据变化通知到视图层，触发视图层页面更新，视图层把触发的事件通知到逻辑层进行业务处理</li></ul><p>小程序的渲染逻辑</p><ul><li>在渲染层将 <code>WXML</code> 先转换为 <code>js</code> 对象也就是虚拟 <code>DOM</code></li><li>在逻辑层将虚拟 <code>DOM</code> 对象生成真实 <code>DOM</code> 树，交给渲染层渲染</li><li>当视图有数据需更新时，逻辑层调用小程序宿主环境提供的 <code>setData</code> 方法将数据从逻辑层传递到渲染层</li><li>经过对比前后差异 ( diff 算法 )，把差异应用在真实的 <code>Dom</code> 树上，渲染出正确的 UI 界面完成视图更新</li></ul><p>虽然小程序是通过 <code>Native</code> 原生渲染的，但是小程序也支持 web 渲染，就是 <code>web-view</code> 组件，在 <code>web-view</code> 中加载 <code>H5</code> 页面，而我们开发小程序时，通常会使用 <code>hybrid</code> 的方式，根据具体情况选择部分功能用小程序原生的代码来开发，部分功能通过 <code>web-view</code> 加载 <code>H5</code> 页面来实现，<code>Native</code> 与 <code>Web 渲染</code> 混合使用，实现项目最优解</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>嗯，就到这了，内容不多，当作回答我觉得讲个 5 ～ 10 分钟就够了，上面就是个大概，先把上面讲一下，然后你得给面试官问的机会，而他问的东西肯定是你讲的这些内容中发散出来的</p><p>所以你还需要按照上文讲述的大致内容看些相关文档，起码是要对上面自己发散出来的东西有一些了解的，能够突出亮点的其实都在渲染机制那里，也是这个问题的重点 ( 这里最能吹 ) ，而面试官发散的点也极大可能是双线程/渲染这里</p><p>最后，此文写的比较快，内容为个人理解，可能会有些片面，如有不当或补充，还请指出，互相讨论，多谢</p><p>对你有用的话，点个赞吧</p><p>哦，还有，可以加个好友加下群一起交流噻，公众号【不正经的前端】也欢迎关注呦 😄</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/new1.png" srcset="/blog/img/loading.gif" alt="new1"></p>]]></content>
    
    
    <categories>
      
      <category>一道面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>小程序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Wechaty|NodeJS基于iPad协议手撸一个简单的微信机器人助手</title>
    <link href="/blog/2020/03/01/other/Wechaty%7CNodeJS%E5%9F%BA%E4%BA%8EiPad%E5%8D%8F%E8%AE%AE%E6%89%8B%E6%92%B8%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%BE%AE%E4%BF%A1%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%8A%A9%E6%89%8B/"/>
    <url>/blog/2020/03/01/other/Wechaty%7CNodeJS%E5%9F%BA%E4%BA%8EiPad%E5%8D%8F%E8%AE%AE%E6%89%8B%E6%92%B8%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%BE%AE%E4%BF%A1%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%8A%A9%E6%89%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Wechaty-NodeJS-基于-iPad-协议手撸一个简单的微信机器人助手"><a href="#Wechaty-NodeJS-基于-iPad-协议手撸一个简单的微信机器人助手" class="headerlink" title="Wechaty|NodeJS 基于 iPad 协议手撸一个简单的微信机器人助手"></a>Wechaty|NodeJS 基于 iPad 协议手撸一个简单的微信机器人助手</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>我是一名前端，平时也喜欢写技术博客和交朋友，为此我也创建了微信技术交流群和微信公众号，一般我都会在文章下面贴出公众号和我的个人二维码，给有兴趣的小伙伴们添加微信然后我再拉他们进群这些，但是不停的同意微信好友验证，再发送群邀请真的是太痛苦了，相信很多做公众号的小伙伴都和我一样，作为一名开发，这种重复劳动是绝对不能忍受的</p><p>我知道也见过有些博主的微信小号是机器人，很方便，如果我也能有一个机器人小号，只是自动通过好友验证，然后关键字回复直接发送群邀请就已经非常实用了，嗯～，想想还有些兴奋</p><p>SO，大概在 19 年 10 月吧，就陆陆续续开始了我的微信机器人之旅</p><p><del>首先，我找了几个微信机器人平台，奈何价格实在不美丽</del></p><p>笑话，咱可是一名正八经的开发，这种非技术手段我会用？( 其实是没得钱噻！😅 )</p><p>说干就干，不过要从 0 到 1 的开发不太现实，所以就开始 Github 上寻找开源作品</p><p>对比了几个比较知名的几个开源微信机器人项目</p><ul><li>itchat<ul><li><code>itchat</code>是一个开源的微信个人号接口，基于 python 调用微信</li><li>使用不到三十行的代码，你就可以完成一个能够处理所有信息的微信机器人</li></ul></li><li>wechaty<ul><li><code>Wechaty</code>是适用于微信个人的 Bot SDK ，可以使用 6 行 js 创建一个机器人</li><li>具有包括<code>linux</code>，<code>Windows</code>，<code>MacOS</code>和 <code>Docker</code> 在内的跨平台支持，基于 Node.js</li></ul></li><li>Vbot<ul><li>是基于微信 web 版的接口，使用<code>http</code>协议以及轮询方式实现</li><li><code>Vbot</code>的亮点在于通过匿名函数，能够实现多种有趣的玩法</li><li>通过 API，更方便的打造属于自己的网页版微信，基于 PHP</li></ul></li></ul><p>上面这些都是项目官方的简述，直接 <code>copy</code> 来的，刚看到这三款作品时，想都没想，果断选择<code>wechaty</code></p><p>为什么？单论第一印象</p><ul><li>对于一名前端来说，Node.js 的亲和力自然不用多说</li><li><code>itchat</code>官方说不到三十行代码实现，<code>Vbot</code>就没说多少行，<code>Wechaty</code>抛开 JS ，官方说只用 6 行</li></ul><p>没错，就是因此，我开始了 <code>wechaty</code> 的第一次亲密接触</p><h2 id="第一次接触-wechaty"><a href="#第一次接触-wechaty" class="headerlink" title="第一次接触 wechaty"></a>第一次接触 wechaty</h2><p>Wechaty 是基于<code>NodeJS+TS</code>实现</p><p>当然开发时我们不一定非要使用 TS，js 也可以的，这也是我个人很喜欢<code>Wechaty</code>团队的一点，因为官方给的示例都是基于 js 的而不是 ts，不习惯 ts 的小伙伴有福了</p><p>开发前，肯定是要先查看 wechaty 文档的，一看还别说，感觉还真挺容易上手的</p><ul><li><a href="https://github.com/wechaty/wechaty" target="_blank" rel="noopener">wechaty-Github</a></li></ul><p>简单的看了一下文档后，我开始下载官方给的示例项目 <a href="https://github.com/wechaty/wechaty-getting-started" target="_blank" rel="noopener">wechaty/wechaty-getting-started</a></p><p>下载完之后就是安装依赖运行</p><p>首次运行很慢的，还有可能不成功，因为中间要安装运行<code>Puppeteer</code>，有人可能要试好多次</p><p>然而这些我都没遇到，运行很成功，一切都很顺利，完全没有意外发生，哈哈哈</p><p>运行成功后如下图，就可以扫码登录了</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other//image-20200226180859522.png" srcset="/blog/img/loading.gif" alt="image-20200226180859522"></p><p>然后，意外就发生了 😬</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other//image-20200226181313773.png" srcset="/blog/img/loading.gif" alt="image-20200226181313773"></p><p>登录不成功，真是尴尬</p><pre><code class="js">&quot;为了你的帐号安全，此微信号不能登录网页微信。你可以使用Windows微信或Mac微信在电脑端登录。Windows微信下载地址：https://pc.weixin.qq.com  Mac微信下载地址：https://mac.weixin.qq.com&quot;</code></pre><h2 id="网页版微信登录不成功"><a href="#网页版微信登录不成功" class="headerlink" title="网页版微信登录不成功"></a>网页版微信登录不成功</h2><p>当初其实卡在这里很久，我重复试了好多次都不行</p><p>原因是因为目前我们使用的是基于 web 端的微信 API 接口，可能是 web 端接口什么的都不太安全吧</p><p>微信官方在慢慢收缩 web 端微信的使用，官方对网页版微信进行了动态安全策略调整</p><p>如登录网页版微信收到安全提示，则不支持登录网页版微信</p><p>2017 年之后注册的微信号都无法登录网页版微信，而 2017 年之前注册得微信账号也有很大几率登录不上</p><p>我赶紧试了试我的所有微信号，都是很早就注册的那种，可是依旧是登录不上，跑起来了登不上，这岂不是凉了</p><p>到了最后终于使用我一个朋友的微信号登上了，但是那是朋友的大号，人家要用的</p><p>后来我就到处找这个东西的解决办法，连带上花钱收可以登录网页版微信的号，拖了好些天依旧无果</p><p>检验你的微信号只不支持 web 端微信，尝试登录一下网页版微信就好了</p><ul><li><a href="https://wx.qq.com/" target="_blank" rel="noopener">https://wx.qq.com/</a></li></ul><p>就这个链接，PC 端进入然后手机扫码登录，可以登上就是可用 web 微信</p><p>早期其实 <code>Vbot</code> 和 <code>itchat</code> 这两个项目都挺火的，但是它们都是基于网页版微信实现的</p><p>特别是<code>itchat</code> 项目的<code>Github issuse</code>中第一个就写着</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other//image-20200226191429357.png" srcset="/blog/img/loading.gif" alt="image-20200226191429357"></p><p>登录不上去的在这里劝大家一句，不要在这个问题上纠结太久</p><p>有渠道的小伙伴可以尝试收一个可以登录网页版微信的号，不过亲测很难</p><p>没有号的小伙伴就不要纠结了，没什么用又浪费时间，亲身经历(某人曾明知道官方限制，还依旧偏执的找解决方案找了好多天 😭)</p><p>看到这里你可能会说：看了这么多了你跟我说不行？</p><p>不要着急，如果你使用<code>Vbot</code>和<code>itchat</code>，没有可登录的微信号确实是往下进行不了</p><p>但是我们现在使用的是<code>wechaty</code>，接下来就可以体现<code>wechaty</code>的过人之处了</p><p>当然如果你可以登录，那就可以看着官方文档或示例开发了，很省事</p><p>你也可以继续看看下文我写的一个小 demo，虽然协议不同，不过 API 和思路都是一致的</p><p>如果你登录不上，那就更要看下解决办法了</p><h2 id="wechaty-puppet-padplus"><a href="#wechaty-puppet-padplus" class="headerlink" title="wechaty-puppet-padplus"></a>wechaty-puppet-padplus</h2><p>网页版微信登录不上？收可登录微信号又收不到？</p><p>不要着急</p><p><code>wechaty-puppet-padplus</code>同是<code>wechaty</code>团队开发，不同于上文基于微信 web 端，它是基于 iPad 协议</p><ul><li><a href="https://github.com/wechaty/wechaty-puppet-padplus" target="_blank" rel="noopener">wechaty-puppet-padplus</a></li></ul><p>使用这个包是需要 <code>Token</code> 令牌的，官方说</p><blockquote><p>Our Mission: Make it easy to build a WeChat Chatbot for developers.</p><p>We provide a <strong>free</strong> access using <a href="https://github.com/wechaty/wechaty-puppet-padplus" target="_blank" rel="noopener">iPad protocol</a> for the developers who have a strong will and ability to build a valuable chatbot for users.</p><p>Any developers can add JuziBOT Inc’s staff ( <strong>Wechat number : botorange_yeah</strong> ) as a Wechat friend. You will receive a review form after adding. If you pass the review and willing to write a blog in Wechaty , you can use our iPad protocol for free！</p><p>我们的使命：轻松为开发人员构建微信聊天机器人</p><p>我们为有强烈意愿和能力为用户构建有价值的聊天机器人的开发人员提供了使用<a href="https://github.com/wechaty/wechaty-puppet-padplus" target="_blank" rel="noopener">iPad 协议</a>的<strong>免费</strong>访问权限</p><p>任何开发人员都可以将 JuziBOT Inc 的工作人员（<strong>微信编号：botorange_yeah</strong>）添加为微信好友。添加后，您将收到一份审查表。如果您通过审查并愿意在 Wechaty 中写博客，则可以免费使用我们的 iPad 协议！</p></blockquote><p>大概意思就是我们提交审查表后，会获得为期 15 天的免费 Token</p><p>想要获取长期有效的免费 token，那就参加所谓的开源激励计划，就是在 15 天后，需要提交一个 MVP(最小可行化产品)的 Github 仓库，Wechaty 会将其 fork 到社区中的同时，会提供一个长期免费 Token</p><p>反之，就需要继续协商讨论后续的合作形式，我觉得是很良心了</p><p>没错，这篇帖子就是我申请的 15 天免费 token 下的一个输出</p><p>当然，我是有时间就会写一些，毕竟时间不多，所以开发出来的东西功能也不多，后期慢慢改进吧</p><p>讲了这么多，接下来才是正经的分享，比较简单，算是入门级，供大家参考吧</p><h2 id="基于-ipad-协议的微信机器人"><a href="#基于-ipad-协议的微信机器人" class="headerlink" title="基于 ipad 协议的微信机器人"></a>基于 ipad 协议的微信机器人</h2><h3 id="明确需求"><a href="#明确需求" class="headerlink" title="明确需求"></a>明确需求</h3><p>开发之前，我们要先明确下需求，就是我需要机器人来做什么</p><ul><li>自动通过好友验证<ul><li>当有人添加机器人时，判断验证消息关键字后通过或直接通过</li><li>通过验证后自动回复并介绍机器人功能</li></ul></li><li>私聊关键字回复<ul><li>例如回复 <code>加群</code> 推送群聊邀请</li><li>例如回复 <code>作者微信</code> 推送作者微信名片</li></ul></li><li>自动聊天<ul><li>群聊中通过 <code>@[机器人]xxx</code> 可以和机器人聊天</li><li>私聊发送消息即可聊天</li></ul></li><li>加入群聊自动欢迎<ul><li>当新的小伙伴加入群聊后自动 <code>@[新的小伙伴]</code> 发一个文字欢迎</li></ul></li></ul><p>OK，先实现这几个简单的功能吧，还是比较有用的，后期再说后期的事嘛</p><h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><p>功能比较简单，分多个就是为了不让所有代码都在一个文件，简单分开下</p><pre><code class="js">|-- src/|---- index.js                # 入口文件|---- config.js              # 配置文件|---- onScan.js                # 机器人需要扫描二维码时监听回调|---- onRoomJoin.js     # 进入房间监听回调|---- onMessage.js        # 消息监听回调|---- onFriendShip.js    # 好友添加监听回调|-- package.json</code></pre><h3 id="初期准备"><a href="#初期准备" class="headerlink" title="初期准备"></a>初期准备</h3><p>首先新建文件夹，初始化</p><pre><code class="js">npm init -y</code></pre><p>接着我们安装比较重要的核心包</p><pre><code class="js">// Wechaty核心包npm install --save wechaty// padplus协议包npm install --save wechaty-puppet-padplus</code></pre><p>我们在开发过程中，还需要用到<code>qrcode-terminal</code>这个包，作用就是将二维码输出在终端来供我们扫码登录</p><pre><code class="js">npm install --save qrcode-terminal</code></pre><p>然后就可以愉快的开发了，没错就是这么简单</p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>所谓的配置文件，就是那个 <code>config.js</code> ，只是把我们需要用到的一些可配置参数拿出来</p><pre><code class="js">module.exports = {  // puppet_padplus Token  token: &quot;你自己申请的ipad协议token&quot;,  // 你的机器人名字  name: &quot;圈子&quot;,  // 房间/群聊  room: {    // 管理群组列表    roomList: {      // 群名字(用于发送群名字加群):群id，后面会介绍到      Web圈: &quot;*****@chatroom&quot;,      男神群: &quot;*****@chatroom&quot;,    },    // 加入房间回复    roomJoinReply: `你好，欢迎加入`,  },  // 私人  personal: {    // 好友验证自动通过关键字    addFriendKeywords: [&quot;加群&quot;, &quot;前端&quot;],    // 是否开启加群    addRoom: true,  },}</code></pre><h3 id="入口文件"><a href="#入口文件" class="headerlink" title="入口文件"></a>入口文件</h3><p>入口文件，也就是我们 <code>src</code> 目录下的 <code>index.js</code> 文件</p><p>这里做的很简单，没有逻辑</p><p>首先引入我们包</p><pre><code class="js">const { Wechaty } = require(&quot;wechaty&quot;) // Wechaty核心包const { PuppetPadplus } = require(&quot;wechaty-puppet-padplus&quot;) // padplus协议包const config = require(&quot;./config&quot;) // 配置文件</code></pre><p>接着初始化我们的 bot</p><pre><code class="js">// 初始化const bot = new Wechaty({  puppet: new PuppetPadplus({    token: config.token,  }),  name: config.name,})</code></pre><p>接下来一段链式调用，监听，启动，完事</p><pre><code class="js">const onScan = require(&quot;./onScan&quot;)const onRoomJoin = require(&quot;./onRoomJoin&quot;)const onMessage = require(&quot;./onMessage&quot;)const onFriendShip = require(&quot;./onFriendShip&quot;)bot  .on(&quot;scan&quot;, onScan) // 机器人需要扫描二维码时监听  .on(&quot;room-join&quot;, onRoomJoin) // 加入房间监听  .on(&quot;message&quot;, onMessage(bot)) // 消息监听  .on(&quot;friendship&quot;, onFriendShip) // 好友添加监听  .start()</code></pre><p>上面代码都有注释，<code>scan, room-join, message, friendship</code> 这些都是我们各个阶段的事件监听</p><ul><li>scan 机器人需要扫描二维码时监听</li><li>room-join 加入房间监听</li><li>message 消息监听</li><li>friendship 好友添加监听</li></ul><p>这些事件监听我只做简单解释，因为没啥说的，api 文档都有</p><p>不由的想起尤大的那个表情包：请仔细阅读我们的文档！！！</p><p>这些个监听后面的回调，我这里只不过把他们单独拿出去了，也就是上文目录结构中的那几个文件</p><p>这里的<code>onMessage</code>是做了一个方法调用，其实还是返回一个回调函数，只不过我们在消息监听中用到了<code>bot</code>实例，所以用这种方式传值而已</p><p>接下来我们按顺序来解释下这几个文件做了什么</p><h3 id="onScan"><a href="#onScan" class="headerlink" title="onScan"></a>onScan</h3><p><code>onScan</code> 文件是我们在机器人需要扫描二维码时的监听回调</p><p>这里面的代码超级简单</p><pre><code class="js">const Qrterminal = require(&quot;qrcode-terminal&quot;)module.exports = function onScan(qrcode, status) {  Qrterminal.generate(qrcode, { small: true })}</code></pre><p>首先引入 <code>qrcode-terminal</code> 包</p><p>这个回调中其实做的很简单，回调接收了两个参数</p><ul><li>qrcode qr 码</li><li>status 状态</li></ul><p>我们借助<code>Qrterminal.generate</code>这个 API 将 qr 码输出到终端而已，后面那个<code>small</code>参数是因为<code>qrcode-terminal</code> 这个包默认输出的二维码太大了，给它变小一些</p><h3 id="onFriendShip"><a href="#onFriendShip" class="headerlink" title="onFriendShip"></a>onFriendShip</h3><p>onFriendShip 是 friendship 事件监听的回调，好友添加监听</p><pre><code class="js">const { Friendship } = require(&quot;wechaty&quot;)// 配置文件const config = require(&quot;./config&quot;)// 好友添加验证消息自动同意关键字数组const addFriendKeywords = config.personal.addFriendKeywords// 好友添加监听回调module.exports = async function onFriendShip(friendship) {  let logMsg  try {    logMsg = &quot;添加好友&quot; + friendship.contact().name()    console.log(logMsg)    switch (friendship.type()) {      /**       * 1. 新的好友请求       * 设置请求后，我们可以从request.hello中获得验证消息,       * 并通过`request.accept（）`接受此请求       */      case Friendship.Type.Receive:        // 判断配置信息中是否存在该验证消息        if (addFriendKeywords.some((v) =&gt; v == friendship.hello())) {          logMsg = `自动通过验证，因为验证消息是&quot;${friendship.hello()}&quot;`          // 通过验证          await friendship.accept()        } else {          logMsg = &quot;不自动通过，因为验证消息是: &quot; + friendship.hello()        }        break      /**       * 2. 友谊确认       */      case Friendship.Type.Confirm:        logMsg = &quot;friend ship confirmed with &quot; + friendship.contact().name()        break    }    console.log(logMsg)  } catch (e) {    logMsg = e.message  }}</code></pre><p>如上所示，我们想加好友时，验证消息填写我们指定的文字可以自动通过</p><p>So，我们从配置文件中拿到这个参数，在新的好友请求过来时做一个判断即可</p><h3 id="onRoomJoin"><a href="#onRoomJoin" class="headerlink" title="onRoomJoin"></a>onRoomJoin</h3><p>onRoomJoin，也就是进入房间监听回调</p><pre><code class="js">// 配置文件const config = require(&quot;./config&quot;)// 加入房间回复const roomJoinReply = config.room.roomJoinReply// 管理群组列表const roomList = config.room.roomList// 进入房间监听回调 room-群聊 inviteeList-受邀者名单 inviter-邀请者module.exports = async function onRoomJoin(room, inviteeList, inviter) {  // 判断配置项群组id数组中是否存在该群聊id  if (Object.values(roomList).some((v) =&gt; v == room.id)) {    // let roomTopic = await room.topic()    inviteeList.map((c) =&gt; {      // 发送消息并@      room.say(roomJoinReply, c)    })  }}</code></pre><p>需求是在我们需要管理的群聊中，只要有新人加入，我们就发一个欢迎词并@他下</p><p>当然这些东西还是在 config 中配置好的，在这里拿到就可以</p><p>此回调接收三个参数</p><ul><li>room 群聊实例</li><li>inviteeList 受邀者名单</li><li>inviter 邀请者</li></ul><p>有了房间，受邀者，邀请者，那么这里也就非常 easy 了</p><p>做一下判断就可以了，这里的<code>room.id</code>就是我们配置的管理群组列表对象的 value 值</p><p>为什么要有管理群组列表对象呢？因为我们在登录了一个微信号时，群组进入监听是针对微信号中所有群组的</p><p>我的需求是要管理我的群组，所以事先跑了下程序，输出了<code>room</code>，然后群里发个消息，就拿到了我想管理的群组所有信息，id 自然也在里面，然后写到了配置里</p><p>接下来就是，监听到新加入，把受邀者列表遍历一下，使用<code>room.say</code>方法发送群消息即可，受邀者列表里存的就是加入的微信号实例，<code>say</code> 方法第一个参数就是要发送的消息，第二个参数就是为了@此人一下。。。感觉我的叙述毫无营养，还是那句话，这里只是说它是什么意思，具体 API 阅读文档吧，文档都有，也很简单</p><h3 id="message"><a href="#message" class="headerlink" title="message"></a>message</h3><p>最后就是 message 回调了，这个是代码最多的一个地方了，消息监听回调嘛</p><p>这也是代码中稍微有些逻辑的地方，因为要有各种判断</p><p>先不说程序逻辑，机器人嘛，总得能聊天不是，所以网上找了个免费的机器人聊天接口对接了一下</p><p>该接口详细请看</p><ul><li><a href="https://drea.cc/mm.php" target="_blank" rel="noopener">https://drea.cc/mm.php</a></li></ul><p>其实就是一个 API，我们做一下封装，调用传入消息，返回消息，仅此而已</p><p>因为有请求，所以这块用了一个请求包，一个参数解码包，所以还要安装并引入下</p><pre><code class="js">npm install --save requestnpm install --save urlencode</code></pre><p>把接口封装下，因为是免费机器人，所以肯定不是太好，不过个人用足够了，如下</p><pre><code class="js">// node-request请求模块包const request = require(&quot;request&quot;)// 请求参数解码const urlencode = require(&quot;urlencode&quot;)/** * @description 机器人请求接口 处理函数 * @param {String} info 发送文字 * @return {Promise} 相应内容 */function requestRobot(info) {  return new Promise((resolve, reject) =&gt; {    let url = `https://open.drea.cc/bbsapi/chat/get?keyWord=${urlencode(info)}`    request(url, (error, response, body) =&gt; {      if (!error &amp;&amp; response.statusCode == 200) {        let res = JSON.parse(body)        if (res.isSuccess) {          let send = res.data.reply          // 免费的接口，所以需要把机器人名字替换成为自己设置的机器人名字          send = send.replace(/Smile/g, name)          resolve(send)        } else {          if (res.code == 1010) {            resolve(&quot;没事别老艾特我，我还以为爱情来了&quot;)          } else {            resolve(&quot;你在说什么，我听不懂&quot;)          }        }      } else {        resolve(&quot;你在说什么，我脑子有点短路诶！&quot;)      }    })  })}</code></pre><p>接着就可以写消息监听回调的逻辑了，这里就不文字叙述了，太费劲了，注释都是按行写的，哈哈</p><pre><code class="js">const { Message } = require(&quot;wechaty&quot;)// 配置文件const config = require(&quot;./config&quot;)// 机器人名字const name = config.name// 管理群组列表const roomList = config.room.roomList// 消息监听回调module.exports = (bot) =&gt; {  return async function onMessage(msg) {    // 判断消息来自自己，直接return    if (msg.self()) return    // 判断此消息类型是否为文本    if (msg.type() == Message.Type.Text) {      // 判断消息类型来自群聊      if (msg.room()) {        // 获取群聊        const room = await msg.room()        // 收到消息，提到自己        if (await msg.mentionSelf()) {          // 获取提到自己的名字          let self = await msg.to()          self = &quot;@&quot; + self.name()          // 获取消息内容，拿到整个消息文本，去掉 @+名字          let sendText = msg.text().replace(self, &quot;&quot;)          // 请求机器人接口回复          let res = await requestRobot(sendText)          // 返回消息，并@来自人          room.say(res, msg.from())          return        }        // 收到消息，没有提到自己  忽略      } else {        // 回复信息是关键字 “加群”        if (await isAddRoom(msg)) return        // 回复信息是所管理的群聊名        if (await isRoomName(bot, msg)) return        // 请求机器人聊天接口        let res = await requestRobot(msg.text())        // 返回聊天接口内容        await msg.say(res)      }    } else {      console.log(&quot;消息不是文本！&quot;)    }  }}/** * @description 回复信息是关键字 “加群” 处理函数 * @param {Object} msg 消息对象 * @return {Promise} true-是 false-不是 */async function isAddRoom(msg) {  // 关键字 加群 处理  if (msg.text() == &quot;加群&quot;) {    let roomListName = Object.keys(roomList)    let info = `${name}当前管理群聊有${roomListName.length}个，回复群聊名即可加入哦\n\n`    roomListName.map((v) =&gt; {      info += &quot;【&quot; + v + &quot;】&quot; + &quot;\n&quot;    })    msg.say(info)    return true  }  return false}/** * @description 回复信息是所管理的群聊名 处理函数 * @param {Object} bot 实例对象 * @param {Object} msg 消息对象 * @return {Promise} true-是群聊 false-不是群聊 */async function isRoomName(bot, msg) {  // 回复信息为管理的群聊名  if (Object.keys(roomList).some((v) =&gt; v == msg.text())) {    // 通过群聊id获取到该群聊实例    const room = await bot.Room.find({ id: roomList[msg.text()] })    // 判断是否在房间中 在-提示并结束    if (await room.has(msg.from())) {      await msg.say(&quot;您已经在房间中了&quot;)      return true    }    // 发送群邀请    await room.add(msg.from())    await msg.say(&quot;已发送群邀请&quot;)    return true  }  return false}</code></pre><p>然后就可以本地启动试试了</p><p>就到这了，也希望对你能有些帮助，给点鼓励可以点个赞噻</p><p>看着文件和代码都不少，其实就只是一些逻辑判断而已</p><p>看一眼 API 文档，怎么发挥就看你自己了，消息监听这里的判断也只做了文本消息的判断而已</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>你如果想用我这些东西，拉下代码<code>config.js</code>里换下 token 和一些配置信息就可以，当然我在不停更新，功能会越来越多，所以仓库中代码和文中会有些不一样，使用时简单看下代码，都写了详细注释，也很简单</p><ul><li><a href="https://github.com/isboyjc/wechaty-Robot" target="_blank" rel="noopener">https://github.com/isboyjc/wechaty-Robot</a></li></ul><p>目前实现的都是一些基础的小功能，登出和容错等一些处理也没有，因为这几天太忙了，后期慢慢加吧，这里就是为了给有想做但还不知道的小伙伴简单介绍下 wechaty，简单好用，快去试试吧，我这边介绍的只是冰山一角，喜欢 Python 的同学，wechat 团队也维护了一个 Python 版本，也可以尝试的 😄</p><p>还可以实现更多好玩的功能(我想到的功能只是针对我个人需求，只是为了和公众号、我的群聊等实现下无缝对接，你当然也可以做其他的嘛，例如做一个定时任务给女友定时发信息啥的)，我现在能想到的后期要加的功能如下</p><ul><li>推送<ul><li>例如每日早 8 点，拉取当日 <code>IT界新闻/掘金热门文章</code>发送至群聊</li><li>群聊中可通过 <code>@[机器人]关键字</code> 查看新闻及文章等</li><li>可设置定时任务，定时给自己/群聊发送消息</li></ul></li><li>群聊功能消息管理<ul><li>监听群聊中消息，有不正当言论时或不文明用语对其警告</li><li>记录同一人警告次数，每月清空记录，当月达到一定警告次数后自动将其移出群聊</li></ul></li><li>群聊投票功能<ul><li>可通过机器人发起对某件事的群投票</li></ul></li><li>群聊游戏<ul><li>猜字迷</li><li>等等</li></ul></li><li>后台管理系统(可视化配置及群聊数据统计)<ul><li>可视化配置机器人的已实现功能，包括登录等所有功能在 web 端可视化操作处理</li><li>统计群聊中的成员活跃度/人员加入情况/警告等系列数据</li></ul></li></ul><p>来吧，生命在于折腾，好玩的东西总要试一试，毕竟费不了多少时间，你也可以加下我的小助手【圈子】微信体验下呦，验证消息写【前端】可以直接通过，和他聊聊天，或者回复【加群】加技术交流群我们一块玩耍都可以的</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other//WechatIMG127.jpeg" srcset="/blog/img/loading.gif" alt="WechatIMG127"></p><p>如果你加小助手微信遇到了问题，也可以通过以下方式联系我或加群</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other//image-20200407143156331.png" srcset="/blog/img/loading.gif" alt="image-20200407143156331"></p>]]></content>
    
    
    <categories>
      
      <category>Web相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Wechaty</tag>
      
      <tag>NodeJS</tag>
      
      <tag>微信机器人</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「硬核JS」深入了解异步解决方案</title>
    <link href="/blog/2020/02/14/javascript/%E3%80%8C%E7%A1%AC%E6%A0%B8JS%E3%80%8D%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E5%BC%82%E6%AD%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <url>/blog/2020/02/14/javascript/%E3%80%8C%E7%A1%AC%E6%A0%B8JS%E3%80%8D%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E5%BC%82%E6%AD%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="「硬核-JS」深入了解异步解决方案"><a href="#「硬核-JS」深入了解异步解决方案" class="headerlink" title="「硬核 JS」深入了解异步解决方案"></a>「硬核 JS」深入了解异步解决方案</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Javascript 语言的执行环境是<code>单线程</code>(single thread，指一次只能完成一件任务，如果有多个任务，就必须排队，前面一个任务完成，再执行后面一个任务，以此类推)</p><p>这种模式的好处是实现起来比较简单，执行环境相对单纯，坏处是只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行，常见的浏览器无响应(假死)，往往就是因为某一段 Javascript 代码长时间运行(比如死循环)，导致整个页面卡在这个地方，其他任务无法执行</p><p>为了解决这个问题，Javascript 将任务的执行模式分成两种：同步(Synchronous)和异步(Asynchronous)</p><p><code>同步模式</code> 就是后一个任务等待前一个任务结束，然后再执行，程序的执行顺序与任务的排列顺序是一致的、同步的</p><p><code>异步模式</code>则完全不同，每一个任务有一个或多个回调函数(callback)，前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的，在浏览器端，耗时很长的操作都应该异步执行，避免浏览器失去响应，最好的例子就是 Ajax 操作。在服务器端，<code>异步模式</code>甚至是唯一的模式，因为执行环境是单线程的，如果允许同步执行所有 http 请求，服务器性能会急剧下降</p><p>前面都是些无用的话，因为大家都对此很清楚，那么，问题来了，你了解几种异步解决方案？</p><p>本文会由浅入深的叙述下面几种已知的异步解决方案，以及它们的区别</p><ul><li>回调函数(callback)</li><li>事件监听(发布/订阅)解析</li><li>Promise 解析及从 0 ～ 1 的源码体验</li><li>Generator 全面解析</li><li>Async/Await 解析</li></ul><p>赶上春节不出门为国家做贡献，写了这篇帖子，本文有点长，因为本来要写四篇文章分别叙述，但是我觉得还是在一块看比较容易对比理解，大概有两万字左右，如果你肯花 20 分钟的时间阅读本文，定会有所收获，我在耐心写，也希望大家可以耐心看完，基础不太好的同学可以分块看，已详细注明各级标题，希望通过本文可以让大家对大 JS 异步编程加深了解</p><p>哦对了，先赞在看，养成习惯，毕竟码字不易，大家的每一个赞和评论都将为我码下一篇文章添一些动力，多谢 😁</p><h2 id="回调函数-callback"><a href="#回调函数-callback" class="headerlink" title="回调函数(callback)"></a>回调函数(callback)</h2><h3 id="简述回调函数"><a href="#简述回调函数" class="headerlink" title="简述回调函数"></a>简述回调函数</h3><p>回调函数大家都应该清楚，简单理解就是一个函数被作为参数传递给另一个函数</p><p>回调并不一定就是异步，并没有直接关系，只不过回调函数是异步的一种解决方案</p><p>我们用例子来简单说明下</p><pre><code class="js">function fn1(callback) {  console.log(&quot;1&quot;)  callback &amp;&amp; callback()}function fn2() {  console.log(&quot;2&quot;)}fn1(fn2)</code></pre><p>如上代码所示，函数 fn1 参数为一个回调，调用 fn1 时传进入了函数 fn2，那么在函数 fn1 执行到 callback 函数调用时会调用 fn2 执行，这是一个典型的回调函数，不过是同步的，我们可以利用这点来解决异步，如下</p><pre><code class="js">fn1(callback){  setTimeout(() =&gt; {    callback &amp;&amp; callback()  }, 1000)}fn1(()=&gt;{  console.log(&quot;1&quot;)})</code></pre><p>如上所示，我们使用 setTimeout 在函数 fn1 中模拟了一个耗时 1s 的任务，耗时任务结束会抛出一个回调，那么我们在调用时就可以做到在函数 fn1 的耗时任务结束后执行回调函数了</p><p>采用这种方式，我们把同步操作变成了异步操作，fn1 不会堵塞程序运行，相当于先执行程序的主要逻辑，将耗时的操作推迟执行</p><h3 id="回调函数优-缺"><a href="#回调函数优-缺" class="headerlink" title="回调函数优/缺"></a>回调函数优/缺</h3><p><strong>优点</strong></p><p>一句话，回调函数是异步编程最基本的方法，其优点是简单、容易理解和部署</p><p><strong>缺点</strong></p><p>回调函数最大的缺点是不利于代码的阅读和维护，各个部分之间高度耦合(Coupling)</p><pre><code class="js">fun1(() =&gt; {  fun2(() =&gt; {    fun3(() =&gt; {      fun4(() =&gt; {        fun5(() =&gt; {          fun6()        })      })    })  })})</code></pre><p>上面这种代码在之前使用 AJAX 请求时很常见，因为业务上在一个请求结束后发起另一个请求的需求太多了，代码不优雅，不易阅读维护，高耦合，层层嵌套造成这种<strong>回调地狱</strong></p><p>异步回调中，回调函数的执行栈与原函数分离开，外部无法抓住异常，异常会变得不可控</p><p>虽然缺点多，但回调函数日常开发中也不可或缺，使用时注意就好了</p><p>回调函数比较简单常用，就先介绍到这里，接下来我们看事件监听</p><h2 id="事件监听-发布订阅模式"><a href="#事件监听-发布订阅模式" class="headerlink" title="事件监听(发布订阅模式)"></a>事件监听(发布订阅模式)</h2><p>解决异步，可以采用事件驱动，任务的执行不取决于代码的顺序，而取决于某个事件是否发生</p><p>在阮一峰老师早期发布的 <strong>Javascript 异步编程的 4 种方法(参考链接【1】)</strong> 一文中，把事件监听和发布订阅作为了不同的两种解决方案，但是我个人觉得这两种完全可以并为一种，都是利用了发布订阅模式的事件驱动，所以就放一块解释了</p><h3 id="JQuery-实现事件监听"><a href="#JQuery-实现事件监听" class="headerlink" title="JQuery 实现事件监听"></a>JQuery 实现事件监听</h3><p>jquery 实现比较简单，因为 jq 为我们封装好了方法，使用即可，只是 JQ 不常用了，简单了解下</p><p>我们可以使用 jquery 中的<code>on</code>来监听事件，使用<code>trigger</code>触发事件，如下</p><pre><code class="js">$(&quot;body&quot;).on(&quot;done&quot;, fn2)function fn1() {  setTimeout(function () {    $(&quot;body&quot;).trigger(&quot;done&quot;)  }, 2000)}function fn2() {  console.log(&quot;fn2执行了&quot;)}fn1()</code></pre><p>我们使用 jq 的<code>on</code>监听了一个自定义事件<code>done</code>，传入了 fn2 回调，表示事件触发后立即执行函数 fn2</p><p>在函数 fn1 中使用 setTimeout 模拟了耗时任务，setTimeout 回调中使用<code>trigger</code>触发了<code>done</code>事件</p><p>我们可以使用<code>on</code>来绑定多个事件，每个事件可以指定多个回调函数</p><h3 id="JavaScript-实现事件监听"><a href="#JavaScript-实现事件监听" class="headerlink" title="JavaScript 实现事件监听"></a>JavaScript 实现事件监听</h3><p>在 JS 中我们要自己实现类似 JQ 的<code>on</code>和<code>trigger</code>了</p><p>实现的过程中用到了一个设计模式，也就是发布订阅模式，所以简单提一下</p><h4 id="简述发布订阅模式-观察者模式"><a href="#简述发布订阅模式-观察者模式" class="headerlink" title="简述发布订阅模式(观察者模式)"></a>简述发布订阅模式(观察者模式)</h4><p>发布订阅模式(publish-subscribe pattern)，又叫观察者模式(observer pattern)，定义了对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知</p><p>来看一个比较挫的例子</p><pre><code class="js">小李辛辛苦苦做了两年程序猿，攒了些钱，内心激动，要去售楼部买一个心仪已久的房型到售楼部问了下，售楼部说暂时没有这种房型的房源了，怎么办呢，下次再来吧但是小李不知道这种房型什么时候有房源，总不能每天打电话到售楼部问吧，小李就把电话和房型信息留到售楼部了，什么时候有这种房源了，售楼部会短信通知要知道，售楼部不会只通知小李一个人，售楼部会把预留信息所有房型信息一致的人都通知一遍在这个比较挫的例子中，小李包括每个买房的人都是订阅者，而售楼部就是发布者</code></pre><p>其实我们都用过发布订阅模式，比如我们在 DOM 节点上绑定一个事件函数，就已经使用了</p><pre><code class="js">document.body.addEventListener(&quot;click&quot;, function () {  console.log(1)})</code></pre><p>但是这只是对发布订阅模式最简单的使用，在很多场景下我们经常会实现一些自定义事件来满足我们的需求</p><p>比如我们下面要防照 JQ 那种来写一个自定义事件监听器，需要监听一个事件，在该事件触发时执行其监听回调</p><h4 id="发布订阅模式实现事件监听器"><a href="#发布订阅模式实现事件监听器" class="headerlink" title="发布订阅模式实现事件监听器"></a>发布订阅模式实现事件监听器</h4><p>发布订阅模式有很多种实现方式，下面我们用<code>class</code>来简单实现下</p><pre><code class="js">class Emitter {  constructor() {    // _listener数组，key为自定义事件名，value为执行回调数组-因为可能有多个    this._listener = []  }  // 订阅 监听事件  on(type, fn) {    // 判断_listener数组中是否存在该事件命    // 存在将回调push到事件名对应的value数组中，不存在直接新增    this._listener[type]      ? this._listener[type].push(fn)      : (this._listener[type] = [fn])  }  // 发布 触发事件  trigger(type, ...rest) {    // 判断该触发事件是否存在    if (!this._listener[type]) return    // 遍历执行该事件回调数组并传递参数    this._listener[type].forEach((callback) =&gt; callback(...rest))  }}</code></pre><p>如上所示，我们创建了一个<code>Emitter</code>类，并且添加了两个原型方法<code>on</code>和<code>trigger</code>，上面代码中均有注释，所以不过多解释了，基础不好的同学多看几遍自己敲一下，比较简单</p><p>使用时</p><pre><code class="js">// 创建一个emitter实例const emitter = new Emitter()emitter.on(&quot;done&quot;, function (arg1, arg2) {  console.log(arg1, arg2)})emitter.on(&quot;done&quot;, function (arg1, arg2) {  console.log(arg2, arg1)})function fn1() {  console.log(&quot;我是主程序&quot;)  setTimeout(() =&gt; {    emitter.trigger(&quot;done&quot;, &quot;异步参数一&quot;, &quot;异步参数二&quot;)  }, 1000)}fn1()</code></pre><p>如上所示，我们先创建一个 emitter 实例，接着注册事件，再触发事件，用法和上面 JQ 雷同，均解决了异步问题</p><p>Vue 的实现就是一个比较复杂的发布订阅模式，使用 Vue 的同学，上面的这个事件监听器，把<code>trigger</code>名字改成<code>emit</code>是不是就眼熟多了，当然我们这个比较简单，毕竟代码就那么六七行，不过理是这么个理</p><h3 id="事件监听优-缺"><a href="#事件监听优-缺" class="headerlink" title="事件监听优/缺"></a>事件监听优/缺</h3><p><strong>优点</strong></p><p>发布订阅模式实现的事件监听，我们可以绑定多个事件，每个事件也可以指定多个回调函数，还是比较符合模块化思想的，我们自写监听器时可以做很多优化从而更好的监控程序运行</p><p><strong>缺点</strong></p><p>整个程序变成了事件驱动，流程上来说或多或少都会有点影响，每次使用还得注册事件监听再进行触发挺麻烦的，代码也不太优雅，并不是事件驱动不好，毕竟需求只是 <strong>解决异步问题</strong> 而已，何况有更优解</p><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><h3 id="Promise-简述"><a href="#Promise-简述" class="headerlink" title="Promise 简述"></a>Promise 简述</h3><p>ES2015 (ES6)标准化和引入了 Promise 对象，它是异步编程的一种解决方案</p><p>简单来说就是用同步的方式写异步的代码，可用来解决回调问题</p><h3 id="Promise-特点"><a href="#Promise-特点" class="headerlink" title="Promise 特点"></a>Promise 特点</h3><h4 id="特点一"><a href="#特点一" class="headerlink" title="特点一"></a>特点一</h4><p>Promise，承诺执行，Promise 对象的状态是不受外界影响的</p><p>Promise 对象代表一个异步操作，它有三种状态</p><ul><li><p>进行中 (Pending)</p></li><li><p>已完成 (Resolved/Fulfilled)</p></li><li><p>已失败 (Rejected)</p></li></ul><p>只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态</p><p>这就是 Promise 这个名字的由来，它的英语意思就是<code>承诺</code>，表示其他手段无法改变</p><h4 id="特点二"><a href="#特点二" class="headerlink" title="特点二"></a>特点二</h4><p>Promise 对象状态一旦改变，就不会再变</p><p>Promise 对象的状态改变，只有两种可能</p><ul><li><p>从 Pending 变为 Resolved</p></li><li><p>从 Pending 变为 Rejected</p></li></ul><p>只要这两种情况发生，状态就凝固，不会再变了，会一直保持这个结果</p><h3 id="Promise-使用"><a href="#Promise-使用" class="headerlink" title="Promise 使用"></a>Promise 使用</h3><p>Promise 是一个构造函数，我们可以通过<code>new</code>关键字来创建一个 Promise 实例，也可以直接使用 Promise 的一些静态方法</p><h4 id="new-一个-Promise-实例"><a href="#new-一个-Promise-实例" class="headerlink" title="new 一个 Promise 实例"></a>new 一个 Promise 实例</h4><p><strong>语法</strong></p><pre><code class="js">new Promise( function(resolve, reject) {...});</code></pre><p><strong>示例</strong></p><pre><code class="js">function fn1() {  return new Promise((resolve, reject) =&gt; {    setTimeout(() =&gt; {      let num = Math.ceil(Math.random() * 10)      if (num &lt; 5) {        resolve(num)      } else {        reject(&quot;数字太大&quot;)      }    }, 2000)  })}</code></pre><p>如上所示，我们使用<code>new</code>关键字创建了一个 promise 实例，并在函数 fn1 中<code>return</code>了出来</p><p><code>new Promise</code>创建了一个 promise 实例，Promise 构造函数会把一个叫做处理器函数(executor function)的函数作为它的参数</p><p>处理器函数接收两个参数分别是<code>resolve</code>和<code>reject</code>，这两个参数也是两个回调函数</p><p><code>resolve</code> 函数在异步操作成功时调用，并将异步操作的结果，作为参数传递出去</p><p><code>reject</code> 函数在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去</p><p>简单理解就是一个是成功回调，一个是失败回调</p><h4 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then()"></a>Promise.prototype.then()</h4><p>Promise 对象有一个原型方法<code>then</code></p><p>Promise 实例生成以后，可以用<code>then</code>方法指定<code>resolved</code>状态和<code>reject</code>状态的回调函数</p><pre><code class="js">Promise.prototype.then(onFulfilled[, onRejected])</code></pre><p><code>then</code>方法接收两个回调 onFulfilled 和 onRejected</p><ul><li><p>onFulfilled-可选</p><ul><li>当 Promise 变成已完成状态(fulfilled)时调用的回调函数</li><li>该函数有一个参数，即接受的最终结果(the fulfillment value)</li><li>如果该参数不是函数，则会在内部被替换为 <code>(x) =&gt; x</code>，即原样返回 promise 最终结果的函数</li></ul></li><li><p>onRejected-可选</p><ul><li>当 Promise 变成接受状态或拒绝状态(rejected)时调用的回调函数</li><li>该函数有一个参数，即拒绝的原因(rejection reason)</li><li>如果该参数不是函数，则会在内部被替换为一个 <code>Thrower</code> 函数(it throws an error it received as argument)</li></ul></li></ul><p><code>then</code>方法在接收一个 promise 实例后会返回一个新的 Promise 实例(并不是原来那个 Promise 实例)，且原来的 promise 实例的返回值将作为参数传入这个新 Promise 的<code>resolve</code>函数</p><p>那么既然<code>then</code>方法返回一个新的 promise 实例，所以我们可以接着使用<code>then</code>方法，即链式调用，也被称为 <strong>复合(composition)</strong>操作</p><p>接上面的示例，函数 fn1 会返回一个 promise 实例</p><pre><code class="js">fn1().then(  (data) =&gt; {    console.log(data)  },  (err) =&gt; {    console.log(err)  })</code></pre><p>如上所示，我们使用了<code>then</code>方法的两个参数</p><p>第一个参数回调我们很常用，其实就是 Promise 变成已完成状态且拿到传递的值</p><p>第二个参数回调就是 Promise 变成接受状态或拒绝状态且拿到错误参数，我们可能用的少，一般都是用<code>catch</code>方法，<code>then</code>方法的第二个参数 onRejected 和<code>catch</code>还是有一些细微区别的，下面会提到</p><p>根据 Promises/A+中对<code>then</code>方法的定义，我们来看<code>then</code>方法的特点</p><p><strong>首先<code>then</code> 方法必须返回一个 <code>promise</code> 对象(划重点)</strong></p><p>链式调用的原理，不论是何种情况 then 方法都会返回一个新的 Promise 对象，这样才会有下个 then 方法</p><p><strong>如果<code>then</code>方法中返回的是一个普通值(如 Number、String 等)就使用此值包装成一个新的 Promise 对象返回</strong></p><p>就像下面这个例子，<code>then</code>方法接收 Promise 对象，<code>then</code>方法中返回一个普通值时，下一个<code>then</code>中是可以接到的</p><pre><code class="js">let p = new Promise((resolve, reject) =&gt; {  resolve(1)})p.then((data) =&gt; {  return 2 // 返回了一个普通值}).then((data) =&gt; {  console.log(data) // 2})</code></pre><p><strong>如果<code>then</code>方法中没有<code>return</code>语句，就返回一个用 Undefined 包装的 Promise 对象</strong></p><p>如下面例子的输出结果</p><pre><code class="js">let p = new Promise((resolve, reject) =&gt; {  resolve(1)})p.then((data) =&gt; {  // 无return语句}).then((data) =&gt; {  console.log(data) // undefined})</code></pre><p><strong>如果<code>then</code>方法中出现异常，则调用失败态方法(reject)跳转到下一个<code>then</code>的 onRejected</strong></p><p><code>then</code>方法的第二个参数 onRejected 是监测不到当前<code>then</code>方法回调异常的，规范中定义当前<code>then</code>方法出现异常则调用失败态方法(reject)流转到下一个<code>then</code>的 onRejected</p><pre><code class="js">let p = new Promise((resolve, reject) =&gt; {  resolve(1)})p.then((data) =&gt; 2)  .then(    (data) =&gt; {      throw &quot;this is err&quot;    },    (err) =&gt; {      console.log(&quot;err1:&quot; + err)    }  )  .then(    (data) =&gt; {      console.log(data)    },    (err) =&gt; {      console.log(&quot;err2:&quot; + err) // err2:this is err    }  )</code></pre><p><strong>如果<code>then</code>方法没有传入任何回调，则继续向下传递(即所谓的值穿透)</strong></p><p>下面示例，在第一个<code>then</code>方法之后连续调用了两个空的<code>then</code>方法 ，没有传入任何回调函数，也没有返回值，此时 Promise 会将值一直向下传递，直到接收处理，这就是所谓的值穿透</p><pre><code class="js">let p = new Promise((resolve, reject) =&gt; {  resolve(1)})p.then((data) =&gt; 2)  .then()  .then()  .then((data) =&gt; {    console.log(data) // 2  })</code></pre><p><strong>如果<code>then</code>方法中返回了一个 Promise 对象，那就以这个对象为准，返回它的结果</strong></p><p>话不多说，来看示例</p><pre><code class="js">let p = new Promise((resolve, reject) =&gt; {  resolve(1)})p.then((data) =&gt; {  return new Promise((resolve, reject) =&gt; {    resolve(2)  })}).then((data) =&gt; {  console.log(data) // 2})</code></pre><h4 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h4><p>除了原型方法<code>then</code>之外，Promise 对象还有一个<code>catch</code>的原型方法</p><p><code>catch</code>方法可以用于 promise 组合中的错误处理，此方法返回一个 Promise，并且处理拒绝的情况</p><pre><code class="js">p.catch(onRejected)p.catch(function (reason) {  // 拒绝})</code></pre><ul><li>onRejected<ul><li>当 Promise 被 rejected 时，被调用的一个回调函数，该函数拥有一个参数为失败原因或错误信息</li></ul></li></ul><p>简单理解就是捕获异常，promise 组合中抛出了错误或 promise 组合中出现 rejected 会被捕获</p><p>同样接最上面的示例，还使用 fn1 函数</p><pre><code class="js">fn1()  .then((data) =&gt; {    console.log(data)  })  .catch((err) =&gt; {    console.log(err)  })</code></pre><p>使用这种方式捕获错误或失败是不是比<code>then</code>方法的第二个参数看着舒服了点呢，毕竟 Promise 就是链式到底</p><p>同样也需要注意一点，<code>catch</code>方法也返回一个新的 promise 实例，如果 <code>onRejected</code>回调抛出一个错误或返回一个本身失败的 Promise ，通过 <code>catch</code> 返回的 Promise 会被 rejected，否则，它就是一个成功的(resolved)promise 实例</p><p>和上面的<code>then</code>方法中的第二个参数几乎是一致的，我们看例子</p><pre><code class="js">fn1()  .catch((err) =&gt; {    console.log(err)    return err  })  .then((data) =&gt; {    console.log(data)  })  .catch((err) =&gt; {    console.log(err)  })</code></pre><p>上面的 fn1 函数有一半的几率返回一个 rejected，当返回一个 rejected 时下面的<code>then</code>方法回调中同样会输出，因为我们在第一个<code>catch</code>中只 return 了错误信息，并没有抛出错误或者返回一个失败 promise，所以第一个<code>catch</code>执行返回的 promise 对象是 resolveing</p><h4 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally()"></a>Promise.prototype.finally()</h4><p>finally，英文是<code>最后</code>的意思，此方法是<code>ES2018</code>的标准</p><p>原型方法<code>finally</code>，我们使用的可能不多，语法如下</p><pre><code class="js">p.finally(onFinally)p.finally(function () {  // 返回状态为(resolved 或 rejected)})</code></pre><p>一句话即可解释<code>finally</code>，在 promise 结束时，不管成功还是失败都将执行其<code>onFinally</code>回调，该回调无参数</p><p>适用于同样的语句需要在<code>then()</code>和<code>catch()</code>中各写一次的情况</p><h4 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h4><p>一句话概括 Promise.resolve()方法，接收一个值，将现有对象转为 Promise 对象</p><pre><code class="js">Promise.resolve(value)</code></pre><p>如下所示，该值可为任意类型，也可是一个 Promise 对象</p><pre><code class="js">const p = Promise.resolve(123)Promise.resolve(p).then((value) =&gt; {  console.log(value) // 123})</code></pre><h4 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h4><p><code>Promise.reject()</code>方法同上面<code>Promise.resolve()</code>一样，只不过是返回一个带有拒绝原因的<code>Promise</code>对象</p><pre><code class="js">Promise.reject(123)  .then((data) =&gt; {    console.log(data)  })  .catch((err) =&gt; {    console.log(&quot;err:&quot; + err)  })// err:123</code></pre><h4 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h4><p><code>Promise.all(iterable)</code>用于将多个 Promise 实例包装成一个新的 Promise 实例，参数为一组 Promise 实例组成的数组</p><p>iterable 类型为 ES6 标准引入，代表可迭代对象，<code>Array</code>、<code>Map</code>和<code>Set</code>都属于<code>iterable</code>类型 ，iterable 下面我们会讲到，这里我们就先把这个参数理解成数组就可以，稍后配合下面的 iterable 来理解</p><pre><code class="js">let p1 = Promise.resolve(1)let p2 = Promise.resolve(2)let p3 = Promise.resolve(3)let p = Promise.all([p1, p2, p3])p.then((data) =&gt; {  console.log(data) // [1,2,3]})</code></pre><p>如上所示，当 p1, p2, p3 状态都 Resolved 的时候，p 的状态才会 Resolved</p><p>只要有一个实例 Rejected ，此时第一个被 Rejected 的实例返回值就会传递给 P 的回调函数</p><pre><code class="js">let p1 = Promise.resolve(1)let p2 = Promise.resolve(2)let p3 = Promise.reject(3)let p = Promise.all([p1, p2, p3])p.then((data) =&gt; {  console.log(data)}).catch((err) =&gt; {  console.log(&quot;err:&quot; + err) // 3})</code></pre><p>应用场景在我们有一个接口，需要其他两个或多个接口返回的数据作为参数时会多一些</p><h4 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h4><p><code>Promise.race(iterable)</code>和上面<code>Promise.all(iterable)</code>类似</p><p><code>all</code>方法是迭代对象中状态全部改变才会执行</p><p><code>race</code>方法正好相反，只要迭代对象中有一个状态改变了，它的状态就跟着改变，并将那个改变状态实例的返回值传递给回调函数</p><pre><code class="js">const p1 = new Promise((resolve, reject) =&gt; {  setTimeout(resolve, 1000, &quot;1&quot;)})const p2 = new Promise((resolve, reject) =&gt; {  setTimeout(resolve, 500, &quot;2&quot;)})Promise.race([p1, p2]).then((value) =&gt; {  console.log(value) // 2})</code></pre><h4 id="Promise-try"><a href="#Promise-try" class="headerlink" title="Promise.try()"></a>Promise.try()</h4><p>开发中，经常遇到一种情况：不知道或不想区分，函数 fn 是同步函数还是异步函数，但想用 Promise 来处理它</p><p>因为这样就可以不管 fn 是不是异步操作，都用 then 方法指定下一步流程，用 catch 方法处理 fn 抛出的错误</p><p>我们可能会使用<code>Promise.resolve</code>把它转换成 Promise 对象</p><pre><code class="js">let fn = () =&gt; console.log(&quot;fn&quot;)Promise.resolve(fn).then((cb) =&gt; cb())console.log(&quot;hahaha&quot;)// hahaha// fn</code></pre><p>但是这样有一个问题，如果函数 fn 是同步的，那么这波操作会把它转成异步，如上输出</p><p>那么有没有一种方法，让同步函数同步执行，异步函数异步执行，并且让它们具有统一的 API 呢？当然可以</p><p>我们可以这样</p><pre><code class="js">const fn = () =&gt; console.log(&quot;fn&quot;);(() =&gt; new Promise((resolve) =&gt; resolve(fn())))()  .then(() =&gt; {    console.log(222)  })  .catch((err) =&gt; {    console.log(err)  })console.log(&quot;111&quot;)// fn// 111// 222</code></pre><p>也可以这样</p><pre><code class="js">const fn = () =&gt; console.log(&quot;fn&quot;);(async () =&gt; fn())()  .then(() =&gt; {    console.log(222)  })  .catch((err) =&gt; {    console.log(err)  })console.log(&quot;111&quot;)// fn// 111// 222</code></pre><p>但是，代码有点诡异，不优雅</p><p>来看使用<code>try</code>方法</p><pre><code class="js">const fn = () =&gt; console.log(&quot;fn&quot;)Promise.try(fn)  .then(() =&gt; {    console.log(222)  })  .catch((err) =&gt; {    console.log(err)  })console.log(&quot;111&quot;)// fn// 111// 222</code></pre><p>如上所示，简洁明了，还是很实用的</p><p>其实，<code>Promise.try</code>就是模拟 try 代码块，就像<code>promise.catch</code>模拟的是 catch 代码块</p><p>最后 <code>Promise.try</code> 并不是 Javascript 的一部分</p><p>早在 16 年有过这个提案，有兴趣的同学可以了解下，现在也没下文了，并没有被纳入标准</p><p>如果想要使用的话，需要使用 Promise 库 Bluebird、Q 等，或引入 Polyfill</p><p>虽然没有被纳入标准，但并不代表它不好用，大家自行体验</p><p>想要了解更多此方法推荐大家看参考链接【4】【5】</p><h4 id="onRejected-和-catch-区别"><a href="#onRejected-和-catch-区别" class="headerlink" title="onRejected 和 catch 区别"></a>onRejected 和 catch 区别</h4><p>上面提到了<code>promise.then(onFulfilled, onRejected)</code>中的第二个参数 onRejected 和<code>catch</code></p><p>看到这大家可能会问，同样都是捕获异常它们的区别在哪</p><p>其实<code>promise.then(onFulfilled, onRejected)</code> 在 <code>onFulfilled</code>回调中发生异常的话，在<code>onRejected</code>中是捕获不到这个异常的，使用<code>catch</code>可以捕获到前面的 onFulfilled 的异常</p><p>其实这不算个缺点，我们完全可以在末尾多加一个<code>then</code>从而达到和<code>catch</code>相同的作用，如下</p><pre><code class="js">Promise.reject(1)  .then(() =&gt; {    console.log(&quot;我是对的&quot;)  })  .then(null, (err) =&gt; {    console.log(&quot;err:&quot; + err) // err:1  })// 等价于Promise.reject(1)  .then(() =&gt; {    console.log(&quot;我是对的&quot;)  })  .catch((err) =&gt; {    console.log(&quot;err:&quot; + err) // err:1  })</code></pre><p>就这么点区别，不过大部分人都喜欢直接使用<code>catch</code>罢了</p><h4 id="then-中抛错未处理"><a href="#then-中抛错未处理" class="headerlink" title="then 中抛错未处理"></a>then 中抛错未处理</h4><p>如果在 then 中抛错，而没有对错误进行处理(catch)，那么会一直保持 reject 状态，直到 catch 了错误</p><p>我们来看一段代码</p><pre><code class="js">Promise.resolve()  .then(() =&gt; {    console.log(a)    console.log(&quot;Task 1&quot;)  })  .then(() =&gt; {    console.log(&quot;Task 2&quot;)  })  .catch((err) =&gt; {    console.log(&quot;err:&quot; + err)  })  .then(() =&gt; {    console.log(&quot;finaltask&quot;)  })// err:ReferenceError: a is not defined// finaltask</code></pre><p>我们看上面代码，我们在第一个<code>then</code>中输出了一个未声明的变量</p><p>输出结果先走了<code>catch</code>然后走了最后一个<code>then</code>，第一个<code>then</code>中抛出错误并跳过了第二个<code>then</code></p><p>也就是说如果我们没有处理这个错误(无 catch)的话，就不会往下执行了</p><p>可参考下图</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20200201231714043.png" srcset="/blog/img/loading.gif" alt="image-20200201231714043"></p><p>promise 的缺点之一就是无法让 promise 中断，利用这个特性可以让 Promise 中断执行，也算一种办法吧</p><h4 id="异步回调中抛错-catch-捕捉不到"><a href="#异步回调中抛错-catch-捕捉不到" class="headerlink" title="异步回调中抛错 catch 捕捉不到"></a>异步回调中抛错 catch 捕捉不到</h4><p>首先我们看在 Promise 对象的处理器函数中直接抛出错误</p><pre><code class="js">const p = new Promise((resolve, reject) =&gt; {  throw new Error(&quot;这是一个错误&quot;)})p.catch((error) =&gt; {  console.log(error)})</code></pre><p>按照上述内容来看，在 Promise 对象的处理器函数中直接抛出错误，<code>catch</code>是可以捕捉到的</p><p>在下面代码，在 Promise 对象的处理器函数中模拟一个异步抛错</p><pre><code class="js">const p = new Promise((resolve, reject) =&gt; {  setTimeout(() =&gt; {    throw new Error(&quot;这是一个错误&quot;)  }, 0)})p.catch((error) =&gt; {  console.log(error)})</code></pre><p>这种情况<code>catch</code>是捕捉不到的，这是为什么呢？先想后看，再做不难</p><p><strong>原因</strong></p><p>JS 事件循环列表有宏任务与微任务之分，setTimeOut 是宏任务， promise 是微任务，执行顺序不同</p><p>那么这段代码的执行顺序是：</p><ol><li>代码执行栈进入 promise 触发 setTimeOut，setTimeOut 回调函数入宏任务队列</li><li>代码执行 promise 的 catch 方法，入微任务队列，此时 setTimeOut 回调还没有执行</li><li>执行栈检查发现当前微任务队列执行完毕，开始执行宏任务队列</li><li>执行<code>throw new Error(&#39;这是一个错误&#39;)</code> 此时这个异常其实是在 promise 外部抛出的</li></ol><p><strong>解决</strong></p><p>使用<code>try catch</code>捕获异常主动触发<code>reject</code></p><pre><code class="js">const p = new Promise((resolve, reject) =&gt; {  setTimeout(() =&gt; {    try {      throw new Error(&quot;这是一个错误&quot;)    } catch (e) {      reject(e)    }  }, 0)})p.catch((error) =&gt; {  console.log(error)})</code></pre><h3 id="手写-Promise—符合-Promises-A-规范"><a href="#手写-Promise—符合-Promises-A-规范" class="headerlink" title="手写 Promise—符合 Promises/A+规范"></a>手写 Promise—符合 Promises/A+规范</h3><h4 id="为什么要手写-Promise"><a href="#为什么要手写-Promise" class="headerlink" title="为什么要手写 Promise"></a>为什么要手写 Promise</h4><p>Promise 源码逻辑相对来说不算简单，可能我们只会使用，并不清楚其原理</p><p>自己实现一遍会加深我们对 Promise 的理解，也可以加强我们 JS 的功底</p><p>更何况手写实现 Promise 是一道前端经典的面试题，此处必然不用多说</p><h4 id="Promises-A"><a href="#Promises-A" class="headerlink" title="Promises/A+"></a>Promises/A+</h4><p>了解了 Promise 的基础用法后，我们来一步步倒推实现 Promise</p><p>Promises/A+标准是一个开放、健全且通用的 JavaScript Promise 标准，由开发者制定，供开发者参考</p><p>很多 Promise 三方库都是按照 Promises/A+标准实现的</p><p>so，此次实现我们严格 Promises/A+标准，包括完成后我们会使用开源社区提供的测试包来测试</p><p>简单来说，测试通过的话，足以证明代码符合 Promises/A+标准，是合法的、完全可以上线提供给他人使用的</p><p>更多 Promises/A+标准请看参考链接【6】【7】</p><h4 id="构造方法核心基础搭建"><a href="#构造方法核心基础搭建" class="headerlink" title="构造方法核心基础搭建"></a>构造方法核心基础搭建</h4><p>Promise 的用法上面已经详细讲了，如果阅读仔细的话，我们会知道</p><ul><li>Promise 有三种状态进行中 (Pending)、已完成 (Resolved/Fulfilled)和已失败 (Rejected)</li><li>Promise 是一个构造方法，实例化 Promise 时传入一个函数作为处理器<ul><li>处理器函数有两个参数(resolve 和 reject)分别将结果变为成功态和失败态</li><li>Promise 对象执行成功了要有一个结果，通过 resolve 传递出去，失败的话失败原因通过 reject 传递出入</li></ul></li><li>Promise 的原型上定义着 then 方法</li></ul><p>那么根据我们上面的这些已知需求我们可以写出一个基础的结构(写法千千万，喜欢 class 也可以用 class)</p><pre><code class="js">function Promise(executor) {  // 状态描述 pending resolved rejected  this.state = &quot;pending&quot;  // 成功结果  this.value = undefined  // 失败原因  this.reason = undefined  function resolve(value) {}  function reject(reason) {}}Promise.prototype.then = function (onFulfilled, onRejected) {}</code></pre><p>如上所示，我们创建了一个 Promise 构造方法，<code>state</code>属性保存了 Promise 对象的状态，使用<code>value</code>属性保存 Promise 对象执行成功的结果，失败原因使用<code>reason</code>属性保存，这些命名完全贴合 Promises/A+标准</p><p>接着我们在构造函数中创建了<code>resolve</code>和<code>reject</code>两个方法，然后在构造函数的原型上创建了一个<code>then</code>方法，以备待用</p><h4 id="初始化实例-executor-立即执行"><a href="#初始化实例-executor-立即执行" class="headerlink" title="初始化实例 executor 立即执行"></a>初始化实例 executor 立即执行</h4><p>我们知道，在创建一个 Promise 实例时，处理器函数(executor)是会立即执行的，所以我们更改代码</p><pre><code class="js">function Promise(executor) {  this.state = &quot;pending&quot;  this.value = undefined  this.reason = undefined  // 让其处理器函数立即执行  try {    executor(resolve, reject)  } catch (err) {    reject(err)  }  function resolve(value) {}  function reject(reason) {}}</code></pre><h4 id="resolve-amp-reject-回调实现"><a href="#resolve-amp-reject-回调实现" class="headerlink" title="resolve&amp;reject 回调实现"></a>resolve&amp;reject 回调实现</h4><p>Promises/A+规范中规定，当 Promise 对象已经由 pending 状态改变为成功态(resolved)或失败态(rejected)后不可再次更改状态，也就是说成功或失败后状态不可更新已经凝固</p><p>因此我们更新状态时要判断，如果当前状态是 pending(等待态)才可更新，由此我们来完善<code>resolve</code>和<code>reject</code>方法</p><pre><code class="js">let _this = thisfunction resolve(value) {  if (_this.state === &quot;pending&quot;) {    _this.value = value    _this.state = &quot;resolved&quot;  }}function reject(reason) {  if (_this.state === &quot;pending&quot;) {    _this.reason = reason    _this.state = &quot;rejected&quot;  }}</code></pre><p>如上所示，首先我们在 Promise 构造函数内部用变量<code>_this</code>托管构造函数的<code>this</code></p><p>接着我们在<code>resolve</code>和<code>reject</code>函数中分别加入了判断，因为只有当前态是 pending 才可进行状态更改操作</p><p>同时将成功结果和失败原因都保存到对应的属性上</p><p>然后将 state 属性置为更新后的状态</p><h4 id="then-方法基础实现"><a href="#then-方法基础实现" class="headerlink" title="then 方法基础实现"></a>then 方法基础实现</h4><p>接着我们来简单实现<code>then</code>方法</p><p>首先<code>then</code>方法有两个回调，当 Promise 的状态发生改变，成功或失败会分别调用<code>then</code>方法的两个回调</p><p>所以，then 方法的实现看起来挺简单，根据 state 状态来调用不同的回调函数即可</p><pre><code class="js">Promise.prototype.then = function (onFulfilled, onRejected) {  if (this.state === &quot;resolved&quot;) {    if (typeof onFulfilled === &quot;function&quot;) {      onFulfilled(this.value)    }  }  if (this.state === &quot;rejected&quot;) {    if (typeof onRejected === &quot;function&quot;) {      onRejected(this.reason)    }  }}</code></pre><p>如上所示，由于<code>onFulfilled &amp; onRejected</code>两个参数都不是必选参，所以我们在判断状态后又判断了参数类型，当参数不为函数类型，就不执行，因为在 Promises/A+规范中定义非函数类型可忽略</p><h4 id="让-Promise-支持异步"><a href="#让-Promise-支持异步" class="headerlink" title="让 Promise 支持异步"></a>让 Promise 支持异步</h4><p>写到这里，我们可能会觉得，咦？Promise 实现起来也不难嘛，这么快就有模有样了，我们来简单测试下</p><pre><code class="js">let p = new Promise((resolve, reject) =&gt; {  resolve(1)})p.then((data) =&gt; console.log(data)) // 1</code></pre><p>嗯，符合预期，再来试下异步代码</p><pre><code class="js">let p = new Promise((resolve, reject) =&gt; {  setTimeout(() =&gt; {    resolve(1);  }，1000);})p.then(data =&gt; console.log(data)) // 无输出</code></pre><p>问题来了，Promise 一个异步解决方案被我们写的不支持异步。。。</p><p>我们来分析下，本来是等 1000ms 后执行<code>then</code>方法，运行上面代码发现没有结果，哪里有问题呢？</p><p>setTimeout 函数让<code>resolve</code>变成了异步执行，有延迟，调用<code>then</code>方法的时候，此刻状态还是等待态(pending)，<code>then</code>方法即没有调用<code>onFulfilled</code>也没有调用<code>onRejected</code></p><p>嗯，清楚原因我们开始改造，如果是你，你会如何解决呢，此处可思考 40 秒，想一个可实施的大致思路</p><p><strong>小提示：</strong> 可以参考上文的发布订阅模式，如果 40 秒还没有思路，嗯，有待提高</p><p>|</p><p>|</p><p>–&gt;为了让您小小活动一下左脑并活跃下气氛，我也是煞费苦心(<strong>ps:</strong>都看到这了，不点个赞鼓励下就太没劲了噻 😄)</p><p>|</p><p>|</p><p>回归正题，我们来解决这个问题</p><p>我们可以参照发布订阅模式，在执行<code>then</code>方法时如果还在等待态(pending)，就把回调函数临时寄存到队列(就是一个数组)里，当状态发生改变时依次从数组中取出执行就好了</p><p>思路有了，我们来实现下</p><p>首先，我们要在构造方法中新增两个 Array 类型的数组，用于存放成功和失败的回调函数</p><pre><code class="js">function Promise(executor) {  let _this = this  this.state = &quot;pending&quot;  this.value = undefined  this.reason = undefined  // 保存成功回调  this.onResolvedCallbacks = []  // 保存失败回调  this.onRejectedCallbacks = []  // ...}</code></pre><p>我们还需要改善<code>then</code>方法，在<code>then</code>方法执行时如果状态是等待态，就将其回调函数存入对应数组</p><pre><code class="js">Promise.prototype.then = function (onFulfilled, onRejected) {  // 新增等待态判断，此时异步代码还未走完，回调入数组队列  if (this.state === &quot;pending&quot;) {    if (typeof onFulfilled === &quot;function&quot;) {      this.onResolvedCallbacks.push(onFulfilled)    }    if (typeof onRejected === &quot;function&quot;) {      this.onRejectedCallbacks.push(onRejected)    }  }  // 以下为之前代码块  if (this.state === &quot;resolved&quot;) {    if (typeof onFulfilled === &quot;function&quot;) {      onFulfilled(this.value)    }  }  if (this.state === &quot;rejected&quot;) {    if (typeof onRejected === &quot;function&quot;) {      onRejected(this.reason)    }  }}</code></pre><p>如上所示，我们改写<code>then</code>方法，除了判断成功态(resolved)、失败态(rejected)，我们又加了一个等待态(pending)判断，当状态为等待态时，异步代码还没有走完，那么我们把对应的回调先存入准备好的数组中即可</p><p>最那么，就差最后一步执行了，我们在<code>resolve</code>和<code>reject</code>方法中调用即可</p><pre><code class="js">function resolve(value) {  if (_this.state === &quot;pending&quot;) {    _this.value = value    // 遍历执行成功回调    _this.onResolvedCallbacks.forEach((cb) =&gt; cb(value))    _this.state = &quot;resolved&quot;  }}function reject(reason) {  if (_this.state === &quot;pending&quot;) {    _this.reason = reason    // 遍历执行失败回调    _this.onRejectedCallbacks.forEach((cb) =&gt; cb(reason))    _this.state = &quot;rejected&quot;  }}</code></pre><p>到了这里，我们已经实现了 Promise 的异步解决，赶快测试下</p><h4 id="实现-Promise-经典的链式调用"><a href="#实现-Promise-经典的链式调用" class="headerlink" title="实现 Promise 经典的链式调用"></a>实现 Promise 经典的链式调用</h4><p>Promise 的<code>then</code>方法可以链式调用，这也是 Promise 的精华之一，在实现起来也算是比较复杂的地方了</p><p>首先我们要理清楚<code>then</code>的需求是什么，这需要仔细看 Promises/A+规范中对<code>then</code>方法的返回值定义及 Promise 解决过程，当然你如果仔细阅读了上文<code>then</code>方法的使用大概也清楚了，我们在这里再次总结下</p><ul><li><p><strong>首先<code>then</code> 方法必须返回一个 <code>promise</code> 对象(划重点)</strong></p></li><li><p><strong>如果<code>then</code>方法中返回的是一个普通值(如 Number、String 等)就使用此值包装成一个新的 Promise 对象返回</strong></p></li><li><p><strong>如果<code>then</code>方法中没有<code>return</code>语句，就返回一个用 Undefined 包装的 Promise 对象</strong></p></li><li><p><strong>如果<code>then</code>方法中出现异常，则调用失败态方法(reject)跳转到下一个<code>then</code>的 onRejected</strong></p></li><li><p><strong>如果<code>then</code>方法没有传入任何回调，则继续向下传递(值穿透)</strong></p></li><li><p><strong>如果<code>then</code>方法中返回了一个 Promise 对象，那就以这个对象为准，返回它的结果</strong></p></li></ul><p>嗯，到此我们需求已经明确，开始代码实现</p><p>需求中说如果<code>then</code>方法没有传入任何回调，则继续向下传递，但是每个<code>then</code>中又返回一个新的 Promise，也就是说当<code>then</code>方法中没有回调时，我们需要把接收到的值继续向下传递，这个其实好办，只需要在判断回调参数不为函数时我们把他变成回调函数返回普通值即可</p><pre><code class="js">Promise.prototype.then = function (onFulfilled, onRejected) {  onFulfilled =    typeof onFulfilled === &quot;function&quot; ? onFulfilled : (value) =&gt; value  onRejected =    typeof onRejected === &quot;function&quot;      ? onRejected      : (err) =&gt; {          throw err        }  // ...}</code></pre><p>我们上面<code>then</code>实现中，在每个可执行处都加了参数是否为函数的类型校验，但是我们这里在<code>then</code>方法开头统一做了校验，就不需要参数校验了</p><p>现在的<code>then</code>方法变成了</p><pre><code class="js">Promise.prototype.then = function (onFulfilled, onRejected) {  onFulfilled =    typeof onFulfilled === &quot;function&quot; ? onFulfilled : (value) =&gt; value  onRejected =    typeof onRejected === &quot;function&quot;      ? onRejected      : (err) =&gt; {          throw err        }  if (this.state === &quot;pending&quot;) {    this.onResolvedCallbacks.push(onFulfilled)    this.onRejectedCallbacks.push(onRejected)  }  if (this.state === &quot;resolved&quot;) {    onFulfilled(this.value)  }  if (this.state === &quot;rejected&quot;) {    onRejected(this.reason)  }}</code></pre><p>接着来</p><p>既然每个<code>thne</code>都反回一个新的 Promise，那么我们就先在<code>then</code>中创建一个 Promise 实例返回，开始改造</p><pre><code class="js">Promise.prototype.then = function (onFulfilled, onRejected) {  onFulfilled =    typeof onFulfilled === &quot;function&quot; ? onFulfilled : (value) =&gt; value  onRejected =    typeof onRejected === &quot;function&quot;      ? onRejected      : (err) =&gt; {          throw err        }  let promise2 = new Promise((resolve, reject) =&gt; {    if (this.state === &quot;pending&quot;) {      this.onResolvedCallbacks.push(onFulfilled)      this.onRejectedCallbacks.push(onRejected)    }    if (this.state === &quot;resolved&quot;) {      onFulfilled(this.value)    }    if (this.state === &quot;rejected&quot;) {      onRejected(this.reason)    }  })  return promise2}</code></pre><p>我们在<code>then</code>方法中先实例化了一个 Promise 对象并返回，我们把原来写的代码放到该实例的处理器函数中</p><p>我们把原来写的代码放到该实例的处理器函数中</p><p>接着在每个执行函数处使用<code>try..catch</code>语法，try 中<code>resolve</code>执行结果，catch 中<code>reject</code>异常，原来的<code>then</code>方法中有 resolved、rejected 和 pending 三种逻辑判断，如下</p><p>在 resolved 状态判断时，rejected 和 resolved 逻辑一致</p><pre><code class="js">if (this.state === &quot;resolved&quot;) {  try {    // 拿到返回值resolve出去    let x = onFulfilled(this.value)    resolve(x)  } catch (e) {    // catch捕获异常reject抛出    reject(e)  }}</code></pre><p>pending 状态判断，逻辑也和 resolved 相似，但是由于此处为了处理异步，我们在这里做了 push 操作，所以我们 push 时在 onFulfilled 和 onRejected 回调外面再套一个回调做操作即可，都是 JS 惯用小套路，不过分解释</p><pre><code class="js">if (this.state === &quot;pending&quot;) {  // push(onFulfilled)  // push(()=&gt;{ onFulfilled() })  // 上面两种执行效果一致，后者可在回调中加一些其他功能，如下  this.onResolvedCallbacks.push(() =&gt; {    try {      let x = onFulfilled(this.value)      resolve(x)    } catch (e) {      reject(e)    }  })  this.onRejectedCallbacks.push(() =&gt; {    try {      let x = onRejected(this.value)      resolve(x)    } catch (e) {      reject(e)    }  })}</code></pre><p>再接下来我们开始处理根据上一个<code>then</code>方法的返回值来生成新 Promise 对象，这块逻辑复杂些，规范中可以抽离出一个方法来做这件事，我们来照做</p><pre><code class="js">/** * 解析then返回值与新Promise对象 * @param {Object} 新的Promise对象，就是我们创建的promise2实例 * @param {*} x 上一个then的返回值 * @param {Function} resolve promise2处理器函数的resolve * @param {Function} reject promise2处理器函数的reject */function resolvePromise(promise2, x, resolve, reject) {  // ...}</code></pre><p>我们来一步步分析完善 resolvePromise 函数</p><p><strong>避免循环引用，当 then 的返回值与新生成的 Promise 对象为同一个(引用地址相同)，则抛出 TypeError 错误</strong></p><p>例：</p><pre><code class="js">let promise2 = p.then((data) =&gt; {  return promise2})// TypeError: Chaining cycle detected for promise #&lt;Promise&gt;</code></pre><p>如果返回了自己的 Promise 对象，状态永远为等待态(pending)，再也无法成为 resolved 或是 rejected，程序就死掉了，因此要先处理它</p><pre><code class="js">function resolvePromise(promise2, x, resolve, reject) {  if (promise2 === x) {    reject(new TypeError(&quot;请避免Promise循环引用&quot;))  }}</code></pre><p><strong>判断 x 类型，分情况处理</strong></p><p>当 x 是一个 Promise，就执行它，成功即成功，失败即失败，如果<code>x</code>是一个对象或是函数，再进一步处理它，否则就是一个普通值</p><pre><code class="js">function resolvePromise(promise2, x, resolve, reject) {  if (promise2 === x) {    reject(new TypeError(&quot;请避免Promise循环引用&quot;))  }  if (x !== null &amp;&amp; (typeof x === &quot;object&quot; || typeof x === &quot;function&quot;)) {    // 可能是个对象或是函数  } else {    // 是个普通值    resolve(x)  }}</code></pre><p>如果 x 是个对象，尝试将对象上的 then 方法取出来，此时如果报错，那就将 promise2 转为失败态</p><p>在这里 catch 防止报错是因为 Promise 有很多实现，假设另一个人实现的 Promise 对象使用<code>Object.defineProperty()</code>在取值时抛错，我们可以防止代码出现 bug</p><pre><code class="js">// resolvePromise方法内部片段if (x !== null &amp;&amp; (typeof x === &quot;object&quot; || typeof x === &quot;function&quot;)) {  // 可能是个对象或是函数  try {    // 尝试取出then方法引用    let then = x.then  } catch (e) {    reject(e)  }} else {  // 是个普通值  resolve(x)}</code></pre><p>如果对象中有<code>then</code>，且<code>then</code>是函数类型，就可以认为是一个 Promise 对象，之后，使用<code>x</code>作为其 this 来调用执行<code>then</code>方法</p><pre><code class="js">// resolvePromise方法内部片段if (x !== null &amp;&amp; (typeof x === &quot;object&quot; || typeof x === &quot;function&quot;)) {  // 可能是个对象或是函数  try {    // 尝试取出then方法引用    let then = x.then    if (typeof then === &quot;function&quot;) {      // then是function，那么执行Promise      then.call(        x,        (y) =&gt; {          resolve(y)        },        (r) =&gt; {          reject(r)        }      )    } else {      resolve(x)    }  } catch (e) {    reject(e)  }} else {  // 是个普通值  resolve(x)}</code></pre><p>此时，我们还要考虑到一种情况，如果 Promise 对象转为成功态或是失败时传入的还是一个 Promise 对象，此时应该继续执行，直到最后的 Promise 执行完，例如下面这种</p><pre><code class="js">Promise.resolve(1).then((data) =&gt; {  return new Promise((resolve, reject) =&gt; {    // resolve传入的还是Promise    resolve(      new Promise((resolve, reject) =&gt; {        resolve(2)      })    )  })})</code></pre><p>解决这种情况，我们可以采用递归，把调用 resolve 改写成递归执行 resolvePromise，这样直到解析 Promise 成一个普通值才会终止</p><pre><code class="js">// resolvePromise方法内部片段if (x !== null &amp;&amp; (typeof x === &quot;object&quot; || typeof x === &quot;function&quot;)) {  // 可能是个对象或是函数  try {    let then = x.then    if (typeof then === &quot;function&quot;) {      then.call(        x,        (y) =&gt; {          // 递归调用，传入y若是Promise对象，继续循环          resolvePromise(promise2, y, resolve, reject)        },        (r) =&gt; {          reject(r)        }      )    } else {      resolve(x)    }  } catch (e) {    reject(e)  }} else {  // 普通值结束递归  resolve(x)}</code></pre><p>规范中定义，如果 resolvePromise 和 rejectPromise 都被调用，或者多次调用同一个参数，第一个调用优先，任何进一步的调用都将被忽略，为了让成功和失败只能调用一个，我们接着完善，设定一个 called 来防止多次调用</p><pre><code class="js">// resolvePromise方法内部片段let calledif (x !== null &amp;&amp; (typeof x === &quot;object&quot; || typeof x === &quot;function&quot;)) {  // 可能是个对象或是函数  try {    let then = x.then    if (typeof then === &quot;function&quot;) {      then.call(        x,        (y) =&gt; {          if (called) return          called = true          // 递归调用，传入y若是Promise对象，继续循环          resolvePromise(promise2, y, resolve, reject)        },        (r) =&gt; {          if (called) return          called = true          reject(r)        }      )    } else {      resolve(x)    }  } catch (e) {    if (called) return    called = true    reject(e)  }} else {  // 普通值结束递归  resolve(x)}</code></pre><p>到此，我们算是实现好了<code>resolvePromise</code>方法，我们来调用它实现完整的<code>then</code>方法，在原来的原型方法<code>then</code>中我们<code>return</code>了一个 promise2，这个实例处理器函数的三种状态判断中把<code>resolve</code>处替换成<code>resolvePromise</code>方法即可</p><p>那么，此时<code>then</code>方法实现完成了吗？</p><p>当然还没有，我们都知道，Promise 中处理器函数是同步执行，而<code>then</code>方法是异步，但是我们完成这个还是同步</p><p>解决这个问题其实也很简单，仿照市面上大多数 Promise 库的做法，使用 setTimeout 模拟，我们在<code>then</code>方法内执行处的所有地方使用 setTimeout 变为异步即可(只是这样做和浏览器自带的 Promises 唯一的区别就是浏览器的 Promise..then 是微任务，我们用 setTimeout 实现是宏任务)，不过这也是大多数 Promise 库的做法，如下</p><pre><code class="js">setTimeout(() =&gt; {  try {    let x = onFulfilled(value)    resolvePromise(promise2, x, resolve, reject)  } catch (e) {    reject(e)  }}, 0)</code></pre><p>现在我们的终极版<code>then</code>方法就大功告成了</p><pre><code class="js">Promise.prototype.then = function (onFulfilled, onRejected) {  onFulfilled =    typeof onFulfilled === &quot;function&quot; ? onFulfilled : (value) =&gt; value  onRejected =    typeof onRejected === &quot;function&quot;      ? onRejected      : (err) =&gt; {          throw err        }  let promise2 = new Promise((resolve, reject) =&gt; {    // 等待态判断，此时异步代码还未走完，回调入数组队列    if (this.state === &quot;pending&quot;) {      this.onResolvedCallbacks.push(() =&gt; {        setTimeout(() =&gt; {          try {            let x = onFulfilled(this.value)            resolvePromise(promise2, x, resolve, reject)          } catch (e) {            reject(e)          }        }, 0)      })      this.onRejectedCallbacks.push(() =&gt; {        setTimeout(() =&gt; {          try {            let x = onRejected(this.value)            resolvePromise(promise2, x, resolve, reject)          } catch (e) {            reject(e)          }        }, 0)      })    }    if (this.state === &quot;resolved&quot;) {      setTimeout(() =&gt; {        try {          let x = onFulfilled(this.value)          resolvePromise(promise2, x, resolve, reject)        } catch (e) {          reject(e)        }      }, 0)    }    if (this.state === &quot;rejected&quot;) {      setTimeout(() =&gt; {        try {          let x = onRejected(this.reason)          resolvePromise(promise2, x, resolve, reject)        } catch (e) {          reject(e)        }      }, 0)    }  })  return promise2}</code></pre><h4 id="catch-实现"><a href="#catch-实现" class="headerlink" title="catch 实现"></a>catch 实现</h4><p>实现了最复杂的<code>then</code>方法后，<code>catch</code>实现非常简单，一看就懂了</p><pre><code class="js">Promise.prototype.catch = function (onRejected) {  return this.then(null, onRejected)}</code></pre><h4 id="代码测试"><a href="#代码测试" class="headerlink" title="代码测试"></a>代码测试</h4><p>开源社区提供了一个包用于测试我们的代码是否符合 Promises/A+规范：<code>promises-aplus-tests</code></p><p>首先我们要为该测试包提供一个<code>deferred</code>钩子，用于测试</p><p>如下，将下面代码防止我们的<code>Promise.js</code>文件末尾即可</p><pre><code class="js">// promises-aplus-tests测试Promise.defer = Promise.deferred = function () {  let defer = {}  defer.promise = new Promise((resolve, reject) =&gt; {    defer.resolve = resolve    defer.reject = reject  })  return defer}try {  module.exports = Promise} catch (e) {}</code></pre><p>接着，安装这个包</p><pre><code class="js">npm install promises-aplus-tests -D</code></pre><p>执行测试</p><pre><code class="js">npx promises-aplus-tests Promise.js</code></pre><p>静等片刻，如果控制台没有爆红就是成功了，符合规范，如图所示</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20200206222942803.png" srcset="/blog/img/loading.gif" alt="image-20200206222942803"></p><h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><p>篇幅已经很长了，后续还有其他内容，所以就实现了比较核心的 Promise 及 then 和 catch 方法</p><p>其他的 resolve/reject/race/all 等比较简单，不在这里描述了</p><p>给大家贴个我这边 Promise 多个方法实现的地址，大家有兴趣自行看代码吧，注释写的很详细了，也就大概 200 多行代码</p><ul><li>Github：<a href="https://github.com/isboyjc/promise" target="_blank" rel="noopener">https://github.com/isboyjc/promise</a></li></ul><h3 id="Promise-优-缺"><a href="#Promise-优-缺" class="headerlink" title="Promise 优/缺"></a>Promise 优/缺</h3><p><strong>优点</strong></p><p>Promise 用同步的方式写异步的代码，避免了层层嵌套的回调函数</p><p>Promise 对象提供了统一的接口，使得控制异步操作更加容易</p><p>链式操作，可以在 then 中继续写 Promise 对象并返回，然后继续调用 then 来进行回调操作</p><p><strong>缺点</strong></p><p>Promise 对象一旦新建就会立即执行，无法中途取消</p><p>若不设置回调函数，Promise 内部会抛出错误，不会流到外部</p><p>当处于 pending 状态时，无法得知当前处于哪一阶段</p><p>用多了 Promise 后代码一眼看上去都是 promise 的 API，而且链式语法总觉得不好看，不优雅</p><h2 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h2><p>Generator 是协程在 ES6 的实现，最大的特点就是可以交出函数的执行权</p><p>我们可以通过 yield 关键字，把函数的执行流挂起，为改变执行流程提供了可能，从而为异步编程提供解决方案</p><p>Generator 的英文是生成器</p><p>想要了解生成器(Generator)，还是绕不过迭代器(Iterator)这个概念，我们先来简单介绍下</p><h3 id="迭代器-Iterator"><a href="#迭代器-Iterator" class="headerlink" title="迭代器(Iterator)"></a>迭代器(Iterator)</h3><h4 id="Iterator-简介"><a href="#Iterator-简介" class="headerlink" title="Iterator 简介"></a>Iterator 简介</h4><p>迭代器是一种接口，也可以说是一种规范</p><p>js 中不同的数据类型如(Array/Object/Set)等等遍历方式都各有不同，比如对象遍历我们会使用<code>for..in..</code>，数组可以使用<code>for循环/for..in../forEach</code>等等</p><p>那么有没有统一的方式遍历这些数据呢？这就是迭代器存在的意义，它可以提供统一的遍历数据的方式，只要在想要遍历的数据结构中添加一个支持迭代器的属性即可</p><h4 id="Iterator-语法"><a href="#Iterator-语法" class="headerlink" title="Iterator 语法"></a>Iterator 语法</h4><pre><code class="js">const obj = {  [Symbol.iterator]: function () {},}</code></pre><p><code>[Symbol.iterator]</code> 属性名是固定的写法，只要拥有了该属性的对象，就能够用迭代器的方式进行遍历</p><p>迭代器的遍历方法是首先获得一个迭代器的指针，初始时该指针指向第一条数据之前</p><p>接着通过调用 <code>next</code> 方法，改变指针的指向，让其指向下一条数据</p><p>每一次的 <code>next</code> 都会返回一个对象，该对象有两个属性</p><ul><li><p>value 代表想要获取的数据</p></li><li><p>done 布尔值，false 表示当前指针指向的数据有值，true 表示遍历已经结束</p></li></ul><h4 id="Iterator-详解"><a href="#Iterator-详解" class="headerlink" title="Iterator 详解"></a>Iterator 详解</h4><p>在 JS 中，<code>Array/Set/Map/String</code>都默认支持迭代器</p><p>由于数组和集合都支持迭代器，所以它们都可以用同一种方式来遍历</p><p>es6 中提供了一种新的循环方法叫做<code>for-of</code>，它实际上就是使用迭代器来进行遍历</p><p>换句话说只有支持了迭代器的数据结构才能使用<code>for-of</code>循环</p><p><strong>数组中使用迭代器遍历</strong></p><pre><code class="js">let arr = [{ num: 1 }, 2, 3]let it = arr[Symbol.iterator]() // 获取数组中的迭代器console.log(it.next()) // { value: Object { num: 1 }, done: false }console.log(it.next()) // { value: 2, done: false }console.log(it.next()) // { value: 3, done: false }console.log(it.next()) // { value: undefined, done: true }</code></pre><p>数组是支持迭代器遍历的，所以可以直接获取其迭代器，集合也是一样</p><p><strong>集合中使用迭代器遍历</strong></p><pre><code class="js">let list = new Set([1, 3, 2, 3])let it = list.entries() // 获取set集合中自带的的迭代器console.log(it.next()) // { value: [ 1, 1 ], done: false }console.log(it.next()) // { value: [ 3, 3 ], done: false }console.log(it.next()) // { value: [ 2, 2 ], done: false }console.log(it.next()) // { value: undefined, done: true }</code></pre><p>集合与数组不同的是，我们可以使用 Set 中的<code>entries</code>方法获取迭代器</p><p>Set 集合中每次遍历出来的值是一个数组，里面的第一和第二个元素都是一样的</p><p><strong>自定义对象中使用迭代器遍历</strong></p><p>首先自定义的对象没有迭代器属性，所以不支持迭代器迭代，我们也都知道<code>for..of</code>是无法遍历对象的，原因就在这里，因为<code>for..of</code>是使用迭代器迭代，所以对象不能用<code>for..of</code></p><p>既然知道是因为自定义对象无迭代器属性，那么我们可以为它加上<code>Symbol.iterator</code>这样一个属性，并为它实现一个迭代器方法，如下</p><pre><code class="js">let obj = {  name: &quot;tom&quot;,  age: 18,  gender: &quot;男&quot;,  intro: function () {    console.log(&quot;my name is &quot; + this.name)  },  [Symbol.iterator]: function () {    let i = 0    // 获取当前对象的所有属性并形成一个数组    let keys = Object.keys(this)    return {      next: function () {        return {          // 外部每次执行next都能得到数组中的第i个元素          value: keys[i++],          // 如果数组的数据已经遍历完则返回true          done: i &gt; keys.length,        }      },    }  },}for (let attr of obj) {  console.log(attr)}</code></pre><p>如上所示，加上<code>[Symbol.iterator]</code>这个迭代器属性我们自定义了一个迭代器方法，就可以使用<code>for..of</code>方法了</p><h4 id="Iterator-作用"><a href="#Iterator-作用" class="headerlink" title="Iterator 作用"></a>Iterator 作用</h4><p>Iterator 的作用有三个：</p><ul><li>为各种数据结构，提供一个统一的、简便的访问接口</li><li>使得数据结构的成员能够按某种次序排列</li><li>ES6 创造了一种新的遍历命令<code>for..of</code>循环，Iterator 接口主要供<code>for..of</code>消费</li></ul><p>Iterator 我们就介绍到这里，到这就理解上文 Iterator 参数是什么了吧，就是代表一个有迭代器属性的参数</p><h3 id="初识-Generator"><a href="#初识-Generator" class="headerlink" title="初识 Generator"></a>初识 Generator</h3><p>Generator 其实也是一个函数，只不过是一个特殊的函数</p><p>普通函数，你运行了这个函数，函数内部不会停，直到这个函数结束</p><p>Generator 这个函数特殊之处就是，中间可以停</p><h4 id="Generator-函数特点"><a href="#Generator-函数特点" class="headerlink" title="Generator 函数特点"></a>Generator 函数特点</h4><pre><code class="js">function* generatorFn() {  console.log(&quot;a&quot;)  yield &quot;1&quot;  console.log(&quot;b&quot;)  yield &quot;2&quot;  console.log(&quot;c&quot;)  return &quot;3&quot;}let it = generatorFn()it.next()it.next()it.next()it.next()</code></pre><p>上面这个示例就是一个 Generator 函数，首先我们观察它的特点，一个一个进行分析</p><ul><li>不同于普通函数，Generator 函数在<code>function</code>后面，函数名之前有个<code>*</code><ul><li><code>*</code>用来表示函数为 Generator 函数</li><li>写法很多，<code>function* fn()</code>、<code>function*fn()</code>和<code>function *fn()</code>都可以</li></ul></li><li>函数内部有<code>yield</code>字段<ul><li><code>yield</code>用来定义函数内部的状态，并让出执行权</li><li>这个关键字只能出现在生成器函数体内，但是生成器中也可以没有 yield 关键字，函数遇到 yield 的时候会暂停，并把 yield 后面的表达式结果抛出去</li></ul></li><li>调用后其函数返回值使用了<code>next</code>方法<ul><li>调用 Generator 函数和调用普通函数一样，在函数名后面加上()即可</li><li>Generator 函数不会像普通函数一样立即执行，而是返回一个指向内部状态对象的指针</li><li>所以要调用迭代器对象 Iterator 的 <code>next</code> 方法，指针就会从函数头部或者上一次停下来的地方开始执行</li><li><code>next</code> 方法其实就是将代码的控制权交还给生成器函数</li></ul></li></ul><h4 id="分析执行过程"><a href="#分析执行过程" class="headerlink" title="分析执行过程"></a>分析执行过程</h4><p>接着我们来分析它的执行过程，线来看它的打印结果，还是上面那个例子</p><pre><code class="js">let it = generatorFn()it.next()// a// {value: &quot;1&quot;, done: false}it.next()// b// {value: &quot;1&quot;, done: false}it.next()// c// {value: &quot;1&quot;, done: true}it.next()// {value: undefined, done: true}</code></pre><p>首先，Generator 函数执行，返回了一个指向内部状态对象的指针，此时没有任何输出</p><p>第一次调用<code>next</code>方法，从 Generator 函数的头部开始执行，先是打印了 a ，执行到<code>yield</code>就停下来，并将<code>yield</code>后边表达式的值 ‘1’，作为返回对象的 value 属性值，此时函数还没有执行完， 返回对象的 done 属性值是 false</p><p>第二次调用<code>next</code>方法时，同上步</p><p>第三次调用<code>next</code>方法时，先是打印了 c ，然后执行了函数的返回操作，并将 return 后面的表达式的值，作为返回对象的 value 属性值，此时函数已经结束，所以 done 属性值为 true</p><p>第四次调用<code>next</code>方法时， 此时函数已经执行完了，所以返回 value 属性值是 undefined，done 属性值是 true ，如果执行第三步时，没有 return 语句的话，就直接返回 <code>{value: undefined, done: true}</code></p><p>简单的理解，Generator 函数<code>yield</code>放到哪里它就停到哪里，调用时使用<code>next</code>方法踹一步就走一步</p><h4 id="next-参数传递"><a href="#next-参数传递" class="headerlink" title="next 参数传递"></a>next 参数传递</h4><p><code>yield</code>是有返回值的，<code>next</code>方法直接调用不传入参数的时候，<code>yield</code> 表达式的返回值是 undefined</p><p>当 next 传入参数的时候，该参数会作为<strong>上一步</strong><code>yield</code>的返回值</p><p>我们通过示例来理解</p><pre><code class="js">function* geFn() {  cosnole.log(&quot;start&quot;)  let a = yield &quot;1&quot;  console.log(a)  let b = yield &quot;2&quot;  console.log(b)  let c = yield &quot;3&quot;  console.log(c)  return 4}let it = geFn()it.next()// start// { value:1, done: false }it1.next()// undefined           未传值，所以a=undefined// { value:2, done: false }it.next(&quot;hahaha&quot;)// hahaha                 传值，所以b=hahaha// { value:3, done: false }it.next(&quot;omg&quot;)// omg                         传值，所以c=omg// {value: 4, done: true}</code></pre><p>由于 <code>next</code> 方法的参数表示上一个 <code>yield</code> 语句的返回值，所以第一次使用 <code>next</code> 方法时，不能带有参数</p><p>V8 引擎会直接忽略第一次使用 <code>next</code> 方法时的参数，只有从第二次使用 <code>next</code> 方法开始，参数才是有效的</p><p>没有接到传值时，<code>yield</code>语句的返回值就是 undefined，正如上面示例输出那样</p><p>通过 <code>next</code> 方法的参数，就有办法在 Generator 函数开始运行之后，继续向函数体内部注入值，这代表了我们可以在 Generator 函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为</p><h4 id="再次理解-yield"><a href="#再次理解-yield" class="headerlink" title="再次理解 yield"></a>再次理解 yield</h4><p>我们再来看一段代码，帮助我们理解<code>yield</code></p><pre><code class="js">function* geFn() {  console.log(&quot;start&quot;)  let a = yield console.log(&quot;1&quot;)  console.log(a)  let b = yield console.log(&quot;2&quot;)  console.log(b)  return console.log(&quot;3&quot;)}let it = geFn()it.next()// start// 1// {value: 1, done: false}it.next(&quot;我是a&quot;)// 我是a// 2// {value: 2, done: false}it.next(&quot;我是b&quot;)// 我是b// 3// {value: 3, done: true}</code></pre><p>通过<code>next</code>调用我们可以看到，第一次调用就输出了<code>start &amp; 1</code> ，意味着<code>yield</code>停止时，后面代码是执行了的</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20200207234938429.png" srcset="/blog/img/loading.gif" alt="image-20200207234938429"></p><p>如上图所示，如果将说<code>yield</code>比做一道墙，那么墙右边和上面是一块，墙左边和下面是一块，这样说应该够直白了吧</p><h4 id="for-of-遍历-Generator"><a href="#for-of-遍历-Generator" class="headerlink" title="for..of 遍历 Generator"></a>for..of 遍历 Generator</h4><p>上文我们就知道了<code>for...of</code>内部实现就是在使用迭代器迭代，那么<code>for...of</code>循环直接用在 Generator 遍历器上岂不是完美</p><p>是的，它可以自动遍历 Generator 函数，而且此时不再需要调用 next 方法，一旦 next 方法的返回对象的 done 属性为 true，<code>for...of</code>循环就会中止，且不包含该返回对象</p><pre><code class="js">function* foo() {  yield 1  yield 2  yield 3  yield 4  yield 5  return 6}for (let v of foo()) {  console.log(v)}// 1 2 3 4 5</code></pre><h4 id="yield-表达式"><a href="#yield-表达式" class="headerlink" title="yield* 表达式"></a>yield* 表达式</h4><p>在<code>yield</code>命令后面加上星号，表明它返回的是一个遍历器，这被称为<code>yield*</code>表达式</p><pre><code class="js">function* foo() {  yield &quot;foo1&quot;  yield &quot;foo2&quot;}function* bar() {  yield &quot;bar1&quot;  yield* foo()  yield &quot;bar2&quot;}for (let val of bar()) {  console.log(val)}// bar1 foo1 foo2 bar2</code></pre><p><code>yield</code>命令后面如果不加星号，返回的是整个数组，加了星号就表示返回的是数组的遍历器</p><pre><code class="js">function* gen1() {  yield [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]}for (let val of gen1()) {  console.log(a)}// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]// ------------------- 上下分割function* gen2() {  yield* [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]}for (let val of gen2()) {  console.log(a)}// a b c</code></pre><h4 id="Generator-中的-return"><a href="#Generator-中的-return" class="headerlink" title="Generator 中的 return"></a>Generator 中的 return</h4><p>return 方法返回给定值，并结束遍历 Generator 函数</p><p>当 return 无值时，就返回 undefined，来看例子</p><pre><code class="js">function* foo() {  yield 1  yield 2  yield 3}var f = foo()f.next()// {value: 1, done: false}f.return(&quot;hahaha&quot;)// 由于调用了return方法，所以遍历已结束，done变true// {value: &quot;hahaha&quot;, done: true}f.next()// {value: undefined, done: true}</code></pre><h4 id="Generator-错误处理-throw"><a href="#Generator-错误处理-throw" class="headerlink" title="Generator 错误处理 throw"></a>Generator 错误处理 throw</h4><p><code>throw</code>方法可以再 Generator 函数体外面抛出异常，再函数体内部捕获，听着是很好理解</p><p>这里一不小心还是挺容易入坑的，我们来看几个例子吧</p><pre><code class="js">function* foo() {  try {    yield &quot;hahaha&quot;  } catch (err) {    console.log(&quot;inside error: &quot; + err)  }}var f = foo()try {  it.throw(&quot;this is err&quot;)} catch (err) {  console.log(&quot;out error: &quot; + err)}</code></pre><p>上面代码会输出哪个错误呢？</p><p>其实答案很简单，上述代码会输出<code>out error：this is err</code></p><p>因为调用<code>throw</code>的时候，我们并没有执行<code>next</code>方法，这个时候内部的<code>try{}catch{}</code>代码都还没执行，因此只会被外面捕捉</p><p>所以说，我们只需要在调用<code>throw</code>之前，先调用一遍<code>next</code>，这个时候函数体内部已经执行了<code>try{}catch{}</code>，那么执行到<code>throw</code>时，内外都有错误捕捉，<strong><code>throw</code>方法会先被内部捕捉</strong>，从而打印<code>inside error：this is err</code></p><p>除此，<strong><code>throw</code>方法会附带执行下一个<code>yield</code></strong>，我们来看示例</p><pre><code class="js">var foo = function* foo() {  try {    yield console.log(&quot;1&quot;)    yield console.log(&quot;2&quot;)  } catch (e) {    console.log(&quot;inside err&quot;)  }  yield console.log(&quot;3&quot;)  yield console.log(&quot;4&quot;)}var g = foo()g.next()g.throw()g.next()</code></pre><p>我们来看上述代码的执行过程</p><p>首先执行第一个<code>next</code>方法，进入<code>try()catch()</code>，输出 1</p><p>接着，执行<code>throw</code>方法，内部捕捉到，输出<code>inside err</code>，此时<code>try()catch()</code>代码块已经执行了<code>catch</code>，<code>try()catch()</code>代码块已经结束了，所以附带执行一个<code>yield</code>会继续向下找，所以再输出 3</p><p>最后执行<code>next</code>方法，输出 4</p><p>最终输出结果为<code>1 3 4</code></p><h3 id="Generator-扩充"><a href="#Generator-扩充" class="headerlink" title="Generator 扩充"></a>Generator 扩充</h3><p>在 Generator 开头有一句话，不知道大家理解没有</p><ul><li>Generator 是协程在 ES6 的实现，最大的特点就是可以交出函数的执行权</li></ul><h4 id="什么是协程？"><a href="#什么是协程？" class="headerlink" title="什么是协程？"></a>什么是协程？</h4><p>这里使用阮一峰老师的文章参考链接【8】中对协程的解释并略带修改及补充</p><p>进程和线程大家应该都清楚，那么协程是什么呢</p><p>不知道大家知不知道用户空间线程，其实就是一种由程序员自己写程序来管理他的调度的线程，对内核来说不可见</p><p>协程(coroutine)，可以理解就是一种“用户空间线程”，也可理解为多个“线程”相互协作，完成异步任务</p><p>由于线程是操作系统的最小执行单元，因此也可以得出，协程是基于线程实现的，不过它要比线程要轻很多</p><p>协程，有几个特点：</p><ul><li>协同，因为是由程序员自己写的调度策略，其通过协作而不是抢占来进行切换</li><li>在用户态完成创建，切换和销毁</li><li>编程角度上看，协程的思想本质上就是控制流的主动让出(yield)和恢复(resume)机制</li></ul><p>它的运行流程如下</p><ul><li>协程 A 开始执行</li><li>协程 A 执行到一半，暂停执行，执行的权利转交给协程 B。</li><li>一段时间后 B 交还执行权</li><li>协程 A 重得执行权，继续执行</li></ul><p>上面的协程 A 就是一个异步任务，因为在执行过程中执行权被 B 抢了，被迫分成两步完成</p><p>举例来说，读取文件的协程写法如下</p><pre><code class="javascript">function asnycJob() {  // ...其他代码  var f = yield readFile(fileA);  // ...其他代码}</code></pre><p>上面代码的函数 asyncJob 是一个协程，其中的 <code>yield</code> 命令，它表示执行到此处，执行权将交给其他协程，也就是说，<code>yield</code>命令是异步两个阶段的分界线</p><p>协程遇到 <code>yield</code> 命令就暂停，等到执行权返回，再从暂停的地方继续往后执行，它的最大优点，就是代码的写法非常像同步操作，只多了一个<code>yield</code>命令</p><h4 id="Generator-与协程"><a href="#Generator-与协程" class="headerlink" title="Generator 与协程"></a>Generator 与协程</h4><p>JS 是单线程的，ES6 中的 Generator 的实现，类似于开了多线程，但是依然同时只能进行一个线程，不过可以切换</p><p>就像汽车在公路上行驶，js 公路只是单行道(主线程)，但是有很多车道(辅助线程)都可以汇入车流(异步任务完成后回调进入主线程的任务队列)</p><p>而 Generator 把 js 公路变成了多车道(协程实现)，但是同一时间只有一个车道上的车能开(所以依然是单线程)，不过可以自由变道(移交控制权)</p><h4 id="Generator-之-Thunk-函数"><a href="#Generator-之-Thunk-函数" class="headerlink" title="Generator 之 Thunk 函数"></a>Generator 之 Thunk 函数</h4><p>thunk 函数的诞生源于一个编译器设计的问题：<code>求值策略</code>，即函数的参数到底应该何时求值</p><pre><code class="js">var x = 1function fn(n) {  return n * 10}fn(x + 5)</code></pre><p>如上所示，其中 fn 方法调用时<code>x+5</code>这个表达式应该什么时候求值，有两种思路</p><ul><li><strong>传值调用(call by value)</strong>，先计算<code>x+5</code>的值，再将这个值 <code>6</code> 传入函数 fn，例如 c 语言，这种做法的好处是实现比较简单，但是有可能会造成性能损失(例如一个函数传入了两个参数，第二个参数是一个表达式，但是函数体内没有用到这个参数，那么先计算出值就会损耗性能且无意义)</li><li><strong>传名调用(call by name)</strong>，即直接将表达式<code>x+5</code>传入函数体，只在用到它的时候求值</li></ul><p>Thunk 函数的定义，就是传名调用的一种实现策略，用来替换某个表达式，实现思路其实也很简单</p><p>先将参数放到一个临时函数之中，再将这个临时函数传入函数体，就像下面这样</p><pre><code class="js">function fn(m) {  return m * 2}fn(x + 5)// thunk实现思路var thunk = function () {  return x + 5}function fn(thunk) {  return thunk() * 2}</code></pre><p>JS 是传值调用，它的 Thunck 函数含义有所不同</p><p>在 JS 中，Thunk 函数替换的不是表达式，是对函数珂里化的一种运用，简单来说，就是把是多参数函数替换成一个只接受回调函数作为参数的单参数函数，我们来看下它的简单实现</p><pre><code class="js">fs.readFile(fileName, callback)const Thunk = function (fn) {  return function (...args) {    return function (callback) {      return fn.call(this, ...args, callback)    }  }}// 使用上面的Thunk转化器，生成fs.readFile的Thunk函数var readFileThunk = Thunk(fs.readFile)readFileThunk(fileName)(callback)</code></pre><p>如果在生产环境要使用 Thunk 函数的话，使用 Thunkify 模块就可以，其实它核心源码就是上面我们写的 Thunk，Thunkify 里多了一个检查机制而已，比较简单，可自行百度 Thunkify 模块了解</p><p>Thunk 这东西在 ES6 前其实没有太大用处，但是在 Generator 函数出来后，Thunk 函数就可以派上用场了，它可以用于 Generator 函数的自动流程管理，接收和交换程序的执行权</p><p>我们来实现一个基于 Thunk 函数的 Generator 自动执行器</p><pre><code class="js">// 基于Thunk函数的Genertor函数自动执行器function run(fn) {  let gen = fn()  function next(err, data) {    // 将指针移动到Generator函数的下一步    let result = gen.next(data)    // 判断是否结束    if (result.done) return    // 递归,把next放进.value中    result.value(next)  }  next()}// 模拟异步方法let sleep = function (n, callback) {  setTimeout(() =&gt; {    console.log(n)    callback &amp;&amp; callback(n)  }, n)}// 模拟异步方法进行Thunk转换let sleepThunk = Thunk(sleep)// Generator函数let gen = function* () {  let f1 = yield sleepThunk(1000)  let f2 = yield sleepThunk(1500)  // ...  let fn = yield sleepThunk(2000)}// 调用Genertor函数自动执行器run(gen)</code></pre><p>上面代码的 run 函数，就是一个 Generator 函数的自动执行器，内部的 next 函数就是 Thunk 的回调函数</p><p>next 函数先将指针移到 Generator 函数的下一步(gen.next 方法)</p><p>然后判断 Generator 函数是否结束(result.done 属性)</p><p>如果没结束，就将 next 函数再传入 Thunk 函数(result.value 属性)，否则就直接退出</p><p>代码中模拟了一个异步操作<code>sleep</code>方法，并将其转化为了 Thunk 方法(使用上文我们实现的那个简易版 Thunk)</p><p>函数 gen 封装了 n 个异步操作，只要执行 run 函数，这些操作就会自动完成</p><p>这样一来，异步操作不仅可以写得像同步操作，而且一行代码就可以执行，极其方便</p><p>不过相信大家也看到了，这种自动执行器传入的 Generator 函数，<strong>yield 方法后面必须是一个 Thunk 函数</strong></p><p>——–👇——–</p><p>Thunk 就简单介绍到这里了，更多 Thunk 相关推荐看阮一峰文参考链接【9】</p><p>我们只需要明白 Thunk 是什么，它和 Generator 有什么关系就可以</p><h4 id="Generator-之-co-函数库"><a href="#Generator-之-co-函数库" class="headerlink" title="Generator 之 co 函数库"></a>Generator 之 co 函数库</h4><p>co 函数库是著名程序员 TJ Holowaychuk 于 2013 年 6 月发布的一个小工具，用于 Generator 函数的自动执行</p><p><a href="https://github.com/tj/co" target="_blank" rel="noopener">co 函数库传送门</a></p><p>co 函数库其实就是将两种自动执行器(Thunk 函数和 Promise 对象)，包装成一个库，所以说使用 co 的前提条件是，Generator 函数的 yield 命令后面，只能是 Thunk 函数或 Promise 对象</p><p>co 函数会返回一个 Promise，所以我们可以后接<code>then</code>等方法</p><p>基于 Thunk 函数的自动执行器上面介绍了下，那么基于 Promise 的其实也差不多，我们简单实现下</p><pre><code class="js">// 基于Promise函数的Genertor函数自动执行器function run(gen) {  let g = gen()  function next(data) {    // 将指针移动到Generator函数的下一步    let result = g.next(data)    // 判断是否结束，结束返回value，value是一个Promise    if (result.done) return result.value    // 递归    result.value.then((data) =&gt; {      next(data)    })  }  next()}// 模拟异步方法进行Promise转换let sleepPromise = function (n) {  return new Promise(function (resolve, reject) {    setTimeout(() =&gt; {      console.log(n)      resolve(n)    }, n)  })}// Generator函数let gen = function* () {  let f1 = yield sleepPromise(1000)  let f2 = yield sleepPromise(1500)  // ...  let fn = yield sleepPromise(2000)}// 调用Genertor函数自动执行器run(gen)</code></pre><p>如上代码，和 Thunk 函数那里区别就是 yield 后面一个跟 Thunk 函数，一个跟 Promise 对象</p><p>如果 Thunk 自执行器你理解了，Promise 使用也 ok 的话，这块代码看看就懂了，也没啥解释的</p><p>接下来我们来看看 co 库的源码</p><p>co 函数库的源码也很简单，只有几十行代码</p><p>首先，co 函数接受 Generator 函数作为参数，返回一个 Promise 对象</p><pre><code class="js">function co(gen) {  var ctx = this  return new Promise(function (resolve, reject) {})}</code></pre><p>在返回的 Promise 对象里面，co 先检查参数 gen 是否为 Generator 函数</p><p>如果是，就执行该函数，得到一个内部指针对象</p><p>如果不是就返回，并将 Promise 对象的状态改为 resolved</p><pre><code class="js">function co(gen) {  var ctx = this  return new Promise(function (resolve, reject) {    if (typeof gen === &quot;function&quot;) gen = gen.call(ctx)    if (!gen || typeof gen.next !== &quot;function&quot;) return resolve(gen)  })}</code></pre><p>接着，co 将 Generator 函数的内部指针对象的 next 方法，包装成 onFulefilled 函数</p><p>主要是为了能够捕捉抛出的错误</p><pre><code class="js">function co(gen) {  var ctx = this  return new Promise(function (resolve, reject) {    if (typeof gen === &quot;function&quot;) gen = gen.call(ctx)    if (!gen || typeof gen.next !== &quot;function&quot;) return resolve(gen)    onFulfilled()    function onFulfilled(res) {      var ret      try {        ret = gen.next(res)      } catch (e) {        return reject(e)      }      next(ret)    }  })}</code></pre><p>最后，就是关键的 next 函数，它会反复调用自身</p><pre><code class="js">function next(ret) {  if (ret.done) return resolve(ret.value)  var value = toPromise.call(ctx, ret.value)  if (value &amp;&amp; isPromise(value)) return value.then(onFulfilled, onRejected)  return onRejected(new TypeError(&#39;You may only yield a function, promise, generator, array, or object, but the following object was passed: &quot;&#39; + String(ret.value) + &#39;&quot;&#39;))    }})</code></pre><p><code>next</code>方法中，第一行，检查当前是否为 Generator 函数的最后一步，如果是就返回</p><p>第二行，确保每一步的返回值，是 Promise 对象</p><p>第三行，使用 then 方法，为返回值加上回调函数，然后通过 onFulfilled 函数再次调用 next 函数</p><p>第四行，在参数不符合要求的情况下(参数非 Thunk 函数和 Promise 对象)，将 Promise 对象的状态改为 rejected，从而终止执行</p><p>co 支持并发的异步操作，即允许某些操作同时进行，等到它们全部完成，才进行下一步，我们可以并发的操作放在数组或对象里面，如下</p><pre><code class="js">// 数组的写法co(function* () {  var res = yield [Promise.resolve(1), Promise.resolve(2)]  console.log(res)}).catch(onerror)// 对象的写法co(function* () {  var res = yield {    1: Promise.resolve(1),    2: Promise.resolve(2),  }  console.log(res)}).catch(onerror)</code></pre><p>——-👇——-</p><p>以上就是 co 的内容了，这里提及只是为了让大家了解 co 这种函数库，虽然目前用的不多，但是对我们理解 Generator 有帮助，即使这里有些迷糊，也无伤大雅，知道 co 是什么，co 的自动执行原理大概是怎么实现的就行</p><p>这块和 Thunk 一样，也是参考阮一峰老师的文章，所以有兴趣的话可以看下参考链接【10】</p><h3 id="Generator-优-缺"><a href="#Generator-优-缺" class="headerlink" title="Generator 优/缺"></a>Generator 优/缺</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>优雅的流程控制方式，可以让函数可中断执行，在某些特殊需求里还是很实用的</p><p>使用过 React-dva 的同学可能会更有感触一些</p><p>之前 Node 的 koa 框架也用 Generator，不过后来被 async/await 替代了</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>Generator 函数的执行必须靠执行器，所以才有了 co 函数库，但 co 模块约定，yield 命令后面只能是 Thunk 函数或 Promise 对象，只针对异步处理来说，还是不太方便</p><h2 id="Async-Await"><a href="#Async-Await" class="headerlink" title="Async/Await"></a>Async/Await</h2><h3 id="Async-和-Await-简介"><a href="#Async-和-Await-简介" class="headerlink" title="Async 和 Await 简介"></a>Async 和 Await 简介</h3><p>ES2017 标准引入了 <code>async</code> 函数，使得异步操作变得更加方便</p><p>JS 异步编程解决方案的历程，从经典的回调函数到事件监听，再到 <code>Promise</code> ，再到 <code>Generator</code> ，再到我们要说的 <code>Async/Await</code> ，可谓艰辛</p><p><code>Async/Await</code> 的出现，被很多人认为是 JS 异步操作的最终且最优雅的解决方案</p><p><code>Async/Await</code> 大家都经常使用，也都知道它是 <code>Generator</code> 的语法糖</p><p>其实我觉得 <code>Async/Await = Generator + Promise</code> 这个解释更适合</p><p><code>async</code> 是异步的意思，而 <code>await</code> 是 <code>async wait</code> 的简写，即异步等待</p><p>所以从语义上就很好理解 <code>async</code> 用于声明一个 <code>function</code> 是异步的，<code>await</code> 用于等待一个异步方法执行完成</p><p>另外 <code>await</code> 只能出现在 <code>async</code> 函数中</p><p>闲聊至此，接下来还是简单介绍下使用</p><h3 id="Async-在做什么"><a href="#Async-在做什么" class="headerlink" title="Async 在做什么"></a>Async 在做什么</h3><p>我们来看一个例子理解</p><pre><code class="js">async function test() {  return &quot;this is async&quot;}const res = test()console.log(res)// Promise {&lt;resolved&gt;: &quot;this is async&quot;}</code></pre><p>可以看到，输出的是一个 Promise 对象</p><p>所以，<code>async</code> 函数返回的是一个 Promise 对象，如果在 <code>async</code> 函数中直接 return 一个直接量，<code>async</code> 会把这个直接量通过 <code>PromIse.resolve()</code> 封装成 Promise 对象返回</p><p>既然 <code>async</code> 返回一个 Promise，那么我们也可以用 <code>then</code> 链来处理这个 Promise 对象，如下</p><pre><code class="js">test().then((res) =&gt; {  console.log(res)})</code></pre><h3 id="Await-在等待什么"><a href="#Await-在等待什么" class="headerlink" title="Await 在等待什么"></a>Await 在等待什么</h3><p>我们常说<code>await</code> 是在等待一个异步完成， 其实按照语法说明， <code>await</code> 等待的是一个表达式，这个表达式的计算结果是 Promise 对象或者其它值(换句话说，就是没有特殊限定，啥都行)</p><ul><li><code>await</code> 后面不是 Promise 对象，直接执行</li><li><code>await</code> 后面是 Promise 对象会阻塞后面的代码，Promise 对象 <code>resolve</code>，然后得到 <code>resolve</code> 的值，作为 <code>await</code> 表达式的运算结果</li><li><code>await</code> 只能在 <code>async</code> 函数中使用</li></ul><p>使用比较简单，大家也经常用就不多说了</p><p>简单说一下为什 <code>await</code> 必须要在 <code>async</code> 函数中使用</p><p>其实很简单， <code>await</code> 会阻塞后面代码，如果允许我们直接使用 <code>await</code> 的话，假如我们使用<code>await</code>等待一个消耗时间比较长的异步请求，那代码直接就阻塞不往下执行了，只能等待 <code>await</code> 拿到结果才会执行下面的代码，那不乱套了</p><p>而 <code>async</code> 函数调用不会造成阻塞，因为它内部所有的阻塞都被封装在一个 Promise 对象中异步执行，所以才规定 <code>await</code> 必须在 <code>async</code> 函数中</p><h3 id="处理异常"><a href="#处理异常" class="headerlink" title="处理异常"></a>处理异常</h3><p>promise 正常 resolve，那么 await 会返回这个结果，但是在 reject 的情况下会抛出一个错误</p><p>所以我们直接把 <code>await</code> 代码块写到 <code>try()catch()</code> 中捕获错误即可</p><pre><code class="js">async function fn() {  try {    let res = await ajax()    console.log(res)  } catch (err) {    console.log(err)  }}</code></pre><h3 id="没有对比没有伤害"><a href="#没有对比没有伤害" class="headerlink" title="没有对比没有伤害"></a>没有对比没有伤害</h3><p>我们经常会遇到这种业务，多个请求，每个请求依赖于上一个请求的结果</p><p>我们用 setTimeout 模拟异步操作，用 Promise 和 Async/Await 分别来实现下</p><pre><code class="js">function analogAsync(n) {  return new Promise((resolve) =&gt; {    setTimeout(() =&gt; resolve(n + 500), n)  })}function fn1(n) {  console.log(`step1 with ${n}`)  return analogAsync(n)}function fn2(n) {  console.log(`step2 with ${n}`)  return analogAsync(n)}function fn3(n) {  console.log(`step3 with ${n}`)  return analogAsync(n)}</code></pre><p>使用 Promise</p><pre><code class="js">function fn() {  let time1 = 0  fn1(time1)    .then((time2) =&gt; fn2(time2))    .then((time3) =&gt; fn3(time3))    .then((res) =&gt; {      console.log(`result is ${res}`)    })}fn()</code></pre><p>使用 Async/Await</p><pre><code class="js">async function fn() {  let time1 = 0  let time2 = await fn1(time1)  let time3 = await fn2(time2)  let res = await fn3(time3)  console.log(`result is ${res}`)}fn()</code></pre><p>输出结果和上面用 Promise 实现是一样的，但这个 <code>aaync/await</code> 代码结构看起来清晰得多，几乎跟同步写法一样，十分优雅</p><p>我们再来看下面这个小例子</p><pre><code class="js">// Generatorfunction* gen() {  let f1 = yield ajax()  let f2 = yield ajax()}gen()// async/awaitasync function asyncAjax() {  let f1 = await ajax()  let f2 = await ajax()}asyncAjax()</code></pre><p>这两块代码看着是不是几乎一样</p><p>上面函数为 Generator 函数执行两个 ajax，下面函数为 async/await 执行</p><p>比较可发现，两个函数其实是一样的，<code>async</code> 不过是把 Generator 函数的 <code>*</code> 号换成 <code>async</code>，<code>yield</code> 换成 <code>await</code></p><p>那么这两个函数在调用时，Generator 函数需要手动调用 <code>next</code> 方法或者使用 co 函数库才可执行，而下面的<code>async</code> 函数直接就按顺序执行完成了，使用非常方便</p><p>异步编程追求的是，让它更像同步编程， <code>Async/Await</code> 完美诠释了这一点</p><p>到这里我们其实就不难看出 <code>Async/Await</code> 已经完虐了 <code>Generator</code> 和 <code>Promise</code></p><p>对比来看我们发现，Async 函数自带执行器</p><h3 id="Async-Await-优-缺"><a href="#Async-Await-优-缺" class="headerlink" title="Async/Await 优/缺"></a>Async/Await 优/缺</h3><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><p>内置执行器， Generator 函数的执行必须靠执行器，所以才有了 co 函数库，而 <code>async</code> 函数自带执行器，也就是说，<code>async</code> 函数的执行，与普通函数一模一样，只要一行</p><p>更好的语义，<code>async</code> 和 <code>await</code>，比起 <code>*</code> 和 <code>yield</code>，语义更清楚了，<code>async</code> 表示函数里有异步操作，<code>await</code> 表示紧跟在后面的表达式需要等待结果</p><p>更广的适用性，co 函数库约定，<code>yield</code> 命令后面只能是 Thunk 函数或 Promise 对象，而 <code>async</code> 函数的 <code>await</code> 命令后面，可以跟 Promise 对象和原始类型的值(数值、字符串和布尔值，但这时等同于同步操作)</p><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><p>滥用 <code>await</code> 可能会导致性能问题，因为 <code>await</code> 会阻塞代码，也许之后的异步代码并不依赖于前者，但仍然需要等待前者完成，导致代码失去了并发性</p><h2 id="异步解决方案对比"><a href="#异步解决方案对比" class="headerlink" title="异步解决方案对比"></a>异步解决方案对比</h2><p>别看了，我没有总结对比</p><p>其实相对来说已经写的很详细了，能讲出来的才算是自己的，大家可根据每种方案列出的优缺点加上自己的理解做个对比或着说总结，毕竟你都看到这了，也不妄花费这么长时间来阅读这两万字的干帖子，总归要有些收获的</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>水平有限，欢迎指错</p><p>码字不易，大家有收获别忘了点个赞鼓励下</p><p>搜索【不正经的前端】或直接扫码可以关注公众号看到更多的精彩文章，也有一些群友提供的学习视频、资源干货什么的免费拿</p><p>也可以直接加我微信，进交流群学习交流</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/qqz.png" srcset="/blog/img/loading.gif" alt=""></p><blockquote><p>参考</p><ol><li><a href="[http://www.ruanyifeng.com/blog/2012/12/asynchronous%EF%BC%BFjavascript.html](http://www.ruanyifeng.com/blog/2012/12/asynchronous＿javascript.html)">Javascript 异步编程的 4 种方法-阮一峰</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener">Promise-MDN</a></li><li><a href="https://www.liaoxuefeng.com/wiki/1022910821149312/1023024358748480" target="_blank" rel="noopener">iterable-廖雪峰</a></li><li><a href="http://cryto.net/~joepie91/blog/2016/05/11/what-is-promise-try-and-why-does-it-matter/" target="_blank" rel="noopener">What is Promise.try, and why does it matter?</a></li><li><a href="https://segmentfault.com/a/1190000018586947" target="_blank" rel="noopener">什么是 Promise.try，为什么它这么重要？-参考 4 译</a></li><li><a href="https://promisesaplus.com/" target="_blank" rel="noopener">Promise/A+规范-英原文</a></li><li><a href="http://www.ituring.com.cn/article/66566" target="_blank" rel="noopener">Promise/A+规范-中文译</a></li><li><a href="http://www.ruanyifeng.com/blog/2015/04/generator.html" target="_blank" rel="noopener">Generator 函数的含义与用法-阮一峰</a></li><li><a href="http://www.ruanyifeng.com/blog/2015/05/thunk.html" target="_blank" rel="noopener">Thunk 函数的含义和用法-阮一峰</a></li><li><a href="http://www.ruanyifeng.com/blog/2015/05/co.html" target="_blank" rel="noopener">co 函数库的含义和用法-阮一峰</a></li></ol></blockquote>]]></content>
    
    
    <categories>
      
      <category>硬核JS系列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「硬核 JS」一次搞懂 JS 运行机制</title>
    <link href="/blog/2020/01/18/javascript/%E3%80%8C%E7%A1%AC%E6%A0%B8JS%E3%80%8D%E4%B8%80%E6%AC%A1%E6%90%9E%E6%87%82JS%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/"/>
    <url>/blog/2020/01/18/javascript/%E3%80%8C%E7%A1%AC%E6%A0%B8JS%E3%80%8D%E4%B8%80%E6%AC%A1%E6%90%9E%E6%87%82JS%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="「硬核-JS」一次搞懂-JS-运行机制"><a href="#「硬核-JS」一次搞懂-JS-运行机制" class="headerlink" title="「硬核 JS」一次搞懂 JS 运行机制"></a>「硬核 JS」一次搞懂 JS 运行机制</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>从开始做前端到目前为止，陆续看了很多帖子讲 JS 运行机制，看过不久就忘了，还是自己理一遍好些</p><p>通过码字使自己对 JS 运行机制相关内容更加深刻(自己用心写过的贴子，内容也会牢记于心)</p><p>顺道给大家看看(我太难了，深夜码字，反复修改，说这么多就是想请你点个赞在看)</p><p>参考了很多资料(帖子)，取其精华，去其糟糠，都在文末，可自行了解</p><p>是时候搞一波我大 js 了</p><p>从零到一百再到一，从多方面了解 JS 的运行机制，体会更深刻，请认真读下去</p><p>本文大致分为以下这样的步骤来帮助我们由广入深更加清晰的了解 JS 运行机制</p><ul><li>首先我们要了解进程和线程的概念</li><li>其次我们要知道浏览器的进程线程常识</li><li>再然后通过 Event Loop、宏任务(macrotask)微任务(microtask)来看浏览器的几个线程间是怎样配合的</li><li>再然后通过例子来印证我们的猜想</li><li>最后提下 NodeJS 的运行机制</li></ul><h2 id="灵魂一问"><a href="#灵魂一问" class="headerlink" title="灵魂一问"></a>灵魂一问</h2><p>JS 运行机制在平常前端面试时不管是笔试题还是面试题命中率都极高</p><p>说到 JS 运行机制，你知道多少</p><p>看到这大家可能会说：JS 运行机制嘛，很简单，事件循环、宏微任务那点东西</p><p>是的，作为一名前端我们都了解，但是如果这真的面试问到了这个地方，你真的可以答好吗(灵魂一问 🤔️)</p><p><strong>不管你对 JS 了解多少，到这里大家不防先停止一下阅读，假设你目前在面试，面试官让你阐述下 JS 运行机制，思考下你的答案，用 20 秒的时间(面试时 20s 已经很长了)，然后带着答案再接着往下看，有人曾经说过：<code>没有思考的阅读纯粹是消磨时间罢了</code>，这话很好(因为是我说的，皮一下 😄)</strong></p><p>也有很多刚开始接触 JS 的同学会被<code>任务队列 执行栈 微任务 宏任务</code>这些高大上点的名字搞的很懵</p><p>接下来，我们来细致的梳理一遍你就可以清晰的了解它们了</p><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><h3 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程"></a>什么是进程</h3><p>我们都知道，<code>CPU</code>是计算机的核心，承担所有的计算任务</p><p>官网说法，<code>进程</code>是<code>CPU</code>资源分配的最小单位</p><p>字面意思就是进行中的程序，我将它理解为一个可以独立运行且拥有自己的资源空间的任务程序</p><p><code>进程</code>包括运行中的程序和程序所使用到的内存和系统资源</p><p><code>CPU</code>可以有很多进程，我们的电脑每打开一个软件就会产生一个或多个<code>进程</code>，为什么电脑运行的软件多就会卡，是因为<code>CPU</code>给每个<code>进程</code>分配资源空间，但是一个<code>CPU</code>一共就那么多资源，分出去越多，越卡，每个<code>进程</code>之间是相互独立的，<code>CPU</code>在运行一个<code>进程</code>时，其他的进程处于非运行状态，<code>CPU</code>使用 <a href="[https://baike.baidu.com/item/%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC%E8%B0%83%E5%BA%A6](https://baike.baidu.com/item/时间片轮转调度)">时间片轮转调度算法</a> 来实现同时运行多个<code>进程</code></p><h3 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h3><p><code>线程</code>是<code>CPU</code>调度的最小单位</p><p><code>线程</code>是建立在<code>进程</code>的基础上的一次程序运行单位，通俗点解释<code>线程</code>就是程序中的一个执行流，一个<code>进程</code>可以有多个<code>线程</code></p><p>一个<code>进程</code>中只有一个执行流称作<code>单线程</code>，即程序执行时，所走的程序路径按照连续顺序排下来，前面的必须处理好，后面的才会执行</p><p>一个<code>进程</code>中有多个执行流称作<code>多线程</code>，即在一个程序中可以同时运行多个不同的<code>线程</code>来执行不同的任务，<br>也就是说允许单个程序创建多个并行执行的<code>线程</code>来完成各自的任务</p><h3 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h3><p>进程是操作系统分配资源的最小单位，线程是程序执行的最小单位</p><p>一个进程由一个或多个线程组成，线程可以理解为是一个进程中代码的不同执行路线</p><p>进程之间相互独立，但同一进程下的各个线程间共享程序的内存空间(包括代码段、数据集、堆等)及一些进程级的资源(如打开文件和信号)</p><p>调度和切换：线程上下文切换比进程上下文切换要快得多</p><h3 id="多进程和多线程"><a href="#多进程和多线程" class="headerlink" title="多进程和多线程"></a>多进程和多线程</h3><p><strong>多进程：</strong>多进程指的是在同一个时间里，同一个计算机系统中如果允许两个或两个以上的进程处于运行状态。多进程带来的好处是明显的，比如大家可以在网易云听歌的同时打开编辑器敲代码，编辑器和网易云的进程之间不会相互干扰</p><p><strong>多线程：</strong>多线程是指程序中包含多个执行流，即在一个程序中可以同时运行多个不同的线程来执行不同的任务，也就是说允许单个程序创建多个并行执行的线程来完成各自的任务</p><h2 id="JS-为什么是单线程"><a href="#JS-为什么是单线程" class="headerlink" title="JS 为什么是单线程"></a>JS 为什么是单线程</h2><p>JS 的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript 的主要用途是与用户互动，以及操作 DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定 JavaScript 同时有两个线程，一个线程在某个 DOM 节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？</p><p>还有人说 js 还有 Worker 线程，对的，为了利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程，但是子线程是完 全受主线程控制的，而且不得操作 DOM</p><p>所以，这个标准并没有改变 JavaScript 是单线程的本质</p><p>了解了进程和线程之后，接下来看看浏览器解析，浏览器之间也是有些许差距的，不过大致是差不多的，下文我们皆用市场占有比例最大的 Chrome 为例</p><h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><h3 id="浏览器是多进程的"><a href="#浏览器是多进程的" class="headerlink" title="浏览器是多进程的"></a>浏览器是多进程的</h3><p>作为前端，免不了和浏览器打交道，浏览器是多进程的，拿 Chrome 来说，我们每打开一个 Tab 页就会产生一个进程，我们使用 Chrome 打开很多标签页不关，电脑会越来越卡，不说其他，首先就很耗 CPU</p><h3 id="浏览器包含哪些进程"><a href="#浏览器包含哪些进程" class="headerlink" title="浏览器包含哪些进程"></a>浏览器包含哪些进程</h3><ul><li><p>Browser 进程</p><ul><li>浏览器的主进程(负责协调、主控)，该进程只有一个</li><li>负责浏览器界面显示，与用户交互。如前进，后退等</li><li>负责各个页面的管理，创建和销毁其他进程</li><li>将渲染(Renderer)进程得到的内存中的 Bitmap(位图)，绘制到用户界面上</li><li>网络资源的管理，下载等</li></ul></li><li><p>第三方插件进程</p><ul><li>每种类型的插件对应一个进程，当使用该插件时才创建</li></ul></li><li><p>GPU 进程</p><ul><li>该进程也只有一个，用于 3D 绘制等等</li></ul></li><li><p>渲染进程(重)</p><ul><li>即通常所说的浏览器内核(Renderer 进程，内部是多线程)</li><li>每个 Tab 页面都有一个渲染进程，互不影响</li><li>主要作用为页面渲染，脚本执行，事件处理等</li></ul></li></ul><h3 id="为什么浏览器要多进程"><a href="#为什么浏览器要多进程" class="headerlink" title="为什么浏览器要多进程"></a>为什么浏览器要多进程</h3><p>我们假设浏览器是单进程，那么某个 Tab 页崩溃了，就影响了整个浏览器，体验有多差</p><p>同理如果插件崩溃了也会影响整个浏览器</p><p>当然多进程还有其它的诸多优势，不过多阐述</p><p>浏览器进程有很多，每个进程又有很多线程，都会占用内存</p><p>这也意味着内存等资源消耗会很大，有点拿空间换时间的意思</p><p>到此可不只是为了让我们理解为何 Chrome 运行时间长了电脑会卡，哈哈，第一个重点来了</p><h3 id="简述渲染进程-Renderer-重"><a href="#简述渲染进程-Renderer-重" class="headerlink" title="简述渲染进程 Renderer(重)"></a>简述渲染进程 Renderer(重)</h3><p>页面的渲染，JS 的执行，事件的循环，都在渲染进程内执行，所以我们要重点了解渲染进程</p><p>渲染进程是多线程的，我们来看渲染进程的一些常用较为主要的线程</p><h3 id="渲染进程-Renderer-的主要线程"><a href="#渲染进程-Renderer-的主要线程" class="headerlink" title="渲染进程 Renderer 的主要线程"></a>渲染进程 Renderer 的主要线程</h3><h4 id="GUI-渲染线程"><a href="#GUI-渲染线程" class="headerlink" title="GUI 渲染线程"></a>GUI 渲染线程</h4><ul><li>负责渲染浏览器界面，解析 HTML，CSS，构建 DOM 树和 RenderObject 树，布局和绘制等<ul><li>解析 html 代码(HTML 代码本质是字符串)转化为浏览器认识的节点，生成 DOM 树，也就是 DOM Tree</li><li>解析 css，生成 CSSOM(CSS 规则树)</li><li>把 DOM Tree 和 CSSOM 结合，生成 Rendering Tree(渲染树)</li></ul></li><li>当我们修改了一些元素的颜色或者背景色，页面就会重绘(Repaint)</li><li>当我们修改元素的尺寸，页面就会回流(Reflow)</li><li>当页面需要 Repaing 和 Reflow 时 GUI 线程执行，绘制页面</li><li>回流(Reflow)比重绘(Repaint)的成本要高，我们要尽量避免 Reflow 和 Repaint</li><li>GUI 渲染线程与 JS 引擎线程是互斥的<ul><li>当 JS 引擎执行时 GUI 线程会被挂起(相当于被冻结了)</li><li>GUI 更新会被保存在一个队列中等到 JS 引擎空闲时立即被执行</li></ul></li></ul><h4 id="JS-引擎线程"><a href="#JS-引擎线程" class="headerlink" title="JS 引擎线程"></a>JS 引擎线程</h4><ul><li>JS 引擎线程就是 JS 内核，负责处理 Javascript 脚本程序(例如 V8 引擎)</li><li>JS 引擎线程负责解析 Javascript 脚本，运行代码</li><li>JS 引擎一直等待着任务队列中任务的到来，然后加以处理<ul><li>浏览器同时只能有一个 JS 引擎线程在运行 JS 程序，所以 js 是单线程运行的</li><li>一个 Tab 页(renderer 进程)中无论什么时候都只有一个 JS 线程在运行 JS 程序</li></ul></li><li>GUI 渲染线程与 JS 引擎线程是互斥的，js 引擎线程会阻塞 GUI 渲染线程<ul><li>就是我们常遇到的 JS 执行时间过长，造成页面的渲染不连贯，导致页面渲染加载阻塞(就是加载慢)</li><li>例如浏览器渲染的时候遇到<code>&lt;script&gt;</code>标签，就会停止 GUI 的渲染，然后 js 引擎线程开始工作，执行里面的 js 代码，等 js 执行完毕，js 引擎线程停止工作，GUI 继续渲染下面的内容。所以如果 js 执行时间太长就会造成页面卡顿的情况</li></ul></li></ul><h4 id="事件触发线程"><a href="#事件触发线程" class="headerlink" title="事件触发线程"></a>事件触发线程</h4><ul><li>属于浏览器而不是 JS 引擎，用来控制事件循环，并且管理着一个事件队列(task queue)</li><li>当 js 执行碰到事件绑定和一些异步操作(如 setTimeOut，也可来自浏览器内核的其他线程，如鼠标点击、AJAX 异步请求等)，会走事件触发线程将对应的事件添加到对应的线程中(比如定时器操作，便把定时器事件添加到定时器线程)，等异步事件有了结果，便把他们的回调操作添加到事件队列，等待 js 引擎线程空闲时来处理。</li><li>当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待 JS 引擎的处理</li><li>因为 JS 是单线程，所以这些待处理队列中的事件都得排队等待 JS 引擎处理</li></ul><h4 id="定时触发器线程"><a href="#定时触发器线程" class="headerlink" title="定时触发器线程"></a>定时触发器线程</h4><ul><li><code>setInterval</code>与<code>setTimeout</code>所在线程</li><li>浏览器定时计数器并不是由 JavaScript 引擎计数的(因为 JavaScript 引擎是单线程的，如果处于阻塞线程状态就会影响记计时的准确)</li><li>通过单独线程来计时并触发定时(计时完毕后，添加到事件触发线程的事件队列中，等待 JS 引擎空闲后执行)，这个线程就是定时触发器线程，也叫定时器线程</li><li>W3C 在 HTML 标准中规定，规定要求<code>setTimeout</code>中低于 4ms 的时间间隔算为 4ms</li></ul><h4 id="异步-http-请求线程"><a href="#异步-http-请求线程" class="headerlink" title="异步 http 请求线程"></a>异步 http 请求线程</h4><ul><li>在 XMLHttpRequest 在连接后是通过浏览器新开一个线程请求</li><li>将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中再由 JavaScript 引擎执行</li><li>简单说就是当执行到一个 http 异步请求时，就把异步请求事件添加到异步请求线程，等收到响应(准确来说应该是 http 状态变化)，再把回调函数添加到事件队列，等待 js 引擎线程来执行</li></ul><p>了解了上面这些基础后，接下来我们开始进入今天的正题</p><h2 id="事件循环-Event-Loop-初探"><a href="#事件循环-Event-Loop-初探" class="headerlink" title="事件循环(Event Loop)初探"></a>事件循环(Event Loop)初探</h2><p>首先要知道，JS 分为同步任务和异步任务</p><p>同步任务都在主线程(这里的主线程就是 JS 引擎线程)上执行，会形成一个<code>执行栈</code></p><p>主线程之外，事件触发线程管理着一个<code>任务队列</code>，只要异步任务有了运行结果，就在<code>任务队列</code>之中放一个事件回调</p><p>一旦<code>执行栈</code>中的所有同步任务执行完毕(也就是 JS 引擎线程空闲了)，系统就会读取<code>任务队列</code>，将可运行的异步任务(任务队列中的事件回调，只要任务队列中有事件回调，就说明可以执行)添加到执行栈中，开始执行</p><p>我们来看一段简单的代码</p><pre><code class="js">let setTimeoutCallBack = function () {  console.log(&quot;我是定时器回调&quot;)}let httpCallback = function () {  console.log(&quot;我是http请求回调&quot;)}// 同步任务console.log(&quot;我是同步任务1&quot;)// 异步定时任务setTimeout(setTimeoutCallBack, 1000)// 异步http请求任务ajax.get(&quot;/info&quot;, httpCallback)// 同步任务console.log(&quot;我是同步任务2&quot;)</code></pre><p>上述代码执行过程</p><p>JS 是按照顺序从上往下依次执行的，可以先理解为这段代码时的执行环境就是主线程，也就是也就是当前执行栈</p><p>首先，执行<code>console.log(&#39;我是同步任务1&#39;)</code></p><p>接着，执行到<code>setTimeout</code>时，会移交给<code>定时器线程</code>，通知<code>定时器线程</code> 1s 后将 <code>setTimeoutCallBack</code> 这个回调交给<code>事件触发线程</code>处理，在 1s 后<code>事件触发线程</code>会收到 <code>setTimeoutCallBack</code> 这个回调并把它加入到<code>事件触发线程</code>所管理的事件队列中等待执行</p><p>接着，执行 http 请求，会移交给<code>异步http请求线程</code>发送网络请求，请求成功后将 <code>httpCallback</code> 这个回调交由事件触发线程处理，<code>事件触发线程</code>收到 <code>httpCallback</code> 这个回调后把它加入到<code>事件触发线程</code>所管理的事件队列中等待执行</p><p>再接着执行<code>console.log(&#39;我是同步任务2&#39;)</code>1</p><p>至此主线程执行栈中执行完毕，<code>JS引擎线程</code>已经空闲，开始向<code>事件触发线程</code>发起询问，询问<code>事件触发线程</code>的事件队列中是否有需要执行的回调函数，如果有将事件队列中的回调事件加入执行栈中，开始执行回调，如果事件队列中没有回调，<code>JS引擎线程</code>会一直发起询问，直到有为止</p><p>到了这里我们发现，浏览器上的所有线程的工作都很单一且独立，非常符合单一原则</p><p>定时触发线程只管理定时器且只关注定时不关心结果，定时结束就把回调扔给事件触发线程</p><p>异步 http 请求线程只管理 http 请求同样不关心结果，请求结束把回调扔给事件触发线程</p><p>事件触发线程只关心异步回调入事件队列</p><p>而我们 JS 引擎线程只会执行执行栈中的事件，执行栈中的代码执行完毕，就会读取事件队列中的事件并添加到执行栈中继续执行，这样反反复复就是我们所谓的<strong>事件循环(Event Loop)</strong></p><p><strong>图解</strong></p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/Xnip2020-01-14_09-51-281.jpg" srcset="/blog/img/loading.gif" alt="Xnip2020-01-14_09-51-28"></p><p>首先，执行栈开始顺序执行</p><p>判断是否为同步，异步则进入异步线程，最终事件回调给事件触发线程的任务队列等待执行，同步继续执行</p><p>执行栈空，询问任务队列中是否有事件回调</p><p>任务队列中有事件回调则把回调加入执行栈末尾继续从第一步开始执行</p><p>任务队列中没有事件回调则不停发起询问</p><h2 id="宏任务-macrotask-amp-微任务-microtask"><a href="#宏任务-macrotask-amp-微任务-microtask" class="headerlink" title="宏任务(macrotask) &amp; 微任务(microtask)"></a>宏任务(macrotask) &amp; 微任务(microtask)</h2><h3 id="宏任务-macrotask"><a href="#宏任务-macrotask" class="headerlink" title="宏任务(macrotask)"></a>宏任务(macrotask)</h3><p>在 ECMAScript 中，<code>macrotask</code>也被称为<code>task</code></p><p>我们可以将每次执行栈执行的代码当做是一个宏任务(包括每次从事件队列中获取一个事件回调并放到执行栈中执行)， 每一个宏任务会从头到尾执行完毕，不会执行其他</p><p>由于<code>JS引擎线程</code>和<code>GUI渲染线程</code>是互斥的关系，浏览器为了能够使<code>宏任务</code>和<code>DOM任务</code>有序的进行，会在一个<code>宏任务</code>执行结果后，在下一个<code>宏任务</code>执行前，<code>GUI渲染线程</code>开始工作，对页面进行渲染</p><pre><code class="js">宏任务 -&gt; GUI渲染 -&gt; 宏任务 -&gt; ...</code></pre><p>常见的宏任务</p><ul><li>主代码块</li><li>setTimeout</li><li>setInterval</li><li>setImmediate ()-Node</li><li>requestAnimationFrame ()-浏览器</li></ul><h3 id="微任务-microtask"><a href="#微任务-microtask" class="headerlink" title="微任务(microtask)"></a>微任务(microtask)</h3><p>ES6 新引入了 Promise 标准，同时浏览器实现上多了一个<code>microtask</code>微任务概念，在 ECMAScript 中，<code>microtask</code>也被称为<code>jobs</code></p><p>我们已经知道<code>宏任务</code>结束后，会执行渲染，然后执行下一个<code>宏任务</code>， 而微任务可以理解成在当前<code>宏任务</code>执行后立即执行的任务</p><p>当一个<code>宏任务</code>执行完，会在渲染前，将执行期间所产生的所有<code>微任务</code>都执行完</p><pre><code class="js">宏任务 -&gt; 微任务 -&gt; GUI渲染 -&gt; 宏任务 -&gt; ...</code></pre><p>常见微任务</p><ul><li>process.nextTick ()-Node</li><li>Promise.then()</li><li>catch</li><li>finally</li><li>Object.observe</li><li>MutationObserver</li></ul><h3 id="简单区分宏任务与微任务"><a href="#简单区分宏任务与微任务" class="headerlink" title="简单区分宏任务与微任务"></a>简单区分宏任务与微任务</h3><p>看了上述宏任务微任务的解释你可能还不太清楚，没关系，往下看，先记住那些常见的宏微任务即可</p><p>我们通过几个例子来看，这几个例子思路来自掘金<code>云中君</code>的文章参考链接【14】，通过渲染背景颜色来区分宏任务和微任务，很直观，我觉得很有意思，所以这里也用这种例子</p><p>找一个空白的页面，在 console 中输入以下代码</p><pre><code class="js">document.body.style = &quot;background:black&quot;document.body.style = &quot;background:red&quot;document.body.style = &quot;background:blue&quot;document.body.style = &quot;background:pink&quot;</code></pre><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/Jan-12-2020__01-05-49.gif" srcset="/blog/img/loading.gif" alt="Jan-12-2020 01-05-49"></p><p>我们看到上面动图背景直接渲染了粉红色，根据上文里讲浏览器会先执行完一个宏任务，再执行当前执行栈的所有微任务，然后移交 GUI 渲染，上面四行代码均属于同一次宏任务，全部执行完才会执行渲染，渲染时<code>GUI线程</code>会将所有 UI 改动优化合并，所以视觉上，只会看到页面变成粉红色</p><p>再接着看</p><pre><code class="js">document.body.style = &quot;background:blue&quot;setTimeout(() =&gt; {  document.body.style = &quot;background:black&quot;}, 200)</code></pre><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/Jan-12-2020__01-28-41.gif" srcset="/blog/img/loading.gif" alt="Jan-12-2020 01-28-41"></p><p>上述代码中，页面会先卡一下蓝色，再变成黑色背景，页面上写的是 200 毫秒，大家可以把它当成 0 毫秒，因为 0 毫秒的话由于浏览器渲染太快，录屏不好捕捉，我又没啥录屏慢放的工具，大家可以自行测试的，结果也是一样，最安全的方法是写一个<code>index.html</code>文件，在这个文件中插入上面的 js 脚本，然后浏览器打开，谷歌下使用控制台中<code>performance</code>功能查看一帧一帧的加载最为恰当，不过这样录屏不好录所以。。。</p><p>回归正题，之所以会卡一下蓝色，是因为以上代码属于两次<code>宏任务</code>，第一次<code>宏任务</code>执行的代码是将背景变成蓝色，然后触发渲染，将页面变成蓝色，再触发第二次宏任务将背景变成黑色</p><p>再来看</p><pre><code class="js">document.body.style = &quot;background:blue&quot;console.log(1)Promise.resolve().then(() =&gt; {  console.log(2)  document.body.style = &quot;background:pink&quot;})console.log(3)</code></pre><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/Jan-12-202__01-31-42.gif" srcset="/blog/img/loading.gif" alt="Jan-12-2020 01-31-42"></p><p>控制台输出 1 3 2 , 是因为 promise 对象的 then 方法的回调函数是异步执行，所以 2 最后输出</p><p>页面的背景色直接变成粉色，没有经过蓝色的阶段，是因为，我们在宏任务中将背景设置为蓝色，但在进行渲染前执行了微任务， 在微任务中将背景变成了粉色，然后才执行的渲染</p><h3 id="微任务宏任务注意点"><a href="#微任务宏任务注意点" class="headerlink" title="微任务宏任务注意点"></a>微任务宏任务注意点</h3><ul><li><p>浏览器会先执行一个宏任务，紧接着执行当前执行栈产生的微任务，再进行渲染，然后再执行下一个宏任务</p><p>微任务和宏任务不在一个任务队列，不在一个任务队列</p><ul><li>例如<code>setTimeout</code>是一个宏任务，它的事件回调在宏任务队列，<code>Promise.then()</code>是一个微任务，它的事件回调在微任务队列，二者并不是一个任务队列</li><li>以 Chrome 为例，有关渲染的都是在渲染进程中执行，渲染进程中的任务（DOM 树构建，js 解析…等等）需要主线程执行的任务都会在主线程中执行，而浏览器维护了一套事件循环机制，主线程上的任务都会放到消息队列中执行，主线程会循环消息队列，并从头部取出任务进行执行，如果执行过程中产生其他任务需要主线程执行的，渲染进程中的其他线程会把该任务塞入到消息队列的尾部，消息队列中的任务都是宏任务</li><li>微任务是如何产生的呢？当执行到 script 脚本的时候，js 引擎会为全局创建一个执行上下文，在该执行上下文中维护了一个微任务队列，当遇到微任务，就会把微任务回调放在微队列中，当所有的 js 代码执行完毕，在退出全局上下文之前引擎会去检查该队列，有回调就执行，没有就退出执行上下文，这也就是为什么微任务要早于宏任务，也是大家常说的，每个宏任务都有一个微任务队列（由于定时器是浏览器的 API，所以定时器是宏任务，在 js 中遇到定时器会也是放入到浏览器的队列中）</li></ul></li></ul><p>此时，你可能还很迷惑，没关系，请接着往下看</p><h3 id="图解宏任务和微任务"><a href="#图解宏任务和微任务" class="headerlink" title="图解宏任务和微任务"></a>图解宏任务和微任务</h3><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/Xnip2020-01-14_00-58-171.jpg" srcset="/blog/img/loading.gif" alt="Xnip2020-01-14_00-58-17"></p><p>首先执行一个宏任务，执行结束后判断是否存在微任务</p><p>有微任务先执行所有的微任务，再渲染，没有微任务则直接渲染</p><p>然后再接着执行下一个宏任务</p><h2 id="图解完整的-Event-Loop"><a href="#图解完整的-Event-Loop" class="headerlink" title="图解完整的 Event Loop"></a>图解完整的 Event Loop</h2><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/Xnip2020-01-14_17-20-441.jpg" srcset="/blog/img/loading.gif" alt="Xnip2020-01-14_17-20-44"></p><p>首先，整体的 script(作为第一个宏任务)开始执行的时候，会把所有代码分为<code>同步任务</code>、<code>异步任务</code>两部分</p><p>同步任务会直接进入主线程依次执行</p><p>异步任务会再分为宏任务和微任务</p><p>宏任务进入到 Event Table 中，并在里面注册回调函数，每当指定的事件完成时，Event Table 会将这个函数移到 Event Queue 中</p><p>微任务也会进入到另一个 Event Table 中，并在里面注册回调函数，每当指定的事件完成时，Event Table 会将这个函数移到 Event Queue 中</p><p>当主线程内的任务执行完毕，主线程为空时，会检查微任务的 Event Queue，如果有任务，就全部执行，如果没有就执行下一个宏任务</p><p>上述过程会不断重复，这就是 Event Loop，比较完整的事件循环</p><h2 id="关于-Promise"><a href="#关于-Promise" class="headerlink" title="关于 Promise"></a>关于 Promise</h2><p><code>new Promise(() =&gt; {}).then()</code> ，我们来看这样一个 Promise 代码</p><p>前面的 <code>new Promise()</code> 这一部分是一个构造函数，这是一个同步任务</p><p>后面的 <code>.then()</code> 才是一个异步微任务，这一点是非常重要的</p><pre><code class="js">new Promise((resolve) =&gt; {  console.log(1)  resolve()}).then(() =&gt; {  console.log(2)})console.log(3)</code></pre><p>上面代码输出<code>1 3 2</code></p><h2 id="关于-async-await-函数"><a href="#关于-async-await-函数" class="headerlink" title="关于 async/await 函数"></a>关于 async/await 函数</h2><p>async/await 本质上还是基于 Promise 的一些封装，而 Promise 是属于微任务的一种</p><p>所以在使用 await 关键字与 Promise.then 效果类似</p><pre><code class="js">setTimeout(() =&gt; console.log(4))async function test() {  console.log(1)  await Promise.resolve()  console.log(3)}test()console.log(2)</code></pre><p>上述代码输出<code>1 2 3 4</code></p><p>可以理解为，<code>await</code> 以前的代码，相当于与 <code>new Promise</code> 的同步代码，<code>await</code> 以后的代码相当于 <code>Promise.then</code>的异步</p><h2 id="举栗印证"><a href="#举栗印证" class="headerlink" title="举栗印证"></a>举栗印证</h2><p>首先给大家来一个比较直观的动图</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/Jan-14-2020__00-03-22.gif" srcset="/blog/img/loading.gif" alt="Jan-14-2020 00-03-22"></p><p>之所以放这个动图，就是为了向大家推荐这篇好文，动图录屏自参考链接【1】</p><p>极力推荐大家看看这篇帖子，非常 nice，分步动画生动且直观，有时间的话可以自己去体验下</p><p>不过在看这个帖子之前你要先了解下运行机制会更好读懂些</p><p>接下来这个来自网上随意找的一个比较简单的面试题，求输出结果</p><pre><code class="js">function test() {  console.log(1)  setTimeout(function () {    // timer1    console.log(2)  }, 1000)}test()setTimeout(function () {  // timer2  console.log(3)})new Promise(function (resolve) {  console.log(4)  setTimeout(function () {    // timer3    console.log(5)  }, 100)  resolve()}).then(function () {  setTimeout(function () {    // timer4    console.log(6)  }, 0)  console.log(7)})console.log(8)</code></pre><p>结合我们上述的 JS 运行机制再来看这道题就简单明了的多了</p><p>JS 是顺序从上而下执行</p><p>执行到 test()，test 方法为同步，直接执行，<code>console.log(1)</code>打印 1</p><p>test 方法中 setTimeout 为异步宏任务，回调我们把它记做 timer1 放入宏任务队列</p><p>接着执行，test 方法下面有一个 setTimeout 为异步宏任务，回调我们把它记做 timer2 放入宏任务队列</p><p>接着执行 promise，new Promise 是同步任务，直接执行，打印 4</p><p>new Promise 里面的 setTimeout 是异步宏任务，回调我们记做 timer3 放到宏任务队列</p><p>Promise.then 是微任务，放到微任务队列</p><p>console.log(8)是同步任务，直接执行，打印 8</p><p>主线程任务执行完毕，检查微任务队列中有 Promise.then</p><p>开始执行微任务，发现有 setTimeout 是异步宏任务，记做 timer4 放到宏任务队列</p><p>微任务队列中的 console.log(7)是同步任务，直接执行，打印 7</p><p>微任务执行完毕，第一次循环结束</p><p>检查宏任务队列，里面有 timer1、timer2、timer3、timer4，四个定时器宏任务，按照定时器延迟时间得到可以执行的顺序，即 Event Queue：timer2、timer4、timer3、timer1，依次拿出放入执行栈末尾执行<strong>(插播一条：浏览器 event loop 的 Macrotask queue，就是宏任务队列在每次循环中只会读取一个任务)</strong></p><p>执行 timer2，console.log(3)为同步任务，直接执行，打印 3</p><p>检查没有微任务，第二次 Event Loop 结束</p><p>执行 timer4，console.log(6)为同步任务，直接执行，打印 6</p><p>检查没有微任务，第三次 Event Loop 结束</p><p>执行 timer3，console.log(5)同步任务，直接执行，打印 5</p><p>检查没有微任务，第四次 Event Loop 结束</p><p>执行 timer1，console.log(2)同步任务，直接执行，打印 2</p><p>检查没有微任务，也没有宏任务，第五次 Event Loop 结束</p><p>结果：1，4，8，7，3，6，5，2</p><h2 id="提一下-NodeJS-中的运行机制"><a href="#提一下-NodeJS-中的运行机制" class="headerlink" title="提一下 NodeJS 中的运行机制"></a>提一下 NodeJS 中的运行机制</h2><p>上面的一切都是针对于浏览器的 EventLoop</p><p>虽然 NodeJS 中的 JavaScript 运行环境也是 V8，也是单线程，但是，还是有一些与浏览器中的表现是不一样的</p><p>其实 nodejs 与浏览器的区别，就是 nodejs 的宏任务分好几种类型，而这好几种又有不同的任务队列，而不同的任务队列又有顺序区别，而微任务是穿插在每一种宏任务之间的</p><p>在 node 环境下，process.nextTick 的优先级高于 Promise，可以简单理解为在宏任务结束后会先执行微任务队列中的 nextTickQueue 部分，然后才会执行微任务中的 Promise 部分</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/Xnip2020-01-18_14-50-011.jpg" srcset="/blog/img/loading.gif" alt="Xnip2020-01-18_14-50-01"></p><p>上图来自 NodeJS 官网</p><p>如上图所示，nodejs 的宏任务分好几种类型，我们只简单介绍大体内容了解，不详细解释，不然又是啰哩啰嗦一大篇</p><p>NodeJS 的 Event Loop 相对比较麻烦</p><pre><code class="js">Node会先执行所有类型为 timers 的 MacroTask，然后执行所有的 MicroTask(NextTick例外)进入 poll 阶段，执行几乎所有 MacroTask，然后执行所有的 MicroTask再执行所有类型为 check 的 MacroTask，然后执行所有的 MicroTask再执行所有类型为 close callbacks 的 MacroTask，然后执行所有的 MicroTask至此，完成一个 Tick，回到 timers 阶段……如此反复，无穷无尽……</code></pre><p>反观浏览器中 Event Loop 就比较容易理解</p><pre><code class="js">先执行一个 MacroTask，然后执行所有的 MicroTask再执行一个 MacroTask，然后执行所有的 MicroTask……如此反复，无穷无尽……</code></pre><p>好了，关于 Node 中各个类型阶段的解析，这里就不过多说明了，自己查阅资料吧，这里就是简单提一下，NodeJS 的 Event Loop 解释起来比浏览器这繁杂，这里就只做个对比</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>上面的流程图都是自己画的，所以有点 low，见谅</p><p>水平有限，欢迎指错</p><p>码字不易，看完对你有帮助请点赞，有疑问请评论提出</p><p>最近拾起了一个被冻结的公众号，又重新搞了下</p><p>欢迎大家关注【不正经的前端】，加我，加群，或者拿一些资料都可以的，时不时发一些优质原创</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/qqz.png" srcset="/blog/img/loading.gif" alt=""></p><blockquote><p>参考</p><ol><li><p><a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/?utm_source=html5weekly" target="_blank" rel="noopener">Tasks, microtasks, queues and schedules - 重点推荐阅读</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/32751855" target="_blank" rel="noopener">聊聊 JavaScript 与浏览器的那些事 - 引擎与线程</a></p></li><li><p><a href="https://www.cnblogs.com/lhb25/p/how-browsers-work.html" target="_blank" rel="noopener">前端文摘：深入解析浏览器的幕后工作原理</a></p></li><li><p><a href="https://www.imweb.io/topic/58e3bfa845e5c13468f567d5" target="_blank" rel="noopener">浏览器进程？线程？傻傻分不清楚！</a></p></li><li><p><a href="https://www.cnblogs.com/iovec/p/7904416.html" target="_blank" rel="noopener">从输入 cnblogs.com 到博客园首页完全展示发生了什么</a></p></li><li><p><a href="https://www.cnblogs.com/wyaocn/p/5761163.html" target="_blank" rel="noopener">前端必读：浏览器内部工作原理</a></p></li><li><p><a href="http://www.ruanyifeng.com/blog/2013/10/event_loop.html" target="_blank" rel="noopener">什么是 Event Loop？</a></p></li><li><p><a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="noopener">JavaScript 运行机制详解：再谈 Event Loop</a></p></li><li><p><a href="https://blog.csdn.net/u012134199/article/details/46290465" target="_blank" rel="noopener">单线程与多线程的区别</a></p></li><li><p><a href="https://blog.csdn.net/qiuchangjun/article/details/79761242" target="_blank" rel="noopener">浏览器进程/线程模型及 JS 运行机制</a></p></li><li><p><a href="https://www.jianshu.com/p/1e455a9226ce" target="_blank" rel="noopener">浏览器的运行机制—2.浏览器都包含哪些进程？</a></p></li><li><p><a href="https://segmentfault.com/a/1190000004292479" target="_blank" rel="noopener">JS 一定要放在 Body 的最底部么？聊聊浏览器的渲染机制</a></p></li><li><p><a href="https://juejin.im/post/5a6547d0f265da3e283a1df7#heading-25" target="_blank" rel="noopener">从浏览器多进程到 JS 单线程，JS 运行机制最全面的一次梳理</a></p></li><li><p><a href="https://juejin.im/post/5d5b4c2df265da03dd3d73e5#heading-4" target="_blank" rel="noopener">「前端进阶」从多线程到 Event Loop 全面梳理</a></p></li><li><p><a href="https://segmentfault.com/a/1190000013119813" target="_blank" rel="noopener">Js 基础知识（四） - js 运行原理与机制</a></p></li><li><p><a href="https://juejin.im/post/59e85eebf265da430d571f89" target="_blank" rel="noopener">这一次，彻底弄懂 JavaScript 执行机制</a></p></li><li><p><a href="https://juejin.im/post/5b543e26e51d4518f54404e4" target="_blank" rel="noopener">前端性能优化：细说浏览器渲染的重排与重绘</a></p></li><li><p><a href="https://juejin.im/post/5d136700f265da1b7c6128db" target="_blank" rel="noopener">10 分钟看懂浏览器的渲染过程及优化</a></p></li></ol></blockquote>]]></content>
    
    
    <categories>
      
      <category>硬核JS系列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一个前端的安利</title>
    <link href="/blog/2019/12/23/other/%E4%B8%80%E4%B8%AA%E5%89%8D%E7%AB%AF%E7%9A%84%E5%AE%89%E5%88%A9/"/>
    <url>/blog/2019/12/23/other/%E4%B8%80%E4%B8%AA%E5%89%8D%E7%AB%AF%E7%9A%84%E5%AE%89%E5%88%A9/</url>
    
    <content type="html"><![CDATA[<h1 id="一个前端的安利"><a href="#一个前端的安利" class="headerlink" title="一个前端的安利"></a>一个前端的安利</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>此文安利内容皆是我在使用的，我之所用，皆为精品，哈哈，并不是胡乱分享，觉得十分好用，就分享下，所以虽有花哨，却也实用</p><h2 id="Chrome-插件"><a href="#Chrome-插件" class="headerlink" title="Chrome 插件"></a>Chrome 插件</h2><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>作为一个正八经的前端，与 chrome 打交道必不可少，chrome 扩展程序有很多，实用且好玩，之前有段不务正业的时光，每天闲下来就喜欢找各种扩展，看着好玩就安装使用，不好用就卸载，后来还去看了看 chrome 扩展开发，还写了几个小扩展 demo，学习技术的动力是升职加薪，是不被淘汰，并不是不喜欢，只是技术是饭碗，所以久而久之，学习技术变成了理所当然，但是插件脚本这些花里胡哨的则是兴趣，接下来为大家安利我目前觉得很 nice 的几款 chrome 扩展</p><h3 id="No-1-GoogleHelper"><a href="#No-1-GoogleHelper" class="headerlink" title="No.1 GoogleHelper"></a>No.1 GoogleHelper</h3><p>谷歌上网助手，我就以 Helper 简称了，Helper 是专门为科研、外贸、跨境电商、海淘人员、开发人员服务的上网加速工具，chrome 内核浏览器专用!可以解决 chrome 扩展无法自动更新的问题，同时可&gt;以访问谷歌 google 搜索，gmail 邮箱，google+等谷歌产品</p><p>上面是官方解释，通俗来说，我们是不能访问谷歌的，需要翻墙，我们访问外网大多数其实只是使用谷歌搜索，或者是看国外的一些网站，翻墙好麻烦，作为 21 世纪有志青年，我们响应祖国的号召，科学文明上网，我们不翻墙，通过 helper 这个浏览器插件就可以让我们访问谷歌，查看外网的一些资源，这就足够了</p><h5 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h5><p>安装谷歌插件没有翻墙的情况下我们我们进不去谷歌商店</p><p>所以可以直接搜索这个插件的官网下载 <a href="http://googlehelper.net/" target="_blank" rel="noopener">GoogleHelper 传送门</a></p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other//image-20191221105008522.png" srcset="/blog/img/loading.gif" alt="image-20191221105008522"></p><p>如上所示，直接下载即可</p><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><p>2018 年 6 月 13 日起,谷歌最新的 Chrome 7 不再支持 CRX 手动安装方法，这样导致国内用户无法顺利安装 Chrome 扩展，大陆用户又无法访问 Chrome 应用商店，Helper 提供了源码安装方式</p><p>这样导致国内用户无法顺利安装 Chrome 扩展</p><p>大陆用户又无法访问 Chrome 应用商店</p><p>它提供了源码安装方式</p><p><strong>1.</strong> 打开你的 Chrome 浏览器的 更多工具&gt;扩展程序页面 ， 或者直接在网址输入: chrome://extensions/</p><p>*<em>2. *</em>在扩展程序右上角打开开发者选项，然后在此页面左上角点击 “添加已解压的扩展程序”</p><p>*<em>3. *</em>选择刚下载包里的 <code>ghelper_source</code> 目录</p><p>*<em>4. *</em>确认后就行了，装上源码包方式后，先登录，没有账号就注册下，免费的</p><p><strong>5.</strong> 最后回到第一步，进扩展程序页面，找到 helper 插件，点击插件详情，找到 <code>允许访问文件网址</code> 选项勾选同意</p><p><strong>6.</strong> 然后就能愉快访问谷歌了</p><h5 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h5><p>我也用过其他的 chrome 上网加速插件，但是一番对比下来，还是 helper 好用</p><h3 id="No-2-OneTab-amp-OneTab-Plus"><a href="#No-2-OneTab-amp-OneTab-Plus" class="headerlink" title="No.2 OneTab &amp; OneTab Plus"></a>No.2 OneTab &amp; OneTab Plus</h3><p>你是否经常因为打开的标签页太多，过于混乱而感到头疼，作为一个前端，每天打开无数的标签，有的是开发预览，有的是技术博客，管理起来是很麻烦的</p><p>OneTab Plus，一秒上手的傻瓜式操作，轻松管理所有标签页</p><p>之前我是使用 OneTab 的，很简洁，就是不太好看，后来看到了 OneTab Plus，OneTab Plus 毕竟是出自 Infinity 的产品，审美一直都是在线</p><p>安装的话，有了上面的 helper 插件，我们就可以直接在谷歌商店中搜索扩展安装了</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other//image-20191221114152092.png" srcset="/blog/img/loading.gif" alt="image-20191221114152092"></p><p>点击添加至 chrome 即可一键安装</p><p>支持的功能有很多，整合标签组，分类归档等等，界面干净整洁，这里不介绍使用了，就是傻瓜式操作，安装一试便知</p><p>可能有些人觉得这种管理标签的插件不是必要的，但是我觉得不妨安装试一试，还是很香的</p><h3 id="No-3-FeHelper"><a href="#No-3-FeHelper" class="headerlink" title="No.3 FeHelper"></a>No.3 FeHelper</h3><p>FeHelper 中文名为 WEB 前端助手，All In One 的一个工具，包含多个独立小应用，比如：Json 工具、代码美化、代码压缩、二维码、Postman、markdown、网页油猴、便签笔记、信息加密与解密、随机密码生成、Crontab 等等</p><p>如下图</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other//image-20191221140814282.png" srcset="/blog/img/loading.gif" alt="image-20191221140814282"></p><p>FeHelper 的这些功能都很常用，总的来说，说是前端必备神器也不为过，所以强烈推荐，装上它还是很有用的</p><p>安装的话也同上，有了 helper 后直接去谷歌商店搜索 FeHelper 安装即可，使用简单，自己摸索吧</p><p>下图为商店中 FeHelper</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other//image-20191221141220058.png" srcset="/blog/img/loading.gif" alt="image-20191221141220058"></p><h3 id="No-4-Vimium"><a href="#No-4-Vimium" class="headerlink" title="No.4 Vimium"></a>No.4 Vimium</h3><h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><p>Vimium 是 Vim 和 Chromium 的结合，Vim 是 linux 中让你脱离鼠标编辑文本的利器，同样 Vimium 是让你脱离鼠标就能上网的终极利器，不用移动鼠标就能跳转页面，切换标签，打开历史记录，打开书签等等，这比传统的鼠键结合的方式要快得多</p><p>总之，Vimium 是极客必备，它可以让我们在浏览器中解放鼠标，效率与装逼集为一体，优雅而酷炫</p><p>作为一个经常和浏览器打交道的前端，这东西用之后有如神助，就很棒，极力推荐前端开发们使用，所以文中会细致介绍下</p><h5 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h5><p>安装也同上，都是浏览器扩展插件嘛，有了 helper 后直接去谷歌商店搜索 Vimium 一键添加即可，就是下图这个</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other//image-20191221144435965.png" srcset="/blog/img/loading.gif" alt="image-20191221144435965"></p><h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><p>首先确保安装成功，浏览器地址栏右侧已经有了小图标</p><p>我们在浏览器打开一个新的标签页，搜索 vimium 回车，按下<code>f</code>键，当前页面的所有链接处都会分配快捷键，这也是最常用的 vimium 快捷键，效果如下图</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other//image-20191221155430821.png" srcset="/blog/img/loading.gif" alt="image-20191221155430821"></p><p>分配的快捷键最多两个字符，也就是说我们最多只需按三下键盘，无需鼠标，想去哪就去哪</p><p>我们想要搜索内容时，只需按下<code>o</code>键，输入内容即可看到结果，同地址栏搜索一样方便简洁，想要在新标签页打开只需按下大写的<code>O</code>，搜索界面如下</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other//image-20191222234639120.png" srcset="/blog/img/loading.gif" alt="image-20191222234639120"></p><p>我是一个喜欢把看到的好帖子收藏下来的人，所有收藏我都存在了谷歌书签，我自认为我的标签分类也算比较细致了，如下图</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other//image-20191221161303845.png" srcset="/blog/img/loading.gif" alt="image-20191221161303845"></p><p>但是久而久之，收藏的东西太多了，不好查找，Vimium 可以非常方便的帮我们查找标签页的内容</p><p>只需按下<code>b</code>键，即可模糊搜索收藏的标签页内容，界面效果和<code>o</code>键搜索一致，大写<code>B</code>键也是在新标签页打开，相信对喜欢收藏帖子加标签的人来说很实用，如下图</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other//image-20191222234855365.png" srcset="/blog/img/loading.gif" alt="image-20191222234855365"></p><h5 id="快捷键一览"><a href="#快捷键一览" class="headerlink" title="快捷键一览"></a>快捷键一览</h5><p>愉快的使用 Vimium，下面这些快捷键必不可少，使用过 Linux 的 vim 的同学会感到毫无压力，没有使用过的同学记住常用的就 OK 了，当然这些快捷键都可以更改，但是建议不要更改，用熟后 linux 的 vim 也是这些操作</p><pre><code class="js">j：        向下细微滚动窗口k：        向上细微滚动窗口J：        (Shift+j的意思，以下大写全部表示加Shift) 下一个标签页K：        上一个标签页d：        向下滚动半个屏幕u：        向上移动半个屏幕g+g：    同连续按两下g，回到顶部G：        到达页面底部H：        后退L：        前进f：        将当前网页上的所有可见链接/输入框分配一个快捷键，输入后就可以打开或者跳转到对应的输入框F：        同f，只不过是将在新窗口中打开页面g+i：    将光标 定位到输入框，如果有多个可以按Tab键切换b：        搜索书签，当前页面打开B：        搜索书签，新标签页打开x：        关闭当前页面X：        恢复刚刚关闭的页面o：        相当于Chrome中的地址栏，搜索并在当前窗口打开，Chrome在全屏时也可使用O：        同o，只不过是可以在新窗口中打开，很nice，Chrome在全屏时也可使用g+s：    查看网页的源代码r：        重新载入当前网页</code></pre><p><strong>注：</strong>浏览器自有页面该插件不可用，如控制台、默认的新标签页等等</p><h5 id="最后-1"><a href="#最后-1" class="headerlink" title="最后"></a>最后</h5><p>没什么可说的，真是装逼神器，赶紧安装试试，安装后你可以尝试下不使用鼠标，仅使用键盘给这篇帖子评论个消息或者点个赞 😄</p><h3 id="No-5-Saladict"><a href="#No-5-Saladict" class="headerlink" title="No.5 Saladict"></a>No.5 Saladict</h3><p>Saladict 沙拉查词是一款专业划词翻译扩展，为交叉阅读而生。大量权威词典涵盖中英日韩法德西语，支持复杂的划词操作、网页翻译、生词本与 PDF 浏览</p><p>以上是官方解释，我认为，它的划词翻译最好，在浏览器中我们阅读外文，你是不是经常点谷歌翻译，谷歌翻译把整个网页翻译为中文，这样做我认为不太好，经常这样搞，英文水平永远也提不上去，而划词翻译不同，我们可以尝试阅读英文文档，遇到不会的直接选中单词或句子进行翻译，慢慢的英文水准就会有所提高</p><p>对比其他划词翻译插件我选择 Saladict 的原因有两点</p><p>1.界面相对漂亮，使用方便，作为前端，我认为它的交互体验非常 nice</p><p>2.多渠道翻译更为精确</p><p>如下图所示</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other//image-20191221200333962.png" srcset="/blog/img/loading.gif" alt="image-20191221200333962"></p><p>我们选中一句话或者一个单词，就会在对应位置自动弹出一个小图标，点击图标即可弹出对应多版本的翻译，使用及其方便，更多功能可安装后自行体验</p><p>沙拉查词的功能也很多，不过我只用这一个简单翻译的功能，想了解更多可以查看 saladict 的官方文档<a href="https://saladict.crimx.com/manual.html" target="_blank" rel="noopener">saladict 传送门</a></p><p>安装方式还是从谷歌商店搜索 Saladict 一键安装即可，该插件如下</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20191221220245249.png" srcset="/blog/img/loading.gif" alt="image-20191221220245249"></p><h3 id="No-6-Octotree"><a href="#No-6-Octotree" class="headerlink" title="No.6 Octotree"></a>No.6 Octotree</h3><p>Octotree 是一款针对 github 的插件，通常我们在浏览 github 时查看一个文件要进去，想查看其他文件就要返回在点入文件，比较麻烦，安装此插件，在我们浏览 github 时，它会为我们生成一个树形结构的侧边栏，这样我们在查看 github 项目时就不用点入点出，极为方便，如下图</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20191221221253478.png" srcset="/blog/img/loading.gif" alt="image-20191221221253478"></p><p>此插件功能强大，但是如要使用更多功能，就需收费了，这点我觉得不太好，不过我们在不注册会员的情况下也可以使用它的树状侧边栏，如果你只需一个方便的侧边栏，那使用它就再好不过了</p><p>安装同上，谷歌商店中搜索扩展名 Octotree，如下图，一键安装使用</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20191221221700133.png" srcset="/blog/img/loading.gif" alt="image-20191221221700133"></p><h3 id="No-7-Sourcegraph"><a href="#No-7-Sourcegraph" class="headerlink" title="No.7 Sourcegraph"></a>No.7 Sourcegraph</h3><h5 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h5><p>Sourcegraph 又是一款为 github 而生的强大插件，它是一款可以为 Github 上的代码添加了即时文档和类型提示，并为每一个标识符添加了跳转到定义处的链接的 Chrome 扩展，它允许你像使用一个很好的 IDE 那样浏览源代码</p><p>我们看官方对它的解释</p><p>你可以从代码仓库和安装包甚至是函数里搜索代码，同时也可以直接点击被完全创建了链接的代码来阅读文档、跳转到变量定义或者马上找到可用的 Demo。总而言之，你可以在你的 web 浏览器上完成这一切，而不需要配置任何编辑器。由 Sourcegraph 出品的这款 Chrome 插件，可以非常方便的浏览和搜索 Github 上的代码，持跨 repository 搜索、跳转到定义、查找引用等功能，宛若一个功能强大的 IDE。核心功能如跳转到定义(Go-to-definition)——浏览文件或查看 pull 请求时，将鼠标悬停在代码上可以查看文档提示，单击即可跳转到定义、查找引用或全文搜索</p><p>可能有人还是不了解它的强大，这样说吧，我们把 github 的项目克隆下来，在 VSCode 打开查看，和直接在 github 上打开感觉如何，这根本就不用比较，github 上浏览项目代码很不方便，你只能像看文档一样查看，就像一个函数，我们要找这个函数定义所在，编译器里 command+鼠标左击直接就进入函数内部了，github 上是肯定不行的，而 Sourcegraph 可以帮你办到，说它是一款极简的线上 IDE 也不为过</p><h5 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h5><p>安装如上一样，谷歌商店搜索扩展 Sourcegraph 安装即可，如下即是</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20191221223305327.png" srcset="/blog/img/loading.gif" alt="image-20191221223305327"></p><h5 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h5><p>安装好该插件后，我们再打开 github 项目，就会看到项目中出现了一个图标如下</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20191221223418443.png" srcset="/blog/img/loading.gif" alt="image-20191221223418443"></p><p>点击该图标即可体验在线 IDE 的强大，它可以为我们浏览 github 优秀项目提供很大的助力</p><p>点击图标后进入界面如下</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20191221223552397.png" srcset="/blog/img/loading.gif" alt="image-20191221223552397"></p><p>可能到了这里，有人会问，既然有 Sourcegraph，那还要 Octotree 何用，Octotree 的侧边栏，Sourcegraph 也有</p><h5 id="Octotree-VS-Sourcegraph"><a href="#Octotree-VS-Sourcegraph" class="headerlink" title="Octotree VS Sourcegraph"></a>Octotree VS Sourcegraph</h5><p>Octotree 不需要跳转页面，就在 github 当前页面生成侧边栏，点击也是跳到对应的 github 地址下，使用极为方便，而 Sourcegraph 不同，它功能太过强大，所以打开会跳转到 Sourcegraph.com 上，打开速度和体验会稍稍有些不好，但是胜在功能强大</p><p>其实我之所以装两个，原因很简单，因为两者都可以用的上，一般我只是简单查看 github 项目时会使用 Octotree，比较快捷，但是我想要深究其中一些内容，又不想克隆到本地时，会使用 Sourcegraph，因为它更强大，函数查找，跳转定义简直不要太爽</p><p>有人可能说装这么多插件就算了，功能重叠的也装，这不是要累死谷歌，不急，看完你就知道了，咱有对策</p><h3 id="No-8-GitZip"><a href="#No-8-GitZip" class="headerlink" title="No.8 GitZip"></a>No.8 GitZip</h3><p>GitZip，全名为 GitZip for github，又是一款 github 神器，只要我们经常混迹 github，那么它就更不可或缺了</p><p>我们都知道，要克隆一个仓库中的文件，我们要把整个仓库克隆下来，这点很不爽，毕竟一个仓库这么大，可能我只需要其中一两个文件，全部克隆过于麻烦</p><p>GitZip，有了它，你就不必烦恼这个问题</p><h5 id="安装-3"><a href="#安装-3" class="headerlink" title="安装"></a>安装</h5><p>谷歌应用商店中搜索 GitZip，点击添加扩展即可，如下</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20191221225332815.png" srcset="/blog/img/loading.gif" alt="image-20191221225332815"></p><h5 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h5><p>找到一个 github 项目，这里以 vue 为例，我只想下载 vue 项目中的 src 文件夹，双击选中即可，如下图</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20191221225536343.png" srcset="/blog/img/loading.gif" alt="image-20191221225536343"></p><p>我们只需要双击选中想要下载的文件夹或文件，左侧会出现对号代表选中，网页右下角会出现下载的箭头图标，我们点击箭头，即可打包下载选中文件</p><p>第一次使用此插件时，内心真的是翻江倒海，虽然功能并不强大，这个小功能正是我所需要的</p><h3 id="No-9-GitHub-Hovercard"><a href="#No-9-GitHub-Hovercard" class="headerlink" title="No.9 GitHub Hovercard"></a>No.9 GitHub Hovercard</h3><h5 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h5><p>GitHub Hovercard，一听名字就又是一款 github 相关的插件，它的作用是-&gt;鼠标悬停快速预览</p><p>浏览 Github 时我们浏览一个项目、一个用户的信息、或者一个 issue，只能点击进去查看详情，如果经常浏览 github 的话，就有些麻烦了</p><p>GitHub Hovercard 这个插件可以让我们快速浏览项目信息/用户信息/项目讨论，只需要把鼠标悬停在想要查看的用户|项目|issue 上就可以查看了，十分方便</p><h5 id="使用-3"><a href="#使用-3" class="headerlink" title="使用"></a>使用</h5><p>下面是使用的一些截图</p><p>悬停在项目上时如下</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20191222011553442.png" srcset="/blog/img/loading.gif" alt="image-20191222011553442"></p><p>悬停在用户上时如下</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20191222011743118.png" srcset="/blog/img/loading.gif" alt="image-20191222011743118"></p><p>悬停在 issue 上时</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20191222011925152.png" srcset="/blog/img/loading.gif" alt="image-20191222011925152"></p><p>悬浮在提交记录上时</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20191222012141465.png" srcset="/blog/img/loading.gif" alt="image-20191222012141465"></p><p>总之，该插件对我们快速浏览项目帮助很大，我们每次要看一个详细信息就不用点击进去了，非常方便</p><h5 id="安装-4"><a href="#安装-4" class="headerlink" title="安装"></a>安装</h5><p>谷歌商店搜索扩展名 GitHub Hovercard 添加至扩展即可，该插件如下</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20191222012618349.png" srcset="/blog/img/loading.gif" alt="image-20191222012618349"></p><h3 id="No-10-React-Developer-Tools"><a href="#No-10-React-Developer-Tools" class="headerlink" title="No.10 React Developer Tools"></a>No.10 React Developer Tools</h3><p>React Developer Tools 这个就不介绍了，React 调试插件，前端都知道</p><h3 id="No-11-Vue-js-devtools"><a href="#No-11-Vue-js-devtools" class="headerlink" title="No.11 Vue.js devtools"></a>No.11 Vue.js devtools</h3><p>Vue.js devtools 同 React Developer Tools 一样，vue 调试插件，都是开发必备的，作为前端应该都知道，不介绍了</p><h3 id="No-12-Postman"><a href="#No-12-Postman" class="headerlink" title="No.12 Postman"></a>No.12 Postman</h3><p>没错，就是 postman，之所以安装 postman 浏览器扩展，就是不想装 Postman 桌面程序</p><p>不要装错呦，看下图</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20191222181152773.png" srcset="/blog/img/loading.gif" alt="image-20191222181152773"></p><p>要安装地球 logo 的这款</p><p>网页中使用该扩展的界面如下</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20191222181256454.png" srcset="/blog/img/loading.gif" alt="image-20191222181256454"></p><p>使用就不介绍了，大家都会用</p><h3 id="No-13-掘金"><a href="#No-13-掘金" class="headerlink" title="No.13 掘金"></a>No.13 掘金</h3><p>掘金 chrome 扩展插件，大家在掘金首页上应该见过它，在那下载安装就成</p><p>为什么推荐它呢，可能有些人看到过它，只不过没注意，我之前偶尔空闲，看了一下官方的介绍，觉得好用，就装了，装之后体验非常棒，就一直留着了，功能很实用，界面很简洁</p><p>它会在你打开一个新的标签页时打开掘金插件定制好的内容聚合页面，你依然可以在地址栏搜索内容，不过映入眼帘的不再是空白的百度或谷歌，而是下图</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20191221230457980.png" srcset="/blog/img/loading.gif" alt="image-20191221230457980"></p><p>如上图所示，打开一个新标签页，左侧会为你显示掘金的近期优质帖子，右边我们可以设置成 github 热门排行，当然这是我的选择，它不只是针对前端，后端和产品等不同人员皆可，自己选择感兴趣的东西即可</p><p>试想，每打开一个新的标签页，当日的 github 热门排行和掘金优质量帖子都会映入眼帘，我们可以在不知不觉中看到热门项目，帖子，如果感兴趣就点进去瞅瞅，这种内容聚合的创意我觉得很赞，大大节省了我刻意刷这些东西的时间</p><h3 id="No-14-Tampermonkey"><a href="#No-14-Tampermonkey" class="headerlink" title="No.14 Tampermonkey"></a>No.14 Tampermonkey</h3><h4 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h4><p>Tampermonkey，大名顶顶的油猴，一个强大的脚本管理扩展，说是谷歌扩展中最强大插件也不为过，这个插件不装上都对不住那些熬夜写脚本的开发者们，你可能听说过油猴，但是因为看到脚本感到距离遥远望而却步，其实它的操作非常简单，只要经过简单设置，下载一些现成脚本，就可以实现超级实用的功能，你可能知道它，你也可能不知道它，不管怎样，今天看到之后，装上它就对了</p><h4 id="安装-5"><a href="#安装-5" class="headerlink" title="安装"></a>安装</h4><p>谷歌应用商店搜索 Tampermonkey 扩展安装，该插件如下</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20191222013358211.png" srcset="/blog/img/loading.gif" alt="image-20191222013358211"></p><h4 id="使用-4"><a href="#使用-4" class="headerlink" title="使用"></a>使用</h4><p>只是安装油猴并无太大作用，重点是通过它管理脚本，此插件太好用了，所以一定要给大家安利上，尽量描述的详细些</p><p>安装油猴后，在浏览器地址栏右侧就会出现油猴的小图标，左击它，会有如下列表</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20191222013747416.png" srcset="/blog/img/loading.gif" alt="image-20191222013747416"></p><h5 id="获取脚本渠道"><a href="#获取脚本渠道" class="headerlink" title="获取脚本渠道"></a>获取脚本渠道</h5><p>首先我们要找几个脚本装一下，点击获取新脚本，会有如下页面</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20191222014025775.png" srcset="/blog/img/loading.gif" alt="image-20191222014025775"></p><p>这里我们获取脚本的渠道有四，我们来看对比</p><ul><li>GreasyFork<ul><li>GreasyFork 是最受欢迎的后起之秀，它由 Jason Barnabe 创建</li><li>Jason Barnabe 同时也是 <a href="https://userstyles.org/" target="_blank" rel="noopener">Stylish</a> 网站的创办者，在其储存库中有大量的脚本资源</li><li>这个库也是我们首推的脚本库，里面插件超级多，关键是可选择中文</li><li>下文安装脚本会以此脚本库做示例</li></ul></li><li>OpenUserJS<ul><li>GreasyFork 之后开始创办</li><li>它由 Sizzle McTwizzle 创建,同样地,在其储存库中也拥有大量的脚本资源</li><li>他是英文的</li></ul></li><li>Userscripts.org<ul><li>老牌脚本库，不过现在不更新了，不推荐使用</li></ul></li><li>GitHub/Gist<ul><li>当然也可以在 github 或 gist 中搜索脚本资源使用，我是没从这找过，我一般都用 GreasyFork</li></ul></li></ul><h5 id="GreasyFork-中下载脚本"><a href="#GreasyFork-中下载脚本" class="headerlink" title="GreasyFork 中下载脚本"></a>GreasyFork 中下载脚本</h5><p>我一般都在 GreasyFork 中找脚本下着玩，里面的脚本足够用了</p><p>点击获取新脚本后，我们找到 GreasyFork 点击进入如下</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20191222014935554.png" srcset="/blog/img/loading.gif" alt="image-20191222014935554"></p><p>我们点击右上角脚本列表，会看到无数的脚本资源，如下图</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20191222015035399.png" srcset="/blog/img/loading.gif" alt="image-20191222015035399"></p><p>你也可以直接在搜索中输入关键字搜索脚本，我先随意下载一个做示例，就列表第一个吧，点击进入脚本详情</p><p>脚本的详情页会有对应的脚本使用介绍，看下就会用了</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20191222015203894.png" srcset="/blog/img/loading.gif" alt="image-20191222015203894"></p><p>点击安装此脚本</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20191222015240191.png" srcset="/blog/img/loading.gif" alt="image-20191222015240191"></p><p>再次点击安装即可，安装之后我们再次点击浏览器地址栏右侧油猴图标</p><p>选择管理面板点击进入，此时我们的油猴中就安装上一个脚本了，如下</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20191222015550494.png" srcset="/blog/img/loading.gif" alt="image-20191222015550494"></p><p>如上图所示，我装的脚本不多，但是都挺好用的，推荐给大家</p><ul><li><p>id 为 5 的是下载图库素材的脚本</p><ul><li>使用它之后下载图片资源，嘿嘿，那还开什么千图网 vip</li></ul></li><li><p>id 为 1 的百度谷歌去广告的脚本</p><ul><li>使用它之后，那百度和谷歌被净化的只剩文字，非常舒服</li><li>还可以自己定制样式</li></ul></li><li><p>id 为 2 的是 CSDN 博客免登陆，去广告，净化剪贴板的脚本</p><ul><li>CSDN 广告太多了，而且看博客时想复制代码粘贴老是携带 CSDN 注入的信息</li><li>用了此脚本之后，嘿嘿</li></ul></li><li><p>id 为 3 的是百度文档免费下载，粘贴的脚本</p><ul><li>有时候我们会找一些文档素材，百度文档不能复制，下载要会员</li><li>有了此插件后，想复制下载，easy</li></ul></li><li><p>id 为 4 的是视频 vip 解析脚本</p><ul><li>还开什么视频 vip，想看啥，直接脚本搜即可</li></ul></li></ul><h4 id="最后-2"><a href="#最后-2" class="headerlink" title="最后"></a>最后</h4><p>上面说这些玩法是非常普通的，Tampermonkey 脚本管理工具玩法很多，脚本一途博大精深，有兴趣的话大家可以自己写脚本玩</p><p>下载的脚本安装后如何使用，一般在安装脚本的详情页会有对应的脚本使用介绍</p><p>脚本并不是都可用的，有些脚本收费，有的脚本则不可用</p><p>我下载的脚本并不多，更多好玩的脚本等着你去发掘</p><p>大家如果安装油猴了，到时候找到什么好玩免费的脚本，别忘了安利给我，先谢过</p><h3 id="No-15-SimpleExtManager"><a href="#No-15-SimpleExtManager" class="headerlink" title="No.15 SimpleExtManager"></a>No.15 SimpleExtManager</h3><p>SimpleExtManager，将此扩展放到最后，意味着它是压轴的，上面说了这么多插件，有 15 款，都是我正在使用的，可能大家会说装这么多扩展，本来谷歌就吃内存，全都安装下来还能扛的住吗？</p><p>有些扩展我们只在特殊的场景下才会使用，但是我们启用禁用一个扩展需要到扩展中心，很麻烦</p><p>SimpleExtManager 就是解决之道</p><p>它是一款快捷管理扩展的扩展插件，你可以使用该插件便捷管理扩展，快速打开扩展或关闭扩展</p><h5 id="安装-6"><a href="#安装-6" class="headerlink" title="安装"></a>安装</h5><p>还是老样子，谷歌应用商店直接搜索扩展 SimpleExtManager 一键添加即可，该扩展在商店中如下</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20191222114846108.png" srcset="/blog/img/loading.gif" alt="image-20191222114846108"></p><h5 id="使用-5"><a href="#使用-5" class="headerlink" title="使用"></a>使用</h5><p>使用也非常简单</p><p>我们只需要点击地址栏对应的 SimpleExtManager 图标即可看到我们所有的扩展</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20191222114950097.png" srcset="/blog/img/loading.gif" alt="image-20191222114950097"></p><p>如上图所示，禁用扩展直接取消选中即可，启用就勾选，还可快捷删除扩展</p><p>界面着实有点 low，不过胜在简单实用</p><h3 id="No-16-The-Great-Suspender"><a href="#No-16-The-Great-Suspender" class="headerlink" title="No.16 The Great Suspender"></a>No.16 The Great Suspender</h3><p>在使用浏览器的过程中，我们很可能会打开很多页面，而且会越来越多，是很消耗内存的，谷歌吃内存就是这</p><p>上面 SimpleExtManager 插件可以帮助我们管理扩展插件以优化 chrome 资源占用</p><p>The Great Suspender 这个插件，它则可以自动冻结一定时间内没有使用到的页面，从而较少内存消耗</p><p>居家必备的神器，用了它之后，你的 chrome 内存占用会减少很多的</p><p>这款插件长下面这个样子</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20191222175527666.png" srcset="/blog/img/loading.gif" alt="image-20191222175527666"></p><p>使用很简单，你只需勾选冻结设置就可以了，冻结的网站如下图</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20191222215920409.png" srcset="/blog/img/loading.gif" alt="image-20191222215920409"></p><p>解冻也非常方便，点击网站任意一处即可解冻</p><p>安装直接在谷歌应用商店搜索该扩展名字 The Great Suspender 即可</p><p>###小结</p><p>访问谷歌用 helper</p><p>高效管理标签使用 OneTab Plus</p><p>前端常用小工具 FeHelper 都有，Postman 网页端接口测试</p><p>不用鼠标，高效使用谷歌用 Vimium</p><p>划词翻译用 saladict</p><p>玩转 Github，Octotree / Sourcegraph / GitZip / Github Hovercard 四神器</p><p>Vue 开发用 Vue Devtools，react 开发用 React Developer Tools</p><p>掘金插件省去刻意查找的时间</p><p>Tampermonkey 油猴插件更是随心所欲，脚本爽到飞起</p><p>SimpleExtManager+The Great Suspender 让你的 chrome 运行如丝般顺滑</p><p>以上就是我安装并使用的 16 款非常 nice 的 chrome 扩展，大家如有更好的，请安利给我</p><h2 id="代码片段截图"><a href="#代码片段截图" class="headerlink" title="代码片段截图"></a>代码片段截图</h2><h3 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h3><p>早在之前，我看到别人分享的代码片段截图非常漂亮，如下图这种</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/code.png" srcset="/blog/img/loading.gif" alt="code"></p><p>这种代码片段我之前一直以为是 Mac 专享，后来入手了 Mac 之后发现也没这功能啊，再到后来才知道，这并不是 Mac 专享，有两种办法皆可生成这种风格代码片段截图</p><h3 id="No-1-Carbon"><a href="#No-1-Carbon" class="headerlink" title="No.1 Carbon"></a>No.1 Carbon</h3><p><a href="https://carbon.now.sh/" target="_blank" rel="noopener">Carbon</a>是一个可以把你的代码转成一张精美海报的工具，让你的代码分享颜值爆表</p><p>Carbon 可以轻松将源代码创建成简洁美观的图像分享出去，支持自定义图片的语法主题，窗口样式</p><p>以下是官网图，使用简单</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20191222171426229.png" srcset="/blog/img/loading.gif" alt="image-20191222171426229"></p><p>可借助这个网站生成漂亮的代码片段图片</p><h3 id="No-2-VS-Code-plugin-CodeSnap"><a href="#No-2-VS-Code-plugin-CodeSnap" class="headerlink" title="No.2 VS Code plugin CodeSnap"></a>No.2 VS Code plugin CodeSnap</h3><p>上述 Carbon 可以帮助我们生成漂亮的代码片段图片，但是使用它要打开网站 copy 代码，比较麻烦，我们会想，在编辑器中写的代码，能不能截图直接在编译器中完成，随之截图带上的也是我们编译器的主题样式，答案当然是可以的</p><p>VS Code 有一款插件，叫 CodeSnap，直接搜索该扩展安装即可，使用也简单</p><p>windows：<code>ctrl+shift+p</code></p><p>mac：<code>command+shift+p</code></p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20191222172647359.png" srcset="/blog/img/loading.gif" alt="image-20191222172647359"></p><p>直接输入 codesnap 回车即可</p><p>然后选中你想截图的代码片段</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20191222172818160.png" srcset="/blog/img/loading.gif" alt="image-20191222172818160"></p><p>插件生成的图片面板下有一个圆圈，点击即可保存图片，这种片段截图在编译器中，方便快捷，还可以保留编译器的样式，当然既然是 vscode 扩展，mac 和 windows 都可用</p><h2 id="在线工具"><a href="#在线工具" class="headerlink" title="在线工具"></a>在线工具</h2><h3 id="No-1-Processon"><a href="#No-1-Processon" class="headerlink" title="No.1 Processon"></a>No.1 Processon</h3><p>市面上的思维导图工具繁多，像百度脑图，xmind，mindmaster 等等，但是他们都得下载客户端，而且有的还收费</p><p>Processon 是一款免费在线的专业流程图和思维导图制作工具，官网如下</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20191222214812008.png" srcset="/blog/img/loading.gif" alt="image-20191222214812008"></p><p>Processon 这个东西知道的人应该挺多的，因为它优点太多了</p><ul><li>在线工具，自然就有了跨平台的特性</li><li>在线存储</li><li>操作简单，0 学习成本，可制作图形巨多</li><li>可多人协作</li></ul><p>来看一款做好的思维脑图模板</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20191222200937011.png" srcset="/blog/img/loading.gif" alt="image-20191222200937011"></p><p>在线存储，我们还可以将做好的脑图分享给其他人，颜值巨高，试试就知道了 <a href="https://www.processon.com/" target="_blank" rel="noopener">Processon 传送门</a></p><h3 id="No-2-Codeshare"><a href="#No-2-Codeshare" class="headerlink" title="No.2 Codeshare"></a>No.2 Codeshare</h3><p><a href="https://codeshare.io/" target="_blank" rel="noopener">Codeshare</a> 是一款在线代码编辑器，用于采访，故障排除，教学等</p><p>它最主要的功能是可以与开发人员实时共享代码，还可以共享视频，十分方便</p><p>官网界面如下</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20191222214518356.png" srcset="/blog/img/loading.gif" alt="image-20191222214518356"></p><h3 id="No-3-Gaoding-com"><a href="#No-3-Gaoding-com" class="headerlink" title="No.3 Gaoding.com"></a>No.3 Gaoding.com</h3><p>搞定设计旗下出品 搞定抠图，在线抠图，这个网站抠图巨快，算法贼 6，使用很方便</p><p>抠图的话就不用使用 PS 了，PS 太复杂，抠图太慢</p><p><a href="https://www.gaoding.com/koutu/" target="_blank" rel="noopener">Gaoding.com 传送门</a></p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20191222221502009.png" srcset="/blog/img/loading.gif" alt="image-20191222221502009"></p><h3 id="No-4-remove-bg"><a href="#No-4-remove-bg" class="headerlink" title="No.4 remove.bg"></a>No.4 remove.bg</h3><p>Gaoding 是在线抠图工具，而 remove.bg 不同，remove.bg 从名字就可以看出作用，删除背景，上传一张图片，一键去除背景，一些简单的背景去除我们可以直接使用此站，复杂一些的就使用 Gaoding 手动抠，还是那两个字，方便</p><p><a href="https://www.remove.bg/" target="_blank" rel="noopener">remove.bg 传送门</a></p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/20200407144913.png" srcset="/blog/img/loading.gif" alt="image-20191222221148849"></p><h3 id="No-5-无版权图片"><a href="#No-5-无版权图片" class="headerlink" title="No.5 无版权图片"></a>No.5 无版权图片</h3><p>无版权的图片资源，里面不乏一些精美图片，我一般没事会逛逛，找一些高清壁纸，好看的图片来收藏</p><p><a href="https://www.sitebuilderreport.com/" target="_blank" rel="noopener">sitebuilderrepor</a></p><p><a href="https://www.pexels.com/" target="_blank" rel="noopener">pexels</a></p><h3 id="No-6-Shodan"><a href="#No-6-Shodan" class="headerlink" title="No.6 Shodan"></a>No.6 Shodan</h3><p>最后给大家说一个搜索引擎 Shodan，被喻为“最可怕”的搜索引擎</p><p>Shodan 上搜索出来的不只是单纯的信息，而是所有接入互联网的设备，如你的手机、电脑、摄像头等等</p><p>大家如果有兴趣，可以自行了解下玩法，它可以让你更加深刻的认识网络</p><p><a href="https://www.shodan.io/" target="_blank" rel="noopener">Shodan 传送门</a></p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/20200407144753.png" srcset="/blog/img/loading.gif" alt="image-20191222222953478"></p><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>以上就是我这次的分享了，都是我经常使用的小东西，还有一些不经常使用的，比较偏门，就没放上去</p><p>我觉得每一个前端都会收藏一些稀奇古怪的玩意，大家不妨分享出来，互惠互利</p><p>大家要是有好玩的东西，又懒得码字，你直接评论或者私我，我去研究研究，回头补充上</p><p>发完这个帖子，接下来就开使写技术帖了，平常也喜欢写技术贴，存了很多的半篇半篇的帖子，觉得写的不太好，就不想发，也没时间完善，久而久之，半篇幅的帖子越来越多，不能这样颓废了</p><p>趁还年轻，趁着啥啥都还新鲜的劲头，加油</p>]]></content>
    
    
    <categories>
      
      <category>Web相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Chrome</tag>
      
      <tag>Vscode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue 项目中优雅使用 icon</title>
    <link href="/blog/2019/11/16/vue/Vue%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BC%98%E9%9B%85%E4%BD%BF%E7%94%A8icon/"/>
    <url>/blog/2019/11/16/vue/Vue%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BC%98%E9%9B%85%E4%BD%BF%E7%94%A8icon/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue-项目中优雅使用-icon"><a href="#Vue-项目中优雅使用-icon" class="headerlink" title="Vue 项目中优雅使用 icon"></a>Vue 项目中优雅使用 icon</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>icon 在我们前端日常开发中是很常用的，它有很多种使用方式，时至今日，它的使用方式经过了很多种演变，本文会为大家介绍 icon 的一些历史演变，分析一下这几种使用方式的优劣，我们将采用<code>svg sprites</code>这种方式使用 icon，演示代码使用 vue+vue-cli3+，看完之后，你会发现这种使用方式完全称得上优雅二字</p><h3 id="追溯历史"><a href="#追溯历史" class="headerlink" title="追溯历史"></a>追溯历史</h3><h4 id="Img-标签引入"><a href="#Img-标签引入" class="headerlink" title="Img 标签引入"></a>Img 标签引入</h4><p>最早我们使用图标时只是单纯 img 标签引入图片，个人感觉也还好</p><p>但是这样网页上会有很多 img 图标的资源请求，这是它最大的缺点</p><h4 id="雪碧图-css-sprites"><a href="#雪碧图-css-sprites" class="headerlink" title="雪碧图(css sprites)"></a>雪碧图(css sprites)</h4><p>后来我们为了优化资源请求开始使用 CSS 雪碧图(css sprites)</p><p>CSS Sprites 在国内很多人叫 css 精灵/css 雪碧图(啥都行)，是一种网页图片应用处理方式。它允许你将一个页面涉及到的所有零星图片都包含到一张大图中去，这样一来，当访问该页面时，载入的图片就不会像以前那样一幅一幅地慢慢显示出来了。加速的关键，不是降低质量，而是减少个数</p><p>CSS Sprites 其实就是把网页中一些背景图片整合到一张图片文件中，再利用 CSS 的<code>background-image background- repeat background-position</code>的组合进行背景定位，<code>background-position</code>可以用数字精确的定位出背景图片的位置</p><p>利用 CSS Sprites 能很好地减少网页的 http 请求，从而大大的提高页面的性能，这也是 CSS Sprites 最大的优点</p><p>同时它的缺点也很明显，CSS Sprites 在开发的时候比较麻烦，需要计算基准位置来进行定位，维护的时候往往改动一个图标我们就得改整个雪碧图，一不小心就搞得整个网页的图标错位了</p><h4 id="font-库"><a href="#font-库" class="headerlink" title="font 库"></a>font 库</h4><p>再到后来就出现了 font 库，也就是字体图标库，它出现给了我们开发很大便利，使用起来也非常方便，字体图标为什么方便，因为我们可以直接从市面上的 font 字体图标库里找图标，直接使用，还可以很好的控制一些基础样式</p><p>国内估计使用量最大也是最全的图标库我觉得就是阿里矢量图标库(iconfont)了，各种图标简直不要太多，最重要的是开源免费</p><p>拿 iconfont 来说，它有三种使用方式，分别是<code>unicode，font-class，symbol</code>，都非常简单</p><p>当然，没有使用过的小伙伴直接百度搜索关键词 iconfont 使用，相信看一看就会了</p><p>接下来我们来看下这三种方式的优缺点(官方的)：</p><h3 id="font-使用方式对比"><a href="#font-使用方式对比" class="headerlink" title="font 使用方式对比"></a>font 使用方式对比</h3><h4 id="unicode-引用"><a href="#unicode-引用" class="headerlink" title="unicode 引用"></a>unicode 引用</h4><hr><p>unicode 是字体在网页端最原始的应用方式，特点是：</p><ul><li>兼容性最好，支持 ie6+，及所有现代浏览器。</li><li>支持按字体的方式去动态调整图标大小，颜色等等。</li><li>但是因为是字体，所以不支持多色。只能使用平台里单色的图标，就算项目里有多色图标也会自动去色。</li></ul><blockquote><p>注意：新版 iconfont 支持多色图标，这些多色图标在 unicode 模式下将不能使用，如果有需求建议使用 symbol 的引用方式</p></blockquote><p>unicode 使用步骤如下：</p><h5 id="第一步：拷贝项目下面生成的-font-face"><a href="#第一步：拷贝项目下面生成的-font-face" class="headerlink" title="第一步：拷贝项目下面生成的 font-face"></a>第一步：拷贝项目下面生成的 font-face</h5><pre><code class="js">@font-face {font-family: &#39;iconfont&#39;;    src: url(&#39;iconfont.eot&#39;);    src: url(&#39;iconfont.eot?#iefix&#39;) format(&#39;embedded-opentype&#39;),    url(&#39;iconfont.woff&#39;) format(&#39;woff&#39;),    url(&#39;iconfont.ttf&#39;) format(&#39;truetype&#39;),    url(&#39;iconfont.svg#iconfont&#39;) format(&#39;svg&#39;);}</code></pre><h5 id="第二步：定义使用-iconfont-的样式"><a href="#第二步：定义使用-iconfont-的样式" class="headerlink" title="第二步：定义使用 iconfont 的样式"></a>第二步：定义使用 iconfont 的样式</h5><pre><code class="js">.iconfont{    font-family:&quot;iconfont&quot; !important;    font-size:16px;font-style:normal;    -webkit-font-smoothing: antialiased;    -webkit-text-stroke-width: 0.2px;    -moz-osx-font-smoothing: grayscale;}</code></pre><h5 id="第三步：挑选相应图标并获取字体编码，应用于页面"><a href="#第三步：挑选相应图标并获取字体编码，应用于页面" class="headerlink" title="第三步：挑选相应图标并获取字体编码，应用于页面"></a>第三步：挑选相应图标并获取字体编码，应用于页面</h5><pre><code class="js">&lt;i class=&quot;iconfont&quot;&gt;&amp;#x33;&lt;/i&gt;</code></pre><h4 id="font-class-引用"><a href="#font-class-引用" class="headerlink" title="font-class 引用"></a>font-class 引用</h4><hr><p>font-class 是 unicode 使用方式的一种变种，主要是解决 unicode 书写不直观，语意不明确的问题。</p><p>与 unicode 使用方式相比，具有如下特点：</p><ul><li>兼容性良好，支持 ie8+，及所有现代浏览器。</li><li>相比于 unicode 语意明确，书写更直观。可以很容易分辨这个 icon 是什么。</li><li>因为使用 class 来定义图标，所以当要替换图标时，只需要修改 class 里面的 unicode 引用。</li><li>不过因为本质上还是使用的字体，所以多色图标还是不支持的。</li></ul><p>使用步骤如下：</p><h5 id="第一步：拷贝项目下面生成的-fontclass-代码："><a href="#第一步：拷贝项目下面生成的-fontclass-代码：" class="headerlink" title="第一步：拷贝项目下面生成的 fontclass 代码："></a>第一步：拷贝项目下面生成的 fontclass 代码：</h5><pre><code class="js">//at.alicdn.com/t/font_8d5l8fzk5b87iudi.css</code></pre><h5 id="第二步：挑选相应图标并获取类名，应用于页面："><a href="#第二步：挑选相应图标并获取类名，应用于页面：" class="headerlink" title="第二步：挑选相应图标并获取类名，应用于页面："></a>第二步：挑选相应图标并获取类名，应用于页面：</h5><pre><code class="css">&lt;i class=&quot;iconfont icon-xxx&quot;&gt;&lt;/i&gt;</code></pre><h4 id="symbol-引用"><a href="#symbol-引用" class="headerlink" title="symbol 引用"></a>symbol 引用</h4><hr><p>这是一种全新的使用方式，应该说这才是未来的主流，也是平台目前推荐的用法。这种用法其实是做了一个 svg 的集合，与上面两种相比具有如下特点：</p><ul><li>支持多色图标了，不再受单色限制。</li><li>通过一些技巧，支持像字体那样，通过<code>font-size</code>,<code>color</code>来调整样式。</li><li>兼容性较差，支持 ie9+,及现代浏览器。</li><li>浏览器渲染 svg 的性能一般，还不如 png。</li></ul><p>使用步骤如下：</p><h5 id="第一步：拷贝项目下面生成的-symbol-代码："><a href="#第一步：拷贝项目下面生成的-symbol-代码：" class="headerlink" title="第一步：拷贝项目下面生成的 symbol 代码："></a>第一步：拷贝项目下面生成的 symbol 代码：</h5><pre><code class="js">//at.alicdn.com/t/font_8d5l8fzk5b87iudi.js</code></pre><h5 id="第二步：加入通用-css-代码（引入一次就行）："><a href="#第二步：加入通用-css-代码（引入一次就行）：" class="headerlink" title="第二步：加入通用 css 代码（引入一次就行）："></a>第二步：加入通用 css 代码（引入一次就行）：</h5><pre><code class="js">&lt;style type=&quot;text/css&quot;&gt;    .icon {       width: 1em; height: 1em;       vertical-align: -0.15em;       fill: currentColor;       overflow: hidden;    }&lt;/style&gt;</code></pre><h5 id="第三步：挑选相应图标并获取类名，应用于页面："><a href="#第三步：挑选相应图标并获取类名，应用于页面：" class="headerlink" title="第三步：挑选相应图标并获取类名，应用于页面："></a>第三步：挑选相应图标并获取类名，应用于页面：</h5><pre><code class="js">&lt;svg class=&quot;icon&quot; aria-hidden=&quot;true&quot;&gt;  &lt;use xlink:href=&quot;#icon-xxx&quot;&gt;&lt;/use&gt;&lt;/svg&gt;</code></pre><p>以上三种使用姿势的优缺点相信大家都了解了，symbol 这中使用方式就是本文的正题了，其实之前我是一直都使用 font-class 这种方式的(大家估计用这个的也很多)，但是它有点麻烦，因为我每次迭代项目时，修改或者添加图标都要去重新下载一份新的包，还不支持多色图标，但是现在我觉决定换了它，因为 get 到了一种更好的方式，它就是 symbol</p><p>symbol 它支持多色图标，兼容性到 ie9+，这也没什么，毕竟某 e 浏览器差不多凉透了，浏览器渲染 svg 性能这个也可以不用担心，早在 14 年张鑫旭的一篇帖子 <a href="http://www.zhangxinxu.com/wordpress/2014/07/introduce-svg-sprite-technology/?spm=a313x.7781069.1998910419.50" target="_blank" rel="noopener">SVG Sprite 介绍</a> 完美诠释了 svg sprite 的工作方式，并且对其很看好，或许这就是大佬的眼光吧 - _ -</p><p>单纯使用 iconfont 官方那种 symbol 方式其实是有点 low 的，实际开发中我们可以结合项目，让他变得简单，接下来我们就要进入本文正题，优雅使用 icon 了，哈哈哈，码这么多字，我太难了</p><h3 id="项目中优雅使用-icon"><a href="#项目中优雅使用-icon" class="headerlink" title="项目中优雅使用 icon"></a>项目中优雅使用 icon</h3><h5 id="搭建环境获取图标"><a href="#搭建环境获取图标" class="headerlink" title="搭建环境获取图标"></a>搭建环境获取图标</h5><p>我们使用 vue-cli3 搭建项目</p><p>怎么样才算优雅，首先我们在 src 目录下新建<code>icons/</code>文件夹，在<code>icons/</code>文件夹下建<code>svg/</code>文件夹，将来我们项目中的 svg 图标都会统一放在这里</p><p>接下来我们在官网搞来一个 svg 图标</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20191116165415085.png" srcset="/blog/img/loading.gif" alt="image-20191116165415085"></p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20191116165528974.png" srcset="/blog/img/loading.gif" alt="image-20191116165528974"></p><p>点击 svg 下载到<code>icons/svg</code>目录下修改文件名为<code>qq.svg</code>，或者是在<code>icons/svg</code>目录下新建一个<code>qq.svg</code>文件，把复制的 svg 代码放进去也可以</p><p>这样就获取到了一个图标，很 easy</p><h5 id="处理-svg-图标"><a href="#处理-svg-图标" class="headerlink" title="处理 svg 图标"></a>处理 svg 图标</h5><p>vue-cli 对 svg 文件有默认的<code>url-loader</code> 处理，我们要使用 svg 图标需单独进行配置</p><p>下载一个插件<code>svg-sprite-loader</code>来单独处理我们的 svg 图标，它是一个 webpack loader，支持将多个 svg 打包成 svg sprites</p><p>npm 下载</p><pre><code class="js">npm install svg-sprite-loader -D</code></pre><p>yarn 下载</p><pre><code class="js">yarn add svg-sprite-loader -D</code></pre><p>我们要怎么使用它呢，首先我们不能覆盖原有的 svg 解析 loader，我们只需要把<code>icons/svg</code>这个文件夹下的 svg 文件解析打包即可，我们在<code>vue.config.js</code>中 chainWebpack 函数中配置，来看代码</p><pre><code class="js">// 内置路径包const path = require(&quot;path&quot;)// 定义resolve方法，获取绝对路径function resolve(dir) {  return path.join(__dirname, dir)}module.exports = {  // 一个函数，会接收一个基于 webpack-chain 的 ChainableConfig 实例  // 允许对内部的 webpack 配置进行更细粒度的修改  chainWebpack: (config) =&gt; {    // 配置svg默认规则排除icons目录中svg文件处理    config.module.rule(&quot;svg&quot;).exclude.add(resolve(&quot;src/icons&quot;)).end()    // 新增icons规则，设置svg-sprite-loader处理icons目录中svg文件    config.module      .rule(&quot;icons&quot;)      .test(/\.svg$/)      .include.add(resolve(&quot;src/icons&quot;))      .end()      .use(&quot;svg-sprite-loader&quot;)      .loader(&quot;svg-sprite-loader&quot;)      .options({ symbolId: &quot;icon-[name]&quot; })      .end()  },}</code></pre><p>如果我们不清楚 cli 的默认配置，怕改错，可通过 vue inspect 审查 webpack 内部配置，详细请看： <a href="*https://cli.vuejs.org/zh/guide/webpack.html#%E5%AE%A1%E6%9F%A5%E9%A1%B9%E7%9B%AE%E7%9A%84-webpack-%E9%85%8D%E7%BD%AE*">inspect 使用</a></p><p>上面代码中我们使用了 webpack 的链式高级用法来处理 loader，首先排除了默认 svg 的 loader 对我们<code>icons/</code>目录下 svg 文件的处理，然后新增了一个规则让<code>svg-sprite-loader</code>处理我们<code>icons/</code>文件夹下的 svg 文件，最后我们设置了<code>icon-</code>加上经过处理的 svg 文件名作为 symbolId，也就是说我们在使用<code>qq.svg</code>时可以直接在 use 标签使用<code>#icon-qq</code>，关于链式操作不了解的小伙伴可以看: <a href="[https://cli.vuejs.org/zh/guide/webpack.html#%E9%93%BE%E5%BC%8F%E6%93%8D%E4%BD%9C-%E9%AB%98%E7%BA%A7](https://cli.vuejs.org/zh/guide/webpack.html#链式操作-高级)">链式操作(高级)</a></p><p>代码中我们引入了<code>path</code>这样一个内置的包，定义了一个<code>resolve</code>方法，该方法主要是来获取文件绝对路径的，我们把使用路径的地方都使用该方法转为绝对路径，当然使用相对路径也是可以的，但是不太安全，平台解析相对路径有差异性，所以绝对路径是最安全的</p><h5 id="svg-sprites-图标使用"><a href="#svg-sprites-图标使用" class="headerlink" title="svg sprites 图标使用"></a>svg sprites 图标使用</h5><p>现在我们就可以在你想使用图标的位置使用了，使用方式如下</p><p>在<code>main.js</code>中引入(全局引入)要使用的图标文件</p><pre><code class="js">import &quot;@/icons/svg/qq.svg&quot;</code></pre><p>模版中使用</p><pre><code class="vue">&lt;svg&gt;  &lt;use xlink:href=&quot;#icon-qq&quot;&gt;&lt;/use&gt;&lt;/svg&gt;</code></pre><p>你以为这就完了？不，还远远不够，这样使用一个图标就得引入文件一次也太麻烦了，接着看下文</p><h5 id="进阶-svg-文件自动引入"><a href="#进阶-svg-文件自动引入" class="headerlink" title="进阶-svg 文件自动引入"></a>进阶-svg 文件自动引入</h5><p>知道为什么在<code>icons/</code>文件夹下还有一个存放 svg 文件的<code>svg/</code>文件夹吗，就是为了这一步自动化引入准备的，我们在<code>icons/</code>文件夹下新建<code>index.js</code>文件，两行代码搞定，内容如下</p><pre><code class="js">// icons图标自动加载const req = require.context(&quot;./svg&quot;, false, /\.svg$/)req.keys().map(req)</code></pre><p>上面代码中我们使用<code>require.context</code>设置了当前目录下的<code>./svg</code>文件为上下文，使用正则匹配了它需要检测的文件名，这样它就会在当前目录的 svg 文件夹下去匹配符合规则的文件名</p><p>然后我们使用<code>req.keys</code>拿到所有文件名数组，再使用 map 遍历加载 req 方法，这样当该文件被调用时会遍历加载所有匹配到的文件，这就很 nice 了</p><p>看看我们改进后的使用方法：</p><p>注释掉之前的代码，在<code>main.js</code>中引入<code>icons/index.js</code>文件</p><pre><code class="js">import &quot;@/icons/index.js&quot;</code></pre><p>模板中使用和上面一样，不过这次改进当我们再次下载了一个 svg 图标时，不用再引入一遍图标 svg 了，因为我们做了自动化，<code>icons/svg/</code>下的 svg 后缀图标文件都可被自动引入</p><pre><code class="vue">&lt;svg&gt;  &lt;use xlink:href=&quot;#icon-qq&quot;&gt;&lt;/use&gt;&lt;/svg&gt;&lt;svg&gt;  &lt;use xlink:href=&quot;#icon-wx&quot;&gt;&lt;/use&gt;&lt;/svg&gt;...</code></pre><p>是不是很方便，你以为结束了？不，我们还可以再简化，因为每次使用都得 svg 标签包着 use 太麻烦了，写着也不太雅观，我们继续简化，一定要看起来使用起来都十分优雅</p><h5 id="再进阶-SvgIcon-组件"><a href="#再进阶-SvgIcon-组件" class="headerlink" title="再进阶-SvgIcon 组件"></a>再进阶-SvgIcon 组件</h5><p>在<code>components/</code>目录下新建<code>SvgIcon/index.vue</code>文件，我们写一个 svgicon 组件，封装一下再全局注册，这样使用起来就会很方便了！</p><p>svg-icon 组件代码如下：</p><pre><code class="vue">&lt;template&gt;  &lt;svg :class=&quot;svgClass&quot; aria-hidden=&quot;true&quot; v-on=&quot;$listeners&quot;&gt;    &lt;use :xlink:href=&quot;iconName&quot; /&gt;  &lt;/svg&gt;&lt;/template&gt;&lt;script&gt;export default {  name: &quot;SvgIcon&quot;,  props: {    iconClass: {      type: String,      required: true,    },    className: {      type: String,      default: &quot;&quot;,    },  },  computed: {    iconName() {      return `#icon-${this.iconClass}`    },    svgClass() {      if (this.className) {        return &quot;svg-icon &quot; + this.className      } else {        return &quot;svg-icon&quot;      }    },  },}&lt;/script&gt;&lt;style scoped&gt;.svg-icon {  width: 1em;  height: 1em;  vertical-align: -0.15em;  fill: currentColor;  overflow: hidden;}&lt;/style&gt;</code></pre><p>当然组件内部我们还可以根据自身项目情况进行扩展，我这边写了基础的配置</p><p>组件写好了之后我们在<code>icons/index.js</code>中进行全局注册，这样我们只引入这一个文件就可以达到自动加载和组件注册两个功能</p><p><code>icons/index.js</code>改进如下：</p><pre><code class="js">import Vue from &quot;vue&quot;import SvgIcon from &quot;@/components/SvgIcon&quot;// icons图标自动加载const req = require.context(&quot;./svg&quot;, false, /\.svg$/)req.keys().map(req)// 全局注册svg-icon组件Vue.component(&quot;svg-icon&quot;, SvgIcon)</code></pre><p>最后就是我们的使用了，在<code>main.js</code>文件引入<code>icons/index.js</code></p><pre><code class="js">import &quot;@/icons/index.js&quot;</code></pre><p>再来看看我们使用图标的方法，组件中：</p><pre><code class="vue">&lt;template&gt;  &lt;svg-icon icon-class=&quot;qq&quot; class-name=&quot;qq-style&quot;&gt;&lt;/svg-icon&gt;&lt;/template&gt;</code></pre><p>看，我们只用在<code>icon-class</code>中传入要使用的图标文件名就可以了，当然<code>class-name</code>还可以传入一个类，进行一些简单的样式修改，是不是很优雅，你 get 到了吗？</p><h3 id="Vue-Awesome"><a href="#Vue-Awesome" class="headerlink" title="Vue-Awesome"></a>Vue-Awesome</h3><p>从掘友那了解到了<a href="https://github.com/Justineo/vue-awesome" target="_blank" rel="noopener">vue-awesome</a>，体验了一番，很 nice，内置了<a href="https://fontawesome.com/" target="_blank" rel="noopener">fontawesome</a>字体图标库</p><p>好像也没啥可对比的，svg 图标引入原理差不多，vue-awesome 除了内置了 fontawesome 图标库之外也可以自己引入图标使用，做了很全面的封装，针对图标由很多功能，所以使用的话会体积会稍大</p><p>不过个人觉得，有了 iconfont 图标库，好像没有太大必要去再用 fontawesome，fontawesome 也并不是全免费，而且国外站点访问很慢，iconfont 毕竟是阿里出的，很全，针对 icon 的话我们可能并不需要太多功能，所以上面我们自己配置的话清晰明了，就已经够用，自己写的话熟悉流程 10 分钟搭一个，实在不够用，我们可以在组件花些功夫，自己做封装的话针对性强，定制性当然是看我们自己需要了，最靠谱的是使用轮子不如造轮子，哈哈</p><p>vue-awesome 是很好的，我们可以从中借鉴一些思路用于自己开发 icon 组件也是不错的，比如那些功能，我们都可以一一实现下，重要的是过程，哈哈</p><blockquote><p>参考文章：</p><p><a href="http://www.zhangxinxu.com/wordpress/2014/07/introduce-svg-sprite-technology/?spm=a313x.7781069.1998910419.50" target="_blank" rel="noopener">未来必热：SVG Sprites 技术介绍-张鑫旭</a></p><p><a href="https://juejin.im/post/59bb864b5188257e7a427c09" target="_blank" rel="noopener">手摸手，带你优雅的使用 icon-掘金</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Vue相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue 基础面试题</title>
    <link href="/blog/2019/06/10/vue/Vue%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/blog/2019/06/10/vue/Vue%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue-基础面试题"><a href="#Vue-基础面试题" class="headerlink" title="Vue 基础面试题"></a>Vue 基础面试题</h1><h3 id="1-MVVM-amp-amp-MVC"><a href="#1-MVVM-amp-amp-MVC" class="headerlink" title="1. MVVM&amp;&amp;MVC"></a>1. MVVM&amp;&amp;MVC</h3><h4 id="1-1-MVVM"><a href="#1-1-MVVM" class="headerlink" title="1.1 MVVM"></a>1.1 MVVM</h4><pre><code class="js">MVVM -&gt; Model-View-ViewModelModel 代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑。View 代表UI组件，它负责将数据模型转化成UI展现出来。ViewModel 监听模型数据的改变和控制视图行为、处理用户交互，简单理解就是一个同步View 和 Model的对象，连接Model和View。在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互，Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。</code></pre><h4 id="1-2-MVC"><a href="#1-2-MVC" class="headerlink" title="1.2 MVC"></a>1.2 MVC</h4><pre><code class="JS">MVC是Model-View- Controller的简写，即模型-视图-控制器，M和V和MVVM中的M和V是一样的，C是Controller即页面义务逻辑使用MVC的目的就是为了M和V代码分离。MVVM的VM并不是完全取代C，VM存在的目的是抽离C中的业务逻辑</code></pre><h4 id="1-3-MVVM-amp-amp-MVC-区别"><a href="#1-3-MVVM-amp-amp-MVC-区别" class="headerlink" title="1.3 MVVM&amp;&amp;MVC 区别"></a>1.3 MVVM&amp;&amp;MVC 区别</h4><pre><code class="js">MVC是单向的数据传递。MVVM是双向数据绑定，主要解决了MVC中大量的DOM操作使页面的渲染性能降低，加载速度变慢，影响用户体验</code></pre><h3 id="2-Vue-生命周期"><a href="#2-Vue-生命周期" class="headerlink" title="2. Vue 生命周期"></a>2. Vue 生命周期</h3><h4 id="2-1-什么是生命周期"><a href="#2-1-什么是生命周期" class="headerlink" title="2.1 什么是生命周期"></a>2.1 什么是生命周期</h4><pre><code class="js">Vue 实例从创建到销毁的过程，就是生命周期。从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、销毁等一系列过程，称之为 Vue 的生命周期</code></pre><h4 id="2-2-生命周期的作用"><a href="#2-2-生命周期的作用" class="headerlink" title="2.2 生命周期的作用"></a>2.2 生命周期的作用</h4><pre><code class="js">生命周期中有多个事件钩子，在控制整个Vue实例的过程时更容易形成好的逻辑</code></pre><h4 id="2-3-生命周期阶段"><a href="#2-3-生命周期阶段" class="headerlink" title="2.3 生命周期阶段"></a>2.3 生命周期阶段</h4><pre><code class="js">它可以总共分为8个阶段：创建前/后, 载入前/后,更新前/后,销毁前/销毁后beforeCreate （创建前） 在数据观测和初始化事件还未开始created         （创建后） 完成数据观测，属性和方法的运算，初始化事件，$el属性还没有显示出来beforeMount  （载入前） 在挂载开始之前被调用，相关的render函数首次被调用。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。注意此时还没有挂载html到页面上。mounted      （载入后） 在el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html页面中。此过程中进行ajax交互。beforeUpdate （更新前） 在数据更新之前调用，发生在虚拟DOM重新渲染和打补丁之前。可以在该钩子中进一步地更改状态，不会触发附加的重渲染过程。updated      （更新后） 在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。beforeDestroy（销毁前） 在实例销毁之前调用。实例仍然完全可用。destroyed    （销毁后） 在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。</code></pre><h4 id="2-4-第一次加载会触发哪些钩子"><a href="#2-4-第一次加载会触发哪些钩子" class="headerlink" title="2.4 第一次加载会触发哪些钩子"></a>2.4 第一次加载会触发哪些钩子</h4><pre><code class="js">会触发beforeCreate, created, beforeMount, mounted</code></pre><h4 id="2-5-DOM-渲染在哪个周期中就已经完成"><a href="#2-5-DOM-渲染在哪个周期中就已经完成" class="headerlink" title="2.5 DOM 渲染在哪个周期中就已经完成"></a>2.5 DOM 渲染在哪个周期中就已经完成</h4><pre><code class="js">DOM 渲染在 mounted 中就已经完成</code></pre><h3 id="3-双向绑定原理"><a href="#3-双向绑定原理" class="headerlink" title="3. 双向绑定原理"></a>3. 双向绑定原理</h3><h4 id="3-1-原理"><a href="#3-1-原理" class="headerlink" title="3.1 原理"></a>3.1 原理</h4><pre><code class="js">Object.defineProperty()vue实现数据双向绑定主要是：采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty（）来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应监听回调。当把一个普通 Javascript 对象传给 Vue 实例来作为它的 data 选项时，Vue 将遍历它的属性，用 Object.defineProperty 将它们转为 getter/setter。用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。vue的数据双向绑定 将MVVM作为数据绑定的入口，整合Observer，Compile和Watcher三者，通过Observer来监听自己的model的数据变化，通过Compile来解析编译模板指令（vue中是用来解析 {{}}），最终利用watcher搭起observer和Compile之间的通信桥梁，达到数据变化 —&gt;视图更新；视图交互变化（input）—&gt;数据model变更双向绑定效果</code></pre><h4 id="3-2-js-实现双向数据绑定"><a href="#3-2-js-实现双向数据绑定" class="headerlink" title="3.2 js 实现双向数据绑定"></a>3.2 js 实现双向数据绑定</h4><pre><code class="html">&lt;body&gt;  &lt;div id=&quot;app&quot;&gt;    &lt;input type=&quot;text&quot; id=&quot;txt&quot; /&gt;    &lt;p id=&quot;show&quot;&gt;&lt;/p&gt;  &lt;/div&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot;&gt;  var obj = {}  Object.defineProperty(obj, &quot;txt&quot;, {    get: function () {      return obj    },    set: function (newValue) {      document.getElementById(&quot;txt&quot;).value = newValue      document.getElementById(&quot;show&quot;).innerHTML = newValue    },  })  document.addEventListener(&quot;keyup&quot;, function (e) {    obj.txt = e.target.value  })&lt;/script&gt;</code></pre><h3 id="4-Vue-组件传参"><a href="#4-Vue-组件传参" class="headerlink" title="4. Vue 组件传参"></a>4. Vue 组件传参</h3><h4 id="4-1-父与子传参"><a href="#4-1-父与子传参" class="headerlink" title="4.1 父与子传参"></a>4.1 父与子传参</h4><pre><code class="js">子组件通过props方法接受数据</code></pre><h4 id="4-2-子与父传参"><a href="#4-2-子与父传参" class="headerlink" title="4.2 子与父传参"></a>4.2 子与父传参</h4><pre><code class="js">$emit方法传递参数</code></pre><h4 id="4-3-非父子-amp-amp-兄弟间传参"><a href="#4-3-非父子-amp-amp-兄弟间传参" class="headerlink" title="4.3 非父子&amp;&amp;兄弟间传参"></a>4.3 非父子&amp;&amp;兄弟间传参</h4><pre><code class="js">eventBus，创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。项目比较小时，这个比较合适。也可以直接使用用VUEX，具体来说看需求</code></pre><h3 id="5-Vue-路由"><a href="#5-Vue-路由" class="headerlink" title="5. Vue 路由"></a>5. Vue 路由</h3><h4 id="5-1-路由跳转"><a href="#5-1-路由跳转" class="headerlink" title="5.1 路由跳转"></a>5.1 路由跳转</h4><pre><code class="js">声明式(标签式)&lt;router-link :to=&quot;index&quot;&gt;编程式router.push({path:&#39;/&#39;,query:{}})</code></pre><h4 id="5-2-路由实现：hash-模式-和-history-模式"><a href="#5-2-路由实现：hash-模式-和-history-模式" class="headerlink" title="5.2 路由实现：hash 模式 和 history 模式"></a>5.2 路由实现：hash 模式 和 history 模式</h4><pre><code class="js">hash模式：在浏览器中符号“#”，#以及#后面的字符称之为hash，用window.location.hash读取；特点：hash虽然在URL中，但不被包括在HTTP请求中；用来指导浏览器动作，对服务端安全无用，hash不会重加载页面。hash 模式下，仅 hash 符号之前的内容会被包含在请求中，如 http://www.xxx.com，因此对于后端来说，即使没有做到对路由的全覆盖，也不会返回 404 错误。history模式：history采用HTML5的新特性；且提供了两个新方法：pushState（），replaceState（）可以对浏览器历史记录栈进行修改，以及popState事件的监听到状态变更。history 模式下，前端的 URL 必须和实际向后端发起请求的 URL 一致，如 http://www.xxx.com/items/id。后端如果缺少对 /items/id 的路由处理，将返回 404 错误。Vue-Router 官网里如此描述：“不过这种模式要玩好，还需要后台配置支持……所以呢，你要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。”</code></pre><h4 id="5-3-Vue-路由守卫-路由钩子"><a href="#5-3-Vue-路由守卫-路由钩子" class="headerlink" title="5.3 Vue 路由守卫(路由钩子)"></a>5.3 Vue 路由守卫(路由钩子)</h4><p>全局守卫</p><pre><code class="js">beforeEach，afterEach 路由钩子函数，也叫路由守卫beforeEach 全局前置守卫，当一个导航触发时，全局前置守卫按照创建顺序调用参数：to：route即将要进入的目标路由对象from：route当前导航正要离开的路由next：function一定要调用该方法resolve这个钩子。执行效果依赖next方法的调用参数。可以控制网页的跳转    next()：跳转下一个页面    next(false): 中断当前的导航，返回原来页面    next({path:&#39;/&#39;})：跳转到一个不同的地址，当前的导航被中断，进行一个新的导航注意：一定要调用next(),否则钩子就不会被 resolved，页面会卡在那，一般用于对路由跳转前进行拦截afterEach 全局后置钩子router.afterEach((to, from) =&gt; {})和前置守卫不同的是，这些钩子不会接受 next 函数也不会改变导航本身</code></pre><p>局部(组件)守卫</p><pre><code class="js">组件中路由钩子beforeRouteEnter(to,from,next){} 路由跳转时注：此钩子在beforeCreate之前执行，但是next在组件mounted周期之后,无法直接调用this访问组件实例，可用next访问vm实例，修改数据beforeRouteLeave(to,from,next){...next()} 离开路由时注意：可以直接访问this,next不可回调beforeRouteUpdate 路由切换时</code></pre><h4 id="5-4-动态渲染路由-addRoutes"><a href="#5-4-动态渲染路由-addRoutes" class="headerlink" title="5.4 动态渲染路由 addRoutes"></a>5.4 动态渲染路由 addRoutes</h4><pre><code class="js">addRoutes用于动态添加路由常用场景：页面级权限控制，服务端存储路由对象，登录后页面加载时根据不同权限动态渲染路由</code></pre><h3 id="6-Vue-计算属性"><a href="#6-Vue-计算属性" class="headerlink" title="6. Vue 计算属性"></a>6. Vue 计算属性</h3><h4 id="6-1-为什么使用计算属性-优点"><a href="#6-1-为什么使用计算属性-优点" class="headerlink" title="6.1 为什么使用计算属性(优点)"></a>6.1 为什么使用计算属性(优点)</h4><pre><code class="js">模板中放入太多的逻辑会让模板过重且难以维护，在需要对数据进行复杂处理，且可能多次使用的情况下，尽量采取计算属性的方式优点：1. 使得数据处理结构清晰2. 依赖于数据，数据更新，处理结果自动更新3. 计算属性内部this指向vm实例4. 在template调用时，直接写计算属性名即可5. methods不管依赖的数据变不变，都会重新计算，computed依赖数据不变时缓存中获取，不会重新计算</code></pre><h3 id="7-Vuex"><a href="#7-Vuex" class="headerlink" title="7. Vuex"></a>7. Vuex</h3><h4 id="7-1-简述"><a href="#7-1-简述" class="headerlink" title="7.1 简述"></a>7.1 简述</h4><pre><code class="js">vue中状态管理器，实现组件间的数据共享通过状态（数据源）集中管理驱动组件的变化，应用级的状态集中放在store中； 改变状态的方式是提交mutations，这是个同步的事物； 异步逻辑应该封装在action中在main.js引入store，注入。新建了一个目录store，... export</code></pre><h3 id="8-浅谈-keep-alive"><a href="#8-浅谈-keep-alive" class="headerlink" title="8. 浅谈 keep-alive"></a>8. 浅谈 keep-alive</h3><pre><code class="js">keep-alive是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染，相当于强缓存vue 2.1.0 版本之后，keep-alive新加入了两个属性: include(包含的组件缓存) 与 exclude(排除的组件不缓存，优先级大于include)</code></pre><p>示例：</p><pre><code class="html">&lt;keep-alive include=&quot;include_components&quot; exclude=&quot;exclude_components&quot;&gt;  &lt;component&gt;    &lt;!-- 该组件是否缓存取决于include和exclude属性 --&gt;  &lt;/component&gt;&lt;/keep-alive&gt;&lt;keep-alive  &gt;&lt;router-view v-if=&quot;”$route.meta.keepAlive”&quot;&gt;&lt;/router-view&gt;&lt;/keep-alive&gt;&lt;router-view v-if=&quot;”$route.meta.keepAlive”&quot;&gt;&lt;/router-view&gt;</code></pre><p>参数：</p><pre><code class="js">include - 字符串或正则表达式，只有名称匹配的组件会被缓存exclude - 字符串或正则表达式，任何名称匹配的组件都不会被缓存include 和 exclude 的属性允许组件有条件地缓存。二者都可以用“，”分隔字符串、正则表达式、数组。当使用正则或者是数组时，要使用v-bind</code></pre><p>示例：</p><pre><code class="html">&lt;!-- 逗号分隔字符串，只有组件a与b被缓存。 --&gt;&lt;keep-alive include=&quot;a,b&quot;&gt;  &lt;component&gt;&lt;/component&gt;&lt;/keep-alive&gt;&lt;!-- 正则表达式 (需要使用 v-bind，符合匹配规则的都会被缓存) --&gt;&lt;keep-alive :include=&quot;/a|b/&quot;&gt;  &lt;component&gt;&lt;/component&gt;&lt;/keep-alive&gt;&lt;!-- Array (需要使用 v-bind，被包含的都会被缓存) --&gt;&lt;keep-alive :include=&quot;[&#39;a&#39;, &#39;b&#39;]&quot;&gt;  &lt;component&gt;&lt;/component&gt;&lt;/keep-alive&gt;</code></pre><h3 id="9-Vue-自定义指令"><a href="#9-Vue-自定义指令" class="headerlink" title="9. Vue 自定义指令"></a>9. Vue 自定义指令</h3><pre><code class="js">vue.directive,可以写在组件内部，也可以写在外部作为全局的使用它的钩子有bind，inserted，update等</code></pre><h3 id="10-Vue-两大核心是什么"><a href="#10-Vue-两大核心是什么" class="headerlink" title="10. Vue 两大核心是什么"></a>10. Vue 两大核心是什么</h3><pre><code class="js">1. 数据驱动2. 组件系统</code></pre><h3 id="11-route-和-router-的区别"><a href="#11-route-和-router-的区别" class="headerlink" title="11. $route 和$router 的区别"></a>11. $route 和$router 的区别</h3><pre><code class="js">$route是&lt;路由信息对象&gt;，包括path，params，hash，query，fullPath，matched，name等路由信息参数$router是&lt;路由实例&gt;对象包括了路由的跳转方法，钩子函数等</code></pre><h3 id="12-Vue-常用修饰符"><a href="#12-Vue-常用修饰符" class="headerlink" title="12. Vue 常用修饰符"></a>12. Vue 常用修饰符</h3><pre><code class="js">.prevent: 提交事件不再重载页面.stop   : 阻止单击事件冒泡.self   : 当事件发生在该元素本身而不是子元素的时候会触发.capture: 事件侦听，事件发生的时候会调用</code></pre><h3 id="13-Vue-中-v-on-怎样绑定多个事件"><a href="#13-Vue-中-v-on-怎样绑定多个事件" class="headerlink" title="13. Vue 中 v-on 怎样绑定多个事件"></a>13. Vue 中 v-on 怎样绑定多个事件</h3><pre><code class="js">方法名后加 () =&gt; 调用方法 多个方法用 ; 隔开例：&lt;div @click=&quot;one();two();three()&quot;&gt;&lt;/div&gt;</code></pre><h3 id="14-vue-中-key-值的作用"><a href="#14-vue-中-key-值的作用" class="headerlink" title="14. vue 中 key 值的作用"></a>14. vue 中 key 值的作用</h3><pre><code class="js">当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。key的作用主要是为了高效的更新虚拟DOM简单来说：为了避免重复渲染，高效更新渲染DOM</code></pre><h3 id="15-Vue-中-css-怎样只在当前组件起作用"><a href="#15-Vue-中-css-怎样只在当前组件起作用" class="headerlink" title="15. Vue 中 css 怎样只在当前组件起作用"></a>15. Vue 中 css 怎样只在当前组件起作用</h3><pre><code class="html">style标签中写入scoped即可 例如：&lt;style scoped&gt;&lt;/style&gt;</code></pre><h3 id="16-v-if-和-v-show-区别"><a href="#16-v-if-和-v-show-区别" class="headerlink" title="16. v-if 和 v-show 区别"></a>16. v-if 和 v-show 区别</h3><pre><code class="js">v-if按照条件是否渲染，如果为false不会渲染v-show是相当于display的block或none，为false是还是会渲染，只不过隐藏了</code></pre><h3 id="17-为什么避免-v-if-和-v-for-用在一起"><a href="#17-为什么避免-v-if-和-v-for-用在一起" class="headerlink" title="17. 为什么避免 v-if 和 v-for 用在一起"></a>17. 为什么避免 v-if 和 v-for 用在一起</h3><pre><code class="js">vue处理指令时，v-for比v-if具有更高的优先级，通过v-if移动到容器的元素，不会在重复遍历列表中的每个值，取而代之的是，我们只检查它一次，且不会v-if为否的时候运算v-for</code></pre><h3 id="18-单页面-SPA-和多页面的区别-优缺点"><a href="#18-单页面-SPA-和多页面的区别-优缺点" class="headerlink" title="18. 单页面(SPA)和多页面的区别(优缺点)"></a>18. 单页面(SPA)和多页面的区别(优缺点)</h3><pre><code class="js">单页面：整个项目中只有一个完整的HTML页面，其它&quot;页面&quot;只是一段HTML片断而已优: 请求少缺: 不利于搜索引擎优化，首次加载时间长页面跳转本质：把当前DOM树中某个DIV删除，下载并挂载另一个div片断多页面：项目中有多个独立的完整的HTML页面缺: 请求次数多，效率低页面跳转本质: 删除旧的DOM树，重新下载新的DOM树</code></pre><h3 id="19-Vue-的优缺点是什么"><a href="#19-Vue-的优缺点是什么" class="headerlink" title="19. Vue 的优缺点是什么"></a>19. Vue 的优缺点是什么</h3><pre><code class="js">优点：低耦合，可重用性，独立开发，可测试，渐进式缺点：不利于SEO，社区维护力度不强，相比还不够成熟</code></pre><h3 id="20-vue-和-react-区别"><a href="#20-vue-和-react-区别" class="headerlink" title="20. vue 和 react 区别"></a>20. vue 和 react 区别</h3><pre><code class="js">相同点：都鼓励组件化，都有props的概念，都有自己的构建工具，React与Vue只有框架的骨架，其他的功能如路由、状态管理等是框架分离的组件不同点：React：单向数据流，语法—JSX，在React中你需要使用setState()方法去更新状态Vue：双向数据流，语法--HTML，state对象并不是必须的，数据由data属性在Vue对象中进行管理。适用于小型应用，对于大型应用而言不太适合</code></pre>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GIT常用命令</title>
    <link href="/blog/2019/04/12/other/GIT%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/blog/2019/04/12/other/GIT%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="GIT-常用命令"><a href="#GIT-常用命令" class="headerlink" title="GIT 常用命令"></a>GIT 常用命令</h1><h3 id="SSH-公钥"><a href="#SSH-公钥" class="headerlink" title="SSH 公钥"></a>SSH 公钥</h3><h5 id="查看本机-ssh-公钥"><a href="#查看本机-ssh-公钥" class="headerlink" title="查看本机 ssh 公钥"></a>查看本机 ssh 公钥</h5><pre><code class="js">1. 打开git bash窗口2. 进入.ssh目录： cd ~/.ssh3. 查看.ssh文件下有无id_rsa.pub文件：ls4. 查看公钥：cat id_rsa.pub  或者  vim id_rsa.pub上述步骤合为一步: cat ~/.ssh/id_rsa.pub</code></pre><h5 id="生成本机-ssh-公钥"><a href="#生成本机-ssh-公钥" class="headerlink" title="生成本机 ssh 公钥"></a>生成本机 ssh 公钥</h5><pre><code class="js">1. 命令行下输入: ssh-keygen2. 确认存放公钥的地址，默认就是上面说的路径，直接enter键确认3. 输入密码和确认密码，如果不想设置密码直接不输入内容 按enter键4. 重复上面查看公钥步骤</code></pre><h5 id="git-中字母代表"><a href="#git-中字母代表" class="headerlink" title="git 中字母代表"></a>git 中字母代表</h5><pre><code class="js">A         # 增加的文件C       # 文件的一个新拷贝D       # 删除的一个文件M       # 文件的内容或者mode被修改了R       # 文件名被修改了T       # 文件类型被修改了U       # 文件没有被合并(需要完成合并才能进行提交)X       # 未知状态(git的bug , 可以向git提交bug report)</code></pre><h3 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h3><h5 id="查询本机已配置参数"><a href="#查询本机已配置参数" class="headerlink" title="查询本机已配置参数"></a>查询本机已配置参数</h5><pre><code class="js">git config --list</code></pre><h5 id="签名级别"><a href="#签名级别" class="headerlink" title="签名级别"></a>签名级别</h5><pre><code class="js">system // 所有用户(本系统)global // 全局local // 本地(默认)</code></pre><h5 id="配置签名–用户名和邮箱"><a href="#配置签名–用户名和邮箱" class="headerlink" title="配置签名–用户名和邮箱"></a>配置签名–用户名和邮箱</h5><p>Git 提交前，必须配置签名, 即用户名和邮箱 信息会永久保存到历史记录</p><pre><code class="js">项目级别git config user.name [AAA]git config user.email [邮箱地址]系统级别git config --global user.name &quot;aaa&quot;git config --global user.email 111@qq.com</code></pre><h5 id="签名信息位置"><a href="#签名信息位置" class="headerlink" title="签名信息位置"></a>签名信息位置</h5><pre><code class="js">cat.git / config</code></pre><h3 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h3><h5 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h5><pre><code class="js">mkdir 新目录名     // 创建一个新目录cd 新目录名        // 进入新目录下pwd               // 显示当前路径</code></pre><h5 id="初始化版本库"><a href="#初始化版本库" class="headerlink" title="初始化版本库"></a>初始化版本库</h5><pre><code class="js">git init</code></pre><h5 id="查看-git-文件"><a href="#查看-git-文件" class="headerlink" title="查看.git 文件"></a>查看.git 文件</h5><pre><code class="js">ls - ah</code></pre><h5 id="添加到仓库暂存区"><a href="#添加到仓库暂存区" class="headerlink" title="添加到仓库暂存区"></a>添加到仓库暂存区</h5><pre><code class="js">git add a.txt index.html</code></pre><h5 id="提交到本地仓库"><a href="#提交到本地仓库" class="headerlink" title="提交到本地仓库"></a>提交到本地仓库</h5><pre><code class="js">git commit -m &quot;提交说明&quot;</code></pre><h5 id="查看当前仓库工作区的状态"><a href="#查看当前仓库工作区的状态" class="headerlink" title="查看当前仓库工作区的状态"></a>查看当前仓库工作区的状态</h5><pre><code class="js">git status</code></pre><h5 id="比较修改的差异"><a href="#比较修改的差异" class="headerlink" title="比较修改的差异"></a>比较修改的差异</h5><pre><code class="js">git diff</code></pre><h5 id="查看提交日志"><a href="#查看提交日志" class="headerlink" title="查看提交日志"></a>查看提交日志</h5><p>16 进制字符串代表 commit id</p><pre><code class="js">git log                                         // 按提交时间列出所有的更新,显示完整信息git log --pretty=oneline                      // 将每个提交放在一行显示,显示完整commit idgit log --oneline                             // 将每个提交放在一行显示,显示不完整commit idgit reflog (HEAD@{移动到当前版本})               // 查看之前版本的log,包括删除的,可查找历史commitID</code></pre><h5 id="版本回滚"><a href="#版本回滚" class="headerlink" title="版本回滚"></a>版本回滚</h5><p>上一版本<code>HEAD^</code>，上上一版本<code>HEAD^^</code> ，上 100<code>HEAD~100</code></p><pre><code class="js">git reset --hard HEAD^</code></pre><h5 id="撤回回滚"><a href="#撤回回滚" class="headerlink" title="撤回回滚"></a>撤回回滚</h5><p>没关闭命令行,a8543 为回退前文件 commitID,只需要前几位就行</p><pre><code class="js">git reset --hard a8543</code></pre><h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><h5 id="克隆项目"><a href="#克隆项目" class="headerlink" title="克隆项目"></a>克隆项目</h5><pre><code class="js">git clone &#39;仓库地址&#39;</code></pre><h5 id="关联远程仓库"><a href="#关联远程仓库" class="headerlink" title="关联远程仓库"></a>关联远程仓库</h5><pre><code class="js">git remote add &#39;仓库地址&#39;</code></pre><h5 id="查看关联远程库"><a href="#查看关联远程库" class="headerlink" title="查看关联远程库"></a>查看关联远程库</h5><pre><code class="js">git remote -v</code></pre><h5 id="修改关联远程库"><a href="#修改关联远程库" class="headerlink" title="修改关联远程库"></a>修改关联远程库</h5><pre><code class="js">git remote set-url origin &#39;仓库地址&#39;</code></pre><h5 id="推送远程仓库"><a href="#推送远程仓库" class="headerlink" title="推送远程仓库"></a>推送远程仓库</h5><pre><code class="js">git push -u origin master   // 第一次推送git push origin master      // 再次推送</code></pre>]]></content>
    
    
    <categories>
      
      <category>Web相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript常用内置API</title>
    <link href="/blog/2019/03/10/javascript/JavaScript%E5%B8%B8%E7%94%A8%E5%86%85%E7%BD%AEAPI/"/>
    <url>/blog/2019/03/10/javascript/JavaScript%E5%B8%B8%E7%94%A8%E5%86%85%E7%BD%AEAPI/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript-常用内置-API"><a href="#JavaScript-常用内置-API" class="headerlink" title="JavaScript 常用内置 API"></a>JavaScript 常用内置 API</h1><h3 id="JS-简述"><a href="#JS-简述" class="headerlink" title="JS 简述"></a>JS 简述</h3><h5 id="三大对象"><a href="#三大对象" class="headerlink" title="三大对象"></a>三大对象</h5><h6 id="本地对象"><a href="#本地对象" class="headerlink" title="本地对象"></a>本地对象</h6><ul><li>与宿主无关，独立于宿主环境的 ECMAScript 实现提供的对象</li><li>简单来说，本地对象就是 <code>ECMA-262</code> 定义的类（引用类型）</li><li>这些引用类型在运行过程中需要通过 <code>new</code> 来创建所需的实例对象</li></ul><p>包括：</p><p>引用类型：<code>Object</code>、<code>Function</code>、<code>Array</code>、<code>Date</code>、<code>RegExp</code></p><p>基本包装类型：<code>String</code>、<code>Boolean</code>、<code>Number</code></p><p>其他类型：<code>Error</code>、<code>EvalError</code>、<code>RangeError</code>、<code>ReferenceError</code>、<code>SyntaxError</code>、<code>TypeError</code>、<code>URIError</code>等</p><h6 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h6><ul><li>与宿主无关，独立于宿主环境的 ECMAScript 实现提供的对象，在 ECMAScript 程序开始执行时出现</li><li>在 <code>ECMAScript</code> 程序开始执行前就存在，本身就是实例化内置对象，开发者无需再去实例化</li><li>内置对象是本地对象的子集</li><li>很多时候，会直接把本地对象和内置对象统称为内置对象，也被叫做单体内置对象</li></ul><p>包含：</p><p><code>Global</code>和<code>Math</code></p><p><code>ECMAScript5</code>中增添了<code>JSON</code>这个存在于全局的内置对象</p><h6 id="宿主对象"><a href="#宿主对象" class="headerlink" title="宿主对象"></a>宿主对象</h6><ul><li>由 ECMAScript 实现的宿主环境提供的对象，包含两大类，一个是宿主提供，一个是自定义类对象</li><li>所有非本地对象都属于宿主对象</li><li>对于嵌入到网页中的 JS 来说，其宿主对象就是浏览器提供的对象，浏览器对象有很多，如<code>Window</code>和<code>Document</code>等</li><li>所有的<code>DOM</code>和<code>BOM</code>对象都属于宿主对象</li></ul><p>包括：</p><ol><li><p>宿主提供的对象</p><p>a. BOM&amp;DOM 等</p></li><li><p>自定义对象</p><p>a. 对象直接量（字面量）</p><p>b. new 操作符跟构造函数</p><p>c. function 对象</p></li></ol><h5 id="两大属性"><a href="#两大属性" class="headerlink" title="两大属性"></a>两大属性</h5><h6 id="自有-实例-属性"><a href="#自有-实例-属性" class="headerlink" title="自有(实例)属性"></a>自有(实例)属性</h6><p>也可叫实例属性：指对象自身的属性，也就是直接在对象中定义的属性</p><h6 id="私有-原型-属性"><a href="#私有-原型-属性" class="headerlink" title="私有(原型)属性"></a>私有(原型)属性</h6><p>也可叫原型属性：指对象从原型中继承的属性，也就是在对象的原型对象中定义的属性</p><h3 id="String-对象"><a href="#String-对象" class="headerlink" title="String 对象"></a>String 对象</h3><h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><h6 id="str-length"><a href="#str-length" class="headerlink" title="str.length"></a>str.length</h6><p>返回字符串的长度</p><h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><h6 id="charAt"><a href="#charAt" class="headerlink" title="charAt()"></a>charAt()</h6><p>功能：返回指定位置的字符</p><p>参数：必须，为目标字符的下标位置</p><blockquote><p>若参数 index 不在 0 与 string.length 之间，该方法将返回一个空字符串</p></blockquote><h6 id="charCodeAt"><a href="#charCodeAt" class="headerlink" title="charCodeAt()"></a>charCodeAt()</h6><p>功能：返回在指定位置的字符的 Unicode 编码</p><p>参数：必须，为目标字符的下标位置</p><blockquote><p>若参数 index 不在 0 与 string.length 之间，该方法将返回 NaN</p></blockquote><h6 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf()"></a>indexOf()</h6><p>功能：检索字符串，返回指定子字符串在字符串中首次出现的位置。</p><p>参数 1：检索目标子字符串，必须</p><p>参数 2：在字符串中开始检索的位置，可选。省略该参数，则将从字符串的首字符开始检索</p><blockquote><p>indexOf() 方法对大小写敏感</p><p>如果要检索的字符串值没有出现，则该方法返回 -1</p></blockquote><h6 id="lastIndexOf"><a href="#lastIndexOf" class="headerlink" title="lastIndexOf()"></a>lastIndexOf()</h6><p>功能：从后向前搜索字符串，返回指定子字符串在字符串中首次出现的位置</p><p>参数 1：检索目标子字符串，必须</p><p>参数 2：在字符串中开始检索的位置，可选。省略该参数，则将从字符串的最后一个字符开始检索</p><h6 id="match"><a href="#match" class="headerlink" title="match()"></a>match()</h6><p>功能：返回指定位置的字符</p><p>参数：必须，规定要检索的字符串值或待匹配的 RegExp 对象</p><p>返回值：存放匹配结果的数组。该数组的内容依赖于 regexp 是否具有全局标志 g</p><blockquote><p>regexp 没有 g，match() 方法只执行一次匹配，如果没有找到任何匹配的文本， match() 将返回 null，否则，它将返回一个数组，其中存放了与它找到的匹配文本有关的信息，该数组的第 0 个元素存放的是匹配文本，返回的数组还含有两个对象属性：index 属性为 stringObject 中的索引，input 属性是对 stringObject 的引用</p><p>regexp 具有标志 g，则 match() 方法将执行全局检索，找到 stringObject 中的所有匹配子字符串。若没有找到子串，返回 null。如果找到了一个或多个匹配子串，则返回一个数组。返回数组元素中存放的是 stringObject 中所有的匹配子串，没有 index 属性或 input 属性</p></blockquote><p>示例：</p><pre><code class="js">let s = &quot;hello23 world23&quot;console.log(s.match(/\d{2}/)) //[ &#39;23&#39;, index: 5, input: &#39;hello21 world21&#39; ]let s = &quot;hello23 world23&quot;console.log(s.match(/\d{2}/g)) //[ &#39;23&#39;, &#39;23&#39; ]</code></pre><h6 id="replace"><a href="#replace" class="headerlink" title="replace()"></a>replace()</h6><p>功能：在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。</p><p>参数 1：regexp/substr，必须，规定子字符串或要匹配的 RegExp 对象</p><p>参数 2：replacement，必须，用于替换的字符串值</p><p>返回值：替换后的一个新字符串</p><p>示例：</p><pre><code class="js">var s = &quot;hello world hello&quot;console.log(s.replace(&quot;hello&quot;, &quot;hi&quot;)) //hi world helloconsole.log(s.replace(/hello/, &quot;hi&quot;)) //hi world helloconsole.log(s.replace(/hello/g, &quot;hi&quot;)) //hi world hi</code></pre><blockquote><p>方法返回一个新字符串，不会修改原字符串</p></blockquote><h6 id="search"><a href="#search" class="headerlink" title="search()"></a>search()</h6><p>功能：检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串</p><p>参数：regexp/substr，必须，规定子字符串或要匹配的 RegExp 对象</p><p>返回值：原字符串中第一次匹配到目标字符串的起始位置</p><p>示例：</p><pre><code class="js">var s = &quot;hello world hello&quot;console.log(s.search(&quot;hello&quot;)) //0console.log(s.search(/hello/g)) //0console.log(s.search(/hello2/)) //-1</code></pre><blockquote><p>方法不执行全局匹配，它将忽略标志 g。也就是说，它只匹配一次。若没匹配到结果，则返回-1</p></blockquote><p>toLowerCase()</p><p>功能：把字符串转换为小写</p><p>返回值：一个新字符串</p><p>示例：</p><pre><code class="js">var s = &quot;Hello World&quot;console.log(s.toLowerCase()) //hello world</code></pre><p>toUpperCase()</p><p>功能：把字符串转换为大写</p><p>返回值：一个新字符串</p><p>示例：</p><pre><code class="js">var s = &quot;Hello World&quot;console.log(s.toUpperCase()) //HELLO WORLD</code></pre><h6 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h6><p>功能：用于连接两个或多个字符串</p><p>语法：stringObject.concat(stringX,stringX,…,stringX)</p><p>返回值：衔接后的新字符串</p><blockquote><p>concat 方法不会修改原字符串</p><p>stringObject.concat() 与 Array.concat() 很相似</p><p>通常使用 “ + “ 运算符来进行字符串的连接运算通常会更简便一些</p></blockquote><p>示例：</p><pre><code class="js">var s1 = &quot;hello &quot;var s2 = &quot;world &quot;var s3 = &quot;001&quot;console.log(s1.concat(s2, s3)) //hello world 001</code></pre><h6 id="split"><a href="#split" class="headerlink" title="split()"></a>split()</h6><p>功能：把一个字符串分割成字符串数组，Array.join( ) 的逆操作</p><p>参数 1：separator，必须，字符串或正则表达式，从该参数指定的地方分割原字符串</p><p>参数 2：howmany，可选，指定返回数组的最大长度</p><p>返回值：一个字符串数组</p><p>示例：</p><pre><code class="js">var s = &quot;he llo&quot;console.log(s.split(&quot;&quot;)) //[ &#39;h&#39;, &#39;e&#39;, &#39; &#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39; ]console.log(s.split(&quot; &quot;)) //[ &#39;he&#39;, &#39;llo&#39; ]console.log(s.split(&quot;l&quot;)) //[&quot;he &quot;, &quot;&quot;, &quot;o&quot;]</code></pre><h6 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h6><p>功能：截取字符串的某个部分</p><p>参数 1：截取的起始位置，必须</p><p>参数 2：截取的结束位置，可选</p><p>返回值：截取部分，一个新的字符串</p><blockquote><p>String.slice() 与 Array.slice() 相似</p><p>slice 方法的两个参数接受负值，若为负数，则该参数规定的是从字符串的尾部开始算起的位置。也就是说，-1 指字符串的最后一个字符，-2 指倒数第二个字符，以此类推。 未指定第二个参数，则默认截取至字符串的末尾。 slice 方法不修改原字符串</p></blockquote><p>示例：</p><pre><code class="js">var s = &quot;he llo&quot;console.log(s.slice(3)) //lloconsole.log(s.slice(1, 5)) //e llconsole.log(s.slice(-5)) //e lloconsole.log(s.slice(-5, -1)) //e ll</code></pre><h6 id="substr"><a href="#substr" class="headerlink" title="substr()"></a>substr()</h6><p>功能：截取从指定下标开始的指定数目的字符</p><p>参数 1：start，必须，截取的起始位置，接受负值</p><p>参数 2：length，可选，截取字符串的长度，未指定，则默认截取到原字符串的末尾</p><p>返回值：截取部分，一个新的字符串</p><blockquote><p>ECMAscript 中未对该方法进行标准化，不建议使用</p></blockquote><p>示例：</p><pre><code class="js">var s = &quot;he llo&quot;console.log(s.substr(3)) //lloconsole.log(s.substr(3, 2)) //llconsole.log(s.substr(-3, 2)) //ll</code></pre><h6 id="substring"><a href="#substring" class="headerlink" title="substring()"></a>substring()</h6><p>功能：截取字符串中介于两个指定下标之间的字符</p><p>参数 1：start，必须，截取的起始位置</p><p>参数 2：end，可选，截取的结束位置，未指定，则默认截取到原字符串的末尾</p><p>返回值：截取部分，一个新的字符串</p><p>示例：</p><pre><code class="js">var s = &quot;he llo&quot;console.log(s.substring(3)) //lloconsole.log(s.substring(3, 5)) //llconsole.log(s.substring(5, 3)) //llconsole.log(s.substring(3, 3)) //&#39;&#39;</code></pre><blockquote><p>与 slice() 和 substr() 方法不同的是，substring() 不接受负的参数</p><p>如果参数 start 与 stop 相等，那么该方法返回的一个空串</p><p>如果 start 比 stop 大，那么该方法在提取子串之前会先交换这两个参数</p></blockquote><h6 id="trim"><a href="#trim" class="headerlink" title="trim()"></a>trim()</h6><p>功能：去除字符串的头尾空格</p><h3 id="Array-对象"><a href="#Array-对象" class="headerlink" title="Array 对象"></a>Array 对象</h3><h5 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h5><h6 id="length"><a href="#length" class="headerlink" title="length"></a>length</h6><p>返回数组中元素的数目</p><blockquote><p>设置 length 属性可改变数组的大小。如果设置的值比其当前值小，数组将被截断，其尾部的元素将丢失。如果设置的值比它的当前值大，数组将增大，新的元素被添加到数组的尾部，它们的值为 undefined</p></blockquote><h6 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h6><p>数组对象构造器，返回对创建此对象的数组函数的引用</p><h6 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h6><p>数组对象原型，用于向对象添加属性和方法</p><h5 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h5><h6 id="concat-1"><a href="#concat-1" class="headerlink" title="concat()"></a>concat()</h6><p>用于拼接数组，不会改变原有数组</p><blockquote><p>如果要进行 concat() 操作的参数是数组，那么添加的是数组中的元素，而不是数组</p></blockquote><h6 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h6><p>把数组中的所有元素放入一个字符串，元素是通过指定的分隔符进行分隔的</p><blockquote><p>若省略了分隔符参数，则默认使用逗号作为分隔符</p></blockquote><p>示例：</p><pre><code class="js">let arr = [1, 2, 3]arr.join() // &#39;1,2,3&#39;arr.join(0) // &#39;10203&#39;</code></pre><h6 id="push"><a href="#push" class="headerlink" title="push()"></a>push()</h6><p>向数组的末尾添加一个或多个元素，返回新的数组长度</p><h6 id="pop"><a href="#pop" class="headerlink" title="pop()"></a>pop()</h6><p>用于删除数组的最后一个元素，把数组长度减 1，返回被删除元素</p><blockquote><p>如果数组已经为空，则 pop() 不改变数组，并返回 undefined</p></blockquote><h6 id="shift"><a href="#shift" class="headerlink" title="shift()"></a>shift()</h6><p>用于把数组的第一个元素从其中删除，并返回被移除的这个元素</p><blockquote><p>如果数组是空的，那么 shift() 方法将不进行任何操作，返回 undefined</p><p>该方法直接修改原数组</p></blockquote><h6 id="unshift"><a href="#unshift" class="headerlink" title="unshift()"></a>unshift()</h6><p>向数组的开头添加一个或更多元素，并返回新的数组长度</p><blockquote><p>该方法直接修改原数组</p></blockquote><h6 id="reverse"><a href="#reverse" class="headerlink" title="reverse()"></a>reverse()</h6><p>用于反转数组中元素顺序</p><p>该方法直接修改原数组，不会创建新数组</p><h6 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h6><p>用于对数组的元素进行排序</p><p>该排序直接修改原数组</p><p>该方法接受一个可选参数，若未使用参数，将按字母顺序对数组元素进行排序，说得更精确点，是按照字符编码的顺序进行排序。要实现这一点，首先应把数组的元素都转换成字符串（如有必要），以便进行比较。</p><p>如果想按照其他标准进行排序，就需要提供比较函数，该函数要比较两个值，然后返回一个用于说明这两个值的相对顺序的数字。比较函数应该具有两个参数 a 和 b，其返回值如下：</p><ul><li>若 a 小于 b，排序后 a 应该在 b 之前，则返回一个小于 0 的值</li><li>若 a 等于 b，则返回 0。</li><li>若 a 大于 b，则返回一个大于 0 的值</li></ul><p>示例：</p><pre><code class="js">arr1 = [&quot;tom&quot;, &quot;array&quot;, &quot;obj&quot;, &quot;string&quot;, &quot;bool&quot;]arr1.sort() // [&quot;array&quot;, &quot;bool&quot;, &quot;obj&quot;, &quot;string&quot;, &quot;tom&quot;] 按照字母顺序arr2 = [1, 20, 90, 21, 1000, 300]arr2.sort() // [1, 1000, 20, 21, 300, 90]arr2.sort((a, b) =&gt; {  return a - b}) // [1, 20, 21, 90, 300, 1000]arr2.sort((a, b) =&gt; {  return b - a}) // [1000, 300, 90, 21, 20, 1]</code></pre><h6 id="slice-1"><a href="#slice-1" class="headerlink" title="slice()"></a>slice()</h6><p>参数：start [,end]</p><p>截取原数组从 start 到 end 位置（不包含它）元素组成的子数组</p><blockquote><p>该方法返回一个新数组，不会修改原数组</p><p>若未指定 end 参数，那么截取 start 直到原数组最后一个元素（包含它）</p></blockquote><h6 id="splice"><a href="#splice" class="headerlink" title="splice()"></a>splice()</h6><p>参数：index,howmany [,item1,item2…]</p><p>删除从 index 处开始的 hownamy 个元素，并且用可选参数列表中声明的一个或多个值来替换那些被删除的元素</p><blockquote><p>该方法返回的是含有被删除的元素组成的数组，若无被删元素，则返回空数组。</p><p>若参数只有 index，那么原数组将从 index 开始删除直至结尾。</p><p>该方法直接修改原数组</p></blockquote><h6 id="includes"><a href="#includes" class="headerlink" title="includes()"></a>includes()</h6><p>参数:1:必须,要判断的元素 2:可选,表示判断的起始位置,可为负数</p><p>返回值:true||false</p><blockquote><p>ES6 数组方法</p><p>判断数组是否包含某一元素</p><p>它直接返回 true 或者 false 表示是否包含元素，对 NaN 一样能有有效</p></blockquote><h6 id="forEach-v-i-a-gt"><a href="#forEach-v-i-a-gt" class="headerlink" title="forEach((v,i,a)=&gt;{})"></a>forEach((v,i,a)=&gt;{})</h6><p>作用：让数组的每一项都执行一次给定的 callback</p><p>参数：callback v 表示当前项的值，i 表示当前索引，a 表示数组本身</p><blockquote><p>forEach 遍历的范围在第一次调用 callback 前就会确定。调用 forEach 后添加到数组中的项不会被 callback 访问到。如果已经存在的值被改变，则传递给 callback 的值是 forEach 遍历到他们那一刻的值。已删除的项不会被遍历到</p></blockquote><h6 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h6><p>参数：map(callback, thisValue)</p><blockquote><p>callback 为必须项，(currentValue,index,arr)=&gt;{}</p><p><em>currentValue</em> 必须。当前元素的值</p><p><em>index</em> 可选。当前元素的索引值</p><p><em>arr</em> 可选。当前元素属于的数组对象</p><p>thisValue 可选。对象作为该执行回调时使用，传递给函数，用作 “this” 的值。 如果省略了 thisValue，或者传入 null、undefined，那么回调函数的 this 为全局对象</p></blockquote><p>示例：</p><pre><code class="js">var numbers = [4, 9, 16, 25]numbers.map(Math.sqrt) // 2,3,4,5</code></pre><h3 id="Number-对象"><a href="#Number-对象" class="headerlink" title="Number 对象"></a>Number 对象</h3><h5 id="toExponential"><a href="#toExponential" class="headerlink" title="toExponential()"></a>toExponential()</h5><p>把对象的值转换为指数计数法</p><p>示例：</p><pre><code class="js">var num = 5.56789var n = num.toExponential() // 5.56789e+0</code></pre><h5 id="toFixed"><a href="#toFixed" class="headerlink" title="toFixed()"></a>toFixed()</h5><p>把数字转换为字符串，结果的小数点后有指定位数的数字</p><p>示例：</p><pre><code class="js">var num = 5.56789var n = num.toFixed(2) // 5.57</code></pre><h5 id="toPrecision"><a href="#toPrecision" class="headerlink" title="toPrecision()"></a>toPrecision()</h5><p>把数字格式化为指定的长度</p><p>示例：</p><pre><code class="js">var num = new Number(13.3714)var n = num.toPrecision(2) // 13</code></pre><h3 id="JSON-对象"><a href="#JSON-对象" class="headerlink" title="JSON 对象"></a>JSON 对象</h3><h5 id="JSON-parse"><a href="#JSON-parse" class="headerlink" title="JSON.parse()"></a>JSON.parse()</h5><p>功能：将字符串反序列化成对象</p><p>参数：JSON 字符串</p><p>返回值：对象</p><h5 id="JSON-stringify"><a href="#JSON-stringify" class="headerlink" title="JSON.stringify()"></a>JSON.stringify()</h5><p>功能：将一个对象解析为 JSON 字符串</p><p>参数：对象</p><p>返回值：JSON 字符串</p><blockquote><p>该字符串应该符合 JSON 格式，并且可以被 JSON.parse 方法还原</p><p>JSON.stringify(obj, selectedProperties)还可以接受一个数组</p><p>作为第二个参数，指定需要转成字符串的属性</p><p>还可以接受第三个参数，用于增加返回的 JSON 字符串的可读性</p><p>如果是数字，表示每个属性前面添加的空格（最多不超过 10 个）</p><p>如果是字符串（不超过 10 个字符），则该字符串会添加在每行前面</p></blockquote><h3 id="Math-对象"><a href="#Math-对象" class="headerlink" title="Math 对象"></a>Math 对象</h3><h5 id="属性-2"><a href="#属性-2" class="headerlink" title="属性"></a>属性</h5><h6 id="Math-E"><a href="#Math-E" class="headerlink" title="Math.E"></a>Math.E</h6><p>常数 e</p><h6 id="Math-LN2"><a href="#Math-LN2" class="headerlink" title="Math.LN2"></a>Math.LN2</h6><p>2 的自然对数</p><h6 id="Math-LN10"><a href="#Math-LN10" class="headerlink" title="Math.LN10"></a>Math.LN10</h6><p>10 的自然对数</p><h6 id="Math-LOG2E"><a href="#Math-LOG2E" class="headerlink" title="Math.LOG2E"></a>Math.LOG2E</h6><p>以 2 为底的 e 的对数</p><h6 id="Math-LOG10E"><a href="#Math-LOG10E" class="headerlink" title="Math.LOG10E"></a>Math.LOG10E</h6><p>以 10 为底的 e 的对数</p><h6 id="Math-PI"><a href="#Math-PI" class="headerlink" title="Math.PI"></a>Math.PI</h6><p>常数 Pi</p><h6 id="Math-SQRT1-2"><a href="#Math-SQRT1-2" class="headerlink" title="Math.SQRT1_2"></a>Math.SQRT1_2</h6><p>0.5 的平方根</p><h6 id="Math-SQRT2"><a href="#Math-SQRT2" class="headerlink" title="Math.SQRT2"></a>Math.SQRT2</h6><p>2 的平方根</p><h5 id="数学方法"><a href="#数学方法" class="headerlink" title="数学方法"></a>数学方法</h5><h6 id="Math-abs"><a href="#Math-abs" class="headerlink" title="Math.abs()"></a>Math.abs()</h6><p>返回参数的绝对值</p><h6 id="Math-ceil"><a href="#Math-ceil" class="headerlink" title="Math.ceil()"></a>Math.ceil()</h6><p>向上取整，接受一个参数，返回大于该参数的最小整数</p><h6 id="Math-floor"><a href="#Math-floor" class="headerlink" title="Math.floor()"></a>Math.floor()</h6><p>向下取整</p><h6 id="Math-max-n-n1-…"><a href="#Math-max-n-n1-…" class="headerlink" title="Math.max(n,n1,…)"></a>Math.max(n,n1,…)</h6><p>可接受多个参数，返回最大值</p><h6 id="Math-min-n-n1"><a href="#Math-min-n-n1" class="headerlink" title="Math.min(n,n1,..)"></a>Math.min(n,n1,..)</h6><p>可接受多个参数，返回最小值</p><h6 id="Math-pow-n-e"><a href="#Math-pow-n-e" class="headerlink" title="Math.pow(n,e)"></a>Math.pow(n,e)</h6><p>指数运算, 返回以第一个参数为底数、第二个参数为幂的指数值</p><h6 id="Math-sqrt"><a href="#Math-sqrt" class="headerlink" title="Math.sqrt()"></a>Math.sqrt()</h6><p>返回参数值的平方根。如果参数是一个负值，则返回 NaN</p><h6 id="Math-log"><a href="#Math-log" class="headerlink" title="Math.log()"></a>Math.log()</h6><p>返回以 e 为底的自然对数值</p><h6 id="Math-exp"><a href="#Math-exp" class="headerlink" title="Math.exp()"></a>Math.exp()</h6><p>返回 e 的指数，也就是常数 e 的参数次方</p><h6 id="Math-round"><a href="#Math-round" class="headerlink" title="Math.round()"></a>Math.round()</h6><p>四舍五入</p><h6 id="Math-random"><a href="#Math-random" class="headerlink" title="Math.random()"></a>Math.random()</h6><p>返回 0 到 1 之间的一个伪随机数，可能等于 0，但是一定小于 1。</p><h5 id="三角函数方法"><a href="#三角函数方法" class="headerlink" title="三角函数方法"></a>三角函数方法</h5><h6 id="Math-sin"><a href="#Math-sin" class="headerlink" title="Math.sin()"></a>Math.sin()</h6><p>返回参数的正弦</p><h6 id="Math-cos"><a href="#Math-cos" class="headerlink" title="Math.cos()"></a>Math.cos()</h6><p>返回参数的余弦</p><h6 id="Math-tan"><a href="#Math-tan" class="headerlink" title="Math.tan()"></a>Math.tan()</h6><p>返回参数的正切</p><h6 id="Math-asin"><a href="#Math-asin" class="headerlink" title="Math.asin()"></a>Math.asin()</h6><p>返回参数的反正弦（弧度值）</p><h6 id="Math-acos"><a href="#Math-acos" class="headerlink" title="Math.acos()"></a>Math.acos()</h6><p>返回参数的反余弦（弧度值）</p><h6 id="Math-atan"><a href="#Math-atan" class="headerlink" title="Math.atan()"></a>Math.atan()</h6><p>返回参数的反正切（弧度值）</p><h3 id="Date-对象"><a href="#Date-对象" class="headerlink" title="Date 对象"></a>Date 对象</h3><h5 id="Date"><a href="#Date" class="headerlink" title="Date()"></a>Date()</h5><p>返回当日的日期和时间</p><h5 id="getDate"><a href="#getDate" class="headerlink" title="getDate()"></a>getDate()</h5><p>从 Date 对象返回一个月中的某一天 (1 ~ 31)</p><h5 id="getDay"><a href="#getDay" class="headerlink" title="getDay()"></a>getDay()</h5><p>从 Date 对象返回一周中的某一天 (0 ~ 6)</p><h5 id="getMonth"><a href="#getMonth" class="headerlink" title="getMonth()"></a>getMonth()</h5><p>从 Date 对象返回月份 (0 ~ 11)</p><h5 id="getFullYear"><a href="#getFullYear" class="headerlink" title="getFullYear()"></a>getFullYear()</h5><p>从 Date 对象以四位数字返回年份</p><h5 id="getYear"><a href="#getYear" class="headerlink" title="getYear()"></a>getYear()</h5><p>ECMAScript v3 开始，JavaScript 的实现就不再使用该方法， 请使用 getFullYear() 方法代替</p><h5 id="getHours"><a href="#getHours" class="headerlink" title="getHours()"></a>getHours()</h5><p>返回 Date 对象的小时 (0 ~ 23)</p><h5 id="getMinutes"><a href="#getMinutes" class="headerlink" title="getMinutes()"></a>getMinutes()</h5><p>返回 Date 对象的分钟 (0 ~ 59)</p><h5 id="getSeconds"><a href="#getSeconds" class="headerlink" title="getSeconds()"></a>getSeconds()</h5><p>返回 Date 对象的秒数 (0 ~ 59)</p><h5 id="getMilliseconds"><a href="#getMilliseconds" class="headerlink" title="getMilliseconds()"></a>getMilliseconds()</h5><p>返回 Date 对象的毫秒(0 ~ 999)</p><h5 id="getTime"><a href="#getTime" class="headerlink" title="getTime()"></a>getTime()</h5><p>返回 1970 年 1 月 1 日至今的毫秒数</p><h5 id="getTimezoneOffset"><a href="#getTimezoneOffset" class="headerlink" title="getTimezoneOffset()"></a>getTimezoneOffset()</h5><p>返回本地时间与格林威治标准时间 (GMT) 的分钟差</p><h5 id="getUTCDate"><a href="#getUTCDate" class="headerlink" title="getUTCDate()"></a>getUTCDate()</h5><p>根据世界时从 Date 对象返回月中的一天 (1 ~ 31)</p><h5 id="getUTCDay"><a href="#getUTCDay" class="headerlink" title="getUTCDay()"></a>getUTCDay()</h5><p>根据世界时从 Date 对象返回周中的一天 (0 ~ 6)</p><h5 id="getUTCMonth"><a href="#getUTCMonth" class="headerlink" title="getUTCMonth()"></a>getUTCMonth()</h5><p>根据世界时从 Date 对象返回月份 (0 ~ 11)</p><h5 id="getUTCFullYear"><a href="#getUTCFullYear" class="headerlink" title="getUTCFullYear()"></a>getUTCFullYear()</h5><p>根据世界时从 Date 对象返回四位数的年份</p><h5 id="getUTCHours"><a href="#getUTCHours" class="headerlink" title="getUTCHours()"></a>getUTCHours()</h5><p>根据世界时返回 Date 对象的小时 (0 ~ 23)</p><h5 id="getUTCMinutes"><a href="#getUTCMinutes" class="headerlink" title="getUTCMinutes()"></a>getUTCMinutes()</h5><p>根据世界时返回 Date 对象的分钟 (0 ~ 59)</p><h5 id="getUTCSeconds"><a href="#getUTCSeconds" class="headerlink" title="getUTCSeconds()"></a>getUTCSeconds()</h5><p>根据世界时返回 Date 对象的秒钟 (0 ~ 59)</p><h5 id="getUTCMilliseconds"><a href="#getUTCMilliseconds" class="headerlink" title="getUTCMilliseconds()"></a>getUTCMilliseconds()</h5><p>根据世界时返回 Date 对象的毫秒(0 ~ 999)</p><h5 id="parse"><a href="#parse" class="headerlink" title="parse()"></a>parse()</h5><p>返回 1970 年 1 月 1 日午夜到指定日期（字符串）的毫秒数</p><h5 id="setDate"><a href="#setDate" class="headerlink" title="setDate()"></a>setDate()</h5><p>设置 Date 对象中月的某一天 (1 ~ 31)</p><h5 id="setMonth"><a href="#setMonth" class="headerlink" title="setMonth()"></a>setMonth()</h5><p>设置 Date 对象中月份 (0 ~ 11)</p><h5 id="setFullYear"><a href="#setFullYear" class="headerlink" title="setFullYear()"></a>setFullYear()</h5><p>设置 Date 对象中的年份（四位数字）</p><h5 id="setYear"><a href="#setYear" class="headerlink" title="setYear()"></a>setYear()</h5><p>请使用 setFullYear() 方法代替</p><h5 id="setHours"><a href="#setHours" class="headerlink" title="setHours()"></a>setHours()</h5><p>设置 Date 对象中的小时 (0 ~ 23)</p><h5 id="setMinutes"><a href="#setMinutes" class="headerlink" title="setMinutes()"></a>setMinutes()</h5><p>设置 Date 对象中的分钟 (0 ~ 59)</p><h5 id="setSeconds"><a href="#setSeconds" class="headerlink" title="setSeconds()"></a>setSeconds()</h5><p>设置 Date 对象中的秒钟 (0 ~ 59)</p><h5 id="setMilliseconds"><a href="#setMilliseconds" class="headerlink" title="setMilliseconds()"></a>setMilliseconds()</h5><p>设置 Date 对象中的毫秒 (0 ~ 999)</p><h5 id="setTime"><a href="#setTime" class="headerlink" title="setTime()"></a>setTime()</h5><p>以毫秒设置 Date 对象</p><h5 id="setUTCDate"><a href="#setUTCDate" class="headerlink" title="setUTCDate()"></a>setUTCDate()</h5><p>根据世界时设置 Date 对象中月份的一天 (1 ~ 31)</p><h5 id="setUTCMonth"><a href="#setUTCMonth" class="headerlink" title="setUTCMonth()"></a>setUTCMonth()</h5><p>根据世界时设置 Date 对象中的月份 (0 ~ 11)</p><h5 id="setUTCFullYear"><a href="#setUTCFullYear" class="headerlink" title="setUTCFullYear()"></a>setUTCFullYear()</h5><p>根据世界时设置 Date 对象中的年份（四位数字）</p><h5 id="setUTCHours"><a href="#setUTCHours" class="headerlink" title="setUTCHours()"></a>setUTCHours()</h5><p>根据世界时设置 Date 对象中的小时 (0 ~ 23)</p><h5 id="setUTCMinutes"><a href="#setUTCMinutes" class="headerlink" title="setUTCMinutes()"></a>setUTCMinutes()</h5><p>根据世界时设置 Date 对象中的分钟 (0 ~ 59)</p><h5 id="setUTCSeconds"><a href="#setUTCSeconds" class="headerlink" title="setUTCSeconds()"></a>setUTCSeconds()</h5><p>根据世界时设置 Date 对象中的秒钟 (0 ~ 59)</p><h5 id="setUTCMilliseconds"><a href="#setUTCMilliseconds" class="headerlink" title="setUTCMilliseconds()"></a>setUTCMilliseconds()</h5><p>根据世界时设置 Date 对象中的毫秒 (0 ~ 999)</p><h5 id="toSource"><a href="#toSource" class="headerlink" title="toSource()"></a>toSource()</h5><p>返回该对象的源代码</p><h5 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h5><p>把 Date 对象转换为字符串</p><h5 id="toTimeString"><a href="#toTimeString" class="headerlink" title="toTimeString()"></a>toTimeString()</h5><p>把 Date 对象的时间部分转换为字符串</p><h5 id="toDateString"><a href="#toDateString" class="headerlink" title="toDateString()"></a>toDateString()</h5><p>把 Date 对象的日期部分转换为字符串</p><h5 id="toGMTString"><a href="#toGMTString" class="headerlink" title="toGMTString()"></a>toGMTString()</h5><p>请使用 toUTCString() 方法代替</p><h5 id="toUTCString"><a href="#toUTCString" class="headerlink" title="toUTCString()"></a>toUTCString()</h5><p>根据世界时，把 Date 对象转换为字符串</p><h5 id="toLocaleString-NaN"><a href="#toLocaleString-NaN" class="headerlink" title="toLocaleString()"></a>toLocaleString()</h5><p>根据本地时间格式，把 Date 对象转换为字符串</p><h5 id="toLocaleTimeString"><a href="#toLocaleTimeString" class="headerlink" title="toLocaleTimeString()"></a>toLocaleTimeString()</h5><p>根据本地时间格式，把 Date 对象的时间部分转换为字符串</p><h5 id="toLocaleDateString"><a href="#toLocaleDateString" class="headerlink" title="toLocaleDateString()"></a>toLocaleDateString()</h5><p>根据本地时间格式，把 Date 对象的日期部分转换为字符串</p><h5 id="UTC"><a href="#UTC" class="headerlink" title="UTC()"></a>UTC()</h5><p>根据世界时返回 1970 年 1 月 1 日 到指定日期的毫秒数</p><h5 id="valueOf-NaN"><a href="#valueOf-NaN" class="headerlink" title="valueOf()"></a>valueOf()</h5><p>返回 Date 对象的原始值</p><h3 id="Global-对象"><a href="#Global-对象" class="headerlink" title="Global 对象"></a>Global 对象</h3><blockquote><p>全局对象只是一个对象，而不是类。既没有构造函数，也无法实例化一个新的全局对象</p></blockquote><h5 id="属性-3"><a href="#属性-3" class="headerlink" title="属性"></a>属性</h5><h6 id="Infinity"><a href="#Infinity" class="headerlink" title="Infinity"></a>Infinity</h6><p>代表正的无穷大的数值</p><h6 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h6><p>代表非数字</p><h6 id="Undefined"><a href="#Undefined" class="headerlink" title="Undefined"></a>Undefined</h6><p>代表未定义的值</p><p>示例：</p><pre><code class="js">var avar b = &quot;&quot;var c = nullconsole.log(a === undefined) //trueconsole.log(b === undefined) //falseconsole.log(c == undefined) //true</code></pre><h5 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h5><h6 id="encodeURI-URIString"><a href="#encodeURI-URIString" class="headerlink" title="encodeURI(URIString)"></a>encodeURI(URIString)</h6><p>功能：将字符串作为 URI 进行编码，返回值为 URIstring 的副本</p><p>参数：URIString(必须)，一个待编码的字符串</p><blockquote><p>该方法不会对 ASCII 字母和数字进行编码，也不会对这些 ASCII 标点符号进行编码： - _ . ! ~ * ‘ ( ) 。</p><p>该方法的目的是对 URI 进行完整的编码，因此对以下在 URI 中具有特殊含义的 ASCII 标点符号，encodeURI() 函数是不会进行转义的：;/?:@&amp;=+$,#</p><p>如果 URI 组件中含有分隔符，比如 ? 和 #，则应当使用 encodeURIComponent() 方法分别对各组件进行编码</p></blockquote><p>示例：</p><pre><code class="js">console.log(encodeURI(&quot;http://www.baidu.com/my m?:@&amp;=+$#&quot;))// http://www.baidu.com/my%20m?:@&amp;=+$#</code></pre><h6 id="decodeURI"><a href="#decodeURI" class="headerlink" title="decodeURI()"></a>decodeURI()</h6><p>功能：上述解码</p><h6 id="encodeURIComponent-URIString"><a href="#encodeURIComponent-URIString" class="headerlink" title="encodeURIComponent(URIString)"></a>encodeURIComponent(URIString)</h6><p>功能：将字符串作为 URI 组件进行编码，返回值为 URIstring 的副本</p><p>参数：URIString(必须)，一个待编码的字符串</p><blockquote><p>该方法不会对 ASCII 字母和数字进行编码，也不会对这些 ASCII 标点符号进行编码： - _ . ! ~ * ‘ ( )</p><p>其他字符（比如 ：;/?:@&amp;=+$,# 这些用于分隔 URI 组件的标点符号），都是由一个或多个十六进制的转义序列替换的</p></blockquote><blockquote><p>encodeURI 和 encodeURIComponent 的区别：</p><p>它们都是编码 URL，唯一区别就是编码的字符范围，其中 encodeURI 方法不会对下列字符编码 ASCII 字母、数字、<del>!@#$&amp;_()=:/,;?+’<br>encodeURIComponent 方法不会对下列字符编码 ASCII 字母、数字、</del>!_()’<br>所以 encodeURIComponent 比 encodeURI 编码的范围更大。<br>实际例子来说，encodeURIComponent 会把 http:// 编码成 http%3A%2F%2F 而 encodeURI 却不会。</p></blockquote><p>示例：</p><pre><code class="js">console.log(encodeURI(&#39;http://www.baidu.com/home/some other thing&#39;)//编码后为：http://www.baidu.com/home/some%20other%20thing 空格被编码成了%20console.log(encodeURIComponent(&#39;http://www.baidu.com/home/some other thing&#39;))//http%3A%2F%2Fwww.baidu.com%2Fhome%2Fsome%20other%20thing    &quot;/&quot;被编码，无法使用var param = &quot;http://www.baidu.com/home/&quot;     //param为参数param = encodeURIComponent(param)var url = &quot;http://www.baidu.com?next=&quot; + paramconsole.log(url) //&#39;http://www.baidu.com?next=http%3A%2F%2Fwww.baidu.com%2Fhome%2F&#39;// 参数中的 &quot;/&quot; 被编码了，如果用encodeURI会出问题，因为后面的/是需要编码的</code></pre><h6 id="decodeURIComponent"><a href="#decodeURIComponent" class="headerlink" title="decodeURIComponent()"></a>decodeURIComponent()</h6><p>功能：上述解码</p><h6 id="escape-string"><a href="#escape-string" class="headerlink" title="escape(string)"></a>escape(string)</h6><p>功能：对字符串进行编码，把中文变乱码</p><blockquote><p>会转义除了<code>@*_+-./</code>以外的所有字符</p><p>已经从 Web 标准中废弃。绝大多数情况都可以使用<code>encodeURI</code>和<code>encodeURIComponent</code>来代替</p></blockquote><p>示例：</p><pre><code class="js">var aaa = &quot;中国123,&quot;escape(aaa) // &quot;%u4E2D%u56FD123%2C&quot;</code></pre><h6 id="unescape"><a href="#unescape" class="headerlink" title="unescape()"></a>unescape()</h6><p>功能：上述反编译</p><h6 id="parseInt-string-radix"><a href="#parseInt-string-radix" class="headerlink" title="parseInt(string,radix)"></a>parseInt(string,radix)</h6><p>功能：解析一个字符串，并返回一个整数。</p><p>参数：</p><ul><li>string(必须)：待解析的字符串</li><li>radix(可选)：表示要解析的数字的基数。该值介于 2 ~ 36 之间，如果该参数小于 2 或者大于 36，则 parseInt() 将返回 NaN</li></ul><blockquote><p>开头和结尾的空格是允许的</p><p>如果字符串的第一个字符不能被转换为数字，那么 parseFloat() 会返回 NaN</p><p>当参数  <em>radix</em>  的值为 0，或没有设置该参数时，parseInt() 会根据  <em>string</em>  来判断数字的基数 。如果 string 以 “0x” 开头，parseInt() 会把 string 的其余部分解析为十六进制的整数。如果 string 以 0 开头，那么 ECMAScript v3 允许 parseInt() 的一个实现把其后的字符解析为八进制或十六进制的数字。如果 string 以 1 ~ 9 的数字开头，parseInt() 将把它解析为十进制的整数</p></blockquote><p>示例：</p><pre><code class="js">parseInt(&quot;10&quot;) //返回 10parseInt(&quot;19&quot;, 10) //返回 19 (10+9)parseInt(&quot;11&quot;, 2) //返回 3 (2+1)parseInt(&quot;17&quot;, 8) //返回 15 (8+7)parseInt(&quot;1f&quot;, 16) //返回 31 (16+15)parseInt(&quot;010&quot;) //未定：返回 10 或 8parseInt(&quot;0x0011&quot;) //17</code></pre><h6 id="parseFloat-string"><a href="#parseFloat-string" class="headerlink" title="parseFloat(string)"></a>parseFloat(string)</h6><p>功能：解析一个字符串，并返回一个浮点数</p><p>参数：string(必须)，待解析的字符串</p><blockquote><p>该函数指定字符串中的首个字符是否是数字。如果是，则对字符串进行解析，直到到达数字的末端为止</p></blockquote><p>示例：</p><pre><code class="js">parseFloat(&quot;10&quot;) //10parseFloat(&quot;10.00&quot;) //10parseFloat(&quot;10.33&quot;) //10.33parseFloat(&quot; 60 &quot;) //60 首尾空格会忽略parseFloat(&quot;23 34 45&quot;) //23 中间空格不会忽略，会中断parseFloat(&quot;23 years&quot;) //23parseFloat(&quot;i am 23&quot;) //NaN</code></pre><h6 id="isFinite-number"><a href="#isFinite-number" class="headerlink" title="isFinite(number)"></a>isFinite(number)</h6><p>功能：用于检查其参数是否是无穷大</p><p>参数：</p><ul><li>number(必须)：待检测数字<br>如果 number 是有限数字（或可转换为有限数字），那么返回 true。否则，如果 number 是 NaN（非数字），或者是正、负无穷大的数，则返回 false</li></ul><p>示例：</p><pre><code class="js">console.log(isFinite(123)) //trueconsole.log(isFinite(-1.23)) //trueconsole.log(isFinite(6 - 3)) //trueconsole.log(isFinite(0)) //trueconsole.log(isFinite(0 / 0)) //falseconsole.log(isFinite(&quot;Hello&quot;)) //false</code></pre><h6 id="isNaN-number"><a href="#isNaN-number" class="headerlink" title="isNaN(number)"></a>isNaN(number)</h6><p>功能：用于检查其参数是否为非数字值</p><p>参数：</p><ul><li>number(必须)：待检测数字<br>如果 number 是非数字值 NaN（或者能被转换成 NaN），返回 true，否则返回 false</li></ul><p>示例：</p><pre><code class="js">console.log(isNaN(123)) //falseconsole.log(isNaN(-1.23)) //falseconsole.log(isNaN(6 - 3)) //falseconsole.log(isNaN(0)) //falseconsole.log(isNaN(0 / 0)) //trueconsole.log(isNaN(&quot;Hello&quot;)) //true</code></pre><h6 id="Number-object"><a href="#Number-object" class="headerlink" title="Number(object)"></a>Number(object)</h6><p>功能：把对象的值转换为数字</p><p>参数：</p><ul><li>object(必须)：待转换的对象<br>如果参数是 Date 对象，Number() 返回从 1970 年 1 月 1 日至今的毫秒数，即时间戳。如果对象的值无法转换为数字，那么 Number() 函数返回 NaN</li></ul><p>示例：</p><pre><code class="js">console.log(Number(true)) // 1console.log(Number(false)) // 0console.log(Number(new Date())) // 1506266494726console.log(Number(&quot;999&quot;)) // 999console.log(Number(&quot;999 888&quot;)) // NaN</code></pre><h6 id="String-object"><a href="#String-object" class="headerlink" title="String(object)"></a>String(object)</h6><p>功能：把对象的值转换为字符串</p><p>参数：object(必须)，待转换的对象</p><p>示例：</p><pre><code class="js">console.log(String(true)) // &#39;true&#39;</code></pre><h6 id="getClass"><a href="#getClass" class="headerlink" title="getClass()"></a>getClass()</h6><p>返回一个 JavaObject 的 JavaClass</p><h6 id="eval-string"><a href="#eval-string" class="headerlink" title="eval(string)"></a>eval(string)</h6><p>功能：可计算某个字符串，并执行其中的的 JavaScript 代码</p><p>参数：必需，要计算的字符串，其中含有要计算的 JavaScript 表达式或要执行的语句</p><p>返回值：通过计算 string 得到的值</p><h3 id="Console-对象"><a href="#Console-对象" class="headerlink" title="Console 对象"></a>Console 对象</h3><h5 id="console-log-text-text2-…"><a href="#console-log-text-text2-…" class="headerlink" title="console.log(text,text2,…)"></a>console.log(text,text2,…)</h5><p>用于在 console 窗口输出信息</p><blockquote><p>它可以接受多个参数，将它们的结果连接起来输出</p><p>如果第一个参数是格式字符串（使用了格式占位符）</p><p>console.log 方法将依次用后面的参数替换占位符，然后再进行输出</p></blockquote><h5 id="console-info"><a href="#console-info" class="headerlink" title="console.info()"></a>console.info()</h5><p>在 console 窗口输出信息，同时，会在输出信息的前面，加上一个蓝色图标</p><h5 id="console-debug"><a href="#console-debug" class="headerlink" title="console.debug()"></a>console.debug()</h5><p>在 console 窗口输出信息，同时，会在输出信息的前面，加上一个蓝色图标</p><h5 id="console-warn"><a href="#console-warn" class="headerlink" title="console.warn()"></a>console.warn()</h5><p>输出信息时，在最前面加一个黄色三角，表示警告</p><h5 id="console-error"><a href="#console-error" class="headerlink" title="console.error()"></a>console.error()</h5><p>输出信息时，在最前面加一个红色的叉，表示出错，同时会显示错误发生的堆栈</p><h5 id="console-table"><a href="#console-table" class="headerlink" title="console.table()"></a>console.table()</h5><p>可以将复合类型的数据转为表格显示</p><h5 id="console-count"><a href="#console-count" class="headerlink" title="console.count()"></a>console.count()</h5><p>用于计数，输出它被调用了多少次</p><h5 id="console-dir"><a href="#console-dir" class="headerlink" title="console.dir()"></a>console.dir()</h5><p>用来对一个对象进行检查（inspect），并以易于阅读和打印的格式显示</p><h5 id="console-dirxml"><a href="#console-dirxml" class="headerlink" title="console.dirxml()"></a>console.dirxml()</h5><p>用于以目录树的形式，显示 DOM 节点</p><h5 id="console-assert"><a href="#console-assert" class="headerlink" title="console.assert()"></a>console.assert()</h5><p>接受两个参数，第一个参数是表达式，第二个参数是字符串</p><blockquote><p>只有当第一个参数为 false，才会输出第二个参数，否则不会有任何结果</p></blockquote><h5 id="console-time"><a href="#console-time" class="headerlink" title="console.time()"></a>console.time()</h5><h5 id="console-timeEnd"><a href="#console-timeEnd" class="headerlink" title="console.timeEnd()"></a>console.timeEnd()</h5><p>这两个方法用于计时，可以算出一个操作所花费的准确时间</p><blockquote><p>time 方法表示计时开始，timeEnd 方法表示计时结束, 它们的参数是计时器的名称</p><p>调用 timeEnd 方法之后，console 窗口会显示“计时器名称: 所耗费的时间”</p></blockquote><h5 id="console-profile"><a href="#console-profile" class="headerlink" title="console.profile()"></a>console.profile()</h5><p>用来新建一个性能测试器（profile），它的参数是性能测试器的名字</p><h5 id="console-profileEnd"><a href="#console-profileEnd" class="headerlink" title="console.profileEnd()"></a>console.profileEnd()</h5><p>用来结束正在运行的性能测试器</p><h5 id="console-group"><a href="#console-group" class="headerlink" title="console.group()"></a>console.group()</h5><h5 id="console-groupend"><a href="#console-groupend" class="headerlink" title="console.groupend()"></a>console.groupend()</h5><p>上面这两个方法用于将显示的信息分组。它只在输出大量信息时有用，分在一组的信息，可以用鼠标折叠/展开</p><h5 id="console-groupCollapsed"><a href="#console-groupCollapsed" class="headerlink" title="console.groupCollapsed()"></a>console.groupCollapsed()</h5><p>用于将显示的信息分组，该组的内容，在第一次显示时是收起的（collapsed），而不是展开的</p><h5 id="console-trace"><a href="#console-trace" class="headerlink" title="console.trace()"></a>console.trace()</h5><p>显示当前执行的代码在堆栈中的调用路径</p><h5 id="console-clear"><a href="#console-clear" class="headerlink" title="console.clear()"></a>console.clear()</h5><p>用于清除当前控制台的所有输出，将光标回置到第一行</p><blockquote><p>本文参考：</p><p><a href="https://segmentfault.com/a/1190000011467723#articleHeader1" target="_blank" rel="noopener">https://segmentfault.com/a/1190000011467723#articleHeader1</a></p><p><a href="https://www.runoob.com/js/js-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/js/js-tutorial.html</a></p><p>您可以克隆到本地，随时随地翻阅，md 格式文档，推荐使用 typora</p><p>本文是为了熟悉下 JS 的 API 所写，只是些常用的，不如手册全面</p><p>如需全面的 api 文档，请移步菜鸟教程等 JS 手册</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue-cli2.0构建流程</title>
    <link href="/blog/2018/10/12/vue/Vue-cli2.0%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B/"/>
    <url>/blog/2018/10/12/vue/Vue-cli2.0%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue-cli-构建流程"><a href="#Vue-cli-构建流程" class="headerlink" title="Vue-cli 构建流程"></a>Vue-cli 构建流程</h1><p>学习 vue 时，总觉得 vue-cli 搭建很复杂，其实也不过如此，使用别人搭建好的包在打包时总会报一些莫名其妙的错误，还是自己动手比较可靠，就像我总觉得我自己写的代码是最好的^_^</p><p>首先，检测 NodeJS 环境</p><p>Windows+R 快捷键打开 cmd 输入以下命令</p><pre><code class="js">node - v</code></pre><p>如果出现 NodeJS 的版本号，表示你已经安装了 NodeJS</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/01.PNG" srcset="/blog/img/loading.gif" alt=""></p><p>反之就是没有安装 NodeJS 了</p><p>安装 NodeJS 请走官网传送门</p><p><a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener">传送门—NodeJS 安装</a></p><p>接下来就正式进入今天的主题脚手架搭建了</p><p>你可以使用 npm 安装，npm 安装速度慢些（因为服务器在国外），你也可以使用淘宝的镜像安装</p><p>安装淘宝镜像，打开 cmd 命令框，输入</p><pre><code class="js">npm install -g cnpm –registry=https://registry.npm.taobao.org</code></pre><p>安装淘宝镜像之后把命令中的 npm 变成 cnpm 就可以了，我这里使用的是 npm 安装 (因为我觉得也慢不了多少)</p><p>全局安装 Vue 脚手架</p><pre><code class="js">npm install -g vue-cli</code></pre><p>安装成功之后 cd 进你的项目文件夹目录</p><p>初始化项目</p><pre><code class="js">vue-init &lt;template-name&gt; [project-name]# &lt;template-name&gt; —— 打包工具# [project-name]  —— 项目名称</code></pre><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/02.PNG" srcset="/blog/img/loading.gif" alt=""></p><p>回答完问题稍等片刻，初始化成功之后就会显示以下内容</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/03.PNG" srcset="/blog/img/loading.gif" alt=""></p><p>然后根据提示 cd 进你的项目目录</p><p>输入<code>npm run dev</code>运行项目，如下</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/04.PNG" srcset="/blog/img/loading.gif" alt=""></p><p>这个时候就可以在浏览器输入 <code>http://localhost:8080</code> ，出现以下界面脚手架搭建成功</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/05.PNG" srcset="/blog/img/loading.gif" alt=""></p><p>以上就是 vue-cli 搭建的全部过程</p><p>脚手架项目结构</p><pre><code class="js">├── build/                      # webpack 编译配置文件: 开发环境与生产环境│   └── ...├── config/│   ├── index.js                # 项目核心配置│   └── ...├ ── node_module/               # 项目中安装的依赖包   ── src/│   ├── main.js                 # 项目入口文件│   ├── App.vue                 # 项目入口vue组件│   ├── components/             # 组件│   │   └── ...│   └── assets/                 # 资源文件，一般放一些静态资源│       └── ...├── static/                     # 纯静态资源 (打包时不会编译，会直接拷贝到dist/static/里面)├── test/│   └── unit/                   # 单元测试│   │   ├── specs/              # 测试规范│   │   ├── index.js            # 测试入口文件│   │   └── karma.conf.js       # 测试运行配置文件│   └── e2e/                    # 端到端测试│   │   ├── specs/              # 测试规范│   │   ├── custom-assertions/  # 端到端测试自定义断言│   │   ├── runner.js           # 运行测试的脚本│   │   └── nightwatch.conf.js  # 运行测试的配置文件├── .babelrc                    # babel 配置文件├── .editorconfig               # 编辑配置文件├── .gitignore                  # 用来过滤一些版本控制的文件，比如node_modules文件夹├── index.html                  # index.html 项目模板入口文件└── package.json                # 项目文件，记载项目依赖及项目说明（重）└── README.md                   # 说明文档，介绍自己的项目，markdown语法书写</code></pre><p>最后项目打包请输入</p><pre><code class="js">npm run bulid</code></pre><p>打包完成后会在项目目录下生成一个 dist 文件</p><pre><code class="js">├── dist/│   ├── index.js                # 项目入口文件│   └── static                   # 静态资源及打包后的一些js/css文件</code></pre><p>详情待续。。。</p><p>最后：喜欢前端，欢迎探讨！！！</p>]]></content>
    
    
    <categories>
      
      <category>Vue相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>被摒弃的jQuery</title>
    <link href="/blog/2018/09/26/other/%E8%A2%AB%E6%91%92%E5%BC%83%E7%9A%84jQuery/"/>
    <url>/blog/2018/09/26/other/%E8%A2%AB%E6%91%92%E5%BC%83%E7%9A%84jQuery/</url>
    
    <content type="html"><![CDATA[<h1 id="被摒弃的-jQuery"><a href="#被摒弃的-jQuery" class="headerlink" title="被摒弃的 jQuery"></a>被摒弃的 jQuery</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr><p>今年 IT 界发生了很多大事，无意间看到<code>jQ</code>的信息后，我决定码了这篇文章</p><p>首先回顾一下今年的大事(-_-)</p><p>十岁的 GitHub 作为全球最大开源代码托管网站，可谓是全球程序员的一片圣地，但是，今年 6 月，微软以 75 亿美元（折合人民币 480 亿 ）的价格收购了 Github</p><p>根据 cnBeta 新闻，在 GitHub 新闻发布之后，GitLab 收到了超过 14300 个独立访问者，这些开发者在 GitLab.com 上开设了超过 10 万个新的存储库</p><p>很多人因为 GitHub 被微软收购从而转去 GitLab，但是大家都没有想过 GitHub 的这种状况和 Google 投资了竞争对手的 GitLab 没有关系吗</p><p>想着也真是搞笑！</p><p>全球最大的闭源软件公司微软(Mircosoft)对于全球最大的开源软件社区 GitHub 的贡献最多</p><p>手握最大开源数据库 MySQL 和开源编程语言 Java 的 Oracle 是开源死敌</p><p>时代性的开源编程语言 Java 的老大 Oracle 在向非付费用户开枪了</p><p>全球最大源代码托管网站 Github 也被微软帝国收购</p><p>Google 也投资了 GitLab</p><p>开源缔造了 IT 时代，如果开源被把控。。。</p><p>目前，GitHub 一切正常，不知未来如何。。。</p><hr><p>喷了一下(~ _ ~)，以上不是本文主体，进入正题，在微软收购 GitHub 后，表示不打算在 GitHub 上做太多改变，且以开发者为中心的初心不会改变，会积极地拥抱开源 ，52 天后，也就是 7 月份，Github 做出一些微软特色的改变，这之中最重要的是 GitHub 网站<strong>重构过程中放弃了 jQuery</strong>，没有再次使用其他任何框架去代替它，而是使用了原生的 JS ，本文是我个人针对此事的看法:</p><h2 id="jQuery-简介"><a href="#jQuery-简介" class="headerlink" title="jQuery 简介"></a>jQuery 简介</h2><p>jQuery 诞生于 2006 年 8 月，作者 John Resig ，jQuery 倡导写更少的代码，做更多的事情。它封装了 JavaScript 常用的功能代码，提供一种简便的 JavaScript 设计模式，优化 HTML 文档操作、事件处理、动画设计和 Ajax 交互</p><p>jQuery 凭借着 跨浏览器、 简单高效 、稳定可靠 、 插件丰富 这些特性迅速风靡全球</p><p>jQuery 使得操作 DOM、定义动画和实现“AJAX”请求，变得十分简单。简单来说，它使得 Web 开发者可以创建更现代、更动态的效果 ，最重要的是，通过 jQuery 在一种浏览器上实现的功能，基本上也能在其他浏览器上运行</p><p>时至今日，jQuery 仍然在支撑着数以千万计各种规模网站的运作</p><p>但是 jQuery 为什么会被摒弃呢？综合网上以及我自己的看法我认为有以下几点：</p><h2 id="摒弃原因"><a href="#摒弃原因" class="headerlink" title="摒弃原因"></a>摒弃原因</h2><ul><li>原生 Js 的发展，使得原生 API 足够的强大</li><li>jQuery 中的经典<code>$(selector)</code> 可以简单地用<code>querySelectorAll()</code>替换</li><li>CSS 类名切换，可以通过<code>Element.classList</code>实现</li><li>CSS 现在支持在样式表中定义视觉动画，无需使用 JavaScript</li><li>$.ajax 请求可以用 Fetch 标准实现（在不支持的浏览器上可以使用 XHR）</li><li><code>addEventListener()</code>接口已经十分稳定，足以跨平台使用</li><li>jQuery 提供的一些语法糖，已随着 JavaScript 语言的发展，而变得多余</li><li>链式语法并不能满足我们直观地书写代码的需要</li><li>自定义元素技术让用户无需下载、解析或编译任何框架</li><li>原生作为标准，更方便以后维持代码的灵活性</li><li>jQuery 大量 DOM 操作虽然方便，但是会牺牲很多页面的性能</li><li>浏览器兼容问题越来越少 ，如今浏览器 API 及其 polyfill 已经有足够标准化的 Web 应用程序开发</li><li>React、Vue 和 Angularjs 等主流前端框架并不依赖 jQuery，都可以独立使用</li><li>以 DOM 为中心的开发模式过于传统 ，目前复杂页面开发流行的是以数据/状态为中心的开发模式</li><li>前端服务化的趋势，<strong>同构</strong>渲染的问题，也是一个要移除 jQuery 的迫切原因</li></ul><p>同构</p><p>同构指前后端运行同一份代码，后端也可以渲染出页面。React 等流行框架天然支持，已经具有可行性。把现有应用改成同构时，因为代码要运行在服务端，但服务端没有 DOM，所以引用 jQuery 就会报错，在很多场合也要避免直接操作 DOM。</p><h2 id="个人感言"><a href="#个人感言" class="headerlink" title="个人感言"></a>个人感言</h2><p>曾经辉煌的 jQuery 终于走到了可以华丽谢幕的时刻，当然，John Resig 是一个伟大的开发者，jQuery 也是一个伟大的工具，<code>一个伟大的工具是指，它解决的问题不再存在，那么可以功成身退了</code>，这句话我觉得非常好，jQuery 引领了一个前端时代，这是不可否认的</p><p>作为一个前端原生爱好者，个人觉得，随着时代的变迁、技术的进步，jQuery 赖以存在的环境正逐渐消失。jQuery 提供了非常易用的 DOM 操作 API，屏蔽了浏览器差异，虽然极大地提高了开发效率，但这也导致很多前端只懂 jQuery ，而忽略了 js，特别是对于那些对前端深感兴趣的初学者，很多都把重心放在了 jQuery 之类的库上，偏离了本质，等回过头来再研究 js 时，费时不说，还会很不习惯，甚至很难转变，长此以往，不利于 js 语言的蓬勃发展，在我心中，js 和 css 是真正的前端核心，这两样技术，js 主导着核心编程，css 引导我们探索与创造，对我来说，这两样水都很深，很难吃透，在工作中考虑开发效率的话，三大框架精一足以，简洁方便，一些简单的操作，原生即可</p><blockquote><p>本文参考</p><p><a href="https://blog.csdn.net/csdnnews/article/details/83189938" target="_blank" rel="noopener">使用了 23 年的 Java 不再免费！</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MjAwODM4MA==&mid=2650698992&idx=1&sn=76bd487d3f044851aaa8da9fc914351d&chksm=bea6052389d18c3523e8024545a81d673c3220c2f21b16f80581fe5bea1d9c44afc849cf8b03&scene=21#wechat_redirect" target="_blank" rel="noopener">收购 GitHub 滔天争议后，微软回应一切</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MjM5MjAwODM4MA==&mid=2650701571&idx=1&sn=61b9cf057317fe00b7bcab4a5a00f034&chksm=bea60ed089d187c67557636b61b73f877ddcce5cf4c946cdf7f27278e8dc3c4b60221c67145c&scene=21#wechat_redirect" target="_blank" rel="noopener">GitHub 改版并放弃了 jQuery</a></p><p><a href="https://githubengineering.com/removing-jquery-from-github-frontend/" target="_blank" rel="noopener">从 GitHub.com 前端删除 jQuery–英文原文</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Web相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jQuery</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue中npm run build报“Error in parsing SVG Unquoted attribute value”</title>
    <link href="/blog/2018/09/11/vue/Error%20in%20parsing%20SVG%20Unquoted%20attribute%20value/"/>
    <url>/blog/2018/09/11/vue/Error%20in%20parsing%20SVG%20Unquoted%20attribute%20value/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue-中-npm-run-build-报“Error-in-parsing-SVG-Unquoted-attribute-value”"><a href="#Vue-中-npm-run-build-报“Error-in-parsing-SVG-Unquoted-attribute-value”" class="headerlink" title="Vue 中 npm run build 报“Error in parsing SVG: Unquoted attribute value”"></a>Vue 中 npm run build 报“Error in parsing SVG: Unquoted attribute value”</h1><p>自己做的一个 Vue 项目，在打包时老是报这个错误</p><pre><code class="js"># Error in parsing SVG: Unquoted attribute value</code></pre><p>查了查网上说的，都说报错原因是压缩和抽离 CSS 的插件中只允许 SVG 使用双引号</p><p>就是项目中外部引入的 CSS 文件里的 SVG 只能是双引号</p><p>我找了好久，这可把我坑坏了。。。</p><p>想想那段时间真是难受。。。</p><p>后来找到了，分享一下，让大家快点脱坑。。。</p><p>首先，如果你项目中使用了 mui 的话应该在这里改</p><p>找到 mui 文件下的 iconfont.css 文件</p><pre><code class="js"># mui/css/iconfont.css</code></pre><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/one.png" srcset="/blog/img/loading.gif" alt="001"></p><p>不要以为完了，还有</p><p>找到 mui 文件下的 mui.css 文件</p><pre><code class="js"># mui/css/mui.css</code></pre><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/two.png" srcset="/blog/img/loading.gif" alt="002"></p><p>以上两个文件修改了再次 build</p><p>如果还报 SVG 的错误，请查看你所有引入的外部 CSS 文件吧</p><p>如果你确定你引入的 CSS 文件中确实没有 SVG 或者是 SVG 确实是双引号，那就没办法了老兄。。。</p><p>最后：喜欢前端，欢迎探讨！！！</p>]]></content>
    
    
    <categories>
      
      <category>Vue相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
      <tag>Bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue不是内部或外部命令，也不是可执行的程序或批处理文件</title>
    <link href="/blog/2018/09/09/vue/Vue%E4%B8%8D%E6%98%AF%E5%86%85%E9%83%A8%E6%88%96%E5%A4%96%E9%83%A8%E5%91%BD%E4%BB%A4%EF%BC%8C%E4%B9%9F%E4%B8%8D%E6%98%AF%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%9A%84%E7%A8%8B%E5%BA%8F%E6%88%96%E6%89%B9%E5%A4%84%E7%90%86%E6%96%87%E4%BB%B6/"/>
    <url>/blog/2018/09/09/vue/Vue%E4%B8%8D%E6%98%AF%E5%86%85%E9%83%A8%E6%88%96%E5%A4%96%E9%83%A8%E5%91%BD%E4%BB%A4%EF%BC%8C%E4%B9%9F%E4%B8%8D%E6%98%AF%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%9A%84%E7%A8%8B%E5%BA%8F%E6%88%96%E6%89%B9%E5%A4%84%E7%90%86%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="vue-不是内部或外部命令，也不是可执行的程序或批处理文件"><a href="#vue-不是内部或外部命令，也不是可执行的程序或批处理文件" class="headerlink" title="vue 不是内部或外部命令，也不是可执行的程序或批处理文件"></a>vue 不是内部或外部命令，也不是可执行的程序或批处理文件</h1><p>平常我们搭个脚手架，可能分分钟就完事了，但是容易忽略一些细节，比如搭脚手架时 cmd 查 vue 版本号报<code>vue不是内部或外部命令，也不是可执行的程序或批处理文件</code>这种错误，明明 vue 下载了，脚手架下载完了怎么也初始化不了，你遇到过吗？</p><p>如果你确实已经在全局状态下安装了 vue 和 vue-cli，cmd<code>vue -V</code>或<code>vue init</code>还是报这个错，嗯，有必要往下看看！</p><p>解决办法：</p><p>配置 vue 的环境变量</p><ul><li>搜索 vue.cmd 文件，复制该文件地址，待用</li><li>注：如果搜索不到，请再下载一遍 vue。。</li></ul><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/000.png" srcset="/blog/img/loading.gif" alt=""></p><ul><li>windows 下进入<code>控制面板\系统和安全\系统</code>点击更改设置</li></ul><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/001.png" srcset="/blog/img/loading.gif" alt=""></p><ul><li>点击高级–环境变量</li></ul><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/002.png" srcset="/blog/img/loading.gif" alt=""></p><ul><li>新建一个系统变量</li></ul><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/003.png" srcset="/blog/img/loading.gif" alt=""></p><ul><li>输入变量名为 Path，变量值为刚复制的 vue.cmd 文件路径</li></ul><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/004.png" srcset="/blog/img/loading.gif" alt=""></p><ul><li>保存重新运行 cmd 输入<code>vue -V</code>即可</li></ul><p>完美结束！！！</p>]]></content>
    
    
    <categories>
      
      <category>Vue相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
      <tag>Bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GitHub 免费搭建个人网站</title>
    <link href="/blog/2018/09/06/other/GitHub%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99/"/>
    <url>/blog/2018/09/06/other/GitHub%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99/</url>
    
    <content type="html"><![CDATA[<h1 id="GitHub-免费搭建个人网站"><a href="#GitHub-免费搭建个人网站" class="headerlink" title="GitHub 免费搭建个人网站"></a>GitHub 免费搭建个人网站</h1><p>学习前端的人应该知道，开始学习前端时，心里想的肯定是我一定要给自己做一个的非常棒的网站，学完之后网站做好了，但是要怎么上线呢？？？</p><p>作为一个前端，拥有有自己的个人网站，算是迈出了前端道路的第一步！</p><h4 id="本文目的"><a href="#本文目的" class="headerlink" title="本文目的"></a>本文目的</h4><p>通过<strong>GitHub Pages</strong>免费快速的搭建个人网站，文章随长，其实非常简单，写的详细是为了能够让多数人都能够看得懂</p><h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><h4 id="建站常识"><a href="#建站常识" class="headerlink" title="建站常识"></a>建站常识</h4><p>首先了解常识，建站三部曲：</p><ul><li>网站项目</li><li>服务器</li><li>域名</li></ul><p>简单来说，就是我们要有一个域名，然后绑定服务器，再把网站上传到服务器上，这样就可以通过域名访问我们的网站了</p><p><strong>网站项目</strong>就是你写的网站文件，这个如果不会的话请去学习前端 <a href="http://www.w3school.com.cn/" target="_blank" rel="noopener">w3school 传送门</a></p><p><strong>服务器</strong>就是网络中为用户提供服务的专用设备。分为访问、文件、数据库、通信等不同功能的服务器。那么要怎样拥有一个服务器呢，(用钱就好了！！！)，正规途径是在网上买一个服务器，看图</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other//fuwuqi1.png" srcset="/blog/img/loading.gif" alt="图1"></p><p>刚开始玩的话买一个空间小的相对便宜的就行，当然有钱请随意！！！</p><p><strong>域名</strong>就是访问网站的网址，怎样获取域名，没错还是用钱，看图</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other//yuming1.png" srcset="/blog/img/loading.gif" alt="图2"></p><p>我的域名是在阿里云注册的，域名也是有区别的，后缀不一，长短不一，相对价钱就不一，如我的域名：</p><p><a href="https://isboyjc.top" target="_blank" rel="noopener">isboyjc.top</a></p><p>欢迎访问啊！不要问为什么是<code>.top</code>的后缀，因为<code>.top</code>的域名最贵了，我最有钱，我最任性</p><p>域名注册好之后首先要进行实名认证，然后域名解析、绑定服务器，最后把网站上传服务器，进行网站备案，静候备案成功就可以了（<strong>注</strong>：国内服务器需要备案，国外或香港服务器不用备案，但是相比国内服务器访问速度慢点，因为距离远嘛！）</p><p>这是一个网站上线的基本流程，当然以上不是本文重点，这些只是一些必备的常识，重点在下面</p><h4 id="GitHub-Pages-建站"><a href="#GitHub-Pages-建站" class="headerlink" title="GitHub Pages 建站"></a>GitHub Pages 建站</h4><p>什么是 GitHub Pages？</p><p>我就不照抄官方文档了，想了解请走传送门</p><p><a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages 传送门</a></p><p>官方文档比较高大上，简单来说 GitHub Pages 就是一个服务器，但它是免费的！免费的！免费的！重要的事说三遍！它能提供给我们 1G 空间的存储，让你放东西，然后还可以请求到</p><p>当然 GitHub Pages 还有一些其他的东西，不过我们的宗旨是建站，其他不用了解</p><p><strong>重点来了：</strong></p><p>登录<a href="https://github.com" target="_blank" rel="noopener">GitHub.com</a>官网(全英的界面，英语不好的朋友请用谷歌翻译！)</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other//github.PNG" srcset="/blog/img/loading.gif" alt=""></p><p>登录后点击右上角的加号，进入<code>new repository</code>选项新建一个储存库,看到以下界面</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other//ku.PNG" srcset="/blog/img/loading.gif" alt=""></p><p>首先输入库名，仓库名字为固定格式</p><pre><code>你的GitHub名.github.io// 例：// 我的GitHub名字为 isboyjc，所以库名为 isboyjc.github.io</code></pre><p>中间还有个储存库说明，可以不写，储存库说明下有一个自动为你选上的<code>Public</code>选项，意思是公开此储存库（就是别人可以看到并下载你库中的内容，当然可以不公开，但是要收费 7 美金/月，这个完全没有必要，因为 IT 的精华就是开源！当然土豪请随意！）</p><p>最后点击绿色按钮提交创建，提交后如下图</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other//create.PNG" srcset="/blog/img/loading.gif" alt=""></p><p>点击<code>README</code>进行初始化 README ，就是用<code>markdown</code>语法编写此储存库的具体说明或者说简单的展示，<code>markdown</code>语法十分简单，我也写了相应的<code>markdown</code>语法教程<a href="#">markdown 和 Typora–传送门</a>，有兴趣可以了解一下，当然这里不写也是可以的，直接点击下面绿色按钮提交即可</p><p><img src="../img/anniu.PNG" srcset="/blog/img/loading.gif" alt=""></p><p>再然后是如下界面：</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other//end.PNG" srcset="/blog/img/loading.gif" alt=""></p><p>上面图片红色框中依次翻译为：创建新文件、上传文件、查找文件、克隆或下载</p><p>点击<code>Upload files</code>上传文件</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other//endd.PNG" srcset="/blog/img/loading.gif" alt=""></p><p>点击<code>choose your files</code>选择文件上传，最后绿色按钮提交(<strong>注：</strong>上传的文件为你的网站文件，默认访问<code>index.html</code>文件所以你的网站首页一定要是<code>index.html</code>，css、js、img 文件同 html 文件一同拖拽进去即可，网速慢的话上传速度较慢请耐心等待，上传失败请重新上传)</p><p>这时神奇的一幕就来了，如果你的操作没错，这时你就可以在浏览器输入<code>你的GitHub名.github.io</code>访问你的网站了（<strong>注：</strong>如果你的储存库下没有<code>index.html文件</code>，访问时会自动显示你的<code>README.md</code>文档）！！！如下：</p><p><a href="https://isboyjc.github.io" target="_blank" rel="noopener">https://isboyjc.github.io</a></p><p>这个名字有点长，我想通过自己购买的域名访问怎么办呢？</p><p>接着往下看</p><h4 id="GitHub-Pages-域名绑定"><a href="#GitHub-Pages-域名绑定" class="headerlink" title="GitHub Pages 域名绑定"></a>GitHub Pages 域名绑定</h4><p>首先是域名解析</p><p>进入你的域名控制台，我的域名是阿里云注册的，所以本文以阿里云为例，如下图</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other//con1.PNG" srcset="/blog/img/loading.gif" alt=""></p><p>点击解析进入解析添加解析，如下图</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other//jiexi.PNG" srcset="/blog/img/loading.gif" alt=""></p><p><strong>记录类型</strong></p><p>记录类型我们选择<code>CNAME</code>，别名记录，就是把一个域名完完全全设置为另外一个域名的别名</p><p><strong>主机记录</strong></p><p>主机记录就是域名前缀，常见用法有：</p><pre><code>www：解析后的域名为www.aliyun.com@：直接解析主域名 aliyun.com*：泛解析，匹配其他所有域名 *.aliyun.commail：将域名解析为mail.aliyun.com，通常用于解析邮箱服务器二级域名：如：abc.aliyun.com，填写abc手机网站：如：m.aliyun.com，填写m显性URL：不支持泛解析（泛解析：将所有子域名解析到同一地址）</code></pre><p>举个例纸，我购买的域名是<code>isboyjc.top</code>我添加了两个域名解析，一个主机记录是<code>@</code>，一个主机记录是<code>www</code>，意思是让我的网站能够分别通过<code>isboyjc.top</code>和<code>www.isboyjc.top</code>访问到</p><p><strong>解析路线</strong></p><pre><code>如果只有一个IP地址或CNAME域名，请务必选择【默认】默认：必填！未匹配到智能解析线路时，返回【默认】线路设置结果境外：向除中国大陆以外的其他国家和地区，返回设置的记录值搜索引擎：向搜索引擎爬虫的DNS，返回设置的记录值</code></pre><p><strong>记录值</strong></p><p>因为我们使用的是<code>GitHub Pages</code>服务器，所以记录值填写为之前的仓库名<code>你的GitHub名字.github.io</code>，如果是你自己购买的服务器，解析时记录值应该填写为你的服务器主机地址</p><p><strong>TTL</strong></p><p>TTL 指的是域名解析的生命周期，简单来说它表示 DNS 服务器解析域名时记录在 DNS 服务器上的缓存时间</p><p>什么意思呢，来点题外话，先说下网站的访问流程，你的网站文件存储在数据服务器上，它会有一个 IP 地址，就像门牌号一样，我们在输入域名访问网站时，数据服务器是不认识你这个域名的，它只认识 IP，你的域名会通过 DNS 服务器解析成 IP 值，通过这个门牌号(IP 值)向数据服务器查找你的网站数据并给你返回到浏览器上</p><p>访问网站时，不会每次都到 DNS 服务器域名解析，而是第一次访问时才到 DNS 服务器进行解析，然后解析的结果会缓存到当地的递归 DNS 服务器(缓存服务器)上，当地的第二个用户访问网站时，递归服务器会直接返回解析结果，而不会再向 DNS 服务器请求解析，那多久之后递归服务器才会更新这个解析结果呢？这就是 TTL 来决定的</p><p>如果增大 TTL 值，可以节约域名解析时间，给网站访问加速 ，TTL 值大多都是以秒为单位的，很多的默认值都是 3600，也就是默认缓存 1 小时，这个值有点小了，难道会有人一个小时就改一次域名记录吗</p><p>如果减小 TTL 值，可以减少更换空间时的不可访问时间 ，如果 TTL 值大了，更换新的域名记录时因为 TTL 缓存的问题，结果可能是有的人可能访问到了新服务器，有的人访问走缓存会访问到了旧的服务器</p><p>那么 TTL 值多少才好呢？</p><p>总的来说，你要访问速度，TTL 值就大一点，如果你近期想更换服务器或 IP，为了更换后能尽量解析到新的 IP 上，TTL 值就小一点，说的有点多了，好了，跳过这个话题，回到主题，本文介绍的是个人建站，一般个人网站建议设置 TTL 值为 600，也就是 10 分钟是刚好的！</p><p>上面的东西弄完之后只剩最后一步啦！！！</p><p><strong>在 GitHub 仓库页添加 CNAME 文件</strong></p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other//cname.PNG" srcset="/blog/img/loading.gif" alt=""></p><p>还是上传文件的这个页面，点击<code>Create new file</code>创建一个新文件，文件名为<code>CNAME</code>，注意是大写，文件内容写你解析的域名，例：</p><pre><code>isboyjc.top</code></pre><p>如果你还解析了<code>www</code>的域名,那么你就在文件中写两个域名，例：</p><pre><code>isboyjc.topwww.isboyjc.top</code></pre><p>然后点击提交</p><p>最后，在浏览器上输入你的域名访问一下吧！！！</p><p>累死我了，终于写完了！！！</p>]]></content>
    
    
    <categories>
      
      <category>Web相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GitHub</tag>
      
      <tag>建站</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue打包后静态资源路径错误</title>
    <link href="/blog/2018/09/01/vue/Vue%E6%89%93%E5%8C%85%E5%90%8E%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E8%B7%AF%E5%BE%84%E9%94%99%E8%AF%AF/"/>
    <url>/blog/2018/09/01/vue/Vue%E6%89%93%E5%8C%85%E5%90%8E%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E8%B7%AF%E5%BE%84%E9%94%99%E8%AF%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue-打包后静态资源路径错误"><a href="#Vue-打包后静态资源路径错误" class="headerlink" title="Vue 打包后静态资源路径错误"></a>Vue 打包后静态资源路径错误</h1><p>vue 项目打包完了，dist 文件也生成了，运行一下，又报错了</p><p>错误还不少，报了好多资源路径找不到的错误，大概有两种</p><ul><li>一种是 js 或 css 文件引入路径错误，找不到文件</li><li>一种是 css 中的图片路径错误，找不到图片</li></ul><p>#############################################</p><ul><li>js 或 css 文件引入路径错误解决办法如下：</li></ul><p>不知道大家发现没有，所有的路径错误都是少了个点，例如：</p><p><code>src=/static/js/app.5d7099352641a1a9dd32.js</code></p><p>知道原因了就找解决办法，手动加也行，不过为了每次打包完即用</p><p>在配置文件里改，一劳永逸</p><p>找到<code>config/index.js</code> 配置文件，找<code>build</code>打包对象里的<code>assetsPublicPath</code>属性</p><p>默认值为<code>/</code>，更改为<code>./</code>就好了</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/20190401001.png" srcset="/blog/img/loading.gif" alt=""></p><ul><li>css 中的图片路径错误，找不到图片解决如下</li></ul><p>在 css 里引入图片路径打包的时候路径会错</p><p>打开<code>build/utils.js</code>文件，把打包 css 文件的配置加一个打包路径即可</p><p>加一行代码，如下</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/20190401002.png" srcset="/blog/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>Vue相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
      <tag>Bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue打包后index.html中无引号</title>
    <link href="/blog/2018/08/26/vue/Vue%E6%89%93%E5%8C%85%E5%90%8Eindex.html%E4%B8%AD%E6%97%A0%E5%BC%95%E5%8F%B7/"/>
    <url>/blog/2018/08/26/vue/Vue%E6%89%93%E5%8C%85%E5%90%8Eindex.html%E4%B8%AD%E6%97%A0%E5%BC%95%E5%8F%B7/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue-打包后-index-html-中无引号"><a href="#Vue-打包后-index-html-中无引号" class="headerlink" title="Vue 打包后 index.html 中无引号"></a>Vue 打包后 index.html 中无引号</h1><p>嗯，历经了千山万水，踩过了无数个坑，终于打包成功了</p><p>点击<code>index.html</code>，报错了，打开代码一看，<code>index.html</code>中路径都不带引号，如下。。。</p><p><code>&lt;link href=/static/css/app.262f48fe370f0ecbe3bd043450d7d62e.css rel=stylesheet&gt;</code></p><p>手动加吧，可行，但是一次又一次打包都手动有点浪费时间</p><p>嗯，聪明人有办法</p><p>找打包配置吧，在<code>build</code>目录下有一个<code>webpack.prod.conf.js</code>文件</p><p>这个文件中搜索<code>minify</code>，这个对象是压缩配置</p><p>在这个对象中有一个叫<code>removeAttributeQuotes</code>的属性，就是删除属性引用的意思</p><p>它的值默认为<code>true</code>，那就直接把他改成<code>false</code>就好了</p><p>现在可以再次<code>build</code>一下试试看了</p><p>如果<code>index.html</code>中还是没有引号，就把<code>minify</code>对象都注释再<code>build</code></p><p>完美解决，perfect！！！</p>]]></content>
    
    
    <categories>
      
      <category>Vue相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
      <tag>Bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>function与感叹号</title>
    <link href="/blog/2018/06/25/javascript/function&amp;!/"/>
    <url>/blog/2018/06/25/javascript/function&amp;!/</url>
    
    <content type="html"><![CDATA[<h1 id="function-与感叹号"><a href="#function-与感叹号" class="headerlink" title="function 与感叹号"></a>function 与感叹号</h1><p>相信大家都看到过在很多 js 代码中函数前面会有一个感叹号，这是什么意思呢？</p><pre><code class="js">!(function () {  alert(&quot;我最帅！&quot;)})() // true</code></pre><p>如上所示，这行代码在控制台输出，会执行 alert 语句，并返回 true，这是为什么呢？</p><p>这是一个匿名函数自调，但是它输出了，并且返回了 true，首先，解释下为什么返回 true，这个不难理解，匿名函数的返回值是<code>undefined</code>，感叹号是非的意思，前面加一个非变成<code>!undefined</code>，所以返回 true，不过重点不在这</p><pre><code class="js">function(){alert(&#39;无敌了&#39;)}()            // 语法错误</code></pre><p>我们都知道，如上所示的这种写法是不对的</p><p>匿名函数自调一般我们都会采用下面两种写法</p><pre><code class="js">;(function () {  alert(&quot;嗯，输出了&quot;)})();(function () {  alert(&quot;嗯，也输出了&quot;)})()</code></pre><p>那为什么上面把括号换成了感叹号的写法也可以执行匿名函数呢？</p><p>又是什么好处使多数前端攻城狮对这种叹号的方式情有独钟？ 是因为感叹号的一个字符比起括号的两个字符更节省空间吗？</p><p>节省空间显然是没有太大的说服力的，确实累死也节省不了多少内存啊，那又是为了什么呢？</p><p>首先我们来说一下为什么感叹号写法可以执行匿名函数</p><p>其实不管是括号还是感叹号的写法都是为了<strong>让 js 函数声明变成函数表达式</strong></p><p>看下面代码的解析</p><pre><code class="js">function fn(){&#39;我又来了&#39;}()        // Unexpected token</code></pre><p>上述代码报错是为什么呢</p><p>大家都知道，<code>function(){}</code>是函数声明，是一个完整的语句，js 解释器在解释完这个语句后就结束了，结束后会再解析后面的<code>()</code>，而 js 语法中<code>()</code>里面是需要有表达式语句的，这里<code>()</code>里面什么都没有，所以 js 解析就会报语法错误，完整来说，就是前面的<code>function fn(){&#39;我又来了&#39;}</code>这句函数声明语句是没有错误的，报的错是<code>()</code>的错误，不信你可以控制台把这条语句分开输入试试</p><p>结果肯定是函数语句没错，错的是<code>()</code></p><pre><code class="js">function(){&#39;没错，又是我&#39;}()        // Unexpected token</code></pre><p>那这条代码为什么错误呢？如上</p><p>注意这条代码和上面那条是不一样的，这条代码函数没有名字，众所周知，函数只有在函数表达式中才可以匿名，所以这里的错误是因为函数没有名字，之后的<code>()</code>根本就不会执行</p><pre><code class="js">var fn = function () {  alert(250)}fn()</code></pre><p>这样为什么会执行？如上</p><p>因为变量<code>fn</code>是函数表达式的引用，相当于调用了一个表达式</p><pre><code class="js">function fn() {  alert(&quot;哈哈哈&quot;)}fn()</code></pre><p>这样又是为什么可以执行呢？如上</p><p>是因为<code>fn</code>是函数名，它指向了这个函数，在当前的作用域中当然可以调用了</p><pre><code class="js">;(function () {  alert(111)})()</code></pre><p>这样为什么又可以执行呢？如上</p><p>是因为 js 语法中<code>()</code>中只能是表达式，所以上述代码强制让 js 解释器认为里面的函数是一个表达式，所以语句后面加上<code>()</code>就可以执行函数了</p><p>综上所述，想要实现调用一个函数，只需要把函数变成表达式调用就行了</p><p>那么怎样可以把函数变成表达式呢</p><p>当然，括号和文章开头的感叹号都是可以的</p><p>其实有很多种方法都可以把函数变成表达式</p><pre><code class="js">!(function () {  alert(1)})() + // true(function () {  alert(1)})() - // NAN  (function () {    alert(1)  })() // NAN~(function () {  alert(1)})() // -1new (function () {  alert(1)})() // Objectdelete (function () {  alert(1)})() // truevoid (function () {  alert(1)})()(  // undefined  function () {    alert(1)  })() // undefined</code></pre><p>如上所示，这些一元运算符和关键字都可以，括号当然也没问题，并且这些写法都是合法的，唯一不同的是返回值不同罢了，但是我们的宗旨是调用匿名函数，返回值一般情况下是不需要在意的</p><p>最后是关于性能了，这些写法中，除了<code>new</code>的方式最慢(可以理解，对象嘛！！！)，括号和加减号的方式最快，其他都差不多，所以说这几种写法都是可行的，但是为什么那么多的人用感叹号不用速度快又标准的括号呢？</p><p>个人认为 q 前端攻城狮喜欢用感叹号自调用函数的原因有四：</p><ul><li><p>one</p><p>感叹号确实比<code>()</code>简单点</p></li><li><p>two</p><p>感叹号的代码可读性较强</p></li><li><p>three</p><p>个人习惯</p></li><li><p>four</p><p>写代码不喜欢写分号的开发者在函数自调用时通常喜欢用感叹号</p><p>因为感叹号可以让我们自调用函数时不写分号也不报错，它防止了代码在合并的时候发生错误</p><p>不写分号的情况下用()的方式自调用函数会报错，虽然 js 解释器会自动补全分号</p><p>为什么<code>()</code>写法会报错呢，这个问题又牵扯到了 js 代码风格了</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
