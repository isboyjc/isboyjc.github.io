<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>跟着来，你也可以手写VueRouter</title>
    <link href="/blog/2021/08/02/vue/%E8%B7%9F%E7%9D%80%E6%9D%A5%EF%BC%8C%E4%BD%A0%E4%B9%9F%E5%8F%AF%E4%BB%A5%E6%89%8B%E6%92%B8VueRouter/"/>
    <url>/blog/2021/08/02/vue/%E8%B7%9F%E7%9D%80%E6%9D%A5%EF%BC%8C%E4%BD%A0%E4%B9%9F%E5%8F%AF%E4%BB%A5%E6%89%8B%E6%92%B8VueRouter/</url>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>VueRouter，无疑是每个 Vue 开发者时时刻刻都在使用的东西了，但对于它的源码，你了解多少呢？</p><p>相信大部分前端说起路由，都可以说出其核心有 <code>hash</code> 和 <code>history</code> 两种模式，<code>hash</code> 模式通过监听 <code>hashchange</code> 事件实现，<code>history</code> 模式通过监听 <code>popstate</code> 事件再使用 <code>pushstate</code> 修改 URL 来实现，你以为这就懂了？还是说你真的以为懂这些就算接触到 VueRouter 精髓了？No，far from it！！！</p><p>其实我和大多数人一样，之前根本没把 VueRouter 放在心上，认为这是一个很简单的东西。但当我开始读 VueRouter 源码时，并不是像我想的那样容易。VueRouter源码的整体架构其实很简单，但想读懂细节还是有难度的，各种谜一样的函数分离以及一些细节实现都让我想当无语，于是我就边读源码边照虎画猫，想通过这种方式深度学习，没成想直接淦了两个大夜才到预期目标。</p><h2 id="本文重点"><a href="#本文重点" class="headerlink" title="本文重点"></a>本文重点</h2><p>话不多说，我们看下读完这篇文章你可以学到什么？</p><p>介绍了关于 Router 的一些常识，并手写了一个精简版的 VueRouter（大部分核心特性），和绝大多数手写文章不同的是，这里的代码是完全以源码为标准一步一步实现的，包括整体架构、API等等都是一致的，跟着此文来一遍，除了能彻底搞懂核心源码之外，后期想看源码细节可无缝接入，看起真正的源码可以毫不夸张的说：纵享丝滑！</p><h2 id="阅前提示"><a href="#阅前提示" class="headerlink" title="阅前提示"></a>阅前提示</h2><p>本文基于最新最稳定的 VueRouter V3.5.2 版本，4.0+ 还是 next，所以不在本文讨论范围之内。</p><p>源码文章很枯燥也没有多少人看是因为难理解以及没有实践乐趣，So，建议拿出编辑器跟着手敲比较快乐。</p><p>关于本文对 VueRouter 的手写实现，主要包括：</p><ul><li>hash/history模式路由</li><li>嵌套路由</li><li>router-view/router-link组件</li><li>$router/$route</li><li>push/replace/go/back等方法</li><li>addRoute/addRoutes/getRouters</li><li>router hook</li></ul><p>没实现的部分，也会做大致介绍，并且我将一份刚 clone 下来的源码做好了注释，放到了手写源码项目的目录里（文末链接），大家手写完觉得不过瘾想磕细节就可以直接去看源码了，一套组合拳，不错，come on～</p><p>开始前，大家可以简单看下整个 VueRouter 对应的三个流程图解，看不懂也关系，有个大致印象即可，文末还会有此图。</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20210725173152169.png"></p><h2 id="前端路由实现原理"><a href="#前端路由实现原理" class="headerlink" title="前端路由实现原理"></a>前端路由实现原理</h2><p>前端路由，指由前端监听 URL 改变从而控制页面中组件渲染做到无刷新式页面跳转，用户虽感觉是一组不同的页面，但其实都在一个页面内。想要实现前端路由，我们需要考虑两个点：</p><ul><li>URL 改变但页面不刷新？</li><li>监测 URL 改变？</li></ul><p>接下来我们分别看看 Hash 和 History 这两种模式是怎么解决的。</p><h3 id="Hash路由简单实现"><a href="#Hash路由简单实现" class="headerlink" title="Hash路由简单实现"></a>Hash路由简单实现</h3><p>Hash 模式其实就是通过改变 URL 中 # 号后面的 hash 值来切换路由，因为在 URL 中 hash 值的改变并不会引起页面刷新，再通过 hashchange 事件来监听 hash 的改变从而控制页面组件渲染，看一个小例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#/home&quot;</span>&gt;</span>home<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#/about&quot;</span>&gt;</span>about<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 渲染路由模块 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;view&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">  <span class="hljs-keyword">let</span> view = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;#view&quot;</span>)</span><br><span class="javascript"></span><br><span class="javascript">  <span class="hljs-keyword">let</span> cb = <span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="javascript">    <span class="hljs-keyword">let</span> hash = location.hash || <span class="hljs-string">&quot;#/home&quot;</span>;</span><br><span class="javascript"></span><br><span class="javascript">  &#125;</span><br><span class="javascript">  <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&quot;hashchange&quot;</span>, cb)</span><br><span class="javascript">  <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&quot;load&quot;</span>, cb)</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如上，通过两个 a 标签来改变路由 hash 值，相当于 <code>router-link</code> 组件，页面中 <code>id=view</code> 的 div 我们可以把它理解为 <code>router-view</code> 组件，页面加载完毕先执行一下 cb 函数为 hash 和路由模块进行初始化赋值，点击 a 标签路由改变后，会被 hashchange 监听到从而触发路由模块更新。</p><h3 id="History路由简单实现"><a href="#History路由简单实现" class="headerlink" title="History路由简单实现"></a>History路由简单实现</h3><p>还有一种不带 # 号的方式，那就是 history，它提供了 pushState 和 replaceState 两个方法，使用这两个方法可以改变 URL 的路径还不会引起页面刷新，同时它也提供了一个 popstate 事件来监控路由改变，但是 popstate 事件并不像 hashchange 那样改变了就会触发。</p><ul><li>通过浏览器前进后退时改变了 URL 会触发 popstate 事件</li><li>js 调用 historyAPI 的 back、go、forward 等方法可以触发该事件</li></ul><p>来看它怎么实现路由监听：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&#x27;/home&#x27;</span>&gt;</span>home<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&#x27;/about&#x27;</span>&gt;</span>about<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 渲染路由模块 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;view&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">  <span class="hljs-keyword">let</span> view = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;#view&quot;</span>)</span><br><span class="javascript"></span><br><span class="javascript">  <span class="hljs-comment">// 路由跳转</span></span><br><span class="javascript">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">push</span>(<span class="hljs-params">path = <span class="hljs-string">&quot;/home&quot;</span></span>)</span>&#123;</span><br><span class="javascript">    <span class="hljs-built_in">window</span>.history.pushState(<span class="hljs-literal">null</span>, <span class="hljs-string">&#x27;&#x27;</span>, path)</span><br><span class="javascript">    update()</span><br><span class="javascript">  &#125;</span><br><span class="javascript">  <span class="hljs-comment">// 更新路由模块视图</span></span><br><span class="javascript">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">update</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">    view.innerHTML = location.pathname</span><br><span class="javascript">  &#125;</span><br><span class="javascript"></span><br><span class="javascript">  <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;popstate&#x27;</span>, <span class="hljs-function">()=&gt;</span>&#123;</span><br><span class="javascript">    update()</span><br><span class="javascript">  &#125;)</span><br><span class="javascript">  <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;load&#x27;</span>, <span class="hljs-function">()=&gt;</span>&#123;</span><br><span class="javascript">    <span class="hljs-keyword">let</span> links = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&#x27;a[href]&#x27;</span>)</span><br><span class="javascript">    links.forEach(<span class="hljs-function"><span class="hljs-params">el</span> =&gt;</span> el.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;</span><br><span class="javascript">      <span class="hljs-comment">// 阻止a标签默认行为</span></span><br><span class="javascript">      e.preventDefault()</span><br><span class="javascript">      push(el.getAttribute(<span class="hljs-string">&#x27;href&#x27;</span>))</span><br><span class="javascript">    &#125;))</span><br><span class="javascript">    push()</span><br><span class="javascript">  &#125;)</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>如上，a 标签为 <code>router-link</code> 组件，div 为 <code>router-view</code> 组件。</p><p>由于 popstate 事件只能监听浏览器前进回退和使用 history 前进后退 API，所以除了在事件监听中要做更新操作，还要在跳转时手动做路由模块更新。</p><p>这样就可以做到和 hash 一样的效果了，同时由于 a 标签存在默认点击跳转行为，所以我们阻止了此行为。同时我们可以直接在浏览器中改变URL刷新，但在这个例子是不支持的，因为这就需要后端来配合了。</p><p>上面就是 hash模式和 history 模式的精简原理了，知道这些基础我们就可以开始写 VueRouter 了</p><h2 id="从使用分析VueRouter"><a href="#从使用分析VueRouter" class="headerlink" title="从使用分析VueRouter"></a>从使用分析VueRouter</h2><p>手写 VueRouter 之前，我们要从它的使用层面分析，看它都有什么，先回顾一下它的使用：</p><ul><li>路由配置文件中引入 VueRouter 并作为一个插件 use 一下</li><li>路由配置文件中配置路由对象生成路由实例并导出</li><li>将配置文件导出的 router 实例挂载到 Vue 的根实例上</li></ul><p>整个步骤如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// router/index.js</span><br><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;<br><span class="hljs-keyword">import</span> VueRouter <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue-router&quot;</span>;<br><br>Vue.use(VueRouter);<br><br><span class="hljs-keyword">const</span> routes = [<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/&quot;</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Home&quot;</span>,<br>    component,<br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/about&quot;</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;About&quot;</span>,<br>    component,<br>  &#125;<br>];<br><br><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> VueRouter(&#123;<br>  <span class="hljs-attr">mode</span>: <span class="hljs-string">&quot;hash&quot;</span>,<br>  <span class="hljs-attr">base</span>: process.env.BASE_URL,<br>  routes,<br>&#125;);<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> router;<br></code></pre></td></tr></table></figure><p>在项目 main.js 文件中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// main.js</span><br><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;<br><span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./App.vue&quot;</span>;<br><span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./router&quot;</span>;<br><br><span class="hljs-keyword">new</span> Vue(&#123;<br>  router,<br>  <span class="hljs-attr">render</span>: <span class="hljs-function">(<span class="hljs-params">h</span>) =&gt;</span> h(App),<br>&#125;).$mount(<span class="hljs-string">&quot;#app&quot;</span>);<br></code></pre></td></tr></table></figure><p>可看出，VueRouter 作为一个类可以被实例化同时它也作为一个 Vue 插件被加载。</p><p>实例化好理解，但是为什么要加载插件呢？</p><p>我们在使用 VueRouter 时，经常会使用到 <code>router-link</code> 和 <code>router-view</code> 两个组件，这两个组件我们没有发现哪里引入了，有没有想过为什么可以全局使用？其实就是在 VueRouter 作为插件初始化时全局注册的。</p><p>在使用过程中，我们可以使用 <code>this.$router</code> 获取路由实例，同时实例上还会有一些像 <code>push/go/back</code> 等方法，还可以通过 <code>this.$route</code> 来获取一个只读的路由对象，其中包括我们当前的路由以及一些参数等。</p><h2 id="手写前的准备"><a href="#手写前的准备" class="headerlink" title="手写前的准备"></a>手写前的准备</h2><h3 id="项目搭建"><a href="#项目搭建" class="headerlink" title="项目搭建"></a>项目搭建</h3><p>创建一个 Vue 项目，使用终端输入下面命令构建一个 Vue 项目：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vue create hello-vue-router<br></code></pre></td></tr></table></figure><p>注意构建时选上 VueRouter 哦！</p><p>构建完成直接 <code>yarn serve</code> 跑起来，如下，一个非常熟悉的界面：</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20210720011259726.png"></p><p>接着我们在 <code>src/</code> 下新建一个文件夹 <code>hello-vue-router/</code> ，此文件夹下就放我们自己写的 VueRouter 代码。</p><p>先新建一个 <code>index.js</code> 文件，导出一个空 VueRouter 类：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @path: src/hello-vue-router/index.js</span><br><span class="hljs-comment"> * @Description: 入口文件 VueRouter类</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VueRouter</span>()</span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">options</span>)</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后来到路由配置文件 <code>src/router/index.js</code> ，将引入的 VueRouter 换成我们自己的，并将路由模式改为 hash，因为我们要先实现 hash 模式，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> VueRouter <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/hello-vue-router/index&#x27;</span><br><span class="hljs-comment">// import VueRouter from &#x27;vue-router&#x27;</span><br><span class="hljs-keyword">import</span> Home <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../views/Home.vue&#x27;</span><br><br>Vue.use(VueRouter)<br><br><span class="hljs-keyword">const</span> routes = [...]<br><br><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> VueRouter(&#123;<br>  <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;hash&#x27;</span>,<br>  <span class="hljs-attr">base</span>: process.env.BASE_URL,<br>  routes<br>&#125;)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> router<br></code></pre></td></tr></table></figure><p>那现在页面就变成了空白，并且控制台报着下面的错：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Cannot call a class as a <span class="hljs-keyword">function</span><br></code></pre></td></tr></table></figure><p>控制台的错误说不能将 class 作为函数调用！！！</p><p>诶，哪里讲 class 作为函数调用了？</p><p>其实是 <code>Vue.use(VueRouter)</code> 这，说到这，我们就不得不介绍下这个 Vue 安装插件的 API 了</p><h3 id="Vue-use-源码解析"><a href="#Vue-use-源码解析" class="headerlink" title="Vue.use()源码解析"></a>Vue.use()源码解析</h3><p>如下，其实说白了，这个方法接收一个类型为函数或对象的参数。如果参数是对象，那它就必须有一个 install 属性方法。不论参数是函数还是对象，在执行 install 方法或者函数本身的时候都会把构造函数 Vue 作为第一个参数传进去。</p><p>这样我们在写插件时，写一个函数或者一个有 install 函数属性的对象，都可以接收到构造函数 Vue，也就可以使用它来做一些事情了，很 easy 吧！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js">Vue.use = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">plugin: <span class="hljs-built_in">Function</span> | <span class="hljs-built_in">Object</span></span>) </span>&#123;<br>  <span class="hljs-comment">// installedPlugins为已安装插件列表，若 Vue 构造函数不存在_installedPlugins属性，初始化</span><br>  <span class="hljs-keyword">const</span> installedPlugins = (<span class="hljs-built_in">this</span>._installedPlugins || (<span class="hljs-built_in">this</span>._installedPlugins = []))<br>  <span class="hljs-comment">// 判断当前插件是否在已安装插件列表，存在直接返回，避免重复安装</span><br>  <span class="hljs-keyword">if</span> (installedPlugins.indexOf(plugin) &gt; -<span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span><br>  &#125;<br><br><span class="hljs-comment">// toArray方法将Use方法的参数转为数组并删除了第一个参数（第一个参数就是我们的插件）</span><br>  <span class="hljs-keyword">const</span> args = toArray(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span>)<br>  <span class="hljs-comment">// use是构造函数Vue的静态方法，那这里的this就是构造函数Vue本身</span><br>  <span class="hljs-comment">// 把this即构造函数Vue放到参数数组args的第一项</span><br>  args.unshift(<span class="hljs-built_in">this</span>)<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> plugin.install === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>    <span class="hljs-comment">// 传入参数存在install属性且为函数</span><br>    <span class="hljs-comment">// 将构造函数Vue和剩余参数组成的args数组作为参数传入install方法，将其this指向插件对象并执行install方法</span><br>    plugin.install.apply(plugin, args)<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> plugin === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>    <span class="hljs-comment">// 传入参数是个函数</span><br>    <span class="hljs-comment">// 将构造函数Vue和剩余参数组成的args数组作为参数传入插件函数并执行</span><br>    plugin.apply(<span class="hljs-literal">null</span>, args)<br>  &#125;<br>  <span class="hljs-comment">// 像已安装插件列表中push当前插件</span><br>  installedPlugins.push(plugin)<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="初步构建install方法"><a href="#初步构建install方法" class="headerlink" title="初步构建install方法"></a>初步构建install方法</h2><p>接下来开始手写代码了！既然知道 Vue 如何加载插件，那就容易了，因为我们导出的是一个 VueRouter 类，也是一个对象，所以为其添加一个 install 方法就行。</p><p>稍微改变下 <code>index.js</code> ，为 VueRouter 类添加静态方法 install：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @path: src/hello-vue-router/index.js</span><br><span class="hljs-comment"> * @Description: 入口文件 VueRouter类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">import</span> &#123; install &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./install&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VueRouter</span>()</span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">options</span>)</span>&#123;&#125;<br>&#125;<br>VueRouter.install = install;<br></code></pre></td></tr></table></figure><p>接着在 <code>src/hello-vue-router/</code> 目录下创建一个 <code>instal.js</code> ，导出一个 install 方法，我们看过 <code>Vue.use()</code> 方法源码了那肯定晓得这个方法的第一个参数是构造函数 Vue，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @path: src/hello-vue-router/install.js</span><br><span class="hljs-comment"> * @Description: 插件安装方法install</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">install</span>(<span class="hljs-params">Vue</span>)</span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>上面也分析过，插件安装时 install 方法会在 Vue 全局挂载两个组件，<code>router-view</code> 和 <code>router-link</code> 。</p><p>要知道，我们在 router 的配置文件中只做了初始化 VueRouter 插件和生成 VueRouter 实例 2 件事情，那我们平常在项目中直接使用的 <code>this.$router &amp; this.$route</code> 是哪来的呢？</p><p>首先 <code>$router</code> 是 VueRouter 的实例对象，<code>$route</code> 是当前路由对象，<code>$route</code> 其实也是 <code>$router</code> 的一个属性，这两个对象在 Vue 所有的组件中都可以使用。</p><p>可能有小伙伴还记得在项目的入口文件 <code>main.js</code> 中，我们把导出的 router 实例挂载到了 Vue 根实例上，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span><br><span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./router&#x27;</span><br><br>Vue.config.productionTip = <span class="hljs-literal">false</span><br><br><span class="hljs-keyword">new</span> Vue(&#123;<br>  router,<br>  <span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">h</span>) </span>&#123; <span class="hljs-keyword">return</span> h(App) &#125;<br>&#125;).$mount(<span class="hljs-string">&#x27;#app&#x27;</span>)<br></code></pre></td></tr></table></figure><p>但问题又来了，我们只是挂载到了根实例上，并没有每个组件都挂，况且直接在 Vue 实例上挂载的对象，Vue 都会给我们放到当前实例的 <code>$options</code> 属性上，结合我们只挂载到了根实例上，那我们想要访问 router 实例对象只能采取 <code>this.$root.$options.router</code> 来获取，这里 <code>this.$root</code> 获取到的即根实例。</p><p>显然，外部并不是这样调用的。</p><p>所以，<code>$router &amp; $route</code> 这两个属性只可能是在 VueRouter 组件内挂载的，并且还需要在 Vue 项目开发过程中能让所有组件都使用。</p><p>细品，VueRouter 组件里怎么获取它的实例对象（在这个类里怎么拿到new VueRouter对象）？</p><p>可能有小伙伴想到了，这个 router 实例在 Vue 根实例挂载了啊，没错，就是在 new Vue 的时候传入的那个 router 。想办法拿就可以了，怎么拿呢？</p><p>上面也说了，我们可以先获取到 Vue 根实例，接着可以用 <code>$options.router</code> 来获取实例上挂载的 router 属性，也就是说目前考虑的是如何在 VueRouter 中拿到 Vue 组件实例（有组件实例就可以拿到根组件实例从而访问它的 <code>$options</code> 属性）</p><p>诶，好像又想到了， VueRouter 的 install 方法会传进来一个 Vue 构造函数，它能搞事情吗？</p><p>构造函数就是构造函数，它当然不是实例，但是构造函数 Vue 有 <code>mixin</code> 方法啊，没错就是 <code>混入</code> </p><blockquote><p><strong>小</strong> <strong>Tips：Vue.mixin</strong></p><p>估摸着很多人都知道这个方法，但还是有必要介绍一下。</p><p>混入分为全局混入和组件混入，我们直接使用构造函数 Vue.mixin 这种是全局混入，它接收一个对象参数，在这个对象参数里，我们可以写任何 Vue 组件里的东西，然后我们写的这堆东西会被混入（也可以理解为合并）到 Vue 每一个组件上。</p><p>比如写一个生命周期，里面写了个逻辑，那么在所有的 Vue 组件中这个生命周期开始前都会先执行我们混入的逻辑。还不懂？再比如，我们写了个 <code>methods</code> ，里面写了个函数，那这个函数会被混入到所有的 Vue 组件的 <code>methods</code> 中，所有组件都可直接调用。</p></blockquote><p>Vue.mixin 可以直接写组件那套，这就简单了，写一个生命周期全局混入到组件就 OK 了。</p><p>那么问题又又来了，在哪个生命周期里写呢？其实也简单，只要看在哪个生命周期 <code>$options</code> 可以构建好就行了，<code>beforeCreate</code> 这个周期 <code>$options</code> 就构建好了，也就是在这个生命周期后都可以使用 <code>$options</code>，还用问吗？肯定越早越好，就是 <code>beforeCreate</code> 这个生命周期了。</p><p>再捋一遍，install 方法可以传过来一个参数构造函数 Vue，使用构造函数 Vue 的静态方法 mixin 为我们所有组件的 <code>beforeCreate</code> 生命周期混入一段逻辑，这段逻辑就是为其挂载上 <code>$router &amp; $route</code> 属性</p><p>根据我们上面的逻辑，先上完整代码再逐步解释：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @path: src/hello-vue-router/install.js</span><br><span class="hljs-comment"> * @Description: 插件安装方法install</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> _Vue;<br><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">install</span>(<span class="hljs-params">Vue</span>)</span>&#123;<br>  <span class="hljs-keyword">if</span> (install.installed &amp;&amp; _Vue === Vue) <span class="hljs-keyword">return</span>;<br>  install.installed = <span class="hljs-literal">true</span>;<br><br>  _Vue = Vue;<br><br>  Vue.mixin(&#123;<br>    <span class="hljs-function"><span class="hljs-title">beforeCreate</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.$options.router) &#123;<br>        <span class="hljs-built_in">this</span>._routerRoot = <span class="hljs-built_in">this</span>;<br>        <span class="hljs-built_in">this</span>._router = <span class="hljs-built_in">this</span>.$options.router;<br>        <span class="hljs-built_in">this</span>._route = &#123;&#125;;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">this</span>._routerRoot = (<span class="hljs-built_in">this</span>.$parent &amp;&amp; <span class="hljs-built_in">this</span>.$parent._routerRoot) || <span class="hljs-built_in">this</span><br>      &#125;<br>    &#125;,<br>  &#125;);<br><br>  <span class="hljs-built_in">Object</span>.defineProperty(Vue.prototype, <span class="hljs-string">&quot;$router&quot;</span>, &#123;<br>    <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>._routerRoot._router;<br>    &#125;,<br>  &#125;);<br>  <br>  <span class="hljs-built_in">Object</span>.defineProperty(Vue.prototype, <span class="hljs-string">&#x27;$route&#x27;</span>, &#123;<br>    <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>._routerRoot._route;<br>    &#125;<br>  &#125;);<br><br>  Vue.component(<span class="hljs-string">&#x27;RouterView&#x27;</span>, &#123;&#125;);<br>  Vue.component(<span class="hljs-string">&#x27;RouterLink&#x27;</span>, &#123;&#125;);  <br>&#125;<br></code></pre></td></tr></table></figure><p>来逐块解释：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> _Vue;<br><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">install</span>(<span class="hljs-params">Vue</span>)</span>&#123;<br>  <span class="hljs-keyword">if</span> (install.installed &amp;&amp; _Vue === Vue) <span class="hljs-keyword">return</span>;<br>  install.installed = <span class="hljs-literal">true</span>;<br><br>  _Vue = Vue;<br>&#125;<br></code></pre></td></tr></table></figure><p>诶？ install 文件中不止导出了一个 install 方法，还导出了一个 _Vue 变量，它是什么？</p><p>在初始化插件的时候会执行 install 方法，在此方法里会把行参也就是 Vue 的构造函数赋值给变量 _Vue 并导出，其实这个 _Vue 它有两个作用：</p><p>第一就是通过它防止插件多次注册安装，因为插件安装方法 install 里我们给此方法添加了一个 installed 属性，当此属性存在且为 true 且 _Vue 已被赋值为构造函数 Vue 时 return，代表已经注册过该插件，无需重复注册。</p><p>第二个作用就是构造函数 Vue 上面挂载了很多实用 API 可供我们在 VueRouter 类里使用，当然也可以通过引入 Vue 来使用它的 API，但是一旦引入包使用，打包的时候也会将整个 Vue 打包进去，即然 install 里会把这个构造函数作为参数传过来，恰巧我们写 router 配置文件时，安装插件（Vue.use）是写在初始化 VueRouter 实例前面的，也就是 install 执行较早，这个时候我们把构造函数参数赋值给一个变量在 VueRouter 类里使用简直完美，还不理解就看图 ⬇️</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20210721134755896.png"></p><p>接着来看混入这块，其实说白了就是挂载 <code>$router &amp; $route</code> ：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">install</span>(<span class="hljs-params">Vue</span>)</span>&#123;  <br>  <span class="hljs-comment">// 全局注册混入，每个 Vue 实例都会被影响</span><br>  Vue.mixin(&#123;<br>    <span class="hljs-comment">// Vue创建前钩子，此生命周期$options已挂载完成</span><br>    <span class="hljs-function"><span class="hljs-title">beforeCreate</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-comment">// 通过判断组件实例this.$options有无router属性来判断是否为根实例</span><br>      <span class="hljs-comment">// 只有根实例初始化时我们挂载了VueRouter实例router（main.js中New Vue(&#123;router&#125;)时）</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.$options.router) &#123;<br>        <span class="hljs-built_in">this</span>._routerRoot = <span class="hljs-built_in">this</span>;<br>        <span class="hljs-comment">// 在 Vue 根实例添加 _router 属性（ VueRouter 实例）</span><br>        <span class="hljs-built_in">this</span>._router = <span class="hljs-built_in">this</span>.$options.router;<br>        <span class="hljs-built_in">this</span>._route = &#123;&#125;;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 为每个组件实例定义_routerRoot，回溯查找_routerRoot</span><br>        <span class="hljs-built_in">this</span>._routerRoot = (<span class="hljs-built_in">this</span>.$parent &amp;&amp; <span class="hljs-built_in">this</span>.$parent._routerRoot) || <span class="hljs-built_in">this</span><br>      &#125;<br>    &#125;,<br>  &#125;);<br><br>  <span class="hljs-comment">// 在 Vue 原型上添加 $router 属性( VueRouter )并代理到 this._routerRoot._router</span><br>  <span class="hljs-built_in">Object</span>.defineProperty(Vue.prototype, <span class="hljs-string">&quot;$router&quot;</span>, &#123;<br>    <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>._routerRoot._router;<br>    &#125;,<br>  &#125;);<br>  <br>  <span class="hljs-comment">// 在 Vue 原型上添加 $route 属性( 当前路由对象 )并代理到 this._routerRoot._route</span><br>  <span class="hljs-built_in">Object</span>.defineProperty(Vue.prototype, <span class="hljs-string">&#x27;$route&#x27;</span>, &#123;<br>    <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>._routerRoot._route;<br>    &#125;<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们看看都做了什么：</p><p>首先写一个mixin，全局注册混入，让每个 Vue 实例都会被影响。混入里写一个 beforeCreate 钩子，因为此生命周期 $options 最早挂载完成。又因全局混入，所以 beforeCreate 钩子里我们写了一个通过组件实例中的 this.$​options 有无 router 属性来判断是否为根实例，只有根实例初始化时才挂载 VueRouter 实例 router（就是 main.js 中 New Vue({router}) 时）。</p><blockquote><p><strong>是根实例：</strong></p><p>是根实例就为其添加 _router 属性，值为 VueRouter 实例，同时添加一个 _routerRoot 属性将 this 也就是根实例也挂载上去</p><p>上面分析过，这里还应有 route 对象，所以最后还为其添加了 _route 属性，暂且将它设置成空对象，后面再完善</p><p><strong>不是根实例：</strong></p><p>不是根实例，那就是子组件实例了，找它的父实例判断其父实例有没有 _routerRoot 属性，没有就为其加上引用，确保每一个组件实例都可以有 _routerRoot 属性，也就是让每个组件中都可以引用并访问到根实例，注意并不是反复赋值，对象间的引用而已</p></blockquote><p>最后为了让每个组件都可以访问到 <code>$router $ $route</code> 对象，我们在 Vue 原型上添加了 $router 属性并代理到 <code>this._routerRoot._router</code>，也在 Vue 原型上添加了 <code>$route</code> 属性并代理到 <code>this._routerRoot._route</code>，剩下就是创建全局组件了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 全局注册组件router-view</span><br>Vue.component(<span class="hljs-string">&#x27;RouterView&#x27;</span>, &#123;&#125;);<br><span class="hljs-comment">// 全局注册组件router-link</span><br>Vue.component(<span class="hljs-string">&#x27;RouterLink&#x27;</span>, &#123;&#125;); <br></code></pre></td></tr></table></figure><p>这块暂时比较简单，使用 Vue.component 全局注册了两个组件，配置对象都直接为空。下面简单的配置一下这两个全局组件，让项目跑起来，毕竟现在运行还在报错。</p><h2 id="初步构建RouterView、RouterLink组件"><a href="#初步构建RouterView、RouterLink组件" class="headerlink" title="初步构建RouterView、RouterLink组件"></a>初步构建RouterView、RouterLink组件</h2><p>稍微分离一下，我们在 <code>src/hello-vue-router/</code> 目录下新建一个 <code>components/</code> 文件夹</p><p>在 <code>components</code> 文件夹下新建 <code>view.js</code> 和 <code>link.js</code> 两个文件，随后还是要先改变一下 install 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @path: src/hello-vue-router/install.js</span><br><span class="hljs-comment"> * @Description: 插件安装方法install</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">import</span> View <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./components/view&quot;</span>;<br><span class="hljs-keyword">import</span> Link <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./components/link&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">install</span>(<span class="hljs-params">Vue</span>)</span>&#123;<br>  <span class="hljs-comment">// 全局注册组件router-view</span><br>  Vue.component(<span class="hljs-string">&#x27;RouterView&#x27;</span>, view);<br><br>  <span class="hljs-comment">// 全局注册组件router-link</span><br>  Vue.component(<span class="hljs-string">&#x27;RouterLink&#x27;</span>, link);  <br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到我们把两个组件的配置对象单独拉出去了两个文件来写，其实就是每个文件导出一个组件配置对象。</p><p>先看 <code>link.js</code> ，link 组件类似 a 标签，其实它默认就会渲染一个 a 标签，组件接收一个 to 参数，可以为对象，也可以为字符串，用作跳转。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/home&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">&quot;&#123;path: &#x27;/home&#x27;&#125;&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>看实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @path: src/hello-vue-router/components/link.js</span><br><span class="hljs-comment"> * @Description: router-link</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;RouterLink&quot;</span>,<br>  <span class="hljs-attr">props</span>: &#123;<br>    <span class="hljs-attr">to</span>: &#123;<br>      <span class="hljs-attr">type</span>: [<span class="hljs-built_in">String</span>, <span class="hljs-built_in">Object</span>],<br>      <span class="hljs-attr">require</span>: <span class="hljs-literal">true</span><br>    &#125;<br>  &#125;,<br>  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params">h</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> href = <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">this</span>.to === <span class="hljs-string">&#x27;string&#x27;</span> ? <span class="hljs-built_in">this</span>.to : <span class="hljs-built_in">this</span>.to.path<br>    <span class="hljs-keyword">const</span> router = <span class="hljs-built_in">this</span>.$router<br>    <span class="hljs-keyword">let</span> data = &#123;<br>      <span class="hljs-attr">attrs</span>: &#123;<br>        <span class="hljs-attr">href</span>: router.mode === <span class="hljs-string">&quot;hash&quot;</span> ? <span class="hljs-string">&quot;#&quot;</span> + href : href<br>      &#125;<br>    &#125;;<br>    <span class="hljs-keyword">return</span> h(<span class="hljs-string">&quot;a&quot;</span>, data, <span class="hljs-built_in">this</span>.$slots.default)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先是 props 接收参数 to，必选项，可为对象或字符串类型，在 render 函数中首先判断了参数 to 的类型，并把它统一做成了对象。</p><p>接着访问了根实例中的 <code>$router</code>，这里的 this 其实是一个 Proxy，输出一下就会知道，这个 Proxy 代理到了 VueComponent 实例，而我们在 install 给每个组件实例都加上了指向根实例的属性 _routerRoot，这里其实想要访问 router 对象有好多种。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// this._self._routerRoot._router</span><br><span class="hljs-comment">// this._routerRoot._router</span><br><span class="hljs-comment">// this.$router</span><br></code></pre></td></tr></table></figure><blockquote><p>用啥都可以，但是源码用的第三种，我们也就用这个了，可能是字符最少</p></blockquote><p>接着就是返回一个 VNode 了，其实 render 的 h 参数就是 createElement 函数，作用就是创建一个 VNode，它的参数看官网描述：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// @returns &#123;VNode&#125;</span><br>createElement(<br>  <span class="hljs-comment">// &#123;String | Object | Function&#125;</span><br>  <span class="hljs-comment">// 一个 HTML 标签名、组件选项对象，或者</span><br>  <span class="hljs-comment">// resolve 了上述任何一种的一个 async 函数。必填项。</span><br>  <span class="hljs-string">&#x27;div&#x27;</span>,<br><br>  <span class="hljs-comment">// &#123;Object&#125;</span><br>  <span class="hljs-comment">// 一个与模板中 attribute 对应的数据对象。可选。</span><br>  &#123;<br>    <span class="hljs-comment">// (详情见下一节)</span><br>  &#125;,<br><br>  <span class="hljs-comment">// &#123;String | Array&#125;</span><br>  <span class="hljs-comment">// 子级虚拟节点 (VNodes)，由 `createElement()` 构建而成，</span><br>  <span class="hljs-comment">// 也可以使用字符串来生成“文本虚拟节点”。可选。</span><br>  [<br>    <span class="hljs-string">&#x27;先写一些文字&#x27;</span>,<br>    createElement(<span class="hljs-string">&#x27;h1&#x27;</span>, <span class="hljs-string">&#x27;一则头条&#x27;</span>),<br>    createElement(MyComponent, &#123;<br>      <span class="hljs-attr">props</span>: &#123;<br>        <span class="hljs-attr">someProp</span>: <span class="hljs-string">&#x27;foobar&#x27;</span><br>      &#125;<br>    &#125;)<br>  ]<br>)<br></code></pre></td></tr></table></figure><p>这里我们想要返回一个 a 标签，所以第一个参数就是字符串 a，第二个参数就是标签 attribute 对应的数据对象，要给他带上 href 属性，属性值就是 to 参数，需要注意的是模式问题，hash 模式下要给所有的跳转路径前加上一个 # 号，所以需要 <code>router.mode</code> 判断一下模式，第三个参数就是子节点了，也就是 <code>router-link</code> 组件中包含的值，其实使用默认插槽即可拿到， <code>this.$slots.default</code> 获取默认插槽。</p><p>OK，到这 <code>router-link</code> 组件就差不多完成了，只是在 history 模式下还有问题，我们后面再说。</p><p>再来看 <code>view.js</code> ，其实我们并不需要 RouterView 组件渲染什么东西，它充其量就是一个占位符，用来替换我们的组件模块UI，所以一不需要生命周期，二不需要状态管理，三不需要各种监听，通俗点就是没必要创造一个实例，作为一个三无组件，函数式组件最符合了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @path: src/hello-vue-router/components/view.js</span><br><span class="hljs-comment"> * @Description: router-view</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;RouterView&quot;</span>,<br>  <span class="hljs-attr">functional</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 函数式组件</span><br>  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params">h</span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> h(<span class="hljs-string">&#x27;div&#x27;</span>, <span class="hljs-string">&#x27;This is RoutePage&#x27;</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上，直接先设置成函数式组件，然后 render 函数直接返回一个 div，内容为 <code>&#39;This is RoutePage&#39;</code>（h 函数即 createElement 函数没有无第二个参数可省略），这里只是初步搭建一下结构，逻辑后面再说，先让页面跑起来，现在你再打开浏览器会发现无报错了，导航也有了，还可以点击切换路由，就是路由模块组件即 <code>router-view</code> 永远都只显示 <code>This is RoutePage</code> ，如下：</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20210721024752049.png"></p><h2 id="初步构建VueRouter类"><a href="#初步构建VueRouter类" class="headerlink" title="初步构建VueRouter类"></a>初步构建VueRouter类</h2><p>install 方法我们暂时可以告一段落，思考一下 VueRouter 类里，我们需要做什么？</p><p>首先，接收到参数肯定要对参数进行一个分析，传进来的是一个对象，其中主要的就是两个属性：</p><ul><li>mode 路由模式</li><li>routes 路由配置数组</li></ul><p>其实 base 属性也比较重要，不过可以先不考虑这个，逻辑跑通后有时间再完善</p><p>思考 mode 配置，我们需要根据 mode 传入的路由模式来初始化对应模式的一些东西，从而实现对该模式下的路由监听。</p><p>那再思考一下关于 routes 数组，我们需要做什么？</p><p>其实，此数组中配置的最重要的就是路由 path 以及 path 对应的路由组件，当然还有一些重定向、动态路由、路由名称、路由别名的配置，这些也都暂时不考虑，后期逐步完善。</p><p>问题来了，监听到路由发生了变化我们需要做什么？</p><p>当然是拿到改变的路由 path ，在 routes 数组中找到匹配的 path 配置，获取它的组件，然后把拿到的组件渲染到对应的 <code>router-view</code> 中去。</p><p>对于 routes 配置，目的很明确了，因为这是一个树结构的数组对象，我们是基于 path 匹配的，很不方便，所以需要提前将此配置解析为 <code>&#123;key : value&#125;</code> 这种结构，当然 key 就是我们的 path ，而 value 则是此路由的配置项。分析完毕，开始敲代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @path: src/hello-vue-router/index.js</span><br><span class="hljs-comment"> * @Description: 入口文件 VueRouter类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">import</span> &#123; install &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./install&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; createMatcher &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./create-matcher&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; HashHistory &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./history/hash&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; HTML5History &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./history/html5&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; AbstractHistory &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./history/abstract&quot;</span>;<br><span class="hljs-keyword">const</span> inBrowser = <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">window</span> !== <span class="hljs-string">&quot;undefined&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VueRouter</span>()</span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">options</span>)</span> &#123;<br>    <span class="hljs-comment">// 路由配置</span><br>    <span class="hljs-built_in">this</span>.options = options;<br>    <span class="hljs-comment">// 创建路由matcher对象，传入routes路由配置列表及VueRouter实例，主要负责url匹配</span><br>    <span class="hljs-built_in">this</span>.matcher = createMatcher(options.routes);<br><br>    <span class="hljs-keyword">let</span> mode = options.mode || <span class="hljs-string">&quot;hash&quot;</span>;<br><br>    <span class="hljs-comment">// 支持所有 JavaScript 运行环境，非浏览器环境强制使用abstract模式，主要用于SSR</span><br>    <span class="hljs-keyword">if</span> (!inBrowser) &#123;<br>      mode = <span class="hljs-string">&quot;abstract&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">this</span>.mode = mode;<br><br>    <span class="hljs-comment">// 根据不同mode，实例化不同history实例</span><br>    <span class="hljs-keyword">switch</span> (mode) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;history&quot;</span>:<br>        <span class="hljs-built_in">this</span>.history = <span class="hljs-keyword">new</span> HTML5History(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;hash&quot;</span>:<br>        <span class="hljs-built_in">this</span>.history = <span class="hljs-keyword">new</span> HashHistory(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;abstract&quot;</span>:<br>        <span class="hljs-built_in">this</span>.history = <span class="hljs-keyword">new</span> AbstractHistory(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">default</span>:<br>        <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">&quot;production&quot;</span>) &#123;<br>          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`[vue-router] invalid mode: <span class="hljs-subst">$&#123;mode&#125;</span>`</span>);<br>        &#125;<br>    &#125;<br>  &#125;<br>&#125;<br>VueRouter.install = install;<br></code></pre></td></tr></table></figure><p>其实 VueRouter 这个类的 constructor 里的逻辑很简单，就是判断传入的 mode 模式随后初始化不同类实例，虽然实例化的是不同的类，但实例方法包括属性等都是一样的</p><p>完整的 VueRouter 有三种模式：</p><ul><li>hash 基本浏览器都支持，但是URL有 # 号，不好看</li><li>history URL好看，但是部分老版本浏览器不支持</li><li>abstract 支持所有环境，主要用于服务端 SSR</li></ul><p>我们不太清楚的可能是 abstract 模式了，其实在官方中把这种模式定义为支持任何环境的模式，因为这种模式是手动模拟一个路由环境，而源码中也有一个和上面一样的逻辑判断（<code>inBrowser</code>），就是在当前环境没有 window 对象也就是非浏览器环境情况下，直接强制切换为此模式，所以这种模式也主要用于 SSR，后面有精力就实现一下，相当简单。</p><p>整个 constructor 其实没有复杂逻辑。先判断当前环境有无 window 对象也就是否是浏览器环境，是的话继续走，不是则强制 mode 值为 abstract；然后就是判断一下 mode 属性值，匹配三个模式分别使用对应类来初始化该路由模式实例，匹配不到直接抛出错误，这里不论是哪个模式，在对应的类中我们都会实现一些相同的方法，并且将初始化的实例挂载到了 VueRouter 实例的 hisory 属性上。</p><p>其实在做 mode 参数校验前，还引入了一个 createMatcher 方法，这个方法的返回值挂载到了 VueRouter 实例的 matcher 属性上，它是做什么的呢？</p><p>你应该大致猜到了，上面也说过，大概就是构建 <code>&#123;key : value&#125;</code> 结构的对象（称之为 pathMap 对象）让我们更便捷的通过 path 路径匹配到对应路由模块。</p><p>那接下来我们就一步步推导下 createMatcher 这个方法是怎么封装的。</p><h2 id="createMatcher方法推导"><a href="#createMatcher方法推导" class="headerlink" title="createMatcher方法推导"></a>createMatcher方法推导</h2><p>你以为 createMatcher 这个方法只是单纯的构建一个 pathMap 映射对象？No，那样的话函数名应该叫 createRouterMap 才对，其实最开始确实是这个名字，但是一套推导下来发现它不仅可以构建出 pathMap 映射对象， <code>addRoutes/addRoute/getRoutes</code> 这几个方法也可以在这里实现。</p><p>构建出 pathMap 映射对象是做什么的？路由匹配啊！输入 path 的时候能够获取到对应的路由配置信息，pathMap 对象就相当于一个路由数据管家，写入的所有路由配置都在这里了，那动态添加路由的时候把新路由对象解析并添加到 pathMap 对象里就可以了，所以我们把路由匹配及动态路由添加的几个方法全放一块合成了 createMatcher 函数，我们叫它 <code>路由匹配器函数</code> 吧，主要作用就是生成一个路由匹配器对象，这个函数就返回了一个包含四个方法属性的对象：</p><ul><li>macth 路由匹配</li><li>addRoutes 动态添加路由（参数必须是一个符合 <code>routes</code> 选项要求的数组）</li><li>addRoute 动态添加路由（添加一条新路由规则）</li><li>getRoutes 获取所有活跃的路由记录列表</li></ul><h3 id="createRouteMap生成路由映射"><a href="#createRouteMap生成路由映射" class="headerlink" title="createRouteMap生成路由映射"></a>createRouteMap生成路由映射</h3><p>首先我们要构建 pathMap 对象，单独拉出来一个文件写这个方法，在 <code>src/hello-vue-router/</code> 目录下新建一个 <code>create-route-map.js</code> 文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @path: src/hello-vue-router/create-route-map.js</span><br><span class="hljs-comment"> * @Description: 生成路由映射</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">// 生成路由映射</span><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createRouteMap</span>(<span class="hljs-params">routes</span>)</span>&#123;<br>  <span class="hljs-keyword">let</span> routeMap = &#123;&#125;<br>  routes.forEach(<span class="hljs-function"><span class="hljs-params">route</span> =&gt;</span> &#123;<br>    routeMap[route.path] = route<br>  &#125;)<br>  <span class="hljs-keyword">return</span> routeMap<br>&#125;<br></code></pre></td></tr></table></figure><p>如上，几行代码就生成了一个 pathMap 路由映射对象，有问题吗？没有问题，但我们上面只匹配了一层，路由配置里面可以有无限层子路由，比如下面这样的配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> routes = [<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/about&quot;</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;About&quot;</span>,<br>    component,<br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/parent&quot;</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Parent&quot;</span>,<br>    component,<br>    <span class="hljs-attr">children</span>:[<br>      &#123;<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;child&quot;</span>,<br>        <span class="hljs-attr">name</span>:<span class="hljs-string">&quot;Child&quot;</span>,<br>        component<br>      &#125;<br>    ]<br>  &#125;<br>];<br></code></pre></td></tr></table></figure><p>我们想要生成的 pathMap 对象是什么，是下面这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-string">&quot;/about&quot;</span>: &#123;...&#125;,<br>  <span class="hljs-string">&quot;/parent&quot;</span>: &#123;...&#125;,<br>  <span class="hljs-string">&quot;/parent/child&quot;</span>: &#123;...&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可是现在的代码逻辑只生成了下面这种：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-string">&quot;/about&quot;</span>: &#123;...&#125;,<br>  <span class="hljs-string">&quot;/parent&quot;</span>: &#123;...&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>有问题吗？有大问题，一层路由是 ok 的，多层级的嵌套路由直接 gameover。所以要递归处理解析，修改一下代码，还是老套路，先看完整代码再逐步解析。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createRouteMap</span>(<span class="hljs-params">routes</span>)</span>&#123;<br>  <span class="hljs-keyword">const</span> pathMap = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>);<br>  <span class="hljs-comment">// 递归处理路由记录，最终生成路由映射</span><br>  routes.forEach(<span class="hljs-function"><span class="hljs-params">route</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// 生成一个RouteRecord并更新pathMap</span><br>    addRouteRecord(pathMap, route, <span class="hljs-literal">null</span>)<br>  &#125;)<br>  <span class="hljs-keyword">return</span> pathMap<br>&#125;<br><br><span class="hljs-comment">// 添加路由记录</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addRouteRecord</span>(<span class="hljs-params">pathMap, route, parent</span>)</span>&#123;<br>  <span class="hljs-keyword">const</span> &#123; path, name &#125; = route<br><br>  <span class="hljs-comment">// 生成格式化后的path(子路由会拼接上父路由的path)</span><br>  <span class="hljs-keyword">const</span> normalizedPath = normalizePath(path, parent)<br><br>  <span class="hljs-comment">// 生成一条路由记录</span><br>  <span class="hljs-keyword">const</span> record = &#123;<br>    <span class="hljs-attr">path</span>: normalizedPath, <span class="hljs-comment">// 规范化后的路径</span><br>    <span class="hljs-attr">regex</span>: <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-comment">// 利用path-to-regexp包生成用来匹配path的增强正则对象，用来匹配动态路由 （/a/:b）</span><br>    <span class="hljs-attr">components</span>: route.component, <span class="hljs-comment">// 保存路由组件，省略了命名视图解析</span><br>    name,<br>    parent, <span class="hljs-comment">// 父路由记录</span><br>    <span class="hljs-attr">redirect</span>: route.redirect, <span class="hljs-comment">// 重定向的路由配置对象</span><br>    <span class="hljs-attr">beforeEnter</span>: route.beforeEnter, <span class="hljs-comment">// 路由独享的守卫</span><br>    <span class="hljs-attr">meta</span>: route.meta || &#123;&#125;, <span class="hljs-comment">// 元信息</span><br>    <span class="hljs-attr">props</span>: route.props == <span class="hljs-literal">null</span> ? &#123;&#125; : route.props<span class="hljs-comment">// 动态路由传参</span><br>  &#125;<br><br>  <span class="hljs-comment">// 处理有子路由情况，递归</span><br>  <span class="hljs-keyword">if</span> (route.children) &#123;<br>    <span class="hljs-comment">// 遍历生成子路由记录</span><br>    route.children.forEach(<span class="hljs-function"><span class="hljs-params">child</span> =&gt;</span> &#123;<br>      addRouteRecord(pathMap, child, record)<br>    &#125;)<br>  &#125;<br><br>  <span class="hljs-comment">// 若pathMap中不存在当前路径，则添加pathList和pathMap</span><br>  <span class="hljs-keyword">if</span> (!pathMap[record.path]) &#123;<br>    pathMap[record.path] = record<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 规格化路径</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">normalizePath</span>(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function">  path,</span></span><br><span class="hljs-params"><span class="hljs-function">  parent</span></span><br><span class="hljs-params"><span class="hljs-function"></span>) </span>&#123;<br>  <span class="hljs-comment">// 下标0为 / ，则是最外层path</span><br>  <span class="hljs-keyword">if</span> (path[<span class="hljs-number">0</span>] === <span class="hljs-string">&#x27;/&#x27;</span>) <span class="hljs-keyword">return</span> path<br>  <span class="hljs-comment">// 无父级，则是最外层path</span><br>  <span class="hljs-keyword">if</span> (!parent) <span class="hljs-keyword">return</span> path<br>  <span class="hljs-comment">// 清除path中双斜杆中的一个</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;parent.path&#125;</span>/<span class="hljs-subst">$&#123;path&#125;</span>`</span>.replace(<span class="hljs-regexp">/\/\//g</span>, <span class="hljs-string">&#x27;/&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>其实这块代码比较简单，也都带上了注释，简单说几个点吧。</p><p>我们在递归中其实把每一个路由配置对象都格式化了一下，生成了一个新的 record 对象，该对象的的 path 其实是完整 path，也就是如果原 path 是以 <code>/</code> 开头，说明自己是顶级路由，path 就是它本身，如果原 path 不是以 <code>/</code> 开头，说明它是子级路由，那我们就需要拼接上父级 path，为此我们单独写了一个 normalizePath 函数来生成完整 path，也就是将 path 规格化。</p><p>因为递归时传入了 parent ，除了顶级路由为 null 之外，子级路由都有父级，而我们子路由递归时是在 record 对象生成之后的，所以每个传入的父级都是格式化好的 record 对象，父级的 path 也是完整 path，这样不论多少子级，都可以拼出完整 path。</p><p>接着说 record 对象，我们还为其添加了一个 parent 属性指向它的父级对象，让父子之间有个联系，还有一些路由中可配置的参数像重定向 <code>redirect</code>、路由独享守卫 <code>beforeEnter</code>、元信息 <code>meta</code>、路由名称 <code>name</code> 这些我们也都接收并放到了 record 对象里。</p><p>单独说 <code>regex</code> 属性，相信大家都知道 VueRouter 里支持动态路由，其实主要是利用一个三方包 <code>path-to-regexp</code> 生成用来匹配path 的增强正则对象，用来匹配对应的动态路由，生成正则之后就放在 <code>regex</code> 属性里，这块对我们手写来说没有特别大的意义，所以我没写，直接置空了，如果有兴趣就直接看源码这里，主要还是 <code>path-to-regexp</code> 这个包的使用，也不复杂。另外最后的 <code>props</code> 属性是动态路由传参用的，暂不做这块可忽略。</p><p>最终一套下来，生成的 pathMap 对象就是 <code>[&#123;path: record&#125;...]</code> 这种格式了，key 是格式化后的完整 path，value是格式化好的路由配置对象 record。</p><p>到这里路由映射对象 pathMap 对象解析方法就差不多写完了。</p><h3 id="createMatcher生成路由匹配器"><a href="#createMatcher生成路由匹配器" class="headerlink" title="createMatcher生成路由匹配器"></a>createMatcher生成路由匹配器</h3><p>接着，我们在 <code>src/hello-vue-router/</code> 文件夹下创建一个 <code>create-matcher.js</code> 文件，按照我们上面分析大致结构如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @path: src/hello-vue-router/create-route-map.js</span><br><span class="hljs-comment"> * @Description: 路由匹配器Matcher对象生成方法</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">import</span> &#123; createRouteMap &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./create-route-map&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createMatcher</span>(<span class="hljs-params">routes</span>)</span>&#123;<br>  <span class="hljs-comment">// 生成路由映射对象 pathMap</span><br>  <span class="hljs-keyword">const</span> pathMap = createRouteMap(routes)<br><br>  <span class="hljs-comment">// 动态添加路由（添加一条新路由规则）</span><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addRoute</span>(<span class="hljs-params"></span>)</span>&#123; &#125;<br><br>  <span class="hljs-comment">// 动态添加路由（参数必须是一个符合 routes 选项要求的数组）</span><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addRoutes</span>(<span class="hljs-params"></span>)</span>&#123; &#125;<br><br>  <span class="hljs-comment">// 获取所有活跃的路由记录列表</span><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getRoutes</span>(<span class="hljs-params"></span>)</span>&#123; &#125;<br><br>  <span class="hljs-comment">// 路由匹配</span><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">match</span>(<span class="hljs-params"></span>)</span>&#123; &#125;<br><br>  <span class="hljs-keyword">return</span> &#123;<br>    match,<br>    addRoute,<br>    getRoutes,<br>    addRoutes<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>路由匹配器 Matcher 对象生成方法即 createMatcher ，我们只需要一个参数，那就是生成路由映射对象 pathMap 所需的 routes 数组（就是 router 配置文件里的那个 routes）。</p><p>其实路由映射对象 pathMap 只有在匹配路由和动态添加路由的时候可以用到，而这些情况都包含在 <code>createMatcher</code> 函数内，所以在 <code>createMatcher</code> 函数内部直接使用刚写好的 <code>createRouteMap</code> 方法生成了 pathMap 对象，在函数调用时，内部一直维护着这个对象，因为 <code>createMatcher</code> 函数返回的几个方法里都有对 pathMap 对象的引用，就是一个典型闭包场景，所以整个 VueRouter 实例初始化过程中 <code>createMatcher</code> 函数只需调用一次就 OK，<code>createRouteMap</code> 方法也抛出了动态修改 pathMap 的方法。</p><h4 id="addRoutes核心实现"><a href="#addRoutes核心实现" class="headerlink" title="addRoutes核心实现"></a>addRoutes核心实现</h4><p>先来看 <code>addRoutes</code> 实现吧，比较简单，这个 API 的定义其实就是用来动态添加路由的，简单点就是把传入的新路由对象解析后加入到老 pathMap 对象里，使用时参数必须是一个符合 routes 选项要求的数组，作用就是可以让我们随时随地的添加几个路由配置，因为参数是数组并且和 routes 是一致的格式，所以完全可以复用 <code>createRouteMap</code> 方法。</p><p>先把 <code>createRouteMap</code> 方法简单修改一下，只需要加一个参数就 ok ，逻辑没问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 新增 oldPathMap 参数</span><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createRouteMap</span>(<span class="hljs-params">routes, oldPathMap</span>)</span>&#123;<br>  <span class="hljs-comment">// const pathMap = Object.create(null); old</span><br>  <span class="hljs-keyword">const</span> pathMap = oldPathMap || <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>); <span class="hljs-comment">// new</span><br>  <br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如上，动态添加的时候，将旧的 pathMap 传进去即可，之前我们直接声明了一个空 pathMap 对象，这里可以判断一下 <code>oldPathMap</code> 参数是否存在，存在就给 pathMap 赋值，不存在默认还是空对象即可。这样就做到了把没有解析的配置，解析并添加到老映射对象里，是不是简单？ <code>addRoutes</code> 方法就更简单了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 动态添加路由（参数必须是一个符合 routes 选项要求的数组）</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addRoutes</span>(<span class="hljs-params">routes</span>)</span>&#123;<br>  createRouteMap(routes, pathMap)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="getRoutes核心实现"><a href="#getRoutes核心实现" class="headerlink" title="getRoutes核心实现"></a>getRoutes核心实现</h4><p>至于 <code>getRoutes</code> ，就更更简单了，直接返回 <code>pathMap</code> 对象即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 获取所有活跃的路由记录列表</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getRoutes</span>(<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-keyword">return</span> pathMap<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="addRoute核心实现"><a href="#addRoute核心实现" class="headerlink" title="addRoute核心实现"></a>addRoute核心实现</h4><p><code>addRoute</code> 这个方法我们要稍微注意一下，因为这个方法将是未来 4.0+ 版本动态添加路由的主流，3.0+版本的 <code>addRoute &amp; addRoutes</code> 两个方法并存，但 4.0+ 中看 <code>addRoutes</code> 方法已经被删除了，先看使用吧。</p><p><code>addRoute</code> 有两个参数，也是 2 种用法：</p><ul><li>添加一条新路由规则。如果该路由规则有 <code>name</code>，并且已经存在一个与之相同的名字，则会覆盖它。</li><li>添加一条新路由规则记录作为现有路由的子路由。如果该路由规则有 <code>name</code>，并且已经存在一个与之相同的名字，则会覆盖它。</li></ul><p>白话一下。第一种就是传入一个路由配置对象，注意，不是之前的 <code>routes</code> 数组了，是只有一个路由配置的对象，当然你可以在这个路由配置下写无数个子路由，但是添加的时候只能传入一个路由对象这种形式添加，一次只追加一条记录，如果当前的路由配置中存在 <code>name</code> 相同的记录，则会覆盖掉，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">this</span>.$router.addRoute(&#123;<br>  <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/parent&quot;</span>,<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Parent&quot;</span>,<br>  component,<br>  <span class="hljs-attr">children</span>:[<br>    &#123;<br>      <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;child&quot;</span><br>      <span class="hljs-comment">// ...</span><br>    &#125;,<br>    <span class="hljs-comment">// ...</span><br>  ]<br>&#125;)<br></code></pre></td></tr></table></figure><p>第二种就是两个参数，第一个参数为一个已经存在的路由 <code>name</code> ，第二个参数为一个路由配置对象，就和上那种使用方式的路由配置对象一致，只是，这种方式会把这个路由配置对象当作第一个参数 <code>name</code> 对应的路由对象的子路由追加进去，简单说就是根据路由 <code>name</code> 定向添加子路由，添加过程中有重复路由 <code>name</code> 也是覆盖掉。</p><p>看着复杂，写起来其实很简单，再为 <code>createRouteMap</code> 加一个 <code>parent</code> 参数即可。修改 <code>createRouteMap</code> 函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 新增 parentRoute 参数</span><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createRouteMap</span>(<span class="hljs-params">routes, oldPathMap, parentRoute</span>)</span>&#123;  <br>  <span class="hljs-keyword">const</span> pathMap = oldPathMap || <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>);<br><br>  routes.forEach(<span class="hljs-function"><span class="hljs-params">route</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// addRouteRecord(pathMap, route, null) old</span><br>    addRouteRecord(pathMap, route, parentRoute) <span class="hljs-comment">// new</span><br>  &#125;)<br>  <span class="hljs-keyword">return</span> pathMap<br>&#125;<br></code></pre></td></tr></table></figure><p>如上所示，第三个参数代表父级路由，需要追加到一条记录上时，只需拿到这个父级路由传入即可，没有第三个参数时默认为 <code>undefined</code> 也不会影响下面逻辑。</p><p>接下来写 <code>addRoute</code> 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 动态添加路由（添加一条新路由规则）</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addRoute</span>(<span class="hljs-params">parentOrRoute, route</span>)</span>&#123;<br>  <span class="hljs-keyword">const</span> parent = (<span class="hljs-keyword">typeof</span> parentOrRoute !== <span class="hljs-string">&#x27;object&#x27;</span>) ? pathMap[parentOrRoute] : <span class="hljs-literal">undefined</span><br>  createRouteMap([route || parentOrRoute], pathMap, parent)<br>&#125;<br></code></pre></td></tr></table></figure><p>如上，<code>addRoute</code> 方法第一个参数有可能是个字符串，也可能是个路由对象，而 <code>createRouteMap</code> 方法第一个参数是路由数组，所以我们调用时直接数组包裹，默认是第二个参数，第二个参数不存在拿第一个参数就是路由对象，然后传入旧的 pathMap 对象，最后的 parent 我们需要在函数开始就判断一下。</p><p>当第一个参数不是一个对象时，也就是输入的是一个路由 <code>name</code> 字符串，我们这里稍微改动一下，用路由 <code>path</code> 代替（明白意思就行），直接通过之前解析好的 pathMap 对象取出规格化路由赋值给 parent，如果是一个对象，那就肯定只有一个参数了，直接给 parent 赋值为 undefined，完美。</p><blockquote><p>解释下为什么不像官方那样用路由 <code>name</code> 匹配，源码中除了 pathMap 对象，还解析了一个 namePath 对象，我们写的是一个简化版，这些类似的东西包括对路由名称、路由别名、重定向参数、动态路由的处理我都省略了，做一个路由 path 的处理大家理解即可，其他处理大多一致，都很简单，不过瘾可以配合我打上注释的源码自行补全，整体架构都一致，无非是多加一些代码。</p></blockquote><h4 id="match路由匹配核心实现"><a href="#match路由匹配核心实现" class="headerlink" title="match路由匹配核心实现"></a>match路由匹配核心实现</h4><p>最后是路由匹配函数 <code>match</code> 方法，也很简单：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 路由匹配</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">match</span>(<span class="hljs-params">location</span>)</span>&#123;<br>  location = <span class="hljs-keyword">typeof</span> location === <span class="hljs-string">&#x27;string&#x27;</span> ? &#123; <span class="hljs-attr">path</span>: location &#125; : location<br>  <span class="hljs-keyword">return</span> pathMap[location.path]<br>&#125;<br></code></pre></td></tr></table></figure><p><code>match</code> 方法我们给它一个参数，这个参数可以是字符串，也可以是个必须带有 path 属性的对象，因为必须要使用 path 才能匹配到配置的路由模块数据，使用如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// String | Object</span><br><br>match(<span class="hljs-string">&quot;/home&quot;</span>)<br>match(&#123;<span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/home&quot;</span>&#125;)<br></code></pre></td></tr></table></figure><p>在函数最开始校验了一下参数类型并统一转为对象，随后直接返回了 pathMap 的 path 映射，是不是很简单？别着急，这块后续还要优化。</p><h3 id="createMatcher的使用及实例方法挂载"><a href="#createMatcher的使用及实例方法挂载" class="headerlink" title="createMatcher的使用及实例方法挂载"></a>createMatcher的使用及实例方法挂载</h3><p>回顾一下我们在 <code>createMatcher</code> 方法中做了哪些事情，其实主要是生成了一个路由映射对象 <code>pathMap</code>，返回了四个函数：</p><ul><li>addRoutes</li><li>getRoutes</li><li>addRoute</li><li>match</li></ul><p>对于这几个方法，其实最后都要挂载在 VueRouter 实例上，因为使用时是 <code>this.$router.addRoute()</code> 这种方式，这里只是核心实现，后续还要在实例挂载，其中  <code>match</code> 方法后续还有优化。</p><p>所以，来看看 <code>createMatcher</code> 函数的使用和这几个实例方法的挂载，再次回到 VueRouter 类这里：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VueRouter</span>()</span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">options</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.options = options;<br>    <span class="hljs-comment">// 创建路由matcher对象，传入routes路由配置列表及VueRouter实例，主要负责url匹配</span><br>    <span class="hljs-built_in">this</span>.matcher = createMatcher(options.routes);<br>    <br>    <span class="hljs-comment">// ...</span><br>  &#125;<br>  <br>  <span class="hljs-comment">// 匹配路由</span><br>  <span class="hljs-function"><span class="hljs-title">match</span>(<span class="hljs-params">location</span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.matcher.match(location)<br>  &#125;<br>  <br>  <span class="hljs-comment">// 获取所有活跃的路由记录列表</span><br>  <span class="hljs-function"><span class="hljs-title">getRoutes</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.matcher.getRoutes()<br>  &#125;<br>  <br>  <span class="hljs-comment">// 动态添加路由（添加一条新路由规则）</span><br>  <span class="hljs-function"><span class="hljs-title">addRoute</span>(<span class="hljs-params">parentOrRoute, route</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.matcher.addRoute(parentOrRoute, route)<br>  &#125;<br>  <br>  <span class="hljs-comment">// 动态添加路由（参数必须是一个符合 routes 选项要求的数组）</span><br>  <span class="hljs-function"><span class="hljs-title">addRoutes</span>(<span class="hljs-params">routes</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.matcher.addRoutes(routes)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上，我们直接在 VueRouter 类的 constructor 里调用了 <code>createMatcher</code> 函数，并将其返回值挂载到了实例的 matcher 属性上，其实这个对象就包含那四个方法，接着挂载这几个方法到实例上，不赘述了。</p><p>现在 VueRouter 实例上就有这些方法了，而 <code>this.$router</code> 在 install 中做了代理到 VueRouter 实例的操作，所以就可以使用这些方法了。</p><h2 id="路由模式父类History实现"><a href="#路由模式父类History实现" class="headerlink" title="路由模式父类History实现"></a>路由模式父类History实现</h2><p>路由匹配器实现告一段落，还记得在 VueRouter 类 constructor 中除了路由匹配器，还有什么吗？没错，校验了传入的 mode 参数，并且通过判断分别为三种模式创建了一个类并实例化后统一挂载到了 VueRouter 实例的 history 属性上。</p><p>那下面我们就逐一实现这几个类，分别是 <code>HTML5History | HashHistory | AbstractHistory</code>。首先在 <code>src/hello-vue-router/</code> 文件夹下新建 <code>history/</code> 的文件夹，在这此文件夹下新建三个文件，对应三种模式构建类：</p><ul><li>hash.js</li><li>html5.js</li><li>abstract.js</li></ul><p>接下来先给三个路由模式类定义一个父类。</p><p>思考：为什么要定义父类？</p><p>其实在初始化实例上 <code>this.history</code> 挂载的一些方法都是一致的，虽然实现方式上几种模式可能不太一致，但不能给用户增加负担，所以使用要统一，为了节省代码以及统一，我们可以定义一个父类，让三个子类都继承这个父类。</p><p>So，在刚刚新建子类的 <code>history/</code> 文件夹下，新建一个 <code>base.js</code> 文件并导出一个 History 类：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @path: src/hello-vue-router/history/base.js</span><br><span class="hljs-comment"> * @Description: 路由模式父类</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">History</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">router</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.router = router;<br>    <span class="hljs-comment">// 当前路由route对象</span><br>    <span class="hljs-built_in">this</span>.current = &#123;&#125;;<br>    <span class="hljs-comment">// 路由监听器数组，存放路由监听销毁方法</span><br>    <span class="hljs-built_in">this</span>.listeners = [];<br>  &#125;<br>  <br>  <span class="hljs-comment">// 启动路由监听</span><br>  <span class="hljs-function"><span class="hljs-title">setupListeners</span>(<span class="hljs-params"></span>)</span> &#123; &#125;<br><br>  <span class="hljs-comment">// 路由跳转</span><br>  <span class="hljs-function"><span class="hljs-title">transitionTo</span>(<span class="hljs-params">location</span>)</span> &#123; &#125;<br><br>  <span class="hljs-comment">// 卸载</span><br>  <span class="hljs-function"><span class="hljs-title">teardown</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.listeners.forEach(<span class="hljs-function">(<span class="hljs-params">cleanupListener</span>) =&gt;</span> &#123;<br>      cleanupListener();<br>    &#125;);<br><br>    <span class="hljs-built_in">this</span>.listeners = [];<br>    <span class="hljs-built_in">this</span>.current = <span class="hljs-string">&quot;&quot;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上，History 类 constructor 中主要做了三件事：</p><ul><li>保存传入的路由实例 router</li><li>声明了一个当前路由对象 current</li><li>声明了一个路由监听器数组，存放路由监听销毁方法</li></ul><p>然后写了几个公共方法：</p><ul><li>setupListeners 启动路由监听的方法</li><li>transitionTo 路由跳转的方法</li><li>teardown 卸载 VueRouter 实例时卸载路由模式类中的监听并清空数据方法</li></ul><blockquote><p>暂时写了这 3 个方法，其实 <code>setupListeners</code> 方法这里只是声明一下，主要逻辑还会在子类中复写， 然后这里只把 <code>teardown</code> 这个卸载的方法完善了，<code>transitionTo</code> 这个路由跳转方法以及后面实现子类过程中需要添加的一些公共方法后续慢慢完善</p></blockquote><p>先看这个销毁方法，思考为什么要销毁？</p><p>其实不论是 hash 或 history 这两种模式在实现过程中肯定都会写一些监听，而当 VueRouter 实例卸载的时候，这些监听并不会被销毁，就会造成内存泄漏，所以我们手动写一个卸载销毁，代码十分简单</p><p>首先是维护了一个公共的路由监听器数组 <code>listeners</code> ，将来在子类中每写一个监听事件，直接就写一个卸载监听方法 <code>push</code> 到这个数组中来，当监听到 VueRouter 卸载时，手动调用卸载方法，方法里就是循环调用一下 <code>listeners</code> 数组中的方法从而销毁监听，可以看到卸载方法的最后把 <code>listeners</code> 数组以及当前路由对象 <code>current</code> 都清空了。</p><p>保存的 router 实例对象后面会用到，可能大家不了解的应该是 <code>current</code> 这个对象吧，接下来着重介绍。</p><p><strong>思考：我们怎么获取当前的路由对象？</strong></p><p>答：<code>$route</code></p><p><strong>思考：路由对象应该在哪里维护？有什么作用？</strong></p><p>先回顾下使用 <code>$route</code> 时，它都有什么属性？</p><p>其实它保存着当前路由的 <code>path、hash、meta、query、params</code> 等等一切与当前路由有关的东西其实都在这里存着，并且官方定义这个路由对象是只读的</p><p>而 <code>current</code> ，就是当前的意思，它其实就是这个路由对象，每当我们监听到路由 path 改变时，就要同步去修改这个路由对象，而当路由对象改变，<code>router-view</code> 组件需要渲染的视图也要改变，可以说这个路由对象就是整个 VueRouter 的中枢。</p><p>可能大家要问，刚刚不是说过这个对象是只读的吗？怎么还会改变？其实路由对象本身是被冻结的，我们只读的是对象中的属性，但是我们可以切换整个路由对象啊！</p><p>上面我们为 <code>current</code> 这个路由对象定义的初始值是空对象，其实因为路由对象是一个面向用户、具有固定格式的对象，所以应该由一个统一的方法来创建这个固定格式的路由对象，此方法我们叫它 <code>createRoute</code>。</p><h2 id="createRoute方法"><a href="#createRoute方法" class="headerlink" title="createRoute方法"></a>createRoute方法</h2><p>还是单拿出来一个文件来实现这样一个方法。</p><p>在 <code>src/hello-vue-router/</code> 目录下新建一个 <code>utils/</code> 文件夹，在该文件夹下新建一个 <code>route.js</code> 文件，实现并导出一个 <code>createRoute</code> 方法。</p><p>先新建好文件，说 <code>createRoute</code> 方法之前，我们思考一下什么时候需要创建这个路由对象？</p><p>首先当然是我们的 <code>current</code> 属性初始化的时候需要创建一个空的路由对象，除此之外呢？</p><p>捋一下，要让 path 路径改变，有两种方式，一是直接改 URL，二是用 <code>push</code> 方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// No.1 oldURL =&gt; newURL</span><br><span class="hljs-keyword">let</span> oldURL = <span class="hljs-string">&quot;http://localhost:8081/#/about&quot;</span><br><span class="hljs-keyword">let</span> newURL = <span class="hljs-string">&quot;http://localhost:8081/#/home?a=1&quot;</span><br><br><span class="hljs-comment">// No.2</span><br><span class="hljs-built_in">this</span>.$router.push(&#123;<br>  <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/home&quot;</span>,<br>  <span class="hljs-attr">query</span>: &#123;<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>&#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>可以看到，在改变路由时，可附带很多属性，就像官方文档中 <code>push</code> 方法支持的属性就有下面这些，具体作用看文档：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">name<br>path<br>hash<br>query<br>params<br>append<br>replace<br></code></pre></td></tr></table></figure><p>路径改变，要去往一个新的 path，新的 path 加上这些可以携带的属性我们称之为 目标信息对象。而当前路由对象 route 要包含当前路由的所有信息，path 匹配的路由配置对象+目标信息信息对象=所有信息，所有信息格式化后就是当前路由对象 route。</p><p>所以更新当前路由对象就需要先通过 path 匹配到路由配置对象，然后路由配置对象和目标信息信息对象合并格式化为 route。在哪里做这样一个更新操作呢？</p><p>回顾下之前我们写的 <code>createMatcher</code> 函数，其中返回了一个 match 方法，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 路由匹配</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">match</span>(<span class="hljs-params">location</span>)</span>&#123;<br>  location = <span class="hljs-keyword">typeof</span> location === <span class="hljs-string">&#x27;string&#x27;</span> ? &#123; <span class="hljs-attr">path</span>: location &#125; : location<br>  <span class="hljs-keyword">return</span> pathMap[location.path]<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们当时返回的是路由配置对象，其实我们的最终目的就是让其匹配到当前路由对象，我们也分析了当前路由对象=路由配置对象+目标信息对象，所以直接匹配到路由对象的话就是最完整的数据，现在改写这个方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @path: src/hello-vue-router/create-route-map.js</span><br><span class="hljs-comment"> * @Description: 路由匹配器Matcher对象生成方法</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">import</span> &#123; createRouteMap &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./create-route-map&quot;</span>;<br><span class="hljs-comment">// 导入route对象创建方法</span><br><span class="hljs-keyword">import</span> &#123; createRoute &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./utils/route&quot;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createMatcher</span>(<span class="hljs-params">routes</span>)</span>&#123;<br>  <span class="hljs-keyword">const</span> pathMap = createRouteMap(routes)<br>  <br>  <span class="hljs-comment">// 路由匹配</span><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">match</span>(<span class="hljs-params">location</span>)</span>&#123;<br>    location = <span class="hljs-keyword">typeof</span> location === <span class="hljs-string">&#x27;string&#x27;</span> ? &#123; <span class="hljs-attr">path</span>: location &#125; : location<br>    <span class="hljs-keyword">return</span> createRoute(pathMap[location.path], location) <span class="hljs-comment">// 修改</span><br>  &#125;<br>  <br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如上，在 <code>createMatcher</code> 函数返回的 <code>match</code> 方法中，直接创建一个新路由对象返回。分析到这里我们就可以确定 <code>createRoute</code> 函数的参数了，就如同上面 <code>createRoute</code> 方法里有 2 个参数，第一个就是路由匹配对象 record，第二个就是目标信息对象 location（这也是为什么我们给 match 方法的参数起名为 location 并允许它有对象和字符串两种格式的原因）。</p><p>我们经常使用的 <code>push</code> 方法其实其中的参数就是 location 对象，既可以是字符串路径，也可以是对象，为对象时可传入的属性就和上面 push 方法可配置的那些属性是一致的</p><p>不过上面写的属性中 <code>append、replace</code> 是两个是附加功能，需要额外解析， <code>push</code> 方法支持，<code>router-link</code> 组件同样支持，作用看下面文档，我们暂时省略这两个参数的解析，因为不是核心逻辑。</p><ul><li><a href="https://router.vuejs.org/zh/api/#append">append属性文档</a> </li><li><a href="https://router.vuejs.org/zh/api/#replace">replace属性文档</a> </li></ul><p>分析准备就绪，可以开始实现 <code>createRoute</code> 方法了，老规矩，先看整体代码，再逐步分析：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @path: src/hello-vue-router/utils/route.js</span><br><span class="hljs-comment"> * @Description: route对象相关方法</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createRoute</span>(<span class="hljs-params">record, location</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> route = &#123;<br>    <span class="hljs-attr">name</span>: location.name || (record &amp;&amp; record.name),<br>    <span class="hljs-attr">meta</span>: (record &amp;&amp; record.meta) || &#123;&#125;,<br>    <span class="hljs-attr">path</span>: location.path || <span class="hljs-string">&quot;/&quot;</span>,<br>    <span class="hljs-attr">hash</span>: location.hash || <span class="hljs-string">&quot;&quot;</span>,<br>    <span class="hljs-attr">query</span>: location.query || &#123;&#125;,<br>    <span class="hljs-attr">params</span>: location.params || &#123;&#125;,<br>    <span class="hljs-attr">fullPath</span>: location.path || <span class="hljs-string">&quot;/&quot;</span>,<br>    <span class="hljs-attr">matched</span>: record &amp;&amp; formatMatch(record),<br>  &#125;;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.freeze(route);<br>&#125;<br><br><span class="hljs-comment">// 初始状态的起始路由</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> START = createRoute(<span class="hljs-literal">null</span>, &#123;<br>  <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span><br>&#125;)<br><br><span class="hljs-comment">// 关联所有路由记录</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">formatMatch</span>(<span class="hljs-params">record</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> res = []<br>  <span class="hljs-keyword">while</span> (record) &#123;<br>    <span class="hljs-comment">// 队列头添加，所以父record永远在前面，当前record永远在最后</span><br>    <span class="hljs-comment">// 在router-view组件中获取匹配的route record时会用到</span><br>    <span class="hljs-comment">// 精准匹配到路由记录是数组最后一个</span><br>    res.unshift(record)<br>    record = record.parent<br>  &#125;<br>  <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><p>如上，<code>createRoute</code> 方法里通过两个参数互相取一些值来构建 route 对象。这里需要注意的有两个地方，<code>fullPath</code> 参数其实是一个 path+qs+hash 的完整路径，但是这里我们只写了path，先不考虑参数的问题。</p><p>还有 <code>matched</code> 这个属性，我们直接写了一个 <code>formatMatch</code> 函数生成，函数中只做了一件事，拿到当前 path 关联的所有路由配置对象。</p><p>函数行参 <code>record</code> 就是路由配置对象，生成路由配置对象的时候，我们为其添加了 parent 属性，指向其父路由，不记得就回顾一下 <code>createRouteMap</code> 方法。 <code>formatMatch</code> 函数里就是递归找当前路径包括它的父级路由配置对象，组成一个数组即 <code>matched</code> 参数，举个例子，如下这个路由配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> routes = [<br>   &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/parent&quot;</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Parent&quot;</span>,<br>    component,<br>    <span class="hljs-attr">children</span>:[<br>      &#123;<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;child&quot;</span>,<br>        <span class="hljs-attr">name</span>:<span class="hljs-string">&quot;Child&quot;</span>,<br>        component,<br>      &#125;<br>    ]<br>  &#125;<br>]<br></code></pre></td></tr></table></figure><p>那么此路由配置解析成 pathMap 如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">pathMap = &#123;<br>  <span class="hljs-string">&quot;/parent&quot;</span>: &#123;<span class="hljs-attr">path</span>:<span class="hljs-string">&quot;/parent&quot;</span>, ...&#125;,<br>  <span class="hljs-string">&quot;/parent/child&quot;</span>: &#123;<span class="hljs-attr">path</span>:<span class="hljs-string">&quot;/parent/child&quot;</span>, ...&#125;,<br>&#125;<br></code></pre></td></tr></table></figure><p>假如要跳转的新 path 是 <code>/parent/child</code>，生成 route 时，经过 <code>formatMatch</code> 方法关联它的所有路由记录，最终该路由对象的 <code>matched</code> 属性就是下面这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">[<br>  &#123;<span class="hljs-attr">path</span>:<span class="hljs-string">&quot;/parent&quot;</span>, component, parent ...&#125;,<br>  &#123;<span class="hljs-attr">path</span>:<span class="hljs-string">&quot;/parent/child&quot;</span>, component, parent ...&#125;<br>]<br></code></pre></td></tr></table></figure><p>注意，因为 <code>formatMatch</code> 函数递归查找父级时，我们使用的是 <code>unshift</code> 方法，所以最终的数组最后一项一定是当前 path 的模块。</p><p>这里其实是为嵌套路由做准备，因为当存在嵌套路由，子路由记录被匹配到时，其实代表着父路由记录也一定被匹配到了。例如匹配 /foo/bar， 当 /foo/bar 本身被匹配了，其父路由对象 /foo 肯定也匹配了，最终匹配结果如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">metched = [&#123;<span class="hljs-attr">path</span>:<span class="hljs-string">&quot;/foo&quot;</span>, ...&#125;,&#123;<span class="hljs-attr">path</span>:<span class="hljs-string">&quot;/foo/bar&quot;</span>&#125;] <br><span class="hljs-comment">// “/foo/bar” 本身匹配模块在数组最后，而第一项是顶级路由匹配项</span><br></code></pre></td></tr></table></figure><p>总结来说，路由对象的 <code>matched</code> 属性是一个数组，数组项是匹配到的路由配置对象，数组项顺序依次是顶级路由匹配对象到当前子级路由本身匹配对象，到此一个简单的路由生成函数就 OK 了。</p><p>思路切回 History 类，<code>current</code> 对象我们还没为其赋初始路由值呢，所以，我们在 <code>route.js</code> 文件中还写了一个初始化路由对象并导出，调用了一下 <code>createRoute</code> 方法，参数一置空，参数二只写一个 path 属性值为 <code>&quot;/&quot;</code> 的对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 初始状态的起始路由</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> START = createRoute(<span class="hljs-literal">null</span>, &#123;<br>  <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>最后修改一下 <code>base.js</code> 文件中的 History 类，将路由对象初始值 <code>START</code> 导入并赋值给 <code>current</code> ：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 导入初始化route对象</span><br><span class="hljs-keyword">import</span> &#123; START &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../utils/route&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">History</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">router</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.router = router;<br>    <br>    <span class="hljs-comment">// 当前路由route对象</span><br>    <span class="hljs-comment">//     this.current = &#123;&#125;;</span><br>    <span class="hljs-comment">// =&gt;  this.current = START;</span><br>    <span class="hljs-built_in">this</span>.current = START;<br>    <br>    <span class="hljs-built_in">this</span>.listeners = [];<br>  &#125;<br>  <br> <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>到这里，父类中的 <code>transitionTo</code> 即路由跳转方法就可以继续补充了，调用路由跳转方法就会传入一个目标信息对象，这时应该做什么？</p><ul><li><p>更新路由对象 <code>current</code> </p></li><li><p>更新 URL</p></li><li><p>更新视图</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 路由跳转</span><br><span class="hljs-function"><span class="hljs-title">transitionTo</span>(<span class="hljs-params">location, onComplete</span>)</span> &#123;<br>  <span class="hljs-comment">// 路由匹配，解析location匹配到其路由对应的数据对象</span><br>  <span class="hljs-keyword">let</span> route = <span class="hljs-built_in">this</span>.router.match(location);<br><br>  <span class="hljs-comment">// 更新current</span><br>  <span class="hljs-built_in">this</span>.current = route;<br><br>  <span class="hljs-comment">// 更新URL</span><br>  <span class="hljs-built_in">this</span>.ensureURL()<br><br>  <span class="hljs-comment">// 跳转成功抛出回调</span><br>  onComplete &amp;&amp; onComplete(route)<br>&#125;<br></code></pre></td></tr></table></figure><p>如上，路由跳转方法 <code>transitionTo</code> 其实传入的就是 location 对象，<code>push</code> 方法也是基于此方法实现的。</p><p>那新的目标信息对象来了，我们首先就要构建一个新的路由对象，History 是一个父类，后面我们还会写子类，子类继承父类，子类在初始化实例的时候（index.js文件 mode 参数判断那块）其实传入了当前 VueRouter 实例，所以我们父类也可以接收到，也就是我们父类 constructor 中的 <code>router</code> 参数，我们将它直接挂在了父类实例属性 <code>router</code> 上，这样我们就可以通过 <code>this.router</code> 获取到 VueRouter 实例。</p><p>VueRouter 实例上我们挂载了 match 方法还记得吗？不记得回顾下代码。</p><p>我们使用 <code>this.router.match</code> 方法，传入 location 参数，就可以生成一个新的路由对象，最后将新的路由对象赋值给 <code>current</code> 属性。</p><p>OK，按照我们的逻辑，路由改变生成新的路由对象并赋值给 <code>current</code> 就完成了，还剩下更新URL以及更新视图。</p><p><strong>思考：为什么更新URL？</strong></p><p>其实直接修改 URL 来跳转，并不需要更新 URL，但如果使用 API 来做路由跳转，例如 <code>push</code> 方法，我们在代码中可以控制更新路由对象 <code>current</code> ，也可以更新视图，但是 URL 并没有改变，所以我们还需要更新 URL。</p><p>那么问题来了，怎么更新 URL？</p><p>可以看到上面代码中我们调用了 <code>ensureURL</code> 方法来更新，而且是 <code>this</code> 调用的，其实这个方法并不在父类上，而在子类。</p><p>为什么将 <code>ensureURL</code> 方法写在子类？</p><p>因为我们存在 3 种模式，不同模式替换 URL 的方式是不同的，所以各个子类上写自己的 URL 更新方法最好了。</p><p>为什么这里可以调用子类方法？</p><p>因为初始化实例的是子类，子类又继承父类，可以理解为父类的方法以及属性都被子类继承了，<code>transitionTo</code> 方法当然也被继承了，那在调用这个跳转方法时，内部的 <code>this</code> 指向就是子类，所以可直接调用子类方法。</p><p>至于视图更新，因为目前还没有完善 <code>router-view</code> 组件，子类也没写好，所以我们放到后面完善。</p><p>最后抛出跳转成功的回调，并传入当前 route 对象参数。</p><h2 id="路由模式子类初步构建"><a href="#路由模式子类初步构建" class="headerlink" title="路由模式子类初步构建"></a>路由模式子类初步构建</h2><p>我们先把三种模式子类初步构建一下，其实就是在三个文件中创建不同的子类，并让他们都继承父类，后面我们一一实现。</p><p>hash.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; History &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./base&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HashHistory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">History</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">router</span>)</span>&#123;<br>    <span class="hljs-built_in">super</span>(router);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>html5.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; History &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./base&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HTML5History</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">History</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">router</span>)</span>&#123;<br>    <span class="hljs-built_in">super</span>(router);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>abstract.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; History &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./base&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractHistory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">History</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">router</span>)</span>&#123;<br>    <span class="hljs-built_in">super</span>(router);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="HashHistory类实现"><a href="#HashHistory类实现" class="headerlink" title="HashHistory类实现"></a>HashHistory类实现</h2><p>来到 <code>history/</code> 的文件夹下的 <code>hash.js</code> 文件，我们先实现 HashHistory 类：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @path: src/hello-vue-router/index.js</span><br><span class="hljs-comment"> * @Description: 路由模式HashHistory子类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">import</span> &#123; History &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./base&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HashHistory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">History</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">router</span>)</span> &#123;<br>    <span class="hljs-comment">// 继承父类</span><br>    <span class="hljs-built_in">super</span>(router);<br>  &#125;<br>  <br>  <span class="hljs-comment">// 启动路由监听</span><br>  <span class="hljs-function"><span class="hljs-title">setupListeners</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-comment">// 路由监听回调</span><br>    <span class="hljs-keyword">const</span> handleRoutingEvent = <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-keyword">let</span> location = getHash();<br>      <span class="hljs-built_in">this</span>.transitionTo(location, <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Hash路由监听跳转成功！`</span>);<br>      &#125;);<br>    &#125;;<br><br>    <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&quot;hashchange&quot;</span>, handleRoutingEvent);<br>    <span class="hljs-built_in">this</span>.listeners.push(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-built_in">window</span>.removeEventListener(<span class="hljs-string">&quot;hashchange&quot;</span>, handleRoutingEvent);<br>    &#125;);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 获取location hash路由</span><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getHash</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> href = <span class="hljs-built_in">window</span>.location.href;<br>  <span class="hljs-keyword">const</span> index = href.indexOf(<span class="hljs-string">&quot;#&quot;</span>);<br>  <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;/&quot;</span>;<br><br>  href = href.slice(index + <span class="hljs-number">1</span>);<br><br>  <span class="hljs-keyword">return</span> href;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上，我们让 HashHistory 类继承 History 类，子类也就继承了父类的一切。我们先实现了 hash 模式下的 <code>setupListeners</code> 方法，即启动路由监听方法。</p><p>来看一下其中的逻辑，主要就是监听了 <code>hashchange</code> 事件，也就是当 hash 路由改变，就会触发其回调。</p><p><strong>思考：监听到路由path改变了我们需要做什么？</strong></p><p>path 变了需要更新当前路由对象、更新视图等等，这个步骤我们前面做过，没错，就是 <code>transitionTo</code> 跳转方法里做的，所以我们直接在监听到路由改变时调用路由跳转方法即可。</p><p>所以回调中先是通过一个 <code>getHash</code> 的工具函数获取到当前 hash 值，返回 hash 路由 path，这个方法简单，不赘述。拿到 path 后接着调用 <code>transitionTo</code> 方法。</p><p>另外，在启动监听后，我们向 <code>listeners</code> 数组（继承父类）中 <code>push</code> 了一个销毁监听的方法，用于卸载时销毁监听事件，这点上面也说过了。</p><p>接下来补充一下子类的方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HashHistory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">History</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">router</span>)</span> &#123;<br>    <span class="hljs-comment">// 继承父类</span><br>    <span class="hljs-built_in">super</span>(router);<br>  &#125;<br>  <br>  <span class="hljs-comment">// 启动路由监听</span><br>  <span class="hljs-function"><span class="hljs-title">setupListeners</span>(<span class="hljs-params"></span>)</span> &#123; <span class="hljs-comment">/** ... **/</span> &#125;<br>  <br>  <span class="hljs-comment">// 更新URL</span><br>  <span class="hljs-function"><span class="hljs-title">ensureURL</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">window</span>.location.hash = <span class="hljs-built_in">this</span>.current.fullPath;<br>  &#125;<br>  <br>  <span class="hljs-comment">// 路由跳转方法</span><br>  <span class="hljs-function"><span class="hljs-title">push</span>(<span class="hljs-params">location, onComplete</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.transitionTo(location, onComplete)<br>  &#125;<br><br>  <span class="hljs-comment">// 路由前进后退</span><br>  <span class="hljs-function"><span class="hljs-title">go</span>(<span class="hljs-params">n</span>)</span>&#123;<br>    <span class="hljs-built_in">window</span>.history.go(n)<br>  &#125;<br>  <br>  <span class="hljs-comment">// 跳转到指定URL，替换history栈中最后一个记录</span><br>  <span class="hljs-function"><span class="hljs-title">replace</span>(<span class="hljs-params">location, onComplete</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.transitionTo(location, <span class="hljs-function">(<span class="hljs-params">route</span>) =&gt;</span> &#123;<br>      <span class="hljs-built_in">window</span>.location.replace(getUrl(route.fullPath))<br>      onComplete &amp;&amp; onComplete(route)<br>    &#125;)<br>  &#125;<br><br>  <span class="hljs-comment">// 获取当前路由</span><br>  <span class="hljs-function"><span class="hljs-title">getCurrentLocation</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> getHash()<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 获取URL</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getUrl</span>(<span class="hljs-params">path</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> href = <span class="hljs-built_in">window</span>.location.href<br>  <span class="hljs-keyword">const</span> i = href.indexOf(<span class="hljs-string">&#x27;#&#x27;</span>)<br>  <span class="hljs-keyword">const</span> base = i &gt;= <span class="hljs-number">0</span> ? href.slice(<span class="hljs-number">0</span>, i) : href<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;base&#125;</span>#<span class="hljs-subst">$&#123;path&#125;</span>`</span><br>&#125;<br><br><span class="hljs-comment">// 获取location hash路由</span><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getHash</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">/** ... **/</span> &#125;<br></code></pre></td></tr></table></figure><p>我们补充了 5 个方法：</p><ul><li><p>ensureURL </p><ul><li>更新 URL ，它的实现其实很简单，更新导航栏 URL 的 hash，使用 <code>window.location.hash</code> API 就可以，在父类跳转方法里，更新当前路由对象之后才调用了 <code>ensureURL</code>，而更新后路由对象中的 <code>fullPath</code> 属性就是完整的hash path，所以直接赋值过去就可以了。</li></ul></li><li><p>push</p><ul><li>路由跳转方法，此方法我们在父类早已经实现好了，所以接在 <code>push</code> 中调用父类的 <code>transitionTo</code> 方法进行跳转就好，参数也都一致。</li></ul></li><li><p>go</p><ul><li>路由的前进后退，其实实现的不论是 hash 还是 history 模式跳转，每次跳转都改变了URL，跳转的记录都存放在浏览器的 <code>window.history</code> 栈中，而浏览器也提供了一个 <code>window.history.go</code> 的方法让用做前进后退路由，所以直接调用即可，参数都一致。</li></ul></li><li><p>getCurrentLocation</p><ul><li>获取当前 URL 路由地址，由于这是 hash 类，我们之前实现过一个 <code>getHash</code> 方法来获取 hash 模式下 URL 中的路由，所以返回此方法的调用值即可。</li></ul></li><li><p>replace </p><ul><li>跳转到指定URL，替换history栈中最后一个记录</li></ul></li></ul><p>我们重点说 <code>replace</code> 方法：</p><p>先说作用，其实也是跳转，只是使用 <code>replace</code> 跳转不会在 <code>window.history</code> 栈中产生记录，也就是当我们从 a 页面使用 <code>push</code> 跳转到 b 页面时，栈中是 <code>[a,b]</code>，再使用 <code>replace</code> 跳转从 b 页面到 c 页面时，栈中还是 <code>[a, b]</code> ，那这个时候我们返回上一个页面，就直接从 c 页面到了 a 页面。</p><p>其实我们大概也知道浏览器有 <code>window.location.replace</code> 方法就可以实现此功能，但 VueRouter 中跳转时需要考虑三块更新（路由对象、URL、视图）。</p><p>试想，假如我们要 <code>replace</code> 一个新的路由，我们需要怎么做？</p><p>先更新当前路由对象，再更新URL，这里的更新要使用 <code>window.location.replace</code> 更新才不会留记录，最后渲染视图。</p><p>诶？好像和 <code>transitionTo</code> 中差不多，那我们可以修改 <code>transitionTo</code> 方法，把它原来更新URL的 <code>ensureURL</code> 方法放到跳转成功回调的后面，这样我们调用 <code>transitionTo</code> 方法，在回调中使用 <code>window.location.replace</code> 更新URL就可以了。</p><p>你可能会疑问，将 <code>ensureURL</code> 方法放到最后，在回调中 <code>replace</code> 但回调执行完毕还是会调用 <code>ensureURL</code> 方法啊？</p><p>其实回调里使用 <code>window.location.replace</code> 更新URL后，URL已经是最新的了，这时再调用 <code>ensureURL</code> 更新URL，由于要更新的URL和当前URL是一致的，所以页面不会跳转。</p><p>因为 <code>ensureURL</code> 方法里其实调用的 <code>window.location.hash</code> ，假如当前页面地址为 <code>http://localhost:8080/#/about</code>，我们使用此 API 将其 hash 改为 <code>/about</code>，由于前后 hash 一致，其实等于啥也没做。。。</p><p>所以我们修改 <code>transitionTo</code> 方法只需修改其成功回调和更新URL的 <code>ensureURL</code> 方法调用顺序即可，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-title">transitionTo</span>(<span class="hljs-params">location, onComplete</span>)</span> &#123;<br>  <span class="hljs-keyword">let</span> route = <span class="hljs-built_in">this</span>.router.match(location);<br>  <span class="hljs-built_in">this</span>.current = route;<br><br>  <span class="hljs-comment">// 跳转成功抛出回调 放上面</span><br>  onComplete &amp;&amp; onComplete(route)<br>  <br>  <span class="hljs-comment">// 更新URL 放下面</span><br>  <span class="hljs-built_in">this</span>.ensureURL()<br>&#125;<br></code></pre></td></tr></table></figure><p>接着实现 <code>replace</code> 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HashHistory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">History</span> </span>&#123;<br><br>  <span class="hljs-comment">// 跳转到指定URL，替换history栈中最后一个记录</span><br>  <span class="hljs-function"><span class="hljs-title">replace</span>(<span class="hljs-params">location, onComplete</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.transitionTo(location, <span class="hljs-function">(<span class="hljs-params">route</span>) =&gt;</span> &#123;<br>      <span class="hljs-built_in">window</span>.location.replace(getUrl(route.fullPath))<br>      onComplete &amp;&amp; onComplete(route)<br>    &#125;)<br>  &#125;<br>  <br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// 获取URL</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getUrl</span>(<span class="hljs-params">path</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> href = <span class="hljs-built_in">window</span>.location.href<br>  <span class="hljs-keyword">const</span> i = href.indexOf(<span class="hljs-string">&#x27;#&#x27;</span>)<br>  <span class="hljs-keyword">const</span> base = i &gt;= <span class="hljs-number">0</span> ? href.slice(<span class="hljs-number">0</span>, i) : href<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;base&#125;</span>#<span class="hljs-subst">$&#123;path&#125;</span>`</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如上，调用 <code>transitionTo</code> 方法，在其回调中 <code>window.location.replace</code> 一下就可以了</p><p>注意这里我们又写了一个工具方法，<code>getUrl</code> ，其实就是传入 hash path，返回完整的新 URL 路径，常规操作，不赘述。</p><p>到了这里，其实我们的 <code>HashHitory</code> 子类就差不多 OK 了。</p><p>接下来就是流程打通了。</p><p>之前在 VueRouter 类的实现中，我们只是初始化了各个路由模块子类，但是还没有开启路由监听，注意子类里启动监听的方法是 <code>setupListeners</code> ，再次回到 <code>src/hello-vue-router/index.js</code> 文件，即 VueRouter 类中，给它添加一个初始化方法。</p><h2 id="VueRouter实例初始化"><a href="#VueRouter实例初始化" class="headerlink" title="VueRouter实例初始化"></a>VueRouter实例初始化</h2><h3 id="初始化方法构建"><a href="#初始化方法构建" class="headerlink" title="初始化方法构建"></a>初始化方法构建</h3><p>思考：VueRouter类初始化时应该做什么？</p><p>当然是启动路由模式类的监听，既然启动了监听，那必然要挂载一下销毁。</p><p>思考：什么时候销毁？</p><p>什么时候不需要监听什么时候销毁！！Vue根实例卸载后就不需要监听了，所以我们监听一下Vue根实例的卸载就可以了。</p><p>问题是我们在外部要怎么监听一个Vue实例的卸载？</p><p>诶！<code>hook:</code> 前缀的特殊事件监听就派上用场了，Vue官方支持。</p><p><strong>小 Tips：</strong><code>hook:</code> <strong>前缀的特殊事件监听</strong></p><p>源码中生命周期钩子函数是通过 <code>callHook</code> 函数去调用的， <code>callHook</code> 函数中有一个 <code>vm._hasHookEvent</code> 的判断，当它为 <code>true</code> 的情况下，有着 <code>hook:</code> 特殊前缀的事件，会在对应的生命周期当中执行。</p><p>组件中监听事件解析后会使用 <code>$on</code> 注册事件回调，使用 <code>$on</code> 或 <code>$once</code> 监听事件时，如事件名以 <code>hook:</code> 作为前缀，那这个事件会被当做 <code>hookEvent</code>，注册事件回调的同时，<code>vm._hasHookEvent</code> 会被置为 <code>true</code>，后当使用 <code>callHook</code> 调用生命周期函数时，由于 <code>_hasHookEvent</code> 为 <code>true</code>，会直接执行 <code>$emit(&#39;hook:xxx&#39;)</code>，所以注册的生命周期函数就会执行。</p><ul><li>在模板中通过 <code>@hook:created</code> 这种形式注册。</li><li>JS 中可通过<code>vm.$on(&#39;hook:created&#39;, cb)</code> 或者 <code>vm.$once(&#39;hook:created&#39;, cb)</code> 注册，vm 指当前组件实例。</li></ul><p>一道经典的面试题，<strong>如何在父组件中监听子组件生命周期</strong>，答案就是在父组件中获取到子组件实例（vm），然后通过注册<code>hook:</code> 前缀+生命周期钩子的特殊事件监听就可以了。</p><p>这里我们要监听根实例，所以要拿到根实例对象再注册监听，监听销毁事件我们没必要使用 <code>$on</code> ，用 <code>$once</code> 就可以，这样只触发一次，触发之后监听器就会被移除，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// vm 为根实例对象</span><br>vm.$once(<span class="hljs-string">&quot;hook:destroyed&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;&#125;)<br></code></pre></td></tr></table></figure><p>知道了这些问题，继续实现 init 方法，既然要拿到根实例对象，那 <code>init</code> 方法的参数就有了，分析完毕，开始写代码吧！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VueRouter</span></span>&#123;<br>  <br><span class="hljs-function"><span class="hljs-title">init</span>(<span class="hljs-params">app</span>)</span> &#123;<br>    <span class="hljs-comment">// 绑定destroyed hook，避免内存泄露</span><br>    app.$once(<span class="hljs-string">&#x27;hook:destroyed&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-built_in">this</span>.app = <span class="hljs-literal">null</span><br><br>      <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.app) <span class="hljs-built_in">this</span>.history.teardown()<br>    &#125;)<br><br>    <span class="hljs-comment">// 存在即不需要重复监听路由</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.app) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-built_in">this</span>.app = app;<br><br>    <span class="hljs-comment">// 启动监听</span><br>    <span class="hljs-built_in">this</span>.history.setupListeners();<br>  &#125;<br>  <br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如上，其实很简单，<code>init</code> 方法传入了一个 app 参数，即 Vue 根实例，方法里判断了 <code>this.app</code> 是否存在，存在直接返回代表已经注册过监听，不存在则将实例赋值给了 VueRouter 类的 app 属性上，最后调用 VueRouter 实例 <code>history</code> 属性的 <code>setupListeners</code> 方法启动监听。</p><p><code>history</code> 就是我们在 <code>constructor</code> 里初始化的路由模式类实例，<code>constructor</code> 构造器在 <code>new VueRouter</code> 的时候就会执行，所以我们完全可以拿到 <code>history</code> 实例。</p><p>而注册的销毁监听也很简单，就是上面说过的使用根实例的 <code>$once</code> 注册一个 <code>hook:destroyed</code> 监听，回调中将 app 属性置空并调用 <code>history</code> 实例的卸载方法 <code>teardown</code> ，此方法是在路由模式父类中实现的，忘了的话可以回看一下。</p><p>OK，<code>init</code> 方法暂时写完了，我们要在什么时候调用它呢？</p><h3 id="初始化方法调用"><a href="#初始化方法调用" class="headerlink" title="初始化方法调用"></a>初始化方法调用</h3><p>因为 init 方法中还有启动监听，所以需要在一切都初始化好了再调用，并且这个时候还要能拿到 Vue 根实例。</p><p>回顾我们上面所有环节，能拿到根实例的地方只有插件安装 install 方法 <code>mixin</code> 混入的时候了。</p><p>所以，在 <code>src/hello-vue-router/install.js</code> 文件 install 方法的 <code>mixin</code> 中添加执行路由组件初始化方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @path: src/hello-vue-router/install.js</span><br><span class="hljs-comment"> * @Description: 入口文件 VueRouter类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">install</span>(<span class="hljs-params">Vue</span>)</span>&#123;<br>  <br>  Vue.mixin(&#123;<br>    <span class="hljs-function"><span class="hljs-title">beforeCreate</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.$options.router) &#123;<br>        <span class="hljs-built_in">this</span>._routerRoot = <span class="hljs-built_in">this</span>;<br>        <span class="hljs-built_in">this</span>._router = <span class="hljs-built_in">this</span>.$options.router;<br>        <br>        <span class="hljs-comment">// 调用VueRouter实例初始化方法</span><br>        <span class="hljs-comment">// _router即VueRouter实，此处this即Vue根实例</span><br>        <span class="hljs-built_in">this</span>._router.init(<span class="hljs-built_in">this</span>) <span class="hljs-comment">// 添加项 </span><br>        <br>        <span class="hljs-built_in">this</span>._route = &#123;&#125;;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">this</span>._routerRoot = (<span class="hljs-built_in">this</span>.$parent &amp;&amp; <span class="hljs-built_in">this</span>.$parent._routerRoot) || <span class="hljs-built_in">this</span><br>      &#125;<br>    &#125;,<br>  &#125;);<br>  <br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这时你会发现，<code>mixin</code> 中 <code>_route</code> 对象还是空对象，我们已经实现了当前路由对象即路由模式类的 <code>current</code> 属性，所以这里可以为其赋值了，再次修改代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js">Vue.mixin(&#123;<br>  <span class="hljs-function"><span class="hljs-title">beforeCreate</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.$options.router) &#123;<br>      <span class="hljs-built_in">this</span>._routerRoot = <span class="hljs-built_in">this</span>;<br>      <span class="hljs-built_in">this</span>._router = <span class="hljs-built_in">this</span>.$options.router;<br>      <span class="hljs-built_in">this</span>._router.init(<span class="hljs-built_in">this</span>)<br><br>      <span class="hljs-comment">// this._route = &#123;&#125;; old</span><br>      <span class="hljs-built_in">this</span>._route =  <span class="hljs-built_in">this</span>._router.history.current; <span class="hljs-comment">// new</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-built_in">this</span>._routerRoot = (<span class="hljs-built_in">this</span>.$parent &amp;&amp; <span class="hljs-built_in">this</span>.$parent._routerRoot) || <span class="hljs-built_in">this</span><br>    &#125;<br>  &#125;,<br>&#125;);<br></code></pre></td></tr></table></figure><p>到了这里其实我们 hash 模式的整个流程基本通了，可以打开项目链接看看，没有报错并且可以点击导航切换路由，有报错那肯定是你写错了，不是我。。虽无报错，但页面中路由模块没有渲染，因为 <code>router-view</code> 组件还没完善。</p><h2 id="RouterView组件完善"><a href="#RouterView组件完善" class="headerlink" title="RouterView组件完善"></a>RouterView组件完善</h2><p>目前我们的 RouterView 组件是这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @path: src/hello-vue-router/components/view.js</span><br><span class="hljs-comment"> * @Description: router-view</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;RouterView&quot;</span>,<br>  <span class="hljs-attr">functional</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params">h</span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> h(<span class="hljs-string">&#x27;div&#x27;</span>, <span class="hljs-string">&#x27;This is RoutePage&#x27;</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上，组件渲染的永远是固定的 div，现在就可以开始完善它了。</p><h3 id="路由组件动态渲染"><a href="#路由组件动态渲染" class="headerlink" title="路由组件动态渲染"></a>路由组件动态渲染</h3><p>思路很简单，先拿到当前路由对象，因为当前路由对象的 <code>matched</code> 数组存着当前 path 所有有关联的路由匹配对象，数组最后一项即当前path本身的路由匹配对象，所以我们只需要取出数组最后一项，然后拿它的 components 属性（即当前 path 对应的路由模块），直接将它给到渲染函数即可。</p><p>开始修改 RouterView 组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;RouterView&quot;</span>,<br>  <span class="hljs-attr">functional</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 函数式组件</span><br>  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params">h,  &#123; parent, data&#125;</span>)</span> &#123;<br>    <span class="hljs-comment">// parent：对父组件的引用</span><br>    <span class="hljs-comment">// data：传递给组件的整个数据对象，作为 createElement 的第二个参数传入组件</span><br>    <br>    <span class="hljs-comment">// 标识当前渲染组件为router-view</span><br>    data.routerView = <span class="hljs-literal">true</span><br><br>    <span class="hljs-keyword">let</span> route = parent.$route<br>    <span class="hljs-keyword">let</span> matched;<br>    <span class="hljs-keyword">if</span>(route.matched)&#123;<br>      matched = route.matched[route.matched.length - <span class="hljs-number">1</span>]<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!matched) <span class="hljs-keyword">return</span> h();<br>  <br>    <span class="hljs-keyword">return</span> h(matched.components, data)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对函数式组件不了解的请看文档 <a href="https://cn.vuejs.org/v2/guide/render-function.html#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6">函数式组件文档</a> 。</p><p>其实代码很简单，先标识了一下当前渲染的是 RouterView 组件，代码中给 data 添加了一个属性，这个 data 最后会被作为 createElement 的第二个参数传入组件，当我们想要知道一个组件是不是 RouterView 渲染出来的，就可以通过这个属性来判断，这个属性存放在组件实例下 <code>$vnode</code> 属性的 data 对象中。</p><p>由于我们已经挂载了 <code>$route</code> 所以通过任何一个实例都可以访问此路由对象，拿到路由对象，取其 <code>matched</code> 属性数组的最后一项，即当前 path 对应的路由组件。</p><p>最后直接在 h（createElement）函数中返回组件即可。</p><p>貌似已经 OK 了，打开项目页面看一下。</p><p>页面中除了导航一片空白，也没报错，点击导航也确实触发跳转监听了（控制台有输出），但是并无任何组件渲染，如下：</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20210723003317616.png"></p><p>怎么回事？捋一遍流程。</p><p>首先，点击导航跳转，监听到 hash 路由改变，走 <code>transitionTo</code> 方法，方法中做三件事：</p><ul><li>更新当前路由对象</li><li>更新URL</li><li>更新组件渲染</li></ul><p>诶！更新组件渲染，这一步我们好像到现在还没做，找到问题所在了！</p><p>RouterView 组件我们已经初步完善了，但是当路由 path 更新，我们怎么通知 RouterView 组件更新渲染呢？？</p><p>想一下，Vue最核心的是什么？当然是数据响应式，RouterView 的核心数据是 <code>$route</code>，如果我们将它做成一个响应式的数据，那当它改变时岂不就可以直接自动重新渲染！</p><p>说干就干，之前写的 <code>$route</code>，它其实是被代理到了 Vue 根实例的 <code>_route</code> 对象，所以只要将 <code>_route</code> 对象搞成响应式的就可以了，做响应式当然还是借助 Vue 提供的方法，不然我们在手写一个数据响应式太费劲了，况且 Vue 本身构造函数就有提供这样的 API，即 <code>Vue.util.defineReactive</code> 函数，使用也很简单，修改一下 install 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js">Vue.mixin(&#123;<br>  <span class="hljs-function"><span class="hljs-title">beforeCreate</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.$options.router) &#123;<br>      <span class="hljs-built_in">this</span>._routerRoot = <span class="hljs-built_in">this</span>;<br>      <span class="hljs-built_in">this</span>._router = <span class="hljs-built_in">this</span>.$options.router;<br>      <span class="hljs-built_in">this</span>._router.init(<span class="hljs-built_in">this</span>) <br><br>      <span class="hljs-comment">// this._route =  this._router.history.current;  old</span><br>      Vue.util.defineReactive(<span class="hljs-built_in">this</span>, <span class="hljs-string">&#x27;_route&#x27;</span>, <span class="hljs-built_in">this</span>._router.history.current); <span class="hljs-comment">// new</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-built_in">this</span>._routerRoot = (<span class="hljs-built_in">this</span>.$parent &amp;&amp; <span class="hljs-built_in">this</span>.$parent._routerRoot) || <span class="hljs-built_in">this</span><br>    &#125;<br>  &#125;,<br>&#125;);<br></code></pre></td></tr></table></figure><p>如上所示，我们使用 <code>Vue.util.defineReactive</code> API，为根实例（this）添加一个响应式属性 <code>_route</code> 并为其赋值为路由对象，这里能够直接使用 Vue 构造函数是因为 <code>install</code> 方法参数传入了 Vue。</p><p>如此，每当 <code>_route</code> 这个对象更改的时候 RouterView 组件就可以自动渲染了，我们再看下页面，点一点导航：</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20210723011856248.png"></p><p>fuck，还是老样子，这是为什么呢？再捋捋。</p><p>首先，点击导航跳转，监听到 hash 路由改变，走 <code>transitionTo</code> 方法，方法中做三件事：</p><ul><li>更新当前路由对象</li><li>更新URL</li><li>更新组件渲染</li></ul><p>好像没毛病啊，诶！等等，好像又发现了问题，更新当前路由对象的时候，好像只更新了 <code>current</code>，并没有更新 <code>_route</code>，<code>_route</code> 对象只在初始化的时候赋了一次值。。改它！！</p><p>首先为 <code>History</code> 类增加一个 <code>listen</code> 方法，并接收一个回调，<code>listen</code> 函数内部则直接将此回调函数保存到了 <code>History</code> 类的 <code>cb</code> 属性上，在 <code>transitionTo</code> 函数里 <code>current</code> 更新后面调用 <code>cb</code> 回调并传出了要更新的 <code>route</code> 对象，而 <code>_route</code> 更新的这一步操作，放在了 VueRouter 类的 init 方法里，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// History父类中新增listen方法 保存赋值回调</span><br><span class="hljs-function"><span class="hljs-title">listen</span>(<span class="hljs-params">cb</span>)</span>&#123;<br>  <span class="hljs-built_in">this</span>.cb = cb<br>&#125;<br><br><span class="hljs-function"><span class="hljs-title">transitionTo</span>(<span class="hljs-params">location, onComplete</span>)</span> &#123;<br>  <span class="hljs-keyword">let</span> route = <span class="hljs-built_in">this</span>.router.match(location);<br>  <span class="hljs-built_in">this</span>.current = route;<br><br>  <span class="hljs-comment">// 修改</span><br>  <span class="hljs-comment">// 调用赋值回调，传出新路由对象，用于更新 _route</span><br>  <span class="hljs-built_in">this</span>.cb &amp;&amp; <span class="hljs-built_in">this</span>.cb(route)<br><br>  onComplete &amp;&amp; onComplete(route)<br>  <span class="hljs-built_in">this</span>.ensureURL()<br>&#125;<br></code></pre></td></tr></table></figure><p>接着是 VueRouter 类的 init 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-title">init</span>(<span class="hljs-params">app</span>)</span> &#123;<br>  app.$once(<span class="hljs-string">&#x27;hook:destroyed&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">this</span>.app = <span class="hljs-literal">null</span><br><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.app) <span class="hljs-built_in">this</span>.history.teardown()<br>  &#125;)<br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.app) <span class="hljs-keyword">return</span>;<br><br>  <span class="hljs-built_in">this</span>.app = app;<br><br>  <span class="hljs-built_in">this</span>.history.setupListeners();<br><br>  <span class="hljs-comment">// 新增 </span><br>  <span class="hljs-comment">// 传入赋值回调，为_route赋值，进而触发router-view的重新渲染 </span><br>  <span class="hljs-comment">// 当前路由对象改变时调用</span><br>  <span class="hljs-built_in">this</span>.history.listen(<span class="hljs-function">(<span class="hljs-params">route</span>) =&gt;</span> &#123;<br>    app._route = route<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>可能有小伙伴会懵，其实也很好理解，就是在 init 方法中调用了 <code>history</code> 实例继承于父类的 <code>listen</code> 方法，传入一个更新 <code>_route</code> 的回调，<code>listen</code> 函数会将这个回调一直保存，每次更新路由对象的时候，传入新的路由对象调用一次即可更新 <code>_route</code>。</p><p>现在打开页面再看一下，刷新页面，没有渲染，点击导航又渲染了。</p><p><strong>思考：为什么刷新时没有渲染组件？</strong></p><p>其实是因为路由 path 改变时，我们能够监听到，进而都做了操作，但当页面初始化时我们没有对初始的 path 进行解析。</p><p>知道了问题就解决！其实也简单，直接在 init 方法中获取当前路由path，然后调用 <code>transitionTo</code> 方法解析path渲染一下就行了，再次修改 VueRouter 类的 init 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-title">init</span>(<span class="hljs-params">app</span>)</span> &#123;<br>  app.$once(<span class="hljs-string">&#x27;hook:destroyed&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">this</span>.app = <span class="hljs-literal">null</span><br><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.app) <span class="hljs-built_in">this</span>.history.teardown()<br>  &#125;)<br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.app) <span class="hljs-keyword">return</span>;<br><br>  <span class="hljs-built_in">this</span>.app = app;<br><br>  <span class="hljs-comment">// 新增</span><br>  <span class="hljs-comment">// 跳转当前路由path匹配渲染 用于页面初始化</span><br>  <span class="hljs-built_in">this</span>.history.transitionTo(<br>    <span class="hljs-comment">// 获取当前页面 path</span><br>    <span class="hljs-built_in">this</span>.history.getCurrentLocation(),<br>    <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-comment">// 启动监听放在跳转后回调中即可</span><br>      <span class="hljs-built_in">this</span>.history.setupListeners();<br>    &#125;<br>  )<br><br>  <span class="hljs-built_in">this</span>.history.listen(<span class="hljs-function">(<span class="hljs-params">route</span>) =&gt;</span> &#123;<br>    app._route = route<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>如上，还记得路由模式子类中写的 <code>getCurrentLocation</code> 方法吗？其实就是获取当前路由path，使用 <code>history</code> 实例的 <code>transitionTo</code> 方法传入当前路由path，由于这里是 init 方法，所以相当于是在页面初始化时执行的，也就是刷新时会获取到当前页面的 path 进行解析渲染一次，我们把启动监听 <code>setupListeners</code> 函数放在了跳转回调中监听，这都无碍。</p><p>那再来看看页面：</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20210723022403939.png"></p><p>不论是刷新还是跳转都没有问题，都可以正常显示，nice！</p><h3 id="嵌套路由组件渲染"><a href="#嵌套路由组件渲染" class="headerlink" title="嵌套路由组件渲染"></a>嵌套路由组件渲染</h3><p>再测试一下嵌套路由吧！</p><p>做下准备，先写一个父级页面，在 <code>src/views/</code> 文件夹下新建 <code>Parent.vue</code> 文件，写入在代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    parent page<br>    <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><p>接着写一个子级页面，在 <code>src/views/</code> 文件夹下新建 <code>Child.vue</code> 文件，写入代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    child page<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><p>修改 <code>src/router/index.js</code> 文件的路由配置数组如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> routes = [<br>  <span class="hljs-comment">// ...</span><br>  <br>  <span class="hljs-comment">//新增路由配置</span><br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/parent&quot;</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Parent&quot;</span>,<br>    <span class="hljs-attr">component</span>: <span class="hljs-function">()=&gt;</span><span class="hljs-keyword">import</span>(<span class="hljs-string">&quot;./../views/Parent.vue&quot;</span>),<br>    <span class="hljs-attr">children</span>:[<br>      &#123;<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;child&quot;</span>,<br>        <span class="hljs-attr">name</span>:<span class="hljs-string">&quot;Child&quot;</span>,<br>        <span class="hljs-attr">component</span>:<span class="hljs-function">()=&gt;</span><span class="hljs-keyword">import</span>(<span class="hljs-string">&quot;./../views/Child.vue&quot;</span>)<br>      &#125;<br>    ]<br>  &#125;<br>];<br></code></pre></td></tr></table></figure><p> 接着修改 <code>src/App.vue</code> 文件中的路由导航，新增 <code>Parent &amp; Child</code> 两个导航如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;nav&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/&quot;</span>&gt;</span>Home<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span> |<br>      <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/about&quot;</span>&gt;</span>About<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span> ｜<br>      <span class="hljs-comment">&lt;!-- 新增 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">&quot;&#123; path: &#x27;/parent&#x27; &#125;&quot;</span>&gt;</span>Parent<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span> |<br>      <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">&quot;&#123; path: &#x27;/parent/child&#x27; &#125;&quot;</span>&gt;</span>Parent Child<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><p>OK，这是一个非常简单的嵌套路由，来看看页面效果吧！</p><p>前两个页面正常，<code>parent</code> 页面组件没有渲染，控制台直接爆栈了：</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20210723025500620.png"></p><p> <code>child</code> 页面显示如下：</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20210723025439114.png"></p><p> <code>child</code> 页面因为只渲染出了子页面的内容，这是一个嵌套路由，子页页面内容是在父页面写的 <code>router-view</code> 中渲染，所以点击子页面正常应该父页面的内容也会显示。</p><p>其实，所有的问题都由于我们在写 RouterView 组件时，没有考虑嵌套的情况，回顾下 RouterView 组件代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;RouterView&quot;</span>,<br>  <span class="hljs-attr">functional</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params">h,  &#123; parent, data&#125;</span>)</span> &#123;<br>    data.routerView = <span class="hljs-literal">true</span><br><br>    <span class="hljs-keyword">let</span> route = parent.$route<br>    <span class="hljs-keyword">let</span> matched;<br>    <span class="hljs-keyword">if</span>(route.matched)&#123;<br>      matched = route.matched[route.matched.length - <span class="hljs-number">1</span>]<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!matched) <span class="hljs-keyword">return</span> h();<br>  <br>    <span class="hljs-keyword">return</span> h(matched.components, data)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>分析一下，以目前的 RouterView 组件代码，假如当前 path 为 <code>/parent/child</code> ，拿到当前路由对象 <code>route</code>，我们知道 <code>route.matched</code>  这里存放的是路径解析后所有相关的路由配置对象，它应该是这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">[<br>  &#123;<span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/parent&quot;</span>, components, ...&#125;,<br>  &#123;<span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/parent/child&quot;</span>, components, ...&#125;<br>]<br></code></pre></td></tr></table></figure><p>而我们取最后一项，只取了子路由模块，所以也就只渲染出了子路由组件。</p><p>再假如当前 path 为 <code>/parent</code> ，当前路由对象解析后拿到的 <code>route.matched</code> 数组是下面这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">[<br>  &#123;<span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/parent&quot;</span>, components, ...&#125;<br>]<br></code></pre></td></tr></table></figure><p>取最后一项，只渲染了父路由组件，由于父路由组件中还有 <code>router-view</code> 组件，继续走组件逻辑，接着渲染父组件。。。一直循环下去，所以就爆栈了。。</p><p>修改一下 RouterView 组件，如下，先看完整代码再解释。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;RouterView&quot;</span>,<br>  <span class="hljs-attr">functional</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 函数式组件</span><br>  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params">h,  &#123; parent, data&#125;</span>)</span> &#123;<br>    <span class="hljs-comment">// parent：对父组件的引用</span><br>    <span class="hljs-comment">// data：传递给组件的整个数据对象，作为 createElement 的第二个参数传入组件</span><br>    <br>    <span class="hljs-comment">// 标识当前组件为router-view</span><br>    data.routerView = <span class="hljs-literal">true</span><br><br>    <span class="hljs-keyword">let</span> depth = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 逐级向上查找组件，当parent指向Vue根实例结束循环</span><br>    <span class="hljs-keyword">while</span>(parent &amp;&amp; parent._routerRoot !== parent)&#123;<br>      <span class="hljs-keyword">const</span> vnodeData = parent.$vnode ? parent.$vnode.data : &#123;&#125;;<br>      <span class="hljs-comment">// routerView属性存在即路由组件深度+1，depth+1</span><br>      <span class="hljs-keyword">if</span>(vnodeData.routerView)&#123;<br>        depth++<br>      &#125;<br><br>      parent = parent.$parent<br>    &#125;<br><br><br>    <span class="hljs-keyword">let</span> route = parent.$route<br>    <br>    <span class="hljs-keyword">if</span> (!route.matched) <span class="hljs-keyword">return</span> h();<br>    <br>    <span class="hljs-comment">// route.matched还是当前path全部关联的路由配置数组</span><br>    <span class="hljs-comment">// 渲染的哪个组件，走上面逻辑时就会找到depth个RouterView组件</span><br>    <span class="hljs-comment">// 由于逐级向上时是从父级组件开始找，所以depth数量并没有包含当前路由组件</span><br>    <span class="hljs-comment">// 假如depth=2，则route.matched数组前两项都是父级，第三项则是当前组件，所以depth=索引</span><br>    <span class="hljs-keyword">let</span> matched = route.matched[depth]<br><br>    <span class="hljs-keyword">if</span> (!matched) <span class="hljs-keyword">return</span> h();<br><br>    <span class="hljs-keyword">return</span> h(matched.components, data)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这块可能不太容易理解。</p><p>首先还是给所有的 RouterView 组件做了一个标识。</p><p>接着开始从 <code>parent</code> 父级实例逐级向上遍历组件，从当前父实例找到顶部根实例，也就是当 <code>parent._routerRoot !== parent</code> 成立时，跳出循环。</p><p>在遍历的逻辑里，判断实例的 <code>$vnode</code> 属性下 data 属性中有无 <code>routerView</code> 属性，有则 <code>depth + 1</code>，遍历的最后让 <code>parent = parent.$parent</code> ，<code>$parent</code> 拿到的是父组件实例，以此开启递归。</p><p>要知道不论怎么搞，当前 path 对应的路由对象 route 对象始终是不变的，而 <code>route.matched</code> 是当前 path 全部关联的路由配置数组。</p><p>假如当前 path 是 <code>/a/b/c</code> ，三级嵌套路由，那它的 <code>route.matched</code> 应如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">[<br>  &#123;<span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/a&quot;</span>, ...&#125;,<br>  &#123;<span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/a/b&quot;</span>, ...&#125;,<br>  &#123;<span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/a/b/c&quot;</span>, ...&#125;,<br>]<br></code></pre></td></tr></table></figure><p>嵌套了三层，也就有三个 RouterView 组件， <code>App.vue、a.vue、b.vue</code> 中各一个，所以当渲染 <code>/a/b/c</code> 时，页面应该是下面这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// /a/b/c</span><br>a<br> b<br>  c<br></code></pre></td></tr></table></figure><p>当 <code>App.vue</code> 页面 RouterView 组件开始渲染，走组件逻辑查找 <code>depth</code> 层级，<strong>从父实例</strong>向上迭代到根实例查找带有 <code>routerView</code> 属性的组件，有 0 个，所以 <code>depth = 0</code> ，<code>route.matched[0]</code> 即 <code>/a</code> 路由组件。</p><p>当 <code>a.vue</code> 页面 RouterView 组件开始渲染，走组件逻辑查找 <code>depth</code> 层级，<strong>从父实例</strong>向上迭代到根实例查找带有 <code>routerView</code> 属性的组件，有 1 个，所以 <code>depth = 1</code> ，<code>route.matched[1]</code> 即 <code>/a</code> 路由组件。</p><p>当 <code>b.vue</code> 页面 RouterView 组件开始渲染，走组件逻辑查找 <code>depth</code> 层级，<strong>从父实例</strong>向上迭代到根实例查找带有 <code>routerView</code> 属性的组件，有 2 个，所以 <code>depth = 2</code> ，<code>route.matched[2]</code> 即 <code>/a</code> 路由组件。</p><p>再来看看页面，我们发现嵌套路由两个页面都正常了。</p><p>/parent：</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20210723075421896.png"></p><p>/parent/child：</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20210723075307597.png"></p><p>所以，看懂了吗？我觉得够详细了，不懂再看几遍配合断点或打印。</p><h2 id="VueRouter实例方法挂载完善"><a href="#VueRouter实例方法挂载完善" class="headerlink" title="VueRouter实例方法挂载完善"></a>VueRouter实例方法挂载完善</h2><p>路由模式类上面我们实现了几个路由跳转相关的方法，还没有挂载到 VueRouter 类上，我们一块来挂载下，还有之前挂载的 <code>addRoute &amp; addRoutes</code> 两个方法，还需要完善一下。</p><p>回到 <code>src/hello-vue-router/index.js</code> 文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VueRouter</span> </span>&#123;<br>  <br>  <span class="hljs-comment">// 导航到新url，向 history栈添加一条新访问记录</span><br>  <span class="hljs-function"><span class="hljs-title">push</span>(<span class="hljs-params">location</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.history.push(location)<br>  &#125;<br><br>  <span class="hljs-comment">// 在 history 记录中向前或者后退多少步</span><br>  <span class="hljs-function"><span class="hljs-title">go</span>(<span class="hljs-params">n</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.history.go(n);<br>  &#125;<br><br>  <span class="hljs-comment">// 导航到新url，替换 history 栈中当前记录</span><br>  <span class="hljs-function"><span class="hljs-title">replace</span>(<span class="hljs-params">location, onComplete</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.history.replace(location, onComplete)<br>  &#125;<br><br>  <span class="hljs-comment">// 导航回退一步</span><br>  <span class="hljs-function"><span class="hljs-title">back</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.history.go(-<span class="hljs-number">1</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上，添加几个路由跳转相关的方法，其实就是调用已经实现好的 history 实例上的方法就 OK 了，不赘述了。</p><p>接着我们看之前挂载的 <code>addRoute &amp; addRoutes</code> 两个方法。</p><p>目前这两个方法调用时，确实进行追加了，普通情况下也是没问题的，但是有一种特殊情况，即在当前页面 path 初始化前，动态添加当前页面的路由组件，这时我们如果使用目前的API加载后，其实只是解析并添加了内部 pathMap， 但由于当前路由对象并没有更新，页面直接就会报错。</p><p>所以需要在动态添加后进行一次路由更新操作，其实还是调用一下 <code>transitionTo</code> 方法跳转当前页面 path 即可，当然还需避免路由初始化时即当前路由等于 <code>START</code> （之前写的路由 current 对象初始值）的情况。</p><p>So，修改这两个函数，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 新增START对象导入</span><br><span class="hljs-keyword">import</span> &#123; START &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./utils/route&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VueRouter</span> </span>&#123;<br>  <br> <span class="hljs-comment">// 动态添加路由（添加一条新路由规则）</span><br>  <span class="hljs-function"><span class="hljs-title">addRoute</span>(<span class="hljs-params">parentOrRoute, route</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.matcher.addRoute(parentOrRoute, route)<br>    <span class="hljs-comment">// 新增</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.history.current !== START) &#123;<br>      <span class="hljs-built_in">this</span>.history.transitionTo(<span class="hljs-built_in">this</span>.history.getCurrentLocation())<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 动态添加路由（参数必须是一个符合 routes 选项要求的数组）</span><br>  <span class="hljs-function"><span class="hljs-title">addRoutes</span>(<span class="hljs-params">routes</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.matcher.addRoutes(routes)<br>    <span class="hljs-comment">// 新增</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.history.current !== START) &#123;<br>      <span class="hljs-built_in">this</span>.history.transitionTo(<span class="hljs-built_in">this</span>.history.getCurrentLocation())<br>    &#125;<br>  &#125;<br>  <br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>比较简单，不赘述了。</p><p>至此，hash 模式的流程完整了。</p><p>接下来就是按部就班的实现 history 模式也就是填充 HTML5History 类了。</p><h2 id="HTML5History类实现"><a href="#HTML5History类实现" class="headerlink" title="HTML5History类实现"></a>HTML5History类实现</h2><p>HTML5History 类虽然和 HashHistory 类实现细节上略有不同，但是我们要写的 API 都是一致的，这样才能完全契合外部的统一调用。</p><p>来到 <code>history/</code> 文件夹下的 <code>html5.js</code> 文件，有了上面 HashHistory 类的经验我们这里就直接贴代码了，因为没有什么困难的地方。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @path: src/hello-vue-router/history/html5.js</span><br><span class="hljs-comment"> * @Description: 路由模式HTML5History子类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">import</span> &#123; History &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./base&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HTML5History</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">History</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">router</span>)</span> &#123;<br>    <span class="hljs-comment">// 继承父类</span><br>    <span class="hljs-built_in">super</span>(router);<br>  &#125;<br><br>  <span class="hljs-comment">// 启动路由监听</span><br>  <span class="hljs-function"><span class="hljs-title">setupListeners</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-comment">// 路由监听回调</span><br>    <span class="hljs-keyword">const</span> handleRoutingEvent = <span class="hljs-function">() =&gt;</span> &#123;<br><br>      <span class="hljs-built_in">this</span>.transitionTo(getLocation(), <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`HTML5路由监听跳转成功！`</span>);<br>      &#125;);<br>    &#125;;<br><br>    <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&quot;popstate&quot;</span>, handleRoutingEvent);<br>    <span class="hljs-built_in">this</span>.listeners.push(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-built_in">window</span>.removeEventListener(<span class="hljs-string">&quot;popstate&quot;</span>, handleRoutingEvent);<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-comment">// 更新URL</span><br>  <span class="hljs-function"><span class="hljs-title">ensureURL</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (getLocation() !== <span class="hljs-built_in">this</span>.current.fullPath) &#123;<br>      <span class="hljs-built_in">window</span>.history.pushState(<br>        &#123; <span class="hljs-attr">key</span>: <span class="hljs-built_in">Date</span>.now().toFixed(<span class="hljs-number">3</span>) &#125;, <br>        <span class="hljs-string">&quot;&quot;</span>, <br>        <span class="hljs-built_in">this</span>.current.fullPath<br>      );<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 路由跳转方法</span><br>  <span class="hljs-function"><span class="hljs-title">push</span>(<span class="hljs-params">location, onComplete</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.transitionTo(location, onComplete)<br>  &#125;<br><br>  <span class="hljs-comment">// 路由前进后退</span><br>  <span class="hljs-function"><span class="hljs-title">go</span>(<span class="hljs-params">n</span>)</span>&#123;<br>    <span class="hljs-built_in">window</span>.history.go(n)<br>  &#125;<br><br>  <span class="hljs-comment">// 跳转到指定URL，替换history栈中最后一个记录</span><br>  <span class="hljs-function"><span class="hljs-title">replace</span>(<span class="hljs-params">location, onComplete</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.transitionTo(location, <span class="hljs-function">(<span class="hljs-params">route</span>) =&gt;</span> &#123;<br>      <span class="hljs-built_in">window</span>.history.replaceState(<span class="hljs-built_in">window</span>.history.state, <span class="hljs-string">&#x27;&#x27;</span>, route.fullPath)<br>      onComplete &amp;&amp; onComplete(route)<br>    &#125;)<br>  &#125;<br><br>  <span class="hljs-comment">// 获取当前路由</span><br>  <span class="hljs-function"><span class="hljs-title">getCurrentLocation</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> getLocation()<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 获取location HTML5 路由</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getLocation</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> path = <span class="hljs-built_in">window</span>.location.pathname;<br>  <span class="hljs-keyword">return</span> path;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上我们很轻松就实现了 HTML5Histoy 类，但是有一个问题，在使用 <code>history</code> ，不断点击 <code>router-link</code> 生成的同一个导航时，每次点击都会刷新页面，这其实就是我们之前说的， <code>router-link</code> 最终生成的是 a 标签，<code>history</code> 模式点击 a 标签，默认会触发页面的跳转，所以需要拦截 a 标签点击事件默认行为，<code>hash</code> 就不会，因为 hash 模式下 a 标签中解析后的 href 属性中是以 <code>#</code> 号开头的。</p><p>在哪里拦截？当然是 <code>router-link</code> 组件。</p><h2 id="RouterLink组件完善"><a href="#RouterLink组件完善" class="headerlink" title="RouterLink组件完善"></a>RouterLink组件完善</h2><p>也比较简单，统一给 RouterLink 组件返回的 a 标签加了阻止默认跳转，然后又加了手动跳转：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;RouterLink&quot;</span>,<br>  <span class="hljs-attr">props</span>: &#123;<br>    <span class="hljs-attr">to</span>: &#123;<br>      <span class="hljs-attr">type</span>: [<span class="hljs-built_in">String</span>, <span class="hljs-built_in">Object</span>],<br>      <span class="hljs-attr">require</span>: <span class="hljs-literal">true</span><br>    &#125;<br>  &#125;,<br>  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params">h</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> href = <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">this</span>.to === <span class="hljs-string">&#x27;string&#x27;</span> ? <span class="hljs-built_in">this</span>.to : <span class="hljs-built_in">this</span>.to.path<br>    <span class="hljs-keyword">const</span> router = <span class="hljs-built_in">this</span>.$router<br>    <span class="hljs-keyword">let</span> data = &#123;<br>      <span class="hljs-attr">attrs</span>: &#123;<br>        <span class="hljs-attr">href</span>: router.mode === <span class="hljs-string">&quot;hash&quot;</span> ? <span class="hljs-string">&quot;#&quot;</span> + href : href<br>      &#125;,<br>      <span class="hljs-comment">//新增</span><br>      <span class="hljs-attr">on</span>: &#123;<br>        <span class="hljs-attr">click</span>: <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>          e.preventDefault()<br>          router.push(href)<br>        &#125;<br>      &#125;<br>    &#125;;<br>    <span class="hljs-keyword">return</span> h(<span class="hljs-string">&quot;a&quot;</span>, data, <span class="hljs-built_in">this</span>.$slots.default)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上，我们在 createElement（h）函数的第二个参数中，对点击事件加入了阻止默认跳转事件，没有了默认跳转，我们进行了一次手动跳转，即直接调用 <code>router</code> 实例的 <code>push</code> 方法进行跳转。</p><h2 id="AbstractHistory类实现"><a href="#AbstractHistory类实现" class="headerlink" title="AbstractHistory类实现"></a>AbstractHistory类实现</h2><p>没有了，其实实现起来很简单，就是用数组模拟了一个历史调用栈，找源码看一眼几分钟就写完了，完全是由一个数组和各种数组操作API组成的类，篇幅问题，不赘述了。</p><h2 id="植入router-hook"><a href="#植入router-hook" class="headerlink" title="植入router hook"></a>植入router hook</h2><p>如果你跟着实现，到了这其实 VueRouter 的核心内容都差不多搞定了，接下来可以疯狂发散下思路，再自己动手找源码中相关实现来参考，最后完善出来 <code>router hook</code>，因为路由钩子是余下功能里实现起来有一定难度的一个，这是一个非常好的锻炼机会。</p><p><strong>Tips：</strong> 路由钩子有三种：</p><ul><li>全局路由钩子</li><li>组件路由钩子</li><li>路由独享beforeEnter守卫</li></ul><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>如果看到这里依然对其流程不太清楚，再来看这张图，说不定可以直接打通任督二脉哦！</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20210725173152169.png"></p><p>整个实现的核心逻辑还算 OK，细节上还存在很多问题，因为我们忽略了一些校验及小功能的实现，但对理解 VueRouter 源码还是有很大帮助。建议跟着手敲一遍，搞完后直接去完整的看一遍 VueRouter 源码，加油吧！欢迎刊误！原创烧脑，写作不易，如果对你有帮助，点个赞吧！！</p><p>项目代码地址：<a href="https://github.com/isboyjc/hello-vue-router">hello-vue-router</a> </p><p>根目录下 <code>src/hello-vue-router</code> 文件夹即手写 VueRouter 完整代码，已作注释</p><p>根目录下 <code>vue-router-source</code> 文件夹即带有注释的 VueRouter V3.5.2 源码</p><p>最后欢迎大家关注微信公众号「不正经的前端」！点个赞吧！</p>]]></content>
    
    
    <categories>
      
      <category>Vue相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
      <tag>VueRouter</tag>
      
      <tag>源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「硬核JS」你的程序中可能存在内存泄漏</title>
    <link href="/blog/2021/07/13/js/%E3%80%8C%E7%A1%AC%E6%A0%B8JS%E3%80%8D%E4%BD%A0%E7%9A%84%E7%A8%8B%E5%BA%8F%E4%B8%AD%E5%8F%AF%E8%83%BD%E5%AD%98%E5%9C%A8%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    <url>/blog/2021/07/13/js/%E3%80%8C%E7%A1%AC%E6%A0%B8JS%E3%80%8D%E4%BD%A0%E7%9A%84%E7%A8%8B%E5%BA%8F%E4%B8%AD%E5%8F%AF%E8%83%BD%E5%AD%98%E5%9C%A8%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>想来很多同学看到内存泄漏，内心直接会跳出两个字：闭包！！！再让你说点其它的估计就噤声了。如果你对内存泄漏的了解仅限于闭包，那真的是应该仔细看此文了，闭包可能会造成内存泄漏，但是内存泄漏并不是只有闭包，它只是内存泄漏的引子之一罢了。</p><p>写的程序运行一段时间后慢慢变卡甚至要崩溃了?</p><p>如题，你的程序中可能存在内存泄漏，说到内存泄漏，建议先读 <a href="https://github.com/isboyjc/blog/issues/35">「硬核JS」你真的懂垃圾回收机制吗</a> 一文，然后再来看此文会比较通透，毕竟垃圾回收和内存泄漏是因果关系，垃圾被回收了啥事没有，垃圾没被回收就是内存泄漏。</p><p>此文我们会介绍内存泄漏的相关概念和引起内存泄漏的一些问题，还会着重给大家介绍内存泄漏的排查、定位及修复方法（学到即可用到），最后还简单扩展了下前端内存三大件的其他两件内存膨胀和频繁 GC 的概念。</p><h2 id="什么是内存泄漏"><a href="#什么是内存泄漏" class="headerlink" title="什么是内存泄漏"></a>什么是内存泄漏</h2><p>引擎中有垃圾回收机制，它主要针对一些程序中不再使用的对象，对其清理回收释放掉内存。</p><p>那么垃圾回收机制会把不再使用的对象（垃圾）全都回收掉吗？</p><p>其实引擎虽然针对垃圾回收做了各种优化从而尽可能的确保垃圾得以回收，但并不是说我们就可以完全不用关心这块了，我们代码中依然要主动避免一些不利于引擎做垃圾回收操作，因为不是所有无用对象内存都可以被回收的，那当不再用到的对象内存，没有及时被回收时，我们叫它内存泄漏（Memory leak）。</p><h2 id="常见的内存泄漏"><a href="#常见的内存泄漏" class="headerlink" title="常见的内存泄漏"></a>常见的内存泄漏</h2><p>代码不规范，同事两行泪，接下来我们看看会引起内存泄漏的一些常见案例。</p><h3 id="不正当的闭包"><a href="#不正当的闭包" class="headerlink" title="不正当的闭包"></a>不正当的闭包</h3><p>闭包就是函数内部嵌套并 return 一个函数？？？这是大多数人认为的闭包，好吧，它确实也是，我们来看看几本 JS 高光书中的描述：</p><ul><li>JavaScript高级程序设计：闭包是指有权访问另一个函数作用域中的变量的函数</li><li>JavaScript权威指南：从技术的角度讲，所有的JavaScript函数都是闭包：它们都是对象，它们都关联到作用域链</li><li>你不知道的JavaScript：当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行</li></ul><p>按照上面三本书中的描述，那闭包所涉及的的范围就比较广了，我们这里暂时不去纠结闭包的定义，就以最简单、大家都认可的闭包例子来看闭包：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn1</span>(<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-keyword">let</span> test = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">1000</span>).fill(<span class="hljs-string">&#x27;isboyjc&#x27;</span>)<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;hahaha&#x27;</span>)<br>  &#125;<br>&#125;<br><span class="hljs-keyword">let</span> fn1Child = fn1()<br>fn1Child()<br></code></pre></td></tr></table></figure><p>上例是闭包吗？它造成内存泄漏了吗？</p><p>显然它是一个典型闭包，但是它并没有造成内存泄漏，因为返回的函数中并没有对 <code>fn1</code> 函数内部的引用，也就是说，函数 <code>fn1</code> 内部的 <code>test</code> 变量完全是可以被回收的，那我们再来看：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn2</span>(<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-keyword">let</span> test = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">1000</span>).fill(<span class="hljs-string">&#x27;isboyjc&#x27;</span>)<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(test)<br>    <span class="hljs-keyword">return</span> test<br>  &#125;<br>&#125;<br><span class="hljs-keyword">let</span> fn2Child = fn2()<br>fn2Child()<br></code></pre></td></tr></table></figure><p>上例是闭包吗？它造成内存泄漏了吗？</p><p>显然它也是闭包，并且因为 <code>return</code> 的函数中存在函数 <code>fn2</code> 中的 <code>test</code> 变量引用，所以 <code>test</code> 并不会被回收，也就造成了内存泄漏。</p><p>那么怎样解决呢？</p><p>其实在函数调用后，把外部的引用关系置空就好了，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn2</span>(<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-keyword">let</span> test = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">1000</span>).fill(<span class="hljs-string">&#x27;isboyjc&#x27;</span>)<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(test)<br>    <span class="hljs-keyword">return</span> test<br>  &#125;<br>&#125;<br><span class="hljs-keyword">let</span> fn2Child = fn2()<br>fn2Child()<br>fn2Child = <span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><p>“ 减少使用闭包，闭包会造成内存泄漏。。。 ”</p><p>醒醒，这句话是过去式了，它的描述不准确，So，应该说不正当的使用闭包可能会造成内存泄漏。</p><h3 id="隐式全局变量"><a href="#隐式全局变量" class="headerlink" title="隐式全局变量"></a>隐式全局变量</h3><p>我们知道 <code>JavaScript</code> 的垃圾回收是自动执行的，垃圾回收器每隔一段时间就会找出那些不再使用的数据，并释放其所占用的内存空间。</p><p>再来看全局变量和局部变量，函数中的局部变量在函数执行结束后这些变量已经不再被需要，所以垃圾回收器会识别并释放它们。但是对于全局变量，垃圾回收器很难判断这些变量什么时候才不被需要，所以全局变量通常不会被回收，我们使用全局变量是 OK 的，但同时我们要避免一些额外的全局变量产生，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-comment">// 没有声明从而制造了隐式全局变量test1</span><br>  test1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">1000</span>).fill(<span class="hljs-string">&#x27;isboyjc1&#x27;</span>)<br>  <br>  <span class="hljs-comment">// 函数内部this指向window，制造了隐式全局变量test2</span><br>  <span class="hljs-built_in">this</span>.test2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">1000</span>).fill(<span class="hljs-string">&#x27;isboyjc2&#x27;</span>)<br>&#125;<br>fn()<br></code></pre></td></tr></table></figure><p>调用函数 <code>fn</code> ，因为 没有声明 和 函数中this 的问题造成了两个额外的隐式全局变量，这两个变量不会被回收，这种情况我们要尽可能的避免，在开发中我们可以使用严格模式或者通过 <code>lint</code> 检查来避免这些情况的发生，从而降低内存成本。</p><p>除此之外，我们在程序中也会不可避免的使用全局变量，这些全局变量除非被取消或者重新分配之外也是无法回收的，这也就需要我们额外的关注，也就是说当我们在使用全局变量存储数据时，要确保使用后将其置空或者重新分配，当然也很简单，在使用完将其置为 <code>null</code> 即可，特别是在使用全局变量做持续存储大量数据的缓存时，我们一定要记得设置存储上限并及时清理，不然的话数据量越来越大，内存压力也会随之增高。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> test = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">10000</span>)<br><br><span class="hljs-comment">// do something</span><br><br>test = <span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><h3 id="游离DOM引用"><a href="#游离DOM引用" class="headerlink" title="游离DOM引用"></a>游离DOM引用</h3><p>考虑到性能或代码简洁方面，我们代码中进行 DOM 时会使用变量缓存 DOM 节点的引用，但移除节点的时候，我们应该同步释放缓存的引用，否则游离的子树无法释放。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;root&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;ul&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;li3&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">  <span class="hljs-keyword">let</span> root = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#root&#x27;</span>)</span><br><span class="javascript">  <span class="hljs-keyword">let</span> ul = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#ul&#x27;</span>)</span><br><span class="javascript">  <span class="hljs-keyword">let</span> li3 = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#li3&#x27;</span>)</span><br><span class="javascript">  </span><br><span class="javascript">  <span class="hljs-comment">// 由于ul变量存在，整个ul及其子元素都不能GC</span></span><br><span class="javascript">  root.removeChild(ul)</span><br><span class="javascript">  </span><br><span class="javascript">  <span class="hljs-comment">// 虽置空了ul变量，但由于li3变量引用ul的子节点，所以ul元素依然不能被GC</span></span><br><span class="javascript">  ul = <span class="hljs-literal">null</span></span><br><span class="javascript">  </span><br><span class="javascript">  <span class="hljs-comment">// 已无变量引用，此时可以GC</span></span><br><span class="javascript">  li3 = <span class="hljs-literal">null</span></span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>如上所示，当我们使用变量缓存 DOM 节点引用后删除了节点，如果不将缓存引用的变量置空，依然进行不了 GC，也就会出现内存泄漏。</p><p>假如我们将父节点置空，但是被删除的父节点其子节点引用也缓存在变量里，那么就会导致整个父 DOM 节点树下整个游离节点树均无法清理，还是会出现内存泄漏，解决办法就是将引用子节点的变量也置空，如下图：</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20210705152421644.png"></p><h3 id="遗忘的定时器"><a href="#遗忘的定时器" class="headerlink" title="遗忘的定时器"></a>遗忘的定时器</h3><p>程序中我们经常会用到计时器，也就是 <code>setTimeout</code> 和 <code>setInterval</code>，先来看一个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 获取数据</span><br><span class="hljs-keyword">let</span> someResource = getData()<br><span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> node = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;Node&#x27;</span>)<br><span class="hljs-keyword">if</span>(node) &#123;<br>    node.innerHTML = <span class="hljs-built_in">JSON</span>.stringify(someResource))<br>&#125;<br>&#125;, <span class="hljs-number">1000</span>)<br></code></pre></td></tr></table></figure><p>上面是我随便 <code>copy</code> 的一个小例子，其代码中每隔一秒就将得到的数据放入到 <code>Node</code> 节点中去，但是在 <code>setInterval</code> 没有结束前，回调函数里的变量以及回调函数本身都无法被回收。</p><p>什么才叫结束呢？也就是调用了 <code>clearInterval</code>。如果没有被 <code>clear</code> 掉的话，就会造成内存泄漏。不仅如此，如果回调函数没有被回收，那么回调函数内依赖的变量也没法被回收。所以在上例中，<code>someResource</code> 就没法被回收。</p><p>同样，<code>setTiemout</code> 也会有同样的问题，所以，当不需要 <code>interval</code> 或者 <code>timeout</code> 时，最好调用 <code>clearInterval</code> 或者 <code>clearTimeout</code>来清除，另外，浏览器中的 <code>requestAnimationFrame</code> 也存在这个问题，我们需要在不需要的时候用 <code>cancelAnimationFrame</code> API 来取消使用。</p><h3 id="遗忘的事件监听器"><a href="#遗忘的事件监听器" class="headerlink" title="遗忘的事件监听器"></a>遗忘的事件监听器</h3><p>当事件监听器在组件内挂载相关的事件处理函数，而在组件销毁时不主动将其清除时，其中引用的变量或者函数都被认为是需要的而不会进行回收，如果内部引用的变量存储了大量数据，可能会引起页面占用内存过高，这样就造成意外的内存泄漏。</p><p>我们就拿 Vue 组件来举例子，React 里也是一样的：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">  <span class="hljs-function"><span class="hljs-title">created</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">    <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&quot;resize&quot;</span>, <span class="hljs-built_in">this</span>.doSomething)</span><br><span class="javascript">  &#125;,</span><br><span class="javascript">  <span class="hljs-function"><span class="hljs-title">beforeDestroy</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">    <span class="hljs-built_in">window</span>.removeEventListener(<span class="hljs-string">&quot;resize&quot;</span>, <span class="hljs-built_in">this</span>.doSomething)</span><br><span class="javascript">  &#125;,</span><br><span class="javascript">  <span class="hljs-attr">methods</span>: &#123;</span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">doSomething</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">      <span class="hljs-comment">// do something</span></span><br><span class="javascript">    &#125;</span><br><span class="javascript">  &#125;</span><br><span class="javascript">&#125;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="遗忘的监听者模式"><a href="#遗忘的监听者模式" class="headerlink" title="遗忘的监听者模式"></a>遗忘的监听者模式</h3><p>监听者模式想必我们都知道，不管是 Vue 、 React 亦或是其他，对于目前的前端开发框架来说，监听者模式实现一些消息通信都是非常常见的，比如 <code>EventBus</code>. . . </p><p>当我们实现了监听者模式并在组件内挂载相关的事件处理函数，而在组件销毁时不主动将其清除时，其中引用的变量或者函数都被认为是需要的而不会进行回收，如果内部引用的变量存储了大量数据，可能会引起页面占用内存过高，这样也会造成意外的内存泄漏。</p><p>还是用 Vue 组件举例子，因为比较简单：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">  <span class="hljs-function"><span class="hljs-title">created</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">    eventBus.on(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-built_in">this</span>.doSomething)</span><br><span class="javascript">  &#125;,</span><br><span class="javascript">  <span class="hljs-function"><span class="hljs-title">beforeDestroy</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">    eventBus.off(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-built_in">this</span>.doSomething)</span><br><span class="javascript">  &#125;,</span><br><span class="javascript">  <span class="hljs-attr">methods</span>: &#123;</span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">doSomething</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">      <span class="hljs-comment">// do something</span></span><br><span class="javascript">    &#125;</span><br><span class="javascript">  &#125;</span><br><span class="javascript">&#125;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如上，我们只需在 <code>beforeDestroy</code> 组件销毁生命周期里将其清除即可。</p><h3 id="遗忘的Map、Set对象"><a href="#遗忘的Map、Set对象" class="headerlink" title="遗忘的Map、Set对象"></a>遗忘的Map、Set对象</h3><p>当使用 <code>Map</code> 或 <code>Set</code> 存储对象时，同 <code>Object</code> 一致都是强引用，如果不将其主动清除引用，其同样会造成内存不自动进行回收。</p><p>如果使用 <code>Map</code> ，对于键为对象的情况，可以采用 <code>WeakMap</code>，<code>WeakMap</code> 对象同样用来保存键值对，对于键是弱引用（注：<code>WeakMap</code> 只对于键是弱引用），且必须为一个对象，而值可以是任意的对象或者原始值，由于是对于对象的弱引用，不会干扰 <code>Js</code> 的垃圾回收。</p><p>如果需要使用 <code>Set</code> 引用对象，可以采用 <code>WeakSet</code>，<code>WeakSet</code> 对象允许存储对象弱引用的唯一值，<code>WeakSet</code> 对象中的值同样不会重复，且只能保存对象的弱引用，同样由于是对于对象的弱引用，不会干扰 <code>Js</code> 的垃圾回收。</p><p>这里可能需要简单介绍下，谈弱引用，我们先来说强引用，之前我们说 JS 的垃圾回收机制是如果我们持有对一个对象的引用，那么这个对象就不会被垃圾回收，这里的引用，指的就是 <code>强引用</code> ，而弱引用就是一个对象若只被弱引用所引用，则被认为是不可访问（或弱可访问）的，因此可能在任何时刻被回收。</p><p>不明白？来看例子就晓得了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// obj是一个强引用，对象存于内存，可用</span><br><span class="hljs-keyword">let</span> obj = &#123;<span class="hljs-attr">id</span>: <span class="hljs-number">1</span>&#125;<br><br><span class="hljs-comment">// 重写obj引用</span><br>obj = <span class="hljs-literal">null</span> <br><span class="hljs-comment">// 对象从内存移除，回收 &#123;id: 1&#125; 对象</span><br></code></pre></td></tr></table></figure><p>上面是一个简单的通过重写引用来清除对象引用，使其可回收。</p><p>再看下面这个：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = &#123;<span class="hljs-attr">id</span>: <span class="hljs-number">1</span>&#125;<br><span class="hljs-keyword">let</span> user = &#123;<span class="hljs-attr">info</span>: obj&#125;<br><span class="hljs-keyword">let</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([obj])<br><span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([[obj, <span class="hljs-string">&#x27;hahaha&#x27;</span>]])<br><br><span class="hljs-comment">// 重写obj</span><br>obj = <span class="hljs-literal">null</span> <br><br><span class="hljs-built_in">console</span>.log(user.info) <span class="hljs-comment">// &#123;id: 1&#125;</span><br><span class="hljs-built_in">console</span>.log(set)<br><span class="hljs-built_in">console</span>.log(map)<br></code></pre></td></tr></table></figure><p>此例我们重写 <code>obj</code> 以后，<code>&#123;id: 1&#125;</code> 依然会存在于内存中，因为 <code>user</code> 对象以及后面的 <code>set/map</code> 都强引用了它，Set/Map、对象、数组对象等都是强引用，所以我们仍然可以获取到 <code>&#123;id: 1&#125;</code> ，我们想要清除那就只能重写所有引用将其置空了。</p><p>接下来我们看 <code>WeakMap</code> 以及 <code>WeakSet</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = &#123;<span class="hljs-attr">id</span>: <span class="hljs-number">1</span>&#125;<br><span class="hljs-keyword">let</span> weakSet = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakSet</span>([obj])<br><span class="hljs-keyword">let</span> weakMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>([[obj, <span class="hljs-string">&#x27;hahaha&#x27;</span>]])<br><br><span class="hljs-comment">// 重写obj引用</span><br>obj = <span class="hljs-literal">null</span><br><br><span class="hljs-comment">// &#123;id: 1&#125; 将在下一次 GC 中从内存中删除</span><br></code></pre></td></tr></table></figure><p>如上所示，使用了 <code>WeakMap</code> 以及 <code>WeakSet</code> 即为弱引用，将 <code>obj</code> 引用置为 <code>null</code> 后，对象 <code>&#123;id: 1&#125;</code> 将在下一次 GC 中被清理出内存。</p><h3 id="未清理的Console输出"><a href="#未清理的Console输出" class="headerlink" title="未清理的Console输出"></a>未清理的Console输出</h3><p>写代码的过程中，肯定避免不了一些输出，在一些小团队中可能项目上线也不清理这些 <code>console</code>，殊不知这些 <code>console</code> 也是隐患，同时也是容易被忽略的，我们之所以在控制台能看到数据输出，是因为浏览器保存了我们输出对象的信息数据引用，也正是因此未清理的 <code>console</code> 如果输出了对象也会造成内存泄漏。</p><p>所以，开发环境下我们可以使用控制台输出来便于我们调试，但是在生产环境下，一定要及时清理掉输出。</p><p>可能有同学会觉得不可思议，甚至不相信，这里我们留一个例子，大家看完文章刚好可以自己测试一下（如何测试看完下文就明白啦！）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;click&quot;</span>&gt;</span>click<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">    !<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Test</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">        <span class="hljs-built_in">this</span>.init()</span><br><span class="javascript">      &#125;</span><br><span class="javascript">      Test.prototype.init = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">        <span class="hljs-built_in">this</span>.a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">10000</span>).fill(<span class="hljs-string">&#x27;isboyjc&#x27;</span>)</span><br><span class="javascript">        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>)</span><br><span class="javascript">      &#125;</span><br><span class="javascript"></span><br><span class="javascript">      <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#click&#x27;</span>).onclick = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">        <span class="hljs-keyword">new</span> Test();</span><br><span class="javascript">      &#125;</span><br><span class="javascript">    &#125;()</span><br><span class="javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="内存泄漏排查、定位与修复"><a href="#内存泄漏排查、定位与修复" class="headerlink" title="内存泄漏排查、定位与修复"></a>内存泄漏排查、定位与修复</h2><p>正如开头所说，程序运行一段时间后慢慢变卡甚至要崩溃了，不知道是什么原因，那我们就通过一个例子来走一遍排查、定位以及修复内存泄漏的整个流程，敲黑板，这是大家真正能够用上的。</p><p>既然上面我们说了几个会造成内存泄漏的案例，那我们就用这些案例写个 <code>Demo</code> 来从浏览器的角度反推排查是否存在内存泄漏，存在的话定位泄漏源并给予修复。</p><p>首先，我们来捏造一个内存泄漏例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;click&quot;</span>&gt;</span>click<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">    <span class="hljs-keyword">let</span> click = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;#click&quot;</span>);</span><br><span class="javascript">    <span class="hljs-keyword">let</span> content = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;#content&quot;</span>)</span><br><span class="javascript">    <span class="hljs-keyword">let</span> arr = []</span><br><span class="javascript"></span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">closures</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">      <span class="hljs-keyword">let</span> test = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">1000</span>).fill(<span class="hljs-string">&#x27;isboyjc&#x27;</span>)</span><br><span class="javascript"></span><br><span class="javascript">      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">        <span class="hljs-keyword">return</span> test</span><br><span class="javascript">      &#125;</span><br><span class="javascript">    &#125;</span><br><span class="javascript"></span><br><span class="javascript">    click.addEventListener(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">      arr.push(closures())</span><br><span class="javascript">      arr.push(closures())</span><br><span class="javascript"></span><br><span class="javascript">      content.innerHTML = arr.length</span><br><span class="javascript">    &#125;);</span><br><span class="javascript"></span><br><span class="javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如上所示，这是一个非常简单的由不正当使用闭包构成的内存泄漏例子。</p><p>我们先来简单介绍下，只看 <code>script</code> 中的 JS 代码即可，首先，我们有一个 <code>closures</code> 函数，这是一个闭包函数，最简单的闭包函数想必不用向大家介绍了吧，然后我们为页面中的 <code>button</code> 元素绑定了一个点击事件，每次点击都将执行 2 次闭包函数并将其执行结果 <code>push</code> 到全局数组 <code>arr</code> 中，由于闭包函数执行结果也是一个函数并且存在对原闭包函数内部数组 <code>test</code> 的引用，所以 <code>arr</code> 数组中每一项元素都使得其引用的闭包内部 <code>test</code> 数组对象无法回收，<code>arr</code> 数组有多少元素，也就代表着我们存在多少次闭包引用，所以此程序点击次数越多，<code>push</code> 的越多，内存消耗越大，页面也会越来越卡。</p><p>那为了便于后期观察，程序中我们在每次点击按钮后，都把全局数组 <code>arr</code> 的长度数据更新到了页面上，即从 0 开始，每点击一次，页面数值加 2。</p><p>当然，这是我们自己写的例子，作为上帝的我们知道是什么原因导致的，那现在，忘掉这些，假设这是我们的一个项目程序，开发完成交付给测试，测试小姐姐发现在程序中不断点击按钮后页面越来越迟钝了，随即提了BUG。</p><p>作为程序员的我们肯定是：“刷新下页面不就好了，卡了就刷新刷新！！！”</p><p>嗯。。。产品和测试肯定都不会答应，一句用户至上就让我们改。。</p><p>行吧，那就改，首先第一步就要排查是哪里出了问题、是什么引起的，那此环节我们就叫排查问题阶段好了。</p><h3 id="排查问题"><a href="#排查问题" class="headerlink" title="排查问题"></a>排查问题</h3><p><code>Chrome</code> 的开发者工具也就是我们所说的浏览器控制台（<code>Chrome Devtool</code> ）功能其实十分强大，通过它可以帮助我们分析程序中像性能、安全、网络等各种东西，也可以让我们快速定位到问题源，只是大多数人并不熟悉其使用而已。</p><p>由于此文我们以内存泄漏为主，那我们就默认上述程序已经排查了除内存之外所有项且都没问题，接下来开始排查内存这块。</p><p>首先我们开启浏览器的无痕模式，接着打开要检查的网页程序代码，然后打开控制台，整个程序界面非常简单，如下图：</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20210706185132675.png"></p><p>接着我们找到 <code>Performance</code> 这一面板，之前叫 <code>Timeline</code> ，它是 <code>Chrome Devtool</code> 用来监控性能指标的一个利器，可以记录并分析在网站的生命周期内所发生的各类事件，我们就可以通过它监控我们程序中的各种性能情况并分析，其中就包括内存，如下图：</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20210706185736718.png"></p><p>接下来开始操作，在开始之前一定要确认勾选了 <code>Memory</code> 选项也就是上图标记 5 ，这样我们才可以看到内存相关的分析。</p><p>点击开始录制（标记 1）进入录制状态，随后先清理一下GC，也就是点击小垃圾桶（标记 6）。</p><p>接着疯狂点击页面中 <code>click</code> 按钮 100 次，这时页面上的数值应该是 200，我们再点击一下小垃圾桶，手动触发一次 GC。</p><p>再次疯狂点击页面中 <code>click</code> 按钮 100 次，这时页面上的数值应该是 400，然后停止录制。</p><p>我们来观察控制台生成的数据面板，如下图：</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20210707012650490.png"></p><p>上面圈红的两块，也就是 <code>Heap</code> 对应的部分表示内存在周期性的回落，简单说就是我们的内存情况。</p><p>我们可以很明显的看到，内存数据呈现出一个不断上涨的趋势，可能有人会说这段时间内是不是还没执行 GC 呢？别急，还记得我们在 200 的时候点击了一下小垃圾桶吗，也就是我们中间手动触发垃圾回收一次，我们就可以通过上面的页面快照找出当页面值为 200 的那一刻在哪里，很简单，鼠标移到内存快照上找就行了，如下图：</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20210707013517909.png"></p><p>可以看到，即使我们中间手动做了一次垃圾回收操作，但清理后的内存并没有减少很多，由此我们推断，此程序的点击操作可能存在内存泄漏。</p><p>OK，排查到问题了，那接下来就是定位泄漏源在哪了。</p><p>你可能会说，既然已经找到问题所在就是点击事件了，直接去改不就完了？</p><p>要知道，这是我们写的一个简单的例子，我们一下子就可以看出问题在哪，但是真实项目中一个点击事件里就可能存在大量操作，而我们只知道点击事件可能导致了内存泄漏，但不知道具体问题是在点击事件的哪一步骤上，更加细粒度的引起原因和位置我们也不知，这些都还需要我们进一步分析去定位。</p><h3 id="分析定位"><a href="#分析定位" class="headerlink" title="分析定位"></a>分析定位</h3><p>接下来我们开始分析定位泄漏源</p><p><code>Chrome Devtool</code> 还为我们提供了 <code>Memory</code> 面板，它可以为我们提供更多详细信息，比如记录 JS CPU 执行时间细节、显示 JS 对象和相关的DOM节点的内存消耗、记录内存的分配细节等。</p><p>其中的 <code>Heap Profiling</code> 可以记录当前的堆内存 <code>heap</code> 的快照，并生成对象的描述文件，该描述文件给出了当下 JS 运行所用的所有对象，以及这些对象所占用的内存大小、引用的层级关系等等，用它就可以定位出引起问题的具体原因以及位置。</p><p>注意，可不是 <code>Performance</code> 面板下那个 <code>Memory</code> ，而是与 <code>Performance</code> 面板同级的 <code>Memory</code> 面板，如下图：</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20210707015743645.png"></p><p>现在页面值为 400，当然也可以刷新一下页面从 0 开始，这里我们选择继续操作</p><p>首先点击一下小垃圾桶（标记 3），触发一下 GC，把没用的东西从内存中干掉</p><p>点击开始生成快照（标记 1），生成第一次快照并选中，如下图：</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20210707020531923.png"></p><p>简单介绍小上图大概表示的什么意思：</p><p>左侧列表中的 <code>Snapshot 1</code> 代表了我们生成的快照1，也就是刚刚那一刻的内存状态</p><p>选中 <code>Snapshot 1</code> 后就是右侧视图表格了，表格左上方有一个下拉框，它有四个值</p><ul><li>Summary：按照构造函数进行分组，捕获对象和其使用内存的情况，可理解为一个内存摘要，用于跟踪定位DOM节点的内存泄漏</li><li>Comparison：对比某个操作前后的内存快照区别，分析操作前后内存释放情况等，便于确认内存是否存在泄漏及造成原因</li><li>Containment：探测堆的具体内容，提供一个视图来查看对象结构，有助分析对象引用情况，可分析闭包及更深层次的对象分析</li><li>Statistics：统计视图</li></ul><p>该下拉默认会为我们选择 <code>Summary</code> ，所以下方表格展示的就是快照1中数据的内存摘要，简单理解就是快照1生成的那一刻，内存中都存了什么，包括占用内存的信息等等。</p><p>来简单了解下 <code>Summary</code> 选项数据表格的列都表示什么</p><ul><li>Constructor：显示所有的构造函数，点击每一个构造函数可以查看由该构造函数创建的所有对象</li><li>Distance：显示通过最短的节点路径到根节点的距离，引用层级</li><li>Shallow Size：显示对象所占内存，不包含内部引用的其他对象所占的内存</li><li>Retained Size：显示对象所占的总内存，包含内部引用的其他对象所占的内存</li></ul><p>OK，暂时知道这么多就可以了，我们继续操作，先点击小垃圾桶手动执行一次GC，然后点击 1 下页面的 <code>click</code> 按钮，最后再次点击生成快照按钮，生成我们的第二次快照。</p><p>为了准确无误，我们多来几次操作，如下：</p><p>先点击小垃圾桶手动执行一次 GC，然后点击 2 下页面的 <code>click</code> 按钮，最后再次点击生成快照按钮，生成我们的第三次快照</p><p>先点击小垃圾桶手动执行一次 GC，然后点击 3 下页面的 <code>click</code> 按钮，最后再次点击生成快照按钮，生成我们的第四次快照</p><p>随后，我们选中快照2，并将其上面的下拉框由默认的 <code>Summary</code> 选项切换为 <code>comparison</code> 选项，也就是对比当前快照与之前一次快照的内存区别，如下图：</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20210707025409871.png"></p><p>我们再来看看选择 <code>Comparison</code> 下拉后，下方的表格列代表着什么，这里介绍几个重要的</p><ul><li>New：新建了多少个对象</li><li>Deleted：回收了多少个对象</li><li>Delta：新建的对象数 减去 回收的对象数</li></ul><p>诶，到这我们就有点那味儿了，我们需要重点关注 <code>Delta</code> ，只要它是正数就可能存在问题，贴心的控制台都已经给我们排好序了，最上面的几个我们依次看就可以。</p><p>当然，我们还需要知道这每一行的数据都代表的是什么，注意力转移到 <code>Constructor</code> 这一列，我们也说过，此列是构造函数，每一个构造函数点击都可以查看由该构造函数创建的所有对象，还是要先介绍下此列中常见的构造函数大致代表什么</p><ul><li>system、system/Context 表示引擎自己创建的以及上下文创建的一些引用，这些不用太关注，不重要</li><li>closure 表示一些函数闭包中的对象引用</li><li>array、string、number、regexp 这一系列也能看出，就是引用了数组、字符串、数字或正则表达式的对象类型</li><li>HTMLDivElement、HTMLAnchorElement、DocumentFragment等等这些其实就是你的代码中对元素的引用或者指定的 DOM 对象引用</li></ul><p>诶，又清晰了很多，那接下来我们就可以依次对比 <code>1-&gt;2 / 2-&gt;3 / 3-&gt;4</code> 来看到底哪里有问题了。</p><p>别着急，想一下现在的我们要怎么做？需要单独的点击一个快照再选中 <code>comparison</code> ，然后看 <code>Delta</code> 列为正数的项再进行分析，这样的操作需要进行 3 次，因为我们有 4 个快照，需要对比分析 3 次，甚至有时候可能生成的快照更多以此来确保准确性。</p><p>有没有更简单的方式呢？有的，我们可以直接选中要对比的快照，右侧表格上还有一个弹框我们可以直接选择快照进行对比，并且还会贴心的为我们过滤掉一些没用的信息：</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20210707032902842.png"></p><p>我们来进行实际操作，左侧选中快照2，选择 <code>快照1</code> 与<code> 快照2</code> 进行对比分析，结果如下：</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20210707033315817.png"></p><p>可以看到，列表中只剩下对比过滤后的 4 项差异</p><p><code>system/Context</code> 我们无需关心。</p><p><code>closure</code> 上面也说过代表闭包引用，我们点击此项看一下具体的信息：</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20210707033805351.png"></p><p>可以看到， <code>closure</code> 下有两个引用，还贴心的为我们指出了在代码的 <code>21</code> 行，点击选中其中一个引用，下方还有更详细的信息展示。</p><p>为什么展开后是两个引用？还记得我们在生成 <code>快照2</code> 时的操作吗，手动执行了一次 GC 并点击了一次 <code>click</code> 按钮，触发了一次点击事件，点击事件中我们执行并 <code>push</code> 了两次闭包函数，所以就是 2 条记录。</p><p>最后我们看 <code>array</code> ，这里存在数组的引用是完全因为我们案例代码中那个全局数组变量 <code>arr</code> 的存在，毕竟每次点击都 <code>push</code> 数据呢，这也是我们上面提到的为什么要额外关注全局变量的使用、要将它及时清理什么的，就是因为像这种情况你不清理的话这些全局变量在页面关闭前就一直在内存里，可能大家对构造函数列中有 2 项都是数组有疑问，其实没毛病，一项代表的是 <code>arr</code> 本身，一项代表的是闭包内部引用的数组变量 <code>test</code> （忘了的话回顾一下上面案例代码），这点也可以通过 <code>Distance</code> 列中表示的引用层级来 GET，一个层级是 7，一个层级是 8。至于数组引起泄漏的代码位置我们也可以点击展开并选中其引用条目，详情里就可以看到代码位置，同上面闭包一样的操作，这里就不演示了。</p><p>诶，那好像就知道具体的泄漏源了，我们再次证实一下，左侧选中快照4，选择 <code>快照3</code> 与<code>快照4</code> 进行对比分析，快照4 前我们做的操作是手动执行了一次 GC 并点击了三次 <code>click</code> 按钮，如果上述结论正确的话，应该同我们上面 <code>快照1</code> 和<code>快照2</code> 对比结果的数据项一致都是 4 项，但是每项的内部引用会是 6 条，因为这次快照前我们点击了三次按钮，每次执行并 <code>push</code> 了两次闭包函数，来看结果：</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20210707041841176.png" alt="image-20210707041841176"></p><p>嗯，到这里一切好像变得清晰明朗了，问题一共有 2 个，一是代码 21 行的闭包引用数组造成的内存泄漏，二是全局变量 <code>arr</code> 的元素不断增多造成的内存泄漏。</p><p>分析定位成功，进入下一步骤，修复并再次验证。</p><h3 id="修复验证"><a href="#修复验证" class="headerlink" title="修复验证"></a>修复验证</h3><p>由于这是临时写的一个案例，没有具体的场景，所以也就没有办法使用针对性的方式来修复，So，此步骤暂时忽略，不过在项目中我们还是要解决的。</p><p>比如全局对象一直增大这个问题，全局对象我们无法避免，但是可以限制一下全局对象的大小，根据场景可以超出就清理一部分。</p><p>比如闭包引用的问题，不让它引用，或者执行完置空，这都是上面说过的。</p><p>总之，一切都需要根据具体场景选择解决方案，解决之后重复上面排查流程看内存即可。</p><h2 id="内存三大件"><a href="#内存三大件" class="headerlink" title="内存三大件"></a>内存三大件</h2><p>其实前端关于内存方面主要有三个问题，我把它们亲切的称作内存三大件：</p><p><code>内存泄漏</code> 我们说很久了，对象已经不再使用但没有被回收，内存没有被释放，即内存泄漏，那想要避免就避免让无用数据还存在引用关系，也就是多注意我们上面说的常见的几种内存泄漏的情况。</p><p><code>内存膨胀</code> 即在短时间内内存占用极速上升到达一个峰值，想要避免需要使用技术手段减少对内存的占用。</p><p><code>频繁 GC</code> 同这个名字，就是 GC 执行的特别频繁，一般出现在频繁使用大的临时变量导致新生代空间被装满的速度极快，而每次新生代装满时就会触发 GC，频繁 GC 同样会导致页面卡顿，想要避免的话就不要搞太多的临时变量，因为临时变量不用了就会被回收，这和我们内存泄漏中说避免使用全局变量冲突，其实，只要把握好其中的度，不太过分就 OK。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>如果你的程序运行出现卡顿却找不到原因，那不妨试试本文的排查方法吧，说不定就是内存泄漏引起的，同时，它也是我们在做页面优化时需要额外注意的一个点。</p><p>今天就到这里了，你 GET 到了吗？欢迎指误堪错！写作不易，动动小手点个赞吧，收藏吃灰是大忌 👊</p>]]></content>
    
    
    <categories>
      
      <category>硬核JS系列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>内存泄漏</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「硬核JS」你真的了解垃圾回收机制吗</title>
    <link href="/blog/2021/07/06/js/%E3%80%8C%E7%A1%AC%E6%A0%B8JS%E3%80%8D%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%90%97/"/>
    <url>/blog/2021/07/06/js/%E3%80%8C%E7%A1%AC%E6%A0%B8JS%E3%80%8D%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%90%97/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>我们知道垃圾回收机制是引擎来做的，JS引擎有很多种（各个浏览器都不同），其垃圾回收机制在一些细节及优化上略有不同，本文我们以一些通用的回收算法作为切入，再由 V8 引擎发展至今对该机制的优化为例（为什么以 V8 为例？因为它市场占有率大 😄），一步一步深入来助我们了解垃圾回收机制，因为只有真正了解垃圾回收机制，后面才能理解内存泄漏的问题以及手动预防和优化</p><p>JavaScript 是门魅力无限的语言，关于它的 GC（垃圾回收）方面，你了解多少呢？想来大部分人是因为面试才去看一些面试题从而了解的垃圾回收，那在正式开始之前，给大家列几个小问题，大家可以先想一下答案，带着问题及答案再去看文章，最后读完此文如果你的答案可以优化，即有收获</p><p>什么是垃圾回收机制？</p><p>垃圾是怎样产生的？</p><p>为什么要进行垃圾回收？</p><p>垃圾回收是怎样进行的？</p><p>V8 引擎对垃圾回收进行了哪些优化？</p><p>当然，我们可不仅仅是为了面试，其目的是一次性彻底搞懂 GC！假如你对其中某块内容不太理解，不要着急，先读完整篇文章了解内容再回过头来仔细看一遍就会清晰很多，干货满满，先赞后看哦</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20210626153042478.png"></p><h2 id="GC是什么"><a href="#GC是什么" class="headerlink" title="GC是什么"></a>GC是什么</h2><p><code>GC</code> 即 <code>Garbage Collection</code> ，程序工作过程中会产生很多 <code>垃圾</code>，这些垃圾是程序不用的内存或者是之前用过了，以后不会再用的内存空间，而 <code>GC</code> 就是负责回收垃圾的，因为他工作在引擎内部，所以对于我们前端来说，<code>GC</code> 过程是相对比较无感的，这一套引擎执行而对我们又相对无感的操作也就是常说的 <code>垃圾回收机制</code> 了</p><p>当然也不是所有语言都有 <code>GC</code>，一般的高级语言里面会自带 <code>GC</code>，比如 <code>Java、Python、JavaScript</code> 等，也有无 <code>GC</code> 的语言，比如 <code>C、C++</code> 等，那这种就需要我们程序员手动管理内存了，相对比较麻烦</p><h2 id="垃圾产生-amp-为何回收"><a href="#垃圾产生-amp-为何回收" class="headerlink" title="垃圾产生&amp;为何回收"></a>垃圾产生&amp;为何回收</h2><p>我们知道写代码时创建一个基本类型、对象、函数……都是需要占用内存的，但是我们并不关注这些，因为这是引擎为我们分配的，我们不需要显式手动的去分配内存</p><p>但是，你有没有想过，当我们不再需要某个东西时会发生什么？JavaScript 引擎又是如何发现并清理它的呢？</p><p>我们举个简单的例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> test = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;isboyjc&quot;</span><br>&#125;;<br>test = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure><p>如上所示，我们假设它是一个完整的程序代码</p><p>我们知道 <code>JavaScript</code> 的引用数据类型是保存在堆内存中的，然后在栈内存中保存一个对堆内存中实际对象的引用，所以，<code>JavaScript</code> 中对引用数据类型的操作都是操作对象的引用而不是实际的对象。可以简单理解为，栈内存中保存了一个地址，这个地址和堆内存中的实际值是相关的</p><p>那上面代码首先我们声明了一个变量 <code>test</code>，它引用了对象 <code>&#123;name: &#39;isboyjc&#39;&#125;</code>，接着我们把这个变量重新赋值了一个数组对象，也就变成了该变量引用了一个数组，那么之前的对象引用关系就没有了，如下图</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20210601204158061.png"></p><p>没有了引用关系，也就是无用的对象，这个时候假如任由它搁置，一个两个还好，多了的话内存也会受不了，所以就需要被清理（回收）</p><p>用官方一点的话说，程序的运行需要内存，只要程序提出要求，操作系统或者运行时就必须提供内存，那么对于持续运行的服务进程，必须要及时释放内存，否则，内存占用越来越高，轻则影响系统性能，重则就会导致进程崩溃</p><h2 id="垃圾回收策略"><a href="#垃圾回收策略" class="headerlink" title="垃圾回收策略"></a>垃圾回收策略</h2><p>在 JavaScript 内存管理中有一个概念叫做 <code>可达性</code>，就是那些以某种方式可访问或者说可用的值，它们被保证存储在内存中，反之不可访问则需回收</p><p>至于如何回收，其实就是怎样发现这些不可达的对象（垃圾）它并给予清理的问题， <code>JavaScript</code> 垃圾回收机制的原理说白了也就是定期找出那些不再用到的内存（变量），然后释放其内存</p><p>你可能还会好奇为什么不是实时的找出无用内存并释放呢？其实很简单，实时开销太大了</p><p>我们都可以 Get 到这之中的重点，那就是怎样找出所谓的垃圾？</p><p>这个流程就涉及到了一些算法策略，有很多种方式，我们简单介绍两个最常见的</p><ul><li>标记清除算法</li><li>引用计数算法</li></ul><h3 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h3><p><strong>策略</strong> </p><p>标记清除（Mark-Sweep），目前在 <code>JavaScript引擎</code> 里这种算法是最常用的，到目前为止的大多数浏览器的 <code>JavaScript引擎</code> 都在采用标记清除算法，只是各大浏览器厂商还对此算法进行了优化加工，且不同浏览器的 <code>JavaScript引擎</code> 在运行垃圾回收的频率上有所差异</p><p>就像它的名字一样，此算法分为 <code>标记</code> 和 <code>清除</code> 两个阶段，标记阶段即为所有活动对象做上标记，清除阶段则把没有标记（也就是非活动对象）销毁</p><p>你可能会疑惑怎么给变量加标记？其实有很多种办法，比如当变量进入执行环境时，反转某一位（通过一个二进制字符来表示标记），又或者可以维护进入环境变量和离开环境变量这样两个列表，可以自由的把变量从一个列表转移到另一个列表，当前还有很多其他办法。其实，怎样标记对我们来说并不重要，重要的是其策略</p><p>引擎在执行 GC（使用标记清除算法）时，需要从出发点去遍历内存中所有的对象去打标记，而这个出发点有很多，我们称之为一组 <code>根</code> 对象，而所谓的根对象，其实在浏览器环境中包括又不止于 <code>全局Window对象</code>、<code>文档DOM树</code> 等 </p><p>整个标记清除算法大致过程就像下面这样</p><ul><li>垃圾收集器在运行时会给内存中的所有变量都加上一个标记，假设内存中所有对象都是垃圾，全标记为0</li><li>然后从各个根对象开始遍历，把不是垃圾的节点改成1</li><li>清理所有标记为0的垃圾，销毁并回收它们所占用的内存空间</li><li>最后，把所有内存中对象标记修改为0，等待下一轮垃圾回收</li></ul><p><strong>优点</strong> </p><p>标记清除算法的优点只有一个，那就是实现比较简单，打标记也无非打与不打两种情况，这使得一位二进制位（0和1）就可以为其标记，非常简单</p><p><strong>缺点</strong> </p><p>标记清除算法有一个很大的缺点，就是在清除之后，剩余的对象内存位置是不变的，也会导致空闲内存空间是不连续的，出现了 <code>内存碎片</code>（如下图），并且由于剩余空闲内存不是一整块，它是由不同大小内存组成的内存列表，这就牵扯出了内存分配的问题</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20210610181159717.png"></p><p>假设我们新建对象分配内存时需要大小为 <code>size</code>，由于空闲内存是间断的、不连续的，则需要对空闲内存列表进行一次单向遍历找出大于等于 <code>size</code> 的块才能为其分配（如下图）</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20210610180729906.png"></p><p>那如何找到合适的块呢？我们可以采取下面三种分配策略</p><ul><li><p><code>First-fit</code>，找到大于等于 <code>size</code> 的块立即返回</p></li><li><p><code>Best-fit</code>，遍历整个空闲列表，返回大于等于 <code>size</code> 的最小分块</p></li><li><p><code>Worst-fit</code>，遍历整个空闲列表，找到最大的分块，然后切成两部分，一部分 <code>size</code> 大小，并将该部分返回</p></li></ul><p>这三种策略里面 <code>Worst-fit</code> 的空间利用率看起来是最合理，但实际上切分之后会造成更多的小块，形成内存碎片，所以不推荐使用，对于 <code>First-fit</code> 和 <code>Best-fit</code> 来说，考虑到分配的速度和效率 <code>First-fit</code> 是更为明智的选择</p><p>综上所述，标记清除算法或者说策略就有两个很明显的缺点</p><ul><li><strong>内存碎片化</strong>，空闲内存块是不连续的，容易出现很多空闲内存块，还可能会出现分配所需内存过大的对象时找不到合适的块</li><li><strong>分配速度慢</strong>，因为即便是使用 <code>First-fit</code> 策略，其操作仍是一个 <code>O(n)</code> 的操作，最坏情况是每次都要遍历到最后，同时因为碎片化，大对象的分配效率会更慢</li></ul><p><strong>PS：标记清除算法的缺点补充</strong></p><p>归根结底，标记清除算法的缺点在于清除之后剩余的对象位置不变而导致的空闲内存不连续，所以只要解决这一点，两个缺点都可以完美解决了</p><p>而 <strong>标记整理（Mark-Compact）算法</strong> 就可以有效地解决，它的标记阶段和标记清除算法没有什么不同，只是标记结束后，标记整理算法会将活着的对象（即不需要清理的对象）向内存的一端移动，最后清理掉边界的内存（如下图）</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20210610181744171.png"></p><h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><p><strong>策略</strong> </p><p>引用计数（Reference Counting），这其实是早先的一种垃圾回收算法，它把 <code>对象是否不再需要</code> 简化定义为 <code>对象有没有其他对象引用到它</code>，如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收，目前很少使用这种算法了，因为它的问题很多，不过我们还是需要了解一下</p><p>它的策略是跟踪记录每个变量值被使用的次数</p><ul><li><p>当声明了一个变量并且将一个引用类型赋值给该变量的时候这个值的引用次数就为 1</p></li><li><p>如果同一个值又被赋给另一个变量，那么引用数加 1</p></li><li><p>如果该变量的值被其他的值覆盖了，则引用次数减 1</p></li><li><p>当这个值的引用次数变为 0 的时候，说明没有变量在使用，这个值没法被访问了，回收空间，垃圾回收器会在运行的时候清理掉引用次数为 0 的值占用的内存</p></li></ul><p>如下例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>() <span class="hljs-comment">// 此对象的引用计数为 1（a引用）</span><br><span class="hljs-keyword">let</span> b = a <span class="hljs-comment">// 此对象的引用计数是 2（a,b引用）</span><br>a = <span class="hljs-literal">null</span>  <span class="hljs-comment">// 此对象的引用计数为 1（b引用）</span><br>b = <span class="hljs-literal">null</span>  <span class="hljs-comment">// 此对象的引用计数为 0（无引用）</span><br>...<span class="hljs-comment">// GC 回收此对象</span><br></code></pre></td></tr></table></figure><p>这种方式是不是很简单？确实很简单，不过在引用计数这种算法出现没多久，就遇到了一个很严重的问题——循环引用，即对象 A 有一个指针指向对象 B，而对象 B 也引用了对象 A ，如下面这个例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-keyword">let</span> A = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>()<br>  <span class="hljs-keyword">let</span> B = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>()<br>  <br>  A.b = B<br>  B.a = A<br>&#125;<br></code></pre></td></tr></table></figure><p>如上所示，对象 A 和 B 通过各自的属性相互引用着，按照上文的引用计数策略，它们的引用数量都是 2，但是，在函数 <code>test</code> 执行完成之后，对象 A 和 B 是要被清理的，但使用引用计数则不会被清理，因为它们的引用数量不会变成 0，假如此函数在程序中被多次调用，那么就会造成大量的内存不会被释放</p><p>我们再用标记清除的角度看一下，当函数结束后，两个对象都不在作用域中，A 和 B 都会被当作非活动对象来清除掉，相比之下，引用计数则不会释放，也就会造成大量无用内存占用，这也是后来放弃引用计数，使用标记清除的原因之一</p><blockquote><p>在 IE8 以及更早版本的 IE 中，<code>BOM</code> 和 <code>DOM</code> 对象并非是原生 <code>JavaScript</code> 对象，它是由 <code>C++</code> 实现的 <code>组件对象模型对象（COM，Component Object Model）</code>，而 <code>COM</code> 对象使用 引用计数算法来实现垃圾回收，所以即使浏览器使用的是标记清除算法，只要涉及到 <code> COM</code> 对象的循环引用，就还是无法被回收掉，就比如两个互相引用的 <code>DOM</code> 对象等等，而想要解决循环引用，需要将引用地址置为 <code>null</code> 来切断变量与之前引用值的关系，如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// COM对象</span><br><span class="hljs-keyword">let</span> ele = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;xxx&quot;</span>)<br><span class="hljs-keyword">let</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>()<br><br><span class="hljs-comment">// 造成循环引用</span><br>obj.ele = ele<br>ele.obj = obj<br><br><span class="hljs-comment">// 切断引用关系</span><br>obj.ele = <span class="hljs-literal">null</span><br>ele.obj = <span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><p>不过在 IE9 及以后的 <code>BOM</code> 与 <code>DOM</code> 对象都改成了 <code>JavaScript</code> 对象，也就避免了上面的问题</p><p>此处参考 JavaScript高级程序设计第四版 4.3.2 小节</p></blockquote><p><strong>优点</strong> </p><p>引用计数算法的优点我们对比标记清除来看就会清晰很多，首先引用计数在引用值为 0 时，也就是在变成垃圾的那一刻就会被回收，所以它可以立即回收垃圾</p><p>而标记清除算法需要每隔一段时间进行一次，那在应用程序（JS脚本）运行过程中线程就必须要暂停去执行一段时间的 <code>GC</code>，另外，标记清除算法需要遍历堆里的活动以及非活动对象来清除，而引用计数则只需要在引用时计数就可以了</p><p><strong>缺点</strong> </p><p>引用计数的缺点想必大家也都很明朗了，首先它需要一个计数器，而此计数器需要占很大的位置，因为我们也不知道被引用数量的上限，还有就是无法解决循环引用无法回收的问题，这也是最严重的</p><h2 id="V8对GC的优化"><a href="#V8对GC的优化" class="headerlink" title="V8对GC的优化"></a>V8对GC的优化</h2><p>我们在上面也说过，现在大多数浏览器都是基于标记清除算法，V8 亦是，当然 V8 肯定也对其进行了一些优化加工处理，那接下来我们主要就来看 V8 中对垃圾回收机制的优化</p><h3 id="分代式垃圾回收"><a href="#分代式垃圾回收" class="headerlink" title="分代式垃圾回收"></a>分代式垃圾回收</h3><p>试想一下，我们上面所说的垃圾清理算法在每次垃圾回收时都要检查内存中所有的对象，这样的话对于一些大、老、存活时间长的对象来说同新、小、存活时间短的对象一个频率的检查很不好，因为前者需要时间长并且不需要频繁进行清理，后者恰好相反，怎么优化这点呢？？？分代式就来了</p><h4 id="新老生代"><a href="#新老生代" class="headerlink" title="新老生代"></a>新老生代</h4><p>V8 的垃圾回收策略主要基于分代式垃圾回收机制，V8 中将堆内存分为新生代和老生代两区域，采用不同的垃圾回收器也就是不同的策略管理垃圾回收</p><p>新生代的对象为存活时间较短的对象，简单来说就是新产生的对象，通常只支持 <code>1～8M</code> 的容量，而老生代的对象为存活时间较长或常驻内存的对象，简单来说就是经历过新生代垃圾回收后还存活下来的对象，容量通常比较大</p><p> V8 整个堆内存的大小就等于新生代加上老生代的内存（如下图）</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20210611021335396.png"></p><p>对于新老两块内存区域的垃圾回收，V8 采用了两个垃圾回收器来管控，我们暂且将管理新生代的垃圾回收器叫做新生代垃圾回收器，同样的，我们称管理老生代的垃圾回收器叫做老生代垃圾回收器好了</p><h4 id="新生代垃圾回收"><a href="#新生代垃圾回收" class="headerlink" title="新生代垃圾回收"></a>新生代垃圾回收</h4><p>新生代对象是通过一个名为 <code>Scavenge</code> 的算法进行垃圾回收，在 <code>Scavenge算法</code> 的具体实现中，主要采用了一种复制式的方法即 <code>Cheney算法</code> ，我们细细道来</p><p><code>Cheney算法</code> 中将堆内存一分为二，一个是处于使用状态的空间我们暂且称之为 <code>使用区</code>，一个是处于闲置状态的空间我们称之为 <code>空闲区</code>，如下图所示</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20210615013353243.png"></p><p>新加入的对象都会存放到使用区，当使用区快被写满时，就需要执行一次垃圾清理操作</p><p>当开始进行垃圾回收时，新生代垃圾回收器会对使用区中的活动对象做标记，标记完成之后将使用区的活动对象复制进空闲区并进行排序，随后进入垃圾清理阶段，即将非活动对象占用的空间清理掉。最后进行角色互换，把原来的使用区变成空闲区，把原来的空闲区变成使用区</p><p>当一个对象经过多次复制后依然存活，它将会被认为是生命周期较长的对象，随后会被移动到老生代中，采用老生代的垃圾回收策略进行管理</p><p>另外还有一种情况，如果复制一个对象到空闲区时，空闲区空间占用超过了 25%，那么这个对象会被直接晋升到老生代空间中，设置为 25% 的比例的原因是，当完成 <code>Scavenge</code> 回收后，空闲区将翻转成使用区，继续进行对象内存的分配，若占比过大，将会影响后续内存分配</p><h4 id="老生代垃圾回收"><a href="#老生代垃圾回收" class="headerlink" title="老生代垃圾回收"></a>老生代垃圾回收</h4><p>相比于新生代，老生代的垃圾回收就比较容易理解了，上面我们说过，对于大多数占用空间大、存活时间长的对象会被分配到老生代里，因为老生代中的对象通常比较大，如果再如新生代一般分区然后复制来复制去就会非常耗时，从而导致回收执行效率不高，所以老生代垃圾回收器来管理其垃圾回收执行，它的整个流程就采用的就是上文所说的标记清除算法了</p><p>首先是标记阶段，从一组根元素开始，递归遍历这组根元素，遍历过程中能到达的元素称为活动对象，没有到达的元素就可以判断为非活动对象</p><p>清除阶段老生代垃圾回收器会直接将非活动对象，也就是数据清理掉</p><p>前面我们也提过，标记清除算法在清除后会产生大量不连续的内存碎片，过多的碎片会导致大对象无法分配到足够的连续内存，而 V8 中就采用了我们上文中说的标记整理算法来解决这一问题来优化空间</p><h4 id="为什么需要分代式？"><a href="#为什么需要分代式？" class="headerlink" title="为什么需要分代式？"></a>为什么需要分代式？</h4><p>正如小标题，为什么需要分代式？这个机制有什么优点又解决了什么问题呢？</p><p>其实，它并不能说是解决了什么问题，可以说是一个优化点吧</p><p>分代式机制把一些新、小、存活时间短的对象作为新生代，采用一小块内存频率较高的快速清理，而一些大、老、存活时间长的对象作为老生代，使其很少接受检查，新老生代的回收机制及频率是不同的，可以说此机制的出现很大程度提高了垃圾回收机制的效率</p><h3 id="并行回收-Parallel"><a href="#并行回收-Parallel" class="headerlink" title="并行回收(Parallel)"></a>并行回收(Parallel)</h3><p>在介绍并行之前，我们先要了解一个概念 <code>全停顿（Stop-The-World）</code>，我们都知道 <code>JavaScript</code> 是一门单线程的语言，它是运行在主线程上的，那在进行垃圾回收时就会阻塞 <code>JavaScript</code> 脚本的执行，需等待垃圾回收完毕后再恢复脚本执行，我们把这种行为叫做 <code>全停顿</code> </p><p>比如一次 <code>GC</code> 需要 <code>60ms</code> ，那我们的应用逻辑就得暂停 <code>60ms</code> ，假如一次 <code>GC</code> 的时间过长，对用户来说就可能造成页面卡顿等问题</p><p>既然存在执行一次 <code>GC</code> 比较耗时的情况，考虑到一个人盖房子难，那两个人、十个人…呢？切换到程序这边，那我们可不可以引入多个辅助线程来同时处理，这样是不是就会加速垃圾回收的执行速度呢？因此 V8 团队引入了并行回收机制</p><p>所谓并行，也就是同时的意思，它指的是垃圾回收器在主线程上执行的过程中，开启多个辅助线程，同时执行同样的回收工作</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20210617200456698.png"></p><p>简单来说，使用并行回收，假如本来是主线程一个人干活，它一个人需要 3 秒，现在叫上了 2 个辅助线程和主线程一块干活，那三个人一块干一个人干 1 秒就完事了，但是由于多人协同办公，所以需要加上一部分多人协同（同步开销）的时间我们算 0.5 秒好了，也就是说，采用并行策略后，本来要 3 秒的活现在 1.5 秒就可以干完了</p><p>不过虽然 1.5 秒就可以干完了，时间也大大缩小了，但是这 1.5 秒内，主线程还是需要让出来的，也正是因为主线程还是需要让出来，这个过程内存是静态的，不需要考虑内存中对象的引用关系改变，只需要考虑协同，实现起来也很简单</p><p>新生代对象空间就采用并行策略，在执行垃圾回收的过程中，会启动了多个线程来负责新生代中的垃圾清理操作，这些线程同时将对象空间中的数据移动到空闲区域，这个过程中由于数据地址会发生改变，所以还需要同步更新引用这些对象的指针，此即并行回收</p><h3 id="增量标记与懒性清理"><a href="#增量标记与懒性清理" class="headerlink" title="增量标记与懒性清理"></a>增量标记与懒性清理</h3><p>我们上面所说的并行策略虽然可以增加垃圾回收的效率，对于新生代垃圾回收器能够有很好的优化，但是其实它还是一种全停顿式的垃圾回收方式，对于老生代来说，它的内部存放的都是一些比较大的对象，对于这些大的对象 <code>GC</code> 时哪怕我们使用并行策略依然可能会消耗大量时间</p><p>所以为了减少全停顿的时间，在 2011 年，V8 对老生代的标记进行了优化，从全停顿标记切换到增量标记</p><h4 id="什么是增量"><a href="#什么是增量" class="headerlink" title="什么是增量"></a>什么是增量</h4><p>增量就是将一次 <code>GC</code> 标记的过程，分成了很多小步，每执行完一小步就让应用逻辑执行一会儿，这样交替多次后完成一轮 <code>GC</code> 标记（如下图）</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20210617191636742.png"></p><p>试想一下，将一次完整的 <code>GC</code> 标记分次执行，那在每一小次 <code>GC</code> 标记执行完之后如何暂停下来去执行任务程序，而后又怎么恢复呢？那假如我们在一次完整的 <code>GC</code> 标记分块暂停后，执行任务程序时内存中标记好的对象引用关系被修改了又怎么办呢？</p><p>可以看出增量的实现要比并行复杂一点，V8 对这两个问题对应的解决方案分别是三色标记法与写屏障</p><h4 id="三色标记法-暂停与恢复"><a href="#三色标记法-暂停与恢复" class="headerlink" title="三色标记法(暂停与恢复)"></a>三色标记法(暂停与恢复)</h4><p>我们知道老生代是采用标记清理算法，而上文的标记清理中我们说过，也就是在没有采用增量算法之前，单纯使用黑色和白色来标记数据就可以了，其标记流程即在执行一次完整的 <code>GC</code> 标记前，垃圾回收器会将所有的数据置为白色，然后垃圾回收器在会从一组跟对象出发，将所有能访问到的数据标记为黑色，遍历结束之后，标记为黑色的数据对象就是活动对象，剩余的白色数据对象也就是待清理的垃圾对象</p><p>如果采用非黑即白的标记策略，那在垃圾回收器执行了一段增量回收后，暂停后启用主线程去执行了应用程序中的一段 <code>JavaScript</code> 代码，随后当垃圾回收器再次被启动，这时候内存中黑白色都有，我们无法得知下一步走到哪里了</p><p>为了解决这个问题，V8 团队采用了一种特殊方式： <code>三色标记法</code> </p><p>三色标记法即使用每个对象的两个标记位和一个标记工作表来实现标记，两个标记位编码三种颜色：白、灰、黑</p><ul><li>白色指的是未被标记的对象</li><li>灰色指自身被标记，成员变量（该对象的引用对象）未被标记</li><li>黑色指自身和成员变量皆被标记</li></ul><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20210617152131431.png"></p><p>如上图所示，我们用最简单的表达方式来解释这一过程，最初所有的对象都是白色，意味着回收器没有标记它们，从一组根对象开始，先将这组根对象标记为灰色并推入到标记工作表中，当回收器从标记工作表中弹出对象并访问它的引用对象时，将其自身由灰色转变成黑色，并将自身的下一个引用对象转为灰色</p><p>就这样一直往下走，直到没有可标记灰色的对象时，也就是无可达（无引用到）的对象了，那么剩下的所有白色对象都是无法到达的，即等待回收（如上图中的 <code>C、E</code> 将要等待回收）</p><p>采用三色标记法后我们在恢复执行时就好办多了，可以直接通过当前内存中有没有灰色节点来判断整个标记是否完成，如没有灰色节点，直接进入清理阶段，如还有灰色标记，恢复时直接从灰色的节点开始继续执行就可以</p><p>三色标记法的 mark 操作可以渐进执行的而不需每次都扫描整个内存空间，可以很好的配合增量回收进行暂停恢复的一些操作，从而减少 <code>全停顿</code> 的时间</p><h4 id="写屏障-增量中修改引用"><a href="#写屏障-增量中修改引用" class="headerlink" title="写屏障(增量中修改引用)"></a>写屏障(增量中修改引用)</h4><p>一次完整的 <code>GC</code> 标记分块暂停后，执行任务程序时内存中标记好的对象引用关系被修改了，增量中修改引用，可能不太好理解，我们举个例子（如图）</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20210618034238671.png"></p><p>假如我们有 <code>A、B、C</code> 三个对象依次引用，在第一次增量分段中全部标记为黑色（活动对象），而后暂停开始执行应用程序也就是 JavaScript 脚本，在脚本中我们将对象 <code>B</code> 的指向由对象 <code>C</code> 改为了对象 <code>D</code> ，接着恢复执行下一次增量分段</p><p>这时其实对象 <code>C</code> 已经无引用关系了，但是目前它是黑色（代表活动对象）此一整轮 <code>GC</code> 是不会清理 <code>C</code> 的，不过我们可以不考虑这个，因为就算此轮不清理等下一轮 <code>GC</code> 也会清理，这对我们程序运行并没有太大影响</p><p>我们再看新的对象 <code>D</code> 是初始的白色，按照我们上面所说，已经没有灰色对象了，也就是全部标记完毕接下来要进行清理了，新修改的白色对象 <code>D</code> 将在次轮 <code>GC</code> 的清理阶段被回收，还有引用关系就被回收，后面我们程序里可能还会用到对象 <code>D</code> 呢，这肯定是不对的</p><p>为了解决这个问题，V8 增量回收使用 <code>写屏障 (Write-barrier)</code> 机制，即一旦有黑色对象引用白色对象，该机制会强制将引用的白色对象改为灰色，从而保证下一次增量 <code>GC</code> 标记阶段可以正确标记，这个机制也被称作 <code>强三色不变性</code> </p><p>那在我们上图的例子中，将对象 <code>B</code> 的指向由对象 <code>C</code> 改为对象 <code>D</code> 后，白色对象 <code>D</code> 会被强制改为灰色</p><h4 id="懒性清理"><a href="#懒性清理" class="headerlink" title="懒性清理"></a>懒性清理</h4><p>增量标记其实只是对活动对象和非活动对象进行标记，对于真正的清理释放内存 V8 采用的是惰性清理(Lazy Sweeping)</p><p>增量标记完成后，惰性清理就开始了。当增量标记完成后，假如当前的可用内存足以让我们快速的执行代码，其实我们是没必要立即清理内存的，可以将清理过程稍微延迟一下，让 <code>JavaScript</code> 脚本代码先执行，也无需一次性清理完所有非活动对象内存，可以按需逐一进行清理直到所有的非活动对象内存都清理完毕，后面再接着执行增量标记</p><h4 id="增量标记与惰性清理的优缺？"><a href="#增量标记与惰性清理的优缺？" class="headerlink" title="增量标记与惰性清理的优缺？"></a>增量标记与惰性清理的优缺？</h4><p>增量标记与惰性清理的出现，使得主线程的停顿时间大大减少了，让用户与浏览器交互的过程变得更加流畅。但是由于每个小的增量标记之间执行了 <code>JavaScript</code> 代码，堆中的对象指针可能发生了变化，需要使用写屏障技术来记录这些引用关系的变化，所以增量标记缺点也很明显：</p><p>首先是并没有减少主线程的总暂停的时间，甚至会略微增加，其次由于写屏障机制的成本，增量标记可能会降低应用程序的吞吐量（吞吐量是啥总不用说了吧）</p><h3 id="并发回收-Concurrent"><a href="#并发回收-Concurrent" class="headerlink" title="并发回收(Concurrent)"></a>并发回收(Concurrent)</h3><p>前面我们说并行回收依然会阻塞主线程，增量标记同样有增加了总暂停时间、降低应用程序吞吐量两个缺点，那么怎么才能在不阻塞主线程的情况下执行垃圾回收并且与增量相比更高效呢？</p><p>这就要说到并发回收了，它指的是主线程在执行 <code>JavaScript</code> 的过程中，辅助线程能够在后台完成执行垃圾回收的操作，辅助线程在执行垃圾回收的时候，主线程也可以自由执行而不会被挂起（如下图）</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20210624005035372.png"></p><p>辅助线程在执行垃圾回收的时候，主线程也可以自由执行而不会被挂起，这是并发的优点，但同样也是并发回收实现的难点，因为它需要考虑主线程在执行 <code>JavaScript </code> 时，堆中的对象引用关系随时都有可能发生变化，这时辅助线程之前做的一些标记或者正在进行的标记就会要有所改变，所以它需要额外实现一些读写锁机制来控制这一点，这里我们不再细说</p><h3 id="再说V8中GC优化"><a href="#再说V8中GC优化" class="headerlink" title="再说V8中GC优化"></a>再说V8中GC优化</h3><p>V8 的垃圾回收策略主要基于分代式垃圾回收机制，这我们说过，关于新生代垃圾回收器，我们说使用并行回收可以很好的增加垃圾回收的效率，那老生代垃圾回收器用的哪个策略呢？我上面说了并行回收、增量标记与惰性清理、并发回收这几种回收方式来提高效率、优化体验，看着一个比一个好，那老生代垃圾回收器到底用的哪个策略？难道是并发？？内心独白：” 好像。。貌似。。并发回收效率最高 “</p><p>其实，这三种方式各有优缺点，所以在老生代垃圾回收器中这几种策略都是融合使用的</p><p>老生代主要使用并发标记，主线程在开始执行 <code>JavaScript</code> 时，辅助线程也同时执行标记操作（标记操作全都由辅助线程完成）</p><p>标记完成之后，再执行并行清理操作（主线程在执行清理操作时，多个辅助线程也同时执行清理操作）</p><p>同时，清理的任务会采用增量的方式分批在各个 <code>JavaScript</code> 任务之间执行</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>那上面就是 V8 引擎为我们的垃圾回收所做的一些主要优化了，虽然引擎有优化，但并不是说我们就可以完全不用关心垃圾回收这块了，我们的代码中依然要主动避免一些不利于引擎做垃圾回收操作，因为不是所有无用对象内存都可以被回收的，那当不再用到的内存，没有及时回收时，我们叫它 <code>内存泄漏</code></p><p>关于内存泄漏又是另一个点了，也碍于篇幅就不放在这篇文章了</p><p>收工，看也看完了，开头的问题你有更深层次的答案了吗？在之前面试时我问过面试者这类问题，大多同学的回答都仅限于标记清除+引用计数两个概念，往深处各种缺陷以及优化上挖一挖就说不出了，其实我们结合 V8 引擎对垃圾回收的优化来回答上面那些问题会更好一些，那么，评论区码出自己的理解吧！</p><p>另外，有哪些没有 Get 到的点可以评论留言，也欢迎指错勘误！！！</p>]]></content>
    
    
    <categories>
      
      <category>硬核JS系列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>垃圾回收</tag>
      
      <tag>GC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>让GIS三维可视化变得简单-投影坐标系统</title>
    <link href="/blog/2021/03/16/cesium/%E8%AE%A9GIS%E4%B8%89%E7%BB%B4%E5%8F%AF%E8%A7%86%E5%8C%96%E5%8F%98%E5%BE%97%E7%AE%80%E5%8D%95-%E6%8A%95%E5%BD%B1%E5%9D%90%E6%A0%87%E7%B3%BB%E7%BB%9F/"/>
    <url>/blog/2021/03/16/cesium/%E8%AE%A9GIS%E4%B8%89%E7%BB%B4%E5%8F%AF%E8%A7%86%E5%8C%96%E5%8F%98%E5%BE%97%E7%AE%80%E5%8D%95-%E6%8A%95%E5%BD%B1%E5%9D%90%E6%A0%87%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<p>接上文地理坐标系统，此文我们一起来了解下坐标系统中的投影坐标系统</p><p>投影坐标系统 <code>PCS（Projection Coordinate System）</code>，它也叫非地球投影坐标系统 <code>（notearth）</code>，或者再简单点叫平面坐标系统，也就是使用基于 <code>X,Y</code> 值的坐标系统来描述地球上某个点所处的位置</p><p>到了这你可能会问投影坐标系统和之前的地理坐标系统是什么关系呢？</p><p>其实，地理坐标系统是球面坐标，参考面是椭球面，坐标单位是经纬度，而投影坐标系是平面坐标系，参考平面是水平面，坐标单位是米、千米等等</p><p><strong>PS：</strong> 因为地图相关太难画了，本文中所有图片皆来自网络，如有侵权，请告知，即删</p><h2 id="什么是投影"><a href="#什么是投影" class="headerlink" title="什么是投影"></a>什么是投影</h2><p>投影指的是用一组光线将物体的形状投射到一个平面上去，称为投影，这个平面我们称之为投影面，且看下图，而我们要学习的投影，待投影的物体就是地球</p><p>能展开成平面的面有平面本身，球永远也展不开成一个平面，那么我们要把球搞成一个平面只有靠投影，而球的投影方式也有很多，我们后面会介绍到</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20210316212534150.png"></p><h2 id="为什么需要投影"><a href="#为什么需要投影" class="headerlink" title="为什么需要投影"></a>为什么需要投影</h2><p>需要投影是因为地理坐标系统中经纬度本身不带单位，度分秒仅仅是一个进制，另外，同样是1度经度，在不同的纬度带表示的弧段长是不一样的，这给面积以及定量计算等带来了困难</p><p>传统的地图（相较于google earth等3D平台）是呈现在二维的平面上的，所以需要一种能够将地球球面上三维坐标转化到二维平面的一种映射方法，这种方法就是地图投影，因此，地图投影是一种由经纬度 <code>B,L,H</code> 到投影坐标 <code>X,Y,Z</code> 的映射方式</p><p>地图投影的实质就是建立地球椭球表面上的点与地图平面上的点之间的对应关系，将建立在球体上的地理坐标系下的经纬度坐标，通过一种投影方法转为平面上的直角坐标</p><p>地图投影的用途，就是建立一种平面坐标系（称为投影坐标系），很多计算、业务在平面上计算相较与曲面上计算要简便一些</p><p>比如球面上，纬度相同，同样经度差的两点，处在不同的纬度上的距离就是不一样的,这给计算带来了不便，欧几里得平面上就不存在这个问题</p><p>很多经典的GIS软件，比如ArcMap等，基本框架，包括渲染、编辑等一些功能都是基于2D平面开发的，这也和我们对地图的要求一致</p><p>在允许变形的范围内，建立统一的平面坐标系，强调这一点，是因为在设计地图投影时，地图的范围也是需要考虑的重要因素</p><h2 id="投影的分类"><a href="#投影的分类" class="headerlink" title="投影的分类"></a>投影的分类</h2><p>将球面上的目标展平到平面上，目标肯定会发生压缩或拉伸，根据变形的性质，地图投影可以简单分为下面几类</p><ul><li><p>等角投影：投影后目标在各个方向上变形一致，总体保持角度不变</p></li><li><p>等距投影：投影后总体保持长度不变，面积和角度有些变形</p></li><li><p>等积投影：假设目标上存在一个微分圆，如果投影后圆面积不变，此投影为等积投影</p></li><li><p>任意投影：投影后面积、角度和长度均发生变化的投影</p></li></ul><p>如下图</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20210316212623599.png"></p><p>按照投影的方式，可以分为下面几类</p><ul><li>圆柱投影：投影面为圆柱</li><li>圆锥投影：投影面为圆锥</li><li>方位投影：投影面为平面</li></ul><p>像后面所说的高斯克吕格投影就是一种圆柱投影，如下图所示</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20210316213128233.png"></p><p>那么按照投影面（圆柱、圆锥，平面）主轴与地轴（连接南北极的短轴）相对位置的关系，投影又可以分为下面几种方式</p><ul><li>正轴投影：投影面中心轴与地轴相互重合</li><li>斜轴投影：投影面中心轴与地轴斜向相交</li><li>横轴投影：投影面中心轴与地轴相互垂直</li><li>相切投影：投影面与椭球体相切</li><li>相割投影：投影面与椭球体相割</li></ul><p>如下图</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20210316213312759.png"></p><h2 id="常见投影方式"><a href="#常见投影方式" class="headerlink" title="常见投影方式"></a>常见投影方式</h2><h3 id="墨卡托投影-Mercator"><a href="#墨卡托投影-Mercator" class="headerlink" title="墨卡托投影-Mercator"></a>墨卡托投影-Mercator</h3><p>墨卡托投影（Mercator），又称麦卡托投影、正轴等角圆柱投影，由荷兰地图学家墨卡托（G.Mercator）于1569年创拟</p><p>简单说就是假设地球被套在一个圆柱中，赤道与圆柱相切，然后在地球中心放一盏灯，把球面上的图形投影到圆柱体上，再把圆柱体展开，就形成以一幅墨卡托投影的世界地图，如下图</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20210316213421776.png"></p><p>由于可显示任两点间的正确方位，航海用途的海图、航路图大部分都这种方式绘制，这种投影中线型比例尺在图中任意一点周围都保持不变，从而可以保持大陆轮廓投影后的角度和形状不变（即等角），但墨卡托投影会使面积产生变形，极点（也就是南北极地区）的比例甚至达到了无穷大</p><p>所以它并没完整展现了整个世界，地图上最高纬度是85.05度，为了简化计算，采用球形映射，而不是椭球体形状，采用墨卡托投影只是为了方便展示地图，我们还需要知道的是，这种映射会给Y轴方向带来 0.33% 的误差，如下图</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20210316213524116.png"></p><h3 id="高斯克吕格投影（Gauss-Kruger）"><a href="#高斯克吕格投影（Gauss-Kruger）" class="headerlink" title="高斯克吕格投影（Gauss - Kruger）"></a>高斯克吕格投影（Gauss - Kruger）</h3><p>此投影是由德国数学家、物理学家、天文学家高斯于19世纪20年代拟定，后经德国大地测量学家克吕格于1912年对投影公式加以补充，故称为 <code>高斯克吕格投影</code></p><p>你可以想象一下一个椭圆柱横着套在（相切于经线圈）地球的椭球面上，围绕地轴旋转，将地球表面投影到椭圆柱面，投影到椭圆柱面后，再沿着椭圆柱面的高剪开摊成平面，如下图</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20210316215210555.png"></p><p>经度有东西各180度，按3度或者6度剥开一瓣用于投影这个叫分带，旋转高斯克吕格的投影面，可以获取下一个分带的投影，以合适全球所有的地方，如下图</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20210316213637538.png"></p><p><code>高斯克吕格投影</code> 又名 <code>等角横切椭圆柱投影</code>，在英美国家称为 <code>横轴墨卡托投影</code>，美国编制世界各地军用地图和地球资源卫星象片所采用的 <code>全球/通用 横轴墨卡托投影（UTM）</code> 是 <code>横轴墨卡托投影</code> 的一种变形</p><h3 id="通用横轴墨卡托投影（UTM）"><a href="#通用横轴墨卡托投影（UTM）" class="headerlink" title="通用横轴墨卡托投影（UTM）"></a>通用横轴墨卡托投影（UTM）</h3><p>UTM 全称 <code>Universal Transverse Mercator</code> 中文叫做 通用横轴墨卡托投影，和高斯克吕格投影非常相似，只不过它并不是切于经线圈，而是为椭圆柱横正轴割地球椭球体（穿地球而过），椭圆柱的中心线位于椭球体赤道面上，且通过椭球体质点，从而将椭球体上的点投影到椭圆柱上，就像下面这个样子</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20210316213739070.png"></p><p>这种投影是美国陆军工程兵测绘局于20世纪40年代提出的，美国本土采用Clarke 1866椭球体，对全球其它地方采用 WGS84 椭球体，目前大部分的遥感影像图用的就是 UTM 投影出来的投影坐标系统</p><h3 id="网络墨卡托投影（WebMercator）"><a href="#网络墨卡托投影（WebMercator）" class="headerlink" title="网络墨卡托投影（WebMercator）"></a>网络墨卡托投影（WebMercator）</h3><p>网络墨卡托投影的英文名为 PVPM（Popular Visualization Pseudo Mercator），它不是严格意义的墨卡托投影，而是一个伪墨卡托的投影方法，由Google Map最先提出</p><p>它的不严谨性在于，在投影过程中，将表示地球的椭球面作为正球面处理</p><p>传说是因为谷歌程序员懒得用椭球面来编程计算屏幕坐标，具体不晓得</p><p>它以整个世界范围赤道作为标准纬线，本初子午线作为中央经线，两者交点为坐标原点，向东向北为正，向西向南为负</p><p>我们上面说过墨卡托投影方法，那么可以知道，当纬度接近两极，y值就趋向于无穷，于是这些 <code>懒惰的工程师</code> 就把 Y轴 的取值范围限定在 <code>[-20037508.3427892,20037508.3427892]</code> 之间</p><p>电子地图通常以经纬度为单位展示地理坐标，而墨卡托投影坐标经度范围：<code>[-180,180]</code> ，纬度上面已知不可能到达 90° 的，取值范围是 <code>[-85.05112877980659，85.05112877980659]</code> ，那其余的地区怎么办呢？没人知道，用不到就不管它</p><p>另外我们还需要知道的是，WebMercator投影 也是采用的 WGS84 基准面，基准面相关请看上文地理坐标系统</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>常用的 <code>高斯克吕格投影</code> 的 PCS 族，在我国，地理坐标系统只有 <code>北京54、西安80、国家2000</code>，根据中央经线按需选用即可</p><p>基于 <code>UTM投影</code> 的 PCS 族，和 <code>高斯克吕格投影</code> 坐标系统族类似，只不过仅基于WGS84，也是根据中央经线按需选用即可</p><p>我国的高德、百度、腾讯地图，谷歌地图、OSM地图都用了网络墨卡托来平面化展示，不过国内高德百度腾讯和国内谷歌地图的地理坐标系统经过加密，而天地图虽然用的是国家 2000 地理坐标系，但是也提供了墨卡托投影方法来展示平面地图，<code>ArcGIS Earth</code> 则和 <code>Google Earth</code> 类似，都是直接使用3857坐标系</p><p>码字不易，来个四连吧，感谢，欢迎关注公众号「不正经的前端」，获取更多内容！</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://book.douban.com/subject/31438879/">地理信息系统导论-第九版</a></p><p><a href="https://www.cnblogs.com/onsummer/p/12081889.html">聊聊GIS中的坐标系|再版</a> </p><p><a href="https://blog.csdn.net/kikitamoon/article/details/50634331">你所不知的有趣投影方法</a></p>]]></content>
    
    
    <categories>
      
      <category>Cesium系列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cesium</tag>
      
      <tag>数据可视化</tag>
      
      <tag>WebGIS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>让GIS三维可视化变得简单-地理坐标系统</title>
    <link href="/blog/2021/02/18/cesium/%E8%AE%A9GIS%E4%B8%89%E7%BB%B4%E5%8F%AF%E8%A7%86%E5%8C%96%E5%8F%98%E5%BE%97%E7%AE%80%E5%8D%95-%E5%9C%B0%E7%90%86%E5%9D%90%E6%A0%87%E7%B3%BB%E7%BB%9F/"/>
    <url>/blog/2021/02/18/cesium/%E8%AE%A9GIS%E4%B8%89%E7%BB%B4%E5%8F%AF%E8%A7%86%E5%8C%96%E5%8F%98%E5%BE%97%E7%AE%80%E5%8D%95-%E5%9C%B0%E7%90%86%E5%9D%90%E6%A0%87%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>地理位置也就是坐标说是 GIS 的灵魂不为过吧，像天气预报、火箭发射包括地震、火山等事故发生时，新闻媒体就会说东经 XX 度、北纬 YY 度发生了什么什么，还有高德百度的地图导航、定位等等都需要用到坐标系统，因为没有准确的位置信息就无法表达地物的位置关系，地图查询分析等等也就无从谈起了</p><p>坐标系统可以分为地理坐标系统和投影坐标系统两大类</p><p>今天我们就以 <code>Cesium</code> 中要用到坐标转换为引，给非专业小伙伴们普及下坐标系统的知识，概念性较多，不需要全部记住，了解概念即可，我们先来说地理坐标系统</p><p>地理坐标系统也就是Geographic Coordinate System，我们简称GCS，它就是由地球表面空间要素产生的定位参照系统，说的很官方，接下来我们渐入</p><p><strong>PS：</strong> 因为地图相关太难画了，本文中所有图片皆来自网络，如有侵权，请告知，即删</p><h2 id="认知地球"><a href="#认知地球" class="headerlink" title="认知地球"></a>认知地球</h2><h3 id="历史演进"><a href="#历史演进" class="headerlink" title="历史演进"></a>历史演进</h3><p>我们想要知道某个地方或物体在哪个位置肯定需要一个参照物，而对于现代生活在地球上的我们知道想要进行全球范围的精准定位，这个参照物只能是地球，因为清楚的了解地球的形状大小、了解人类与地球的关系</p><p>但是古时候的人，由于活动范围很小，只看到自己生活地区的一小块地方，所以单凭直觉就产生了种种有关 <code>天圆地方</code> 的说法</p><p>比如我国早在两千多年前的周代，就有 <code>天圆如张盖，地方如棋局</code> 的盖天说</p><p>古代埃及人认识，天像一块穹窿形的天花板，地像一个方盒</p><p>俄罗斯人则认为大地像一块盾牌，由三条巨鲸用背驮着，漂游在茫茫的海洋里</p><p>印度人也有俄罗斯类似的传说，不过他们认为驮着这块大地的，不是巨鲸，而是站在海龟背上的三头大象，大象动一动便会引起地震</p><p>后面古希腊科学家亚里士多德提出大地是球形，再到后来1519-1521年麦哲伦环绕地球航行一周成功，才使得地球这一名字正式的产生</p><p>随着测量技术的不断进步，特别是人造地球卫星的利用，才使得我们对地球有了一个明确的认知，地球并不是一个正球体，而是一个两极稍扁、赤道略鼓的不规则球体，可以成为椭球，地球的平均半径 6371 千米，极半径为 6356 千米，两者相差为 21 千米，最大周长也就是我们所说的赤道约 4 万千米，表面积约 5.1 亿平方千米，如下图</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20210316204449226.png"></p><h3 id="经纬度-amp-弧度"><a href="#经纬度-amp-弧度" class="headerlink" title="经纬度&amp;弧度"></a>经纬度&amp;弧度</h3><p>地理坐标系统是由经纬度来定义的，那么可能有人不知道经纬度，so，这里把的经纬度也给大家介绍下</p><p>经度是从本初子午线开始向东或向西度量角度，东半球为正西半球为负，而纬度是从赤道平面向北或向南度量角度的，赤道北为正，赤道南为负</p><p>哦，对了本初子午线指的是的在地球上连接南北两极的经线，叫法很多，零经线、首子午线、零子午线等都是，赤道则是地球表面随地球自转产生的轨迹中周长最长的圆周线，划分了南北半球</p><p>本初子午线和赤道就是地理坐标系统的基线了，两者相切，可以理解为 x/y 坐标轴，那么我们说的经度就相当于 x 值，纬度就相当于 y 值，如下图</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20210316205227139.png"></p><p>关于经纬度的单位我们可以用度分秒（DMS）、十进制度数（DD），或者我们变成中可能会用到的弧度（rad）表示</p><p>度分秒表示法中，1度等于60分、1分等于60秒（ <code>1° = 60′  1′ = 60″</code> ），比如经纬度 <code>45°52′30″</code>，那我们转换为十进制来表示就是 45.875°（45+52/60+30/3600），除此之外的我们常用的弧度，我们记住两个值就可以了，敲重点了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">1rad= <span class="hljs-number">57.2958</span>°<br><span class="hljs-number">1</span>°  = <span class="hljs-number">0.</span>01745rad<br></code></pre></td></tr></table></figure><h3 id="大地水准面"><a href="#大地水准面" class="headerlink" title="大地水准面"></a>大地水准面</h3><p>地球表面有高山、有洼地，是崎岖不平的，所以当我们想要使用数学法则来描述它，就必须找到一个相对来说较规则的数学面</p><p>我们都知道地球也可以叫水球，因为大部分是海洋，所以，人们假设海水处于完全静止的平衡状态，那么从海平面延伸到所有大陆下部，而与地球重力方向处处正交的一个连续、闭合的曲面就是大地水准面，如下图</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20210316204533585.png"></p><h3 id="地球椭球体-amp-椭球面"><a href="#地球椭球体-amp-椭球面" class="headerlink" title="地球椭球体&amp;椭球面"></a>地球椭球体&amp;椭球面</h3><p>上面我们说大地水准面忽略了地面上的凸凹不平相对规则，但由于地球内物质分布的不均匀，大地水准面仍是起伏不平，它虽然非常接近一个规则椭球体，但并不是完全规则，还是没有办法用数学表达</p><p>我们知道用椭圆绕短轴旋转可生成一个椭球体，所以为了定量描述地球的形状而不受起伏的影响，测量上把与大地水准面符合的最理想的旋转椭球体叫做 <code>地球椭球体</code> 也叫 <code>参考椭球体</code>，并选择能用数学方程表示的椭球体面作为投影的基准面，这个基准面就称为 <code>参考椭球面</code>，简称 <code>椭球面</code>，参考下图</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20210316204556677.png"></p><h3 id="大地基准面"><a href="#大地基准面" class="headerlink" title="大地基准面"></a>大地基准面</h3><p>上面我们说了大地水准面、地球椭球体椭球面等概念，接下来我们来看大地基准面，简单讲，我们把地球比作一个马铃薯🥔，因为它表面坑坑洼洼的，那么我们上面讲的参考椭球体就可以用鸭蛋🥚表示，因为它比较规则，我们随意挑选一个方位视角把鸭蛋放在马铃薯上，旋转或者放大缩小鸭蛋让它尽可能的去贴合这个方位的马铃薯面，调整合适之后在这个方位视角的鸭蛋面就是大地基准面（马铃薯鸭蛋之说取自网上偶然看到的一篇文章，觉得很贴切，找不到地址了。。）</p><p>由于我们可以随意的旋转马铃薯从而变换方位，那么鸭蛋（参考椭球体）也会随着马铃薯（地球）视角方位进行改变，基准面也就会随着地球的某个方位测量产生多个，不同国家或地区都会选择自己相对贴合的位置测量从而产生各自的基准面，也就出现了我们现在十分头疼的不同坐标系转换的问题，原因是它们的基准面不同，如下图</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20210316204616875.png"></p><p>我们经常听到的北京 54 坐标系、西安 80 坐标系，实际上是指我国的两个大地基准面</p><p>各个国家在马铃薯（地球）的所处的位置不同，旋转放大或缩小产生的鸭蛋（参考椭球体）也不同，所以产生了很多参考椭球体，我国参照前苏联从 1953 年起采用克拉索夫斯基（Krassovsky）椭球体建立了北京 54 坐标系，后面在 1978 年采用国际大地测量协会推荐的1975地球椭球体（IAG75）建立了新的大地坐标系——西安 80 坐标系</p><h3 id="参心坐标系"><a href="#参心坐标系" class="headerlink" title="参心坐标系"></a>参心坐标系</h3><p>球的测量肯定要定球心，上面我们说过的鸭蛋也就是参考椭球体，地球的球心不好确定，但参考椭球体是规则的，那么以参考椭球体的几何中心为原点的大地坐标系就是 <code>参心坐标系</code>，而这个参心指的就是参考椭球的球心我们计作原点 O</p><p>参心坐标系通常说的是参心空间直角坐标系（以x，y，z为坐标元素）和参心大地坐标系（以B，L，H为其坐标元素）</p><p>参心坐标系是在参考椭球内建立的 <code>O-XYZ</code> 坐标系，原点 O 为参考椭球的几何中心，X轴与赤道面和本初子午面的交线重合，向东为正。Z轴与旋转椭球的短轴重合，向北为正，Y轴与XZ平面垂直构成右手系，如下图</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20210316204639050.png"></p><p>在测量中，为了处理观测成果和传算地面控制网的坐标，通常须选取一个 <code>参考椭球面</code> 作为基本参考面，选一参考点作为大地测量的起算点（这个点就是 <code>大地原点</code>），利用大地原点的天文观测量来确定参考椭球在地球内部的位置和方向</p><h3 id="地心坐标系"><a href="#地心坐标系" class="headerlink" title="地心坐标系"></a>地心坐标系</h3><p>20世纪50年代之前，一个国家或一个地区都是在使所选择的参考椭球与其所在地区的大地水准面最佳拟合的条件下，按弧度测量方法来建立各自的局部大地坐标系的</p><p>由于当时除海洋上只有稀疏的重力测量外，大地测量工作只能在各个大陆上进行，而各大陆的局部大地坐标系间几乎没有联系，不过在当时的科学发展水平上，局部大地坐标系已能基本满足各国大地测量和制图工作的要求</p><p>但是后来为了研究地球形状的整体及其外部重力场以及地球动力现象，特别是50年代末，人造地球卫星和远程弹道武器出现后，为了描述它们在空间的位置和运动，以及表示其地面发射站和跟踪站的位置，都必须采用地心坐标系，因此，建立全球地心坐标系（也称为世界坐标系）已成为大地测量所面临的迫切任务，再到后来就确立了地球的质心（也就是世界统一的地球唯一中心点）</p><p>这个背景下以地球 <code>质心为原点</code> 建立的空间直角坐标系，或以球心与地球质心重合的地球椭球面为基准面所建立的 <code>大地坐标系</code> 就诞生了</p><p>以地球质心为原点的大地坐标系通常分为地心空间直角坐标系（以x，y，z为其坐标元素）和地心大地坐标系（以B，L，H为其坐标元素）</p><p>地心坐标系是在大地体内建立的 <code>O-XYZ</code> 坐标系，原点O设在大地体的质量中心，用相互垂直的X，Y，Z三个轴来表示，X轴与首子午面与赤道面的交线重合，向东为正，Z轴与地球旋转轴重合，向北为正，Y轴与XZ平面垂直构成右手系，和上面参心图差不多，就不放图了</p><p>到此，相信你对我们的地球有了一个新的认知，那么接下来我们介绍几种常用的坐标系</p><h2 id="常用坐标系"><a href="#常用坐标系" class="headerlink" title="常用坐标系"></a>常用坐标系</h2><p>我们这里简单介绍 4 个比较常见的坐标系，分别是两个我国早期使用的坐标系 <code>北京54</code>、<code>西安80</code>，目前我国主流的 <code>CGCS2000</code>，和世界常用的地理坐标系统 <code>WGS84</code></p><h3 id="北京54"><a href="#北京54" class="headerlink" title="北京54"></a>北京54</h3><p>新中国成立以后，我国采用了前苏联的克拉索夫斯基椭球参数（也就是说它是一个参心坐标系），并与前苏联1942 年坐标系进行联测，通过计算建立了我国大地坐标系，定名为 1954 年北京坐标系，简称北京 54 坐标系</p><p>1954 年北京坐标系可以认为是前苏联1942年坐标系的延伸，因为它的原点不在北京而是在前苏联的普尔科沃</p><p>北京54是建国初，在当时技术条件不高时引苏联的地理坐标系统到我国境内的，大地原点都不在我国境内，所以北京54在我国境内有较大偏差，已逐渐废弃</p><h3 id="西安80"><a href="#西安80" class="headerlink" title="西安80"></a>西安80</h3><p>1978年4月在西安召开全国天文大地网平差会议，确定重新定位，建立我国新的坐标系，为此有了1980年国家大地坐标系，1980年国家大地坐标系采用地球椭球基本参数为 1975 年国际大地测量与地球物理联合会第十六届大会推荐的数据（也是参心坐标系）</p><p>此坐标系的 <code>大地原点</code> 设在我国中部的陕西省泾阳县永乐镇，位于西安市西北方向约60公里，故称1980年西安坐标系，也可简称西安 80 坐标系</p><p>它的基准面采用青岛大港验潮站1952－1979年确定的黄海平均海水面（即1985国家高程基准），目前也逐渐废弃了</p><h3 id="西安80与北京54"><a href="#西安80与北京54" class="headerlink" title="西安80与北京54"></a>西安80与北京54</h3><p>西安80坐标系与北京54坐标系其实是一种椭球参数的转换作为这种转换在同一个椭球里的转换都是严密的，而在不同的椭球之间的转换是不严密，因此不存在一套转换参数可以全国通用的，在每个地方会不一样，因为它们是两个不同的椭球基准</p><p>北京54和西安80是两种不同的大地基准面，不同的参考椭球体，因而两种地图下，同一个点的坐标是不同的，无论是三度带六度带坐标还是经纬度坐标都是不同的，相同的是它们两个都已经逐渐废弃了</p><h3 id="CGCS2000"><a href="#CGCS2000" class="headerlink" title="CGCS2000"></a>CGCS2000</h3><p>从北京54到西安80，随着情况的变化和时间的推移，上述两个以经典测量技术为基础的局部大地坐标系，已经不能适应科学技术特别是空间技术发展，不能适应中国经济建设和国防建设需要，中国大地坐标系的更新换代，是经济建设、国防建设、社会发展和科技发展的客观需要</p><p>以地球质量中心为原点的地心大地坐标系，是21世纪空间时代全球通用的基本大地坐标系，所以以空间技术为基础的地心大地坐标系，是中国新一代大地坐标系的适宜选择</p><p>CGCS2000是2000国家大地坐标系，属于地心大地坐标系统，此坐标系是通过中国GPS 连续运行基准站、 空间大地控制网以及天文大地网与空间地网联合平差建立的地心大地坐标系统，2000（中国）国家大地坐标系以ITRF 97 参考框架为基准, 参考框架历元为2000.0，全称叫中国国家2000地理坐标系统，它的英文名字叫  <code>China Geodetic Coordinate System 2000</code> </p><p>次坐标系是目前我国主流坐标系，干说这个坐标系你可能不知道，这样说吧，我国的GPS系统-北斗导航系统以及国家发行的天地图，用的都是这一套地理坐标系统，晓得了吗</p><h3 id="WGS84"><a href="#WGS84" class="headerlink" title="WGS84"></a>WGS84</h3><p>WGS84是美国GPS使用的一个全球地理坐标系统，OSM地图、谷歌地图（国外版）、Landsat系列卫星影像图等均在地理坐标系统上使用了这个，有许多开发地图的API默认是使用WGS84的，</p><p>它的全称叫<code> World Geodetic System 1984</code>，我们在网上交流的数据大部分也都是WGS84的，所以目前世界上使用最广泛的坐标系可能就是WGS84了</p><p>我国的高德、百度等地图使用的也都是WGS84，只不过它们都在WGS84基础上再次加密，在民间叫火星坐标系，采用就是大名鼎鼎的GCJ02加密算法，它与真实的WGS84坐标是有误差的，这个误差值并不固定，通常是几十米到几百米（百度地图更狠，在GCJ02的基础上还做了再次偏移，也就是BD09，我们通常叫百度坐标系），至于为什么加密，不用我说，你懂的哈</p><h3 id="CGCS2000与WGS84"><a href="#CGCS2000与WGS84" class="headerlink" title="CGCS2000与WGS84"></a>CGCS2000与WGS84</h3><p>上面提到CGCS2000与WGS84这两种坐标系都是地心坐标系，所以CGCS2000的定义与WGS84实质一样，采用的参考椭球非常接近</p><p>但是由于扁率差异引起椭球面上的纬度和高度变化最大达 <code>0.1mm</code>，在当前测量精度范围内是可以忽略这点差异的，可以说两者相容至cm级水平，但若是一个点的坐标精度达不到cm水平时，就不认为CGCS2000和WGS84的坐标是相容的，反之两者皆可</p><h3 id="常用坐标系小结"><a href="#常用坐标系小结" class="headerlink" title="常用坐标系小结"></a>常用坐标系小结</h3><p>来总结一下这几个常用坐标系，由于是介绍常识上面写的都挺官方，我们总结的话就接地气一点</p><p>北京54参心坐标系是建国初在当时技术条件不好时引苏联的地理坐标系统到我国境内的，大地原点不在我国境内，所以在我国境内有较大偏差，已逐渐废弃</p><p>西安80参心坐标系则是改革开放后，技术稍好，为解决北京54偏差问题，为我国各项事业发展搞的一个适用于国内的地理坐标系统，现也已逐渐废弃</p><p>北斗导航系统、天地图都在用的CGCS2000是目前我国主流，地心坐标系</p><p>WGS84是一个源于美国且世界流通较广的全球地理坐标系统，地心坐标系</p><p>这张图不错</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20210316204707166.png"></p><p>先解释一下，ArcGIS的WKID，我们应该都知道ArcGIS，美国环境系统研究所ERSl（EnvironmentalSystems ResearchInstitute）搞的，它们可以说是GIS行业之首</p><p>那WKID是什么呢，WKID全称叫Well-known ID，它表示空间参考的ID，简单来说，世界上的坐标系太多了，我们把每一个坐标系比作一个人，北京54、西安80、CGCS2000、WGS84等等都是名字简称，全名太长了，而且可以改名啥的，但是身份证号是唯一且不变的，这个身份证号就是指的WKID，它在空间数据的使用、转换、共享等都起到了关键作用，所以记住这几个常用的ID有好处</p><p>想要查WKID的话可以去这里查 👉 <a href="https://developers.arcgis.com/javascript/3/jshelp/pcs.htm">JavaScript版本</a> </p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>由于篇幅问题，投影坐标系统放在了下文中讲了</p><p>感谢阅读，也欢迎大家关注公众号「不正经的前端」，记得点赞哦！！！</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://book.douban.com/subject/31438879/">地理信息系统导论-第九版</a></p><p><a href="https://www.cnblogs.com/onsummer/p/12081889.html">聊聊GIS中的坐标系|再版</a> </p>]]></content>
    
    
    <categories>
      
      <category>Cesium系列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cesium</tag>
      
      <tag>数据可视化</tag>
      
      <tag>WebGIS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「算法与数据结构」JavaScript中的链表</title>
    <link href="/blog/2021/01/25/suanfa/%E3%80%8C%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8DJavaScript%E4%B8%AD%E7%9A%84%E9%93%BE%E8%A1%A8/"/>
    <url>/blog/2021/01/25/suanfa/%E3%80%8C%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8DJavaScript%E4%B8%AD%E7%9A%84%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>此文会先探讨下什么是链表以及在 JavaScript 中的链表，接着我们会使用 JavaScript 这门语言动手实现下各类链表的设计，最后我们会抛出一些常规疑问，并从各个方面一一解答，总之，目的就是完全搞定链表</p><p>搞定概念之后我们可以去力扣上选择链表分类，按照难易程度把它们刷完，其实力扣上链表的题目相对简单，只要你完整的看完了此文的链表设计，最起码可以轻松淦掉20题，同时链表题目数量也比较少，一共也就有50题左右，还有十来题需要会员，也就是说刷个40题，链表这种数据结构就可以初步掌握了，如果你不想找题排序，可以按照我的 GitHub 算法仓库库中的顺序刷题，有不太懂的题目或者概念可以看我写的题解，同时我也录制了视频，文末有链接，那么我们来开始学习链表，GO！</p><h2 id="什么是链表"><a href="#什么是链表" class="headerlink" title="什么是链表"></a>什么是链表</h2><p>通常我们在程序中想要存储多个元素，数组可能是最常用的数据结构，数组这种数据结构非常方便，它甚至可以通过非常简单的方式即 <code>[]</code> 这种语法来访问其元素</p><p>而链表存储的也是有序的元素集合，但不同于数组的是，链表中的元素在内存中并不是连续的，每个元素由一个存储元素本身的节点和一个指向下一个元素的引用（也可以称为指针）组成</p><p><img src="https://cdn.jsdelivr.net/gh/isboyjc/PictureBed/other/image-20201227022306651.png"></p><p>我们接着再来看数组这种数据结构，它有一个缺点，在大多数语言中数组的大小是固定的，从数组的起点或中间插入或移除项的成本很高，因为需要移动元素，如下图</p><p><img src="https://cdn.jsdelivr.net/gh/isboyjc/PictureBed/other/image-20201227023740687.png"></p><p>上图数组删除索引为 2 值为 3 的元素，那么我们首先要删掉 3 这个元素，因为索引为 2 值为 3 的元素删除了，索引 2 就空了，所以接着，我们要把索引 3 也就是元素 4 向前移动一位，与此同时后面的元素 5 也需要向前移动一位，向数组中插入一个元素也是这个道理，只要数组中少了一位或者多了一位，那么后面的元素都要依次向前或向后移动一位，那么可想而之，当数组长度很大的时候，插入及删除的效率就会逐渐降低</p><p>我们再来看看链表</p><p><img src="https://cdn.jsdelivr.net/gh/isboyjc/PictureBed/other/image-20201227024501152.png"></p><p>同样是删除元素 3，链表这里只需要迭代到值为 3 的节点，将节点 2 指向节点 4 就行了，节点 3 没有了引用关系，就会被垃圾回收机制当作垃圾回收了，即使当节点非常多的情况下，依然只用改变一下引用关系即可删除元素，而插入元素则是反过来，即先断开插入位置两边的元素，然后让前一个元素指向插入元素，插入元素指向后一个元素即可，元素越多对比数组的效率就会越高</p><p>相对于传统的数组，链表的一个好处就在于，添加或移除元素的时候不需要移动其他元素，但是在数组中，我们可以直接访问任何位置的任何元素，链表中是不行的，因为链表中每个节点只有对下一个节点的引用，所以想访问链表中间的一个元素，必须要从起点（链表头部节点）开始迭代链表直到找到所需的元素，这点需要注意</p><h2 id="JavaScript中的链表"><a href="#JavaScript中的链表" class="headerlink" title="JavaScript中的链表"></a>JavaScript中的链表</h2><p>上面我们简单介绍了常规链表的概念，但是在 JavaScript 这门语言中，我们怎么表示链表呢？</p><p>由于 JS 中没有内置链表这种数据结构，所以我们需要使用对象来模拟实现链表，就如同我们上面介绍链表，它其实是一个单向链表，除此之外还有双向链表、环形链表等等，我们接下来会一一介绍并使用 JavaScript 来实现下</p><h3 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h3><p>我们先来看基础的单项链表，单向链表每个元素由一个存储元素本身的节点和一个指向下一个元素的指针构成，如下图</p><p><img src="https://cdn.jsdelivr.net/gh/isboyjc/PictureBed/other/image-20201227135703111.png"></p><p>要实现链表这种数据结构，关键在于保存 head 元素（即链表的头元素）以及每一个元素的 next 指针，有这两部分我们就可以很方便地遍历链表从而操作所有的元素，你可以把链表想象成一条铁链，铁链中的每一个节点都是相互连接的，我们只要找到铁链的头，整条铁链就都可以找到了，那么单向链表在 JS 中究竟要如何来模拟呢，我们一步一步来</p><p>首先，我们要创建一个类，这个类的作用就是描述链表的节点，它很简单，只需要有两个属性就可以了，一个用来保存此节点的值，一个用来保存指向下一个节点的指针，如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>: 创建链表单节点类</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;*&#125;</span> </span>val 节点值</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;*&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ListNode</span>(<span class="hljs-params">val</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.val = val<br>  <span class="hljs-built_in">this</span>.next = <span class="hljs-literal">null</span><br>&#125;<br></code></pre></td></tr></table></figure><p>接着，我们需要先写一个链表类，其中 length属性 代表链表长度，head属性 代表链表头部节点</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>: 创建链表类</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;*&#125;</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;*&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">LinkedList</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.length = <span class="hljs-number">0</span><br>  <span class="hljs-built_in">this</span>.head = <span class="hljs-literal">null</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们思考下，既然是来模拟一个链表类，那么就应该把它所有可能会用到的特性都塞进这个类里，就比如数组有 <code>push/splice/indexOf/...</code> 等等这些好用的方法我们链表必须也得有啊，我们先仔细构思下要给链表添加哪些实用的特性或者说方法，先搭一个基础骨架，这里我列出了很多，我们来一一实现下，也欢迎补充</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 向链表中追加节点</span><br>LinkedList.prototype.append = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">val</span>) </span>&#123; &#125;<br><br><span class="hljs-comment">// 在链表的指定位置插入节点</span><br>LinkedList.prototype.insert = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">index, val</span>) </span>&#123; &#125;<br><br><span class="hljs-comment">// 删除链表中指定位置的元素，并返回这个元素的值</span><br>LinkedList.prototype.removeAt = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">index</span>) </span>&#123; &#125;<br><br><span class="hljs-comment">// 删除链表中对应的元素</span><br>LinkedList.prototype.remove = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">val</span>) </span>&#123; &#125;<br><br><span class="hljs-comment">// 获取链表中给定元素的索引</span><br>LinkedList.prototype.indexOf = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">val</span>) </span>&#123; &#125;<br><br><span class="hljs-comment">// 获取链表中某个节点</span><br>LinkedList.prototype.find = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">val</span>) </span>&#123; &#125;<br><br><span class="hljs-comment">// 获取链表中索引所对应的元素</span><br>LinkedList.prototype.getElementAt = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">index</span>) </span>&#123; &#125;<br><br><span class="hljs-comment">// 判断链表是否为空</span><br>LinkedList.prototype.isEmpty = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; &#125;<br><br><span class="hljs-comment">// 获取链表的长度</span><br>LinkedList.prototype.size = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; &#125;<br><br><span class="hljs-comment">// 获取链表的头元素</span><br>LinkedList.prototype.getHead = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; &#125;<br><br><span class="hljs-comment">// 清空链表</span><br>LinkedList.prototype.clear = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; &#125;<br><br><span class="hljs-comment">// 序列化链表</span><br>LinkedList.prototype.join = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">string</span>) </span>&#123; &#125;<br></code></pre></td></tr></table></figure><h4 id="getElementAt-index"><a href="#getElementAt-index" class="headerlink" title="getElementAt(index)"></a>getElementAt(<em>index</em>)</h4><p>我们先来实现获取链表中索引所对应的元素即 <code>getElementAt</code> 方法以及通过节点值获取链表元素即 <code>find</code> 方法，因为后面要多次用到它们，我们先说 <code>getElementAt</code> 方法，上面我们说想要找一个元素，我们必须从头迭代，所以我们直接根据传入的索引进行迭代即可</p><p>首先判断参数 <code>index</code> 的边界值，如果值超出了索引的范围（小于 0 或者大于 <code>length - 1</code>），则返回<code>null</code>，我们从链表的 <code>head</code> 节点开始，遍历整个链表直到找到对应索引位置的节点，然后返回这个节点，是不是很简单？和所有有序数据集合一样，链表的索引也是从 0 开始，只要有链表的头节点，就可以遍历找到索引所在位置的元素，所以我们在构造函数即 <code>LinkedList</code> 类中保存了 <code>head</code> 值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 获取链表中索引所对应的元素</span><br>LinkedList.prototype.getElementAt = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">index</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= <span class="hljs-built_in">this</span>.length) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span><br><br>  <span class="hljs-keyword">let</span> cur = <span class="hljs-built_in">this</span>.head<br>  <span class="hljs-keyword">while</span> (index--) &#123;<br>    cur = cur.next<br>  &#125;<br>  <span class="hljs-keyword">return</span> cur<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="find-val"><a href="#find-val" class="headerlink" title="find(val)"></a>find(<em>val</em>)</h4><p><code>find</code> 方法和 <code>getElementAt</code> 方法类似，一个通过索引找元素，一个通过节点值找元素，所以我们直接迭代查找对比即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 获取链表中某个节点</span><br>LinkedList.prototype.find = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">val</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> cur = <span class="hljs-built_in">this</span>.head<br>  <span class="hljs-keyword">while</span> (cur) &#123;<br>    <span class="hljs-keyword">if</span> (cur.val == val) <span class="hljs-keyword">return</span> cur<br>    cur = cur.next<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="append-val"><a href="#append-val" class="headerlink" title="append(val)"></a>append(<em>val</em>)</h4><p>有了 <code>getElementAt</code> 方法后，接下来我们就可以很方便地实现 <code>append</code> 方法，此方法的作用是在链表末尾追加元素</p><p>此方法传入的是一个值，我们可以通过上面的构造函数 <code>ListNode</code> 来创建一个新节点</p><p>而后，我们需要考虑，如果链表的 <code>head</code> 为 <code>null</code> 时，这种情况表示链表为空，所以需要将 <code>head</code> 节点指向新添加的元素，以此来确保存储头节点，如果不为空，我们通过 <code>getElementAt</code> 方法找到链表的最后一个节点，最后一个节点的索引就是构造函数中的我们存的链表长度 <code>length</code> 属性减去 1，再将最后一个节点的 <code>next</code> 指针指向新添加的元素即可</p><p>新添加的元素 <code>next</code> 指针默认为 <code>null</code>，链表最后一个元素的 <code>next</code> 值也就为 <code>null</code>，另外，将节点挂到链表上之后，还需将链表的长度加 1，保证 <code>length</code> 属性等于链表长度，如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 向链表中追加节点</span><br>LinkedList.prototype.append = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">val</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> node = <span class="hljs-keyword">new</span> ListNode(val)<br><br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.head) &#123;<br>    <span class="hljs-built_in">this</span>.head = node<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">let</span> cur = <span class="hljs-built_in">this</span>.getElementAt(<span class="hljs-built_in">this</span>.length - <span class="hljs-number">1</span>)<br>    cur.next = node<br>  &#125;<br>  <span class="hljs-built_in">this</span>.length++<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="insert-index-val"><a href="#insert-index-val" class="headerlink" title="insert(index, val)"></a>insert(<em>index</em>, <em>val</em>)</h4><p>接下来我们要实现 <code>insert</code> 方法，即在链表的任意位置添加节点</p><p>在指定位置插入元素，首先我们还是需要先判断下传入 <code>index</code> 索引是否超出边界</p><p>接着我们分两种情况考虑</p><p>当 <code>index</code> 的值为 0 时，表示要在链表的头部插入新节点，将新插入节点的 <code>next</code> 指针指向现在的 <code>head</code>，然后更新 <code>head</code> 的值为新插入的节点即可，如下图</p><p><img src="https://cdn.jsdelivr.net/gh/isboyjc/PictureBed/other/image-20201227172151358.png"></p><p>当 <code>index</code> 的值不为 0 时，即插入的节点在链表的中间或者尾部，我们首先找到待插入位置的前一个节点 <code>prevNode</code>，然后将新节点 <code>newNode</code> 的 <code>next</code> 指针指向 <code>prevNode</code> 的 <code>next</code> 所对应的节点，再将 <code>prevNode</code> 的 <code>next</code> 指针指向 <code>newNode</code>，这样就把新节点插入链表中了，当插入的节点在链表的尾部，这种方法也同样适用，如下图</p><p><img src="https://cdn.jsdelivr.net/gh/isboyjc/PictureBed/other/image-20201227172716975.png"></p><p>最后，我们插入了节点，还需要将链表的长度即 <code>length</code> 长度加 1，代码如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 在链表的指定位置插入节点</span><br>LinkedList.prototype.insert = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">index, val</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt; <span class="hljs-built_in">this</span>.length) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br><br>  <span class="hljs-keyword">let</span> node = <span class="hljs-keyword">new</span> ListNode(val)<br><br>  <span class="hljs-keyword">if</span> (index === <span class="hljs-number">0</span>) &#123;<br>    node.next = <span class="hljs-built_in">this</span>.head<br>    <span class="hljs-built_in">this</span>.head = node<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">let</span> prev = <span class="hljs-built_in">this</span>.getElementAt(index - <span class="hljs-number">1</span>)<br>    node.next = prev.next<br>    prev.next = node<br>  &#125;<br><br>  <span class="hljs-built_in">this</span>.length++<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="removeAt-index"><a href="#removeAt-index" class="headerlink" title="removeAt(index)"></a>removeAt(<em>index</em>)</h4><p>相同的方式，我们可以很容易地写出 <code>removeAt</code> 方法，用来删除链表中指定位置的节点</p><p>依然还是先判断下传入 <code>index</code> 索引是否超出边界</p><p>还是分两种情况</p><p>如果要删除的节点是链表的头部，将 <code>head</code> 移到下一个节点即可，如果当前链表只有一个节点，那么下一个节点为 <code>null</code>，此时将 <code>head</code> 指向下一个节点等同于将 <code>head</code> 设置成 <code>null</code>，删除之后链表为空</p><p><img src="https://cdn.jsdelivr.net/gh/isboyjc/PictureBed/other/image-20201227180334649.png"></p><p>如果要删除的节点在链表的中间部分，我们需要找出 <code>index</code> 所在位置的前一个节点，将它的 <code>next</code> 指针指向 <code>index</code> 所在位置的下一个节点，总之，删除节点只需要修改相应节点的指针，断开删除位置左右相邻的节点再重新连接上即可</p><p><img src="https://cdn.jsdelivr.net/gh/isboyjc/PictureBed/other/image-20201227180444604.png" alt="image-20201227180444604"></p><p>被删除的节点没有了引用关系，JavaScript 垃圾回收机制会处理它，关于垃圾回收机制，同样不在此文讨论范围内，知道即可，删除节点元素，我们还需将链表的长度减 1，最终代码如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 删除链表中指定位置的元素，并返回这个元素的值</span><br>LinkedList.prototype.removeAt = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">index</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= <span class="hljs-built_in">this</span>.length) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span><br><br>  <span class="hljs-keyword">let</span> cur = <span class="hljs-built_in">this</span>.head<br><br>  <span class="hljs-keyword">if</span> (index === <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-built_in">this</span>.head = cur.next<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">let</span> prev = <span class="hljs-built_in">this</span>.getElementAt(index - <span class="hljs-number">1</span>)<br>    cur = prev.next<br>    prev.next = cur.next<br>  &#125;<br><br>  <span class="hljs-built_in">this</span>.length--<br>  <span class="hljs-keyword">return</span> cur.val<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="indexOf-val"><a href="#indexOf-val" class="headerlink" title="indexOf(val)"></a>indexOf(<em>val</em>)</h4><p>获取链表中给定元素的索引，这个比较简单，直接迭代即可，匹配到了返回对应索引，匹配不到返回 -1</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 获取链表中给定元素的索引</span><br>LinkedList.prototype.indexOf = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">val</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> cur = <span class="hljs-built_in">this</span>.head<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">this</span>.length; i++) &#123;<br>    <span class="hljs-keyword">if</span> (cur.val === val) <span class="hljs-keyword">return</span> i<br>    cur = cur.next<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="remove-val"><a href="#remove-val" class="headerlink" title="remove(val)"></a>remove(<em>val</em>)</h4><p>删除链表中对应的元素，有了之前的铺垫，这里就比较简单了，我们可以直接用 <code>indexOf</code> 方法拿到对应索引，再使用 <code>removeAt</code> 方法删除节点即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 删除链表中对应的元素</span><br>LinkedList.prototype.remove = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">val</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> index = <span class="hljs-built_in">this</span>.indexOf(val)<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.removeAt(index)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="isEmpty"><a href="#isEmpty" class="headerlink" title="isEmpty()"></a>isEmpty()</h4><p>判断链表是否为空，只需要我们判断一下链表长度 <code>length</code> 等不等于 0 即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 判断链表是否为空</span><br>LinkedList.prototype.isEmpty = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> !<span class="hljs-built_in">this</span>.length<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="size"><a href="#size" class="headerlink" title="size()"></a>size()</h4><p>获取链表长度就是取其 <code>length</code> </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 获取链表的长度</span><br>LinkedList.prototype.size = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.length<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="getHead"><a href="#getHead" class="headerlink" title="getHead()"></a>getHead()</h4><p> 获取链表的头元素即返回 <code>head</code> 属性即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 获取链表的头元素</span><br>LinkedList.prototype.getHead = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.head<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="clear"><a href="#clear" class="headerlink" title="clear()"></a>clear()</h4><p>清空链表，我们只需要将 <code>head</code> 置空，然后让 <code>length</code> 等于 0，等待垃圾回收机制回收无引用的废弃链表即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 清空链表</span><br>LinkedList.prototype.clear = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.head = <span class="hljs-literal">null</span><br>  <span class="hljs-built_in">this</span>.length = <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="join-string"><a href="#join-string" class="headerlink" title="join(string)"></a>join(<em>string</em>)</h4><p>序列化链表即使用指定格式输出链表，类似于数组中 <code>join</code> 方法，此举旨在便于我们测试</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 序列化链表</span><br>LinkedList.prototype.join = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">string</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> cur = <span class="hljs-built_in">this</span>.head<br>  <span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;&#x27;</span><br>  <span class="hljs-keyword">while</span> (cur) &#123;<br>    str += cur.val<br><br>    <span class="hljs-keyword">if</span> (cur.next) str += string<br><br>    cur = cur.next<br>  &#125;<br>  <span class="hljs-keyword">return</span> str<br>&#125;<br></code></pre></td></tr></table></figure><p>那么到此，我们的单向链表类就设计完成了，快来测试一下吧，我们输入下面代码进行测试</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> linkedList = <span class="hljs-keyword">new</span> LinkedList()<br>linkedList.append(<span class="hljs-number">10</span>)<br>linkedList.append(<span class="hljs-number">20</span>)<br>linkedList.append(<span class="hljs-number">30</span>)<br><br><span class="hljs-built_in">console</span>.log(linkedList.join(<span class="hljs-string">&quot;--&quot;</span>))<br><br>linkedList.insert(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>)<br>linkedList.insert(<span class="hljs-number">2</span>, <span class="hljs-number">15</span>)<br>linkedList.insert(<span class="hljs-number">4</span>, <span class="hljs-number">25</span>)<br><span class="hljs-built_in">console</span>.log(linkedList.join(<span class="hljs-string">&quot;--&quot;</span>))<br><br><span class="hljs-built_in">console</span>.log(linkedList.removeAt(<span class="hljs-number">0</span>))<br><span class="hljs-built_in">console</span>.log(linkedList.removeAt(<span class="hljs-number">1</span>))<br><span class="hljs-built_in">console</span>.log(linkedList.removeAt(<span class="hljs-number">2</span>))<br><span class="hljs-built_in">console</span>.log(linkedList.join(<span class="hljs-string">&quot;--&quot;</span>))<br><br><span class="hljs-built_in">console</span>.log(linkedList.indexOf(<span class="hljs-number">20</span>))<br><br>linkedList.remove(<span class="hljs-number">20</span>)<br><br><span class="hljs-built_in">console</span>.log(linkedList.join(<span class="hljs-string">&quot;--&quot;</span>))<br><br><span class="hljs-built_in">console</span>.log(linkedList.find(<span class="hljs-number">10</span>))<br><br>linkedList.clear()<br><span class="hljs-built_in">console</span>.log(linkedList.size())<br></code></pre></td></tr></table></figure><p>最终输出如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 10--20--30</span><br><span class="hljs-comment">// 5--10--15--20--25--30</span><br><span class="hljs-comment">// 5</span><br><span class="hljs-comment">// 15</span><br><span class="hljs-comment">// 25</span><br><span class="hljs-comment">// 10--20--30</span><br><span class="hljs-comment">// 1</span><br><span class="hljs-comment">// 10--30</span><br><span class="hljs-comment">// ListNode &#123; val: 10, next: ListNode &#123; val: 30, next: null &#125; &#125;</span><br><span class="hljs-comment">// 0</span><br></code></pre></td></tr></table></figure><p>上面代码中少了一些参数校验，不过够我们学习用了，完成代码文末附链接</p><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p>上面我们说了单向链表，接下来我们来说双向链表，那么什么是双向链表呢？其实听名字就可以听出来，单向链表中每一个元素只有一个 <code>next</code> 指针，用来指向下一个节点，我们只能从链表的头部开始遍历整个链表，任何一个节点只能找到它的下一个节点，而不能找到它的上一个节点，双向链表中的每一个元素拥有两个指针，一个用来指向下一个节点，一个用来指向上一个节点，双向链表中，除了可以像单向链表一样从头部开始遍历之外，还可以从尾部进行遍历，如下图</p><p><img src="https://cdn.jsdelivr.net/gh/isboyjc/PictureBed/other/image-20201227215932114.png"></p><p>同单向链表，我们首先创建链表节点类，不同的是，它需要多一个 <code>prev</code> 属性用来指向前一个节点</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>: 创建双向链表单节点类</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;*&#125;</span> </span>val 节点值</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;*&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ListNode</span>(<span class="hljs-params">val</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.val = val<br>  <span class="hljs-built_in">this</span>.next = <span class="hljs-literal">null</span><br>  <span class="hljs-built_in">this</span>.prev = <span class="hljs-literal">null</span><br>&#125;<br></code></pre></td></tr></table></figure><p>双向链表类同单向链表多增加了一个尾部节点 <code>tail</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>: 创建双向链表类</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;*&#125;</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;*&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">DoubleLinkedList</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.length = <span class="hljs-number">0</span><br>  <span class="hljs-built_in">this</span>.head = <span class="hljs-literal">null</span><br>  <span class="hljs-built_in">this</span>.tail = <span class="hljs-literal">null</span><br>&#125;<br></code></pre></td></tr></table></figure><p>接下来我们来实现双向链表的原型方法</p><h4 id="getElementAt-index-1"><a href="#getElementAt-index-1" class="headerlink" title="getElementAt(index)"></a>getElementAt(<em>index</em>)</h4><p>首先就是，获取双向链表中索引所对应的元素，双向链表由于可以双向进行迭代查找，所以这里 <code>getElementAt</code> 方法我们可以进行优化，当索引大于链表长度 <code>length/2</code> 时，我们可以从后往前找，反之则从前向后找，这样可以更快找到该节点元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 获取双向链表中索引所对应的元素</span><br>DoubleLinkedList.prototype.getElementAt = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">index</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= <span class="hljs-built_in">this</span>.length) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span><br><br>  <span class="hljs-keyword">let</span> cur = <span class="hljs-literal">null</span><br>  <span class="hljs-keyword">if</span>(index &gt; <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">this</span>.length / <span class="hljs-number">2</span>))&#123;<br>    <span class="hljs-comment">// 从后往前</span><br>    cur = <span class="hljs-built_in">this</span>.tail<br>    <span class="hljs-keyword">let</span> i = <span class="hljs-built_in">this</span>.length - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> (i &gt; index) &#123;<br>      cur = cur.prev<br>      i--<br>    &#125;<br>  &#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-comment">// 从前往后</span><br>    cur = <span class="hljs-built_in">this</span>.head<br>    <span class="hljs-keyword">while</span> (index--) &#123;<br>      cur = cur.next<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> cur<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="find-val-1"><a href="#find-val-1" class="headerlink" title="find(val)"></a>find(<em>val</em>)</h4><p><code>find</code> 方法和 <code>getElementAt</code> 方法是类似的，<code>getElementAt</code> 方法可以优化，那么 <code>find</code> 再变成双向链表后也可优化，我们想，既然双向都可以进行迭代，那么我们两边同时迭代岂不是更快，双向迭代的情况下，只有找不到时才会迭代整个链表，效率更高</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 获取双向链表中某个节点</span><br>DoubleLinkedList.prototype.find = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">val</span>) </span>&#123;<br><span class="hljs-keyword">let</span> curHead = <span class="hljs-built_in">this</span>.head<br>  <span class="hljs-keyword">let</span> curTail = <span class="hljs-built_in">this</span>.tail<br>  <span class="hljs-keyword">while</span> (curHead) &#123;<br>    <span class="hljs-keyword">if</span> (curHead.val == val) <span class="hljs-keyword">return</span> curHead<br>    curHead = curHead.next<br><br>    <span class="hljs-keyword">if</span> (curTail.val == val) <span class="hljs-keyword">return</span> curTail<br>    curTail = curTail.prev<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="append-val-1"><a href="#append-val-1" class="headerlink" title="append(val)"></a>append(<em>val</em>)</h4><p>又来到了我们的追加节点元素，双向链表追加与单向链表还是有些区别的</p><p>当链表为空时，除了要将 <code>head</code> 指向当前添加的节点外，还要将 <code>tail</code> 也指向当前要添加的节点</p><p>当链表不为空时，直接将 <code>tail</code> 的 <code>next</code> 指向当前要添加的节点 <code>node</code>，然后修改 <code>node</code> 的 <code>prev</code> 指向旧的 <code>tail</code>，最后修改 <code>tail</code> 为新添加的节点</p><p>双向链表的追加操作我们不需要从头开始遍历整个链表，通过 <code>tail</code> 可以直接找到链表的尾部，这一点比单向链表的操作更方便，最后将 <code>length</code> 值加 1，修改链表的长度即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 向双向链表中追加节点</span><br>DoubleLinkedList.prototype.append = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">val</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> node = <span class="hljs-keyword">new</span> ListNode(val)<br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.head === <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-comment">// 链表为空，head 和 tail 都指向当前添加的节点</span><br>    <span class="hljs-built_in">this</span>.head = node<br>    <span class="hljs-built_in">this</span>.tail = node<br>  &#125;<br>  <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 链表不为空，将当前节点添加到链表的尾部</span><br>    <span class="hljs-built_in">this</span>.tail.next = node<br>    node.prev = <span class="hljs-built_in">this</span>.tail<br>    <span class="hljs-built_in">this</span>.tail = node<br>  &#125;<br><br>  <span class="hljs-built_in">this</span>.length++<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="insert-index-val-1"><a href="#insert-index-val-1" class="headerlink" title="insert(index, val)"></a>insert(<em>index</em>, <em>val</em>)</h4><p>接着是插入节点元素方法，同样思路一致，并不困难，我们注意 <code>tail</code> 及 <code>prev</code> 指针分情况讨论，插入后长度加 1 即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 在双向链表的指定位置插入节点</span><br>DoubleLinkedList.prototype.insert = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">index, val</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt; <span class="hljs-built_in">this</span>.length) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br><br>  <span class="hljs-comment">// 插入到尾部</span><br>  <span class="hljs-keyword">if</span> (index === <span class="hljs-built_in">this</span>.length) &#123;<br>    <span class="hljs-built_in">this</span>.append(val)<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">let</span> node = <span class="hljs-keyword">new</span> ListNode(val)<br><br>    <span class="hljs-keyword">if</span> (index === <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 插入到头部</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.head === <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-built_in">this</span>.head = node<br>        <span class="hljs-built_in">this</span>.tail = node<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        node.next = <span class="hljs-built_in">this</span>.head<br>        <span class="hljs-built_in">this</span>.head.prev = node<br>        <span class="hljs-built_in">this</span>.head = node<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 插入到中间位置</span><br>      <span class="hljs-keyword">let</span> curNode = <span class="hljs-built_in">this</span>.getElementAt(index)<br>      <span class="hljs-keyword">let</span> prevNode = curNode.prev<br>      node.next = curNode<br>      node.prev = prevNode<br>      prevNode.next = node<br>      curNode.prev = node<br>    &#125;<br>    <span class="hljs-built_in">this</span>.length++<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="removeAt-index-1"><a href="#removeAt-index-1" class="headerlink" title="removeAt(index)"></a>removeAt(<em>index</em>)</h4><p>删除双向链表中指定位置的元素，同样是注意 <code>tail</code> 及 <code>prev</code> 指针分情况讨论，最后删除后长度减 1 即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 删除双向链表中指定位置的元素，并返回这个元素的值</span><br>DoubleLinkedList.prototype.removeAt = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">index</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= <span class="hljs-built_in">this</span>.length) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span><br><br>  <span class="hljs-keyword">let</span> current = <span class="hljs-built_in">this</span>.head<br>  <span class="hljs-keyword">let</span> prevNode<br><br>  <span class="hljs-keyword">if</span> (index === <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 移除头部元素</span><br>    <span class="hljs-built_in">this</span>.head = current.next<br>    <span class="hljs-built_in">this</span>.head.prev = <span class="hljs-literal">null</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.length === <span class="hljs-number">1</span>) <span class="hljs-built_in">this</span>.tail = <span class="hljs-literal">null</span><br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (index === <span class="hljs-built_in">this</span>.length - <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 移除尾部元素</span><br>    current = <span class="hljs-built_in">this</span>.tail<br>    <span class="hljs-built_in">this</span>.tail = current.prev<br>    <span class="hljs-built_in">this</span>.tail.next = <span class="hljs-literal">null</span><br>  &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 移除中间元素</span><br>    current = <span class="hljs-built_in">this</span>.getElementAt(index)<br>    prevNode = current.prev<br>    prevNode.next = current.next<br>    current.next.prev = prevNode<br>  &#125;<br><br>  <span class="hljs-built_in">this</span>.length--<br>  <span class="hljs-keyword">return</span> current.val<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="indexOf-val-1"><a href="#indexOf-val-1" class="headerlink" title="indexOf(val)"></a>indexOf(<em>val</em>)</h4><p>在双向链表中查找元素索引，有了上面的 <code>find</code> 方法做铺垫，这里就简单了，思路一致，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 获取双向链表中给定元素的索引</span><br>DoubleLinkedList.prototype.indexOf = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">val</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> curHead = <span class="hljs-built_in">this</span>.head<br>  <span class="hljs-keyword">let</span> curTail = <span class="hljs-built_in">this</span>.tail<br>  <span class="hljs-keyword">let</span> idx = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">while</span> (curHead !== curTail) &#123;<br>    <span class="hljs-keyword">if</span> (curHead.val == val) <span class="hljs-keyword">return</span> idx<br>    curHead = curHead.next<br><br>    <span class="hljs-keyword">if</span> (curTail.val == val) <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.length - <span class="hljs-number">1</span> - idx<br>    curTail = curTail.prev<br><br>    idx++<br>  &#125;<br>  <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="joinstring"><a href="#joinstring" class="headerlink" title="joinstring)"></a>join<em>string</em>)</h4><p>序列化链表我们还是和上面单向链表一致即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 序列化双向链表</span><br>DoubleLinkedList.prototype.join = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">string</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> cur = <span class="hljs-built_in">this</span>.head<br>  <span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;&#x27;</span><br>  <span class="hljs-keyword">while</span> (cur) &#123;<br>    str += cur.val<br><br>    <span class="hljs-keyword">if</span> (cur.next) str += string<br><br>    cur = cur.next<br>  &#125;<br>  <span class="hljs-keyword">return</span> str<br>&#125;<br></code></pre></td></tr></table></figure><p>双向链表我们就介绍这么多，剩下的方法比较简单，就不赘述了，文末双向链表案例中有完整代码</p><p>同样，我们来简单测试一下对与否</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> doubleLinkedList = <span class="hljs-keyword">new</span> DoubleLinkedList()<br>doubleLinkedList.append(<span class="hljs-number">10</span>)<br>doubleLinkedList.append(<span class="hljs-number">15</span>)<br>doubleLinkedList.append(<span class="hljs-number">20</span>)<br>doubleLinkedList.append(<span class="hljs-number">25</span>)<br><span class="hljs-built_in">console</span>.log(doubleLinkedList.join(<span class="hljs-string">&quot;&lt;-&gt;&quot;</span>))<br><br><span class="hljs-built_in">console</span>.log(doubleLinkedList.getElementAt(<span class="hljs-number">0</span>).val)<br><span class="hljs-built_in">console</span>.log(doubleLinkedList.getElementAt(<span class="hljs-number">1</span>).val)<br><span class="hljs-built_in">console</span>.log(doubleLinkedList.getElementAt(<span class="hljs-number">5</span>))<br><br><span class="hljs-built_in">console</span>.log(doubleLinkedList.join(<span class="hljs-string">&quot;&lt;-&gt;&quot;</span>))<br><span class="hljs-built_in">console</span>.log(doubleLinkedList.indexOf(<span class="hljs-number">10</span>))<br><span class="hljs-built_in">console</span>.log(doubleLinkedList.indexOf(<span class="hljs-number">25</span>))<br><span class="hljs-built_in">console</span>.log(doubleLinkedList.indexOf(<span class="hljs-number">50</span>))<br><br>doubleLinkedList.insert(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>)<br>doubleLinkedList.insert(<span class="hljs-number">3</span>, <span class="hljs-number">18</span>)<br>doubleLinkedList.insert(<span class="hljs-number">6</span>, <span class="hljs-number">30</span>)<br><span class="hljs-built_in">console</span>.log(doubleLinkedList.join(<span class="hljs-string">&quot;&lt;-&gt;&quot;</span>))<br><br><span class="hljs-built_in">console</span>.log(doubleLinkedList.find(<span class="hljs-number">10</span>).val)<br><span class="hljs-built_in">console</span>.log(doubleLinkedList.removeAt(<span class="hljs-number">0</span>))<br><span class="hljs-built_in">console</span>.log(doubleLinkedList.removeAt(<span class="hljs-number">1</span>))<br><span class="hljs-built_in">console</span>.log(doubleLinkedList.removeAt(<span class="hljs-number">5</span>))<br><span class="hljs-built_in">console</span>.log(doubleLinkedList.remove(<span class="hljs-number">10</span>))<br><span class="hljs-built_in">console</span>.log(doubleLinkedList.remove(<span class="hljs-number">100</span>))<br><br><span class="hljs-built_in">console</span>.log(doubleLinkedList.join(<span class="hljs-string">&quot;&lt;-&gt;&quot;</span>))<br></code></pre></td></tr></table></figure><p>上面代码输出如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 10&lt;-&gt;15&lt;-&gt;20&lt;-&gt;25</span><br><span class="hljs-comment">// 10</span><br><span class="hljs-comment">// 15</span><br><span class="hljs-comment">// null</span><br><span class="hljs-comment">// 10&lt;-&gt;15&lt;-&gt;20&lt;-&gt;25</span><br><span class="hljs-comment">// 0</span><br><span class="hljs-comment">// 3</span><br><span class="hljs-comment">// -1</span><br><span class="hljs-comment">// 5&lt;-&gt;10&lt;-&gt;15&lt;-&gt;18&lt;-&gt;20&lt;-&gt;25&lt;-&gt;30</span><br><span class="hljs-comment">// 10</span><br><span class="hljs-comment">// 5</span><br><span class="hljs-comment">// 15</span><br><span class="hljs-comment">// null</span><br><span class="hljs-comment">// 10</span><br><span class="hljs-comment">// null</span><br><span class="hljs-comment">// 18&lt;-&gt;20&lt;-&gt;25&lt;-&gt;30</span><br></code></pre></td></tr></table></figure><p>嗯，没有报错，简单对比一下，是正确的，No Problem</p><h3 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h3><p>我们再来看另一种链表，环形链表，顾名思义，环形链表的尾部节点指向它自己的头节点</p><p>环形链表有单向环形链表，也可以有双向环形链表，如下图</p><p><img src="https://cdn.jsdelivr.net/gh/isboyjc/PictureBed/other/image-20201228203035921.png"></p><p>单双环形链表这里我们就不再一一的写了，你可以尝试自己写一下，对比上面我们环形链表只需要注意下尾部节点要指向头节点即可</p><h2 id="为什么JavaScript中不内置链表？"><a href="#为什么JavaScript中不内置链表？" class="headerlink" title="为什么JavaScript中不内置链表？"></a>为什么JavaScript中不内置链表？</h2><p>根据我们上面所说，链表有这么多优点，那么为什么 <code>JavaScript</code> 这门语言不内置链表这种数据结构呢？</p><p>其实 JS 中，数组几乎实现了链表的所有功能，所以没那个必要去再麻烦一次了，听到这里你可能会疑惑，上面不是说，数组在某些情况（例如头部插入等等）下性能不如链表吗？</p><p>我们来用事实说话，现在我们用上面完成的单向链表类 <code>LinkedList</code>，同原生数组做一个简单的的时间测试</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> linkedList = <span class="hljs-keyword">new</span> LinkedList()<br><span class="hljs-keyword">let</span> arr = []<br><br><span class="hljs-comment">// 测试 分别尝试 「总数100 插入节点50」/「总数100000 插入节点50000」</span><br><span class="hljs-keyword">let</span> count = <span class="hljs-number">100</span><br><span class="hljs-keyword">let</span> insertIndex = <span class="hljs-number">50</span><br><span class="hljs-comment">// let count = 100000</span><br><span class="hljs-comment">// let insertIndex = 50000</span><br><br><span class="hljs-built_in">console</span>.time(<span class="hljs-string">&#x27;链表push操作&#x27;</span>)<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>  linkedList.append(i)<br>&#125;<br><span class="hljs-built_in">console</span>.timeEnd(<span class="hljs-string">&#x27;链表push操作&#x27;</span>)<br><br><span class="hljs-built_in">console</span>.time(<span class="hljs-string">&#x27;数组push操作&#x27;</span>)<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>  arr.push(i)<br>&#125;<br><span class="hljs-built_in">console</span>.timeEnd(<span class="hljs-string">&#x27;数组push操作&#x27;</span>)<br><br><br><span class="hljs-built_in">console</span>.time(<span class="hljs-string">&#x27;链表insert操作&#x27;</span>)<br>linkedList.insert(<span class="hljs-string">&#x27;test节点&#x27;</span>, insertIndex)<br><span class="hljs-built_in">console</span>.timeEnd(<span class="hljs-string">&#x27;链表insert操作&#x27;</span>)<br><br><span class="hljs-built_in">console</span>.time(<span class="hljs-string">&#x27;数组insert操作&#x27;</span>)<br>arr.splice(insertIndex, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;test节点&#x27;</span>)<br><span class="hljs-built_in">console</span>.timeEnd(<span class="hljs-string">&#x27;数组insert操作&#x27;</span>)<br><br><br><span class="hljs-built_in">console</span>.time(<span class="hljs-string">&#x27;链表remove操作&#x27;</span>)<br>linkedList.removeAt(insertIndex)<br><span class="hljs-built_in">console</span>.timeEnd(<span class="hljs-string">&#x27;链表remove操作&#x27;</span>)<br><br><span class="hljs-built_in">console</span>.time(<span class="hljs-string">&#x27;数组remove操作&#x27;</span>)<br>arr.splice(insertIndex, <span class="hljs-number">1</span>)<br><span class="hljs-built_in">console</span>.timeEnd(<span class="hljs-string">&#x27;数组remove操作&#x27;</span>)<br></code></pre></td></tr></table></figure><p>我们来看下结果</p><p>追加 100 个数据，在索引 50 插入元素，再删除插入的元素</p><p><img src="https://cdn.jsdelivr.net/gh/isboyjc/PictureBed/other/image-20201228210751995.png"></p><p>追加 100000 个数据，在索引 50000 插入元素，再删除插入的元素</p><p><img src="https://cdn.jsdelivr.net/gh/isboyjc/PictureBed/other/image-20201228210701979.png"></p><p>What？？？？？？</p><p>我们从测试结果可以看到不论基数为 100 这样的小量级或者基数为 100000 这样一个很大的量级时，原生 Array 的性能都依然碾压链表</p><p>也就是说链表效率高于数组效率这种话，事实上在 JS 中是不存在的，即使你创建一个长度为 1 亿的数组，再创建一个长度为 10 的数组，并且向这两个数组的中间添加元素，<code>console.time</code> 时间出来看看，你会发现所用时间与数组长度长度无关，这说明 JS 数组达到了链表的效率要求</p><p>而且数组中我们也可以用 <code>splice()</code> 方法向数组的指定位置去添加和删除元素，经测试，所需时间同样与数组长度无关，也能达到链表的要求，而数组的下标完全可以取代链表的 <code>head,tail,next,prev</code> 等方法，并且大多数情况下会更方便些，再加上工作中链表这种数据结构的使用场景不是太多，所以可以说 JS 中的数组是完爆链表的</p><p>当然，这只局限于 JavaScript 这门语言中，这和 JS 内部的数组实现机制有关，其实 JS 中的数组只是叫数组而已，它和常规语言中的数组概念就不同，那么关于数组概念以及内部实现，不在我们此章节讨论范围之内，先留一个疑问，过几天有空了再另起一篇 JS 数组相关的文章吧，其实自己找去答案最好了，我们说 JS 是一门解释型高级语言，它的底层实现并不像我们看起来那么简单循规，有点打破常规的意思</p><p>讲的这里，你可能会吐槽这一篇文章好不容易看完了，现在你给我说没用。。。不要着急，收好臭鸡蛋</p><h2 id="JavaScript中链表无用？"><a href="#JavaScript中链表无用？" class="headerlink" title="JavaScript中链表无用？"></a>JavaScript中链表无用？</h2><p>如我们上面所说，难道 <code>JavaScript</code> 中的链表当真就毫无作用了吗？</p><p>其实也不是，就比如三大法宝之一 <code>React</code> 中的 <code>Fiber</code> 架构，就用到了链表这种数据结构</p><p><code>Fiber</code> 在英文中的意思为 <code>纤维化</code>，即细化，将任务进行细化，它把一个耗时长的任务分成很多小片，每一个小片的运行时间很短，虽然总时间依然很长，但是在每个小片执行完之后，都给其他任务一个执行的机会，这样唯一的线程就不会被独占，其他任务依然有运行的机会，<code>React</code> 中的 <code>Fiber</code> 就把整个 <code>VDOM</code> 的更新过程碎片化</p><p>在之前 <code>React</code> 中的 <code>render()</code> 方法会接收一个 <code>虚拟DOM</code> 对象和一个真实的 <code>容器DOM</code> 作为 <code>虚拟DOM</code> 渲染完成后的挂载节点，其主要作用就是将 <code>虚拟DOM</code> 渲染为 <code>真实DOM</code> 并挂载到容器下，这个方法在更新的时候是进行递归操作的，如果在更新的过程中有大量的节点需要更新，就会出现长时间占用 JS 主线程的情况，并且整个递归过程是无法被打断的，由于 JS 线程和 GUI 线程是互斥的（详看👉<a href="https://juejin.cn/post/6844904050543034376">「硬核JS」一次搞懂JS运行机制</a>），所以大量更新的情况下你可能会看到界面有些卡顿</p><p><code>Fiber</code> 架构其实就解决两个问题，一是保证任务在浏览器空闲的时候执行，二是将任务进行碎片化，接下来我们简单说下 <code>Fiber</code> </p><p>JS 中有一个实验性质的方法 <code>requestIdleCallback(callback)</code> ，它可以传入一个回调函数，回调函数能够收到一个 <code>deadline</code> 对象，通过该对象的 <code>timeRemaining()</code> 方法可以获取到当前浏览器的空闲时间，如果有空闲时间，那么就可以执行一小段任务，如果时间不足了，则继续 <code>requestIdleCallback</code>，等到浏览器又有空闲时间的时候再接着执行，这样就实现了浏览器空闲的时候执行</p><p>但是 <code>虚拟DOM</code> 是树结构，当任务被打断后，树结构无法恢复之前的任务继续执行，所以需要一种新的数据结构，也就是我们的链表，链表可以包含多个指针，<code>Fiber</code> 采用的链表中就包含三个指针，<code>parent</code> 指向其父 <code>Fiber</code>  节点，<code>child</code> 指向其子 <code>Fiber</code> 节点，<code>sibling</code> 指向其兄弟 <code>Fiber</code> 节点，一个 <code>Fiber</code> 节点对应一个任务节点，这样就可以轻易找到下一个节点，继而也就可以恢复任务的执行</p><p>这简简单单的一段，就是大名鼎鼎的 <code>Fiber</code> 架构，那么你说链表有用吗？</p><p>说了这么多，其实对于普通需求，我们 JS 确实不需要用到链表，数组能完爆它，但是特殊需求里，链表独具它一定的优势，总之三个字，看需求，再者，我们现在是在用 JS 来阐述链表，但是其它常规语言可没有 JS 中的数组这么强悍，而且学会了链表，我们下一个学习树结构时就更加得心应手了</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>文中的案例完整代码地址如下 👇</p><p><a href="https://github.com/isboyjc/DailyAlgorithms/tree/master/demo/algorithm">单双链表DEMO</a> </p><p>此文介绍数据结构之一的链表，作为链表刷题前的小知识</p><p>上班摸鱼水群不如摸鱼刷道算法，百利无一害，坚持每天刷题吧，加油</p><p>GitHub建了个算法仓库，从零更算法题/文字/视频 题解ing，一块来刷吧 👉 <a href="https://github.com/isboyjc/DailyAlgorithms">GitHub传送门</a>  </p><p>此文视频版本详见 👉 <a href="https://www.bilibili.com/video/BV1aV411q7WF">B站传送门</a> </p><p>看到这里了，来个三连吧，如有错误请指正，也欢迎大家关注公众号「不正经的前端」，和算法群的朋友们组团刷算法，效率更高</p>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>算法</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「算法与数据结构」时间与空间复杂度</title>
    <link href="/blog/2020/12/25/suanfa/%E3%80%8C%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8D%E6%97%B6%E9%97%B4%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    <url>/blog/2020/12/25/suanfa/%E3%80%8C%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8D%E6%97%B6%E9%97%B4%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>可能有些人会吐槽，学算法有什么用，顶多就是去面试大厂的时候能用上，大厂面试算法也只是强中筛强的一个敲门砖而已，我又不去面大厂，不用学它，真的是这样吗？</p><p>肯定不是，在计算机行业发展，不管是前端亦或是后端，算法都是进阶的一个绊脚石，可以说不会算法永远也成不了一个合格的高级工程师，想要进大厂确实要会些算法，但是它并不只是为了面试，它和我们的程序是息息相关的，有人说前端不需要算法？你把大名鼎鼎的 <code>虚拟DOM (Virtual DOM)</code> 置于何地，它就是 <code>算法与数据结构</code> 的一种体现，可能又有人会说了，我又不写虚拟DOM。。。嗯，那你总想要赚钱吧，走技术路线想拿高薪，算法是基石</p><p>网上有很多算法文章以及课程，说 7 天学会算法数据结构，30 天掌握算法与数据结构等等等等，别傻了，算法没有捷径，只能靠我们一点一点累积，你要做的首先就是相信自己不是天才，其次是每天坚持刷题，时间紧可以一周刷四五题，最好速度是每天一题，后期时间充裕或者熟练了甚至可以一天刷几题，即使很聪明的人在一段时间不接触算法后，还是会忘掉，所以重要的是持续下去</p><p>接下来我们来从零开始学习算法吧，如果你未曾刷过算法，这篇文章会带你了解什么是算法，什么是数据结构，在刷算法的同时，我们要明确自己的解法是否足够优质，而判断优质解发会通过时间以及空间两个维度来体现，本文更会重点介绍，这些都是刷算法之前需要必备的知识，如果能为你的算法之路带来启蒙，那真是太棒了，十分荣幸，如果你已经了解了这些知识，那么不妨快速阅读下，看看是否能为你的算法知识做些扩充，当然如果有错误的地方，你也可以为我指引，更是十分荣幸</p><h2 id="什么是数据结构"><a href="#什么是数据结构" class="headerlink" title="什么是数据结构"></a>什么是数据结构</h2><p>数据结构其实就是是程序存储组织数据的方式，一个数据结构是由程序中的数据元素按照某种逻辑关系组织起来的，是若干个数据元素的组合</p><p>数据结构是程序中处理数据的基本单位，在程序中作为一个整体来使用</p><p>例如一个数字 1 或者一个字符 <code>A</code>，它是一种数据结构</p><p>例如一个日期 <code>2020年12月14日</code>，它由年月日这 3 种格式组成，也是一种数据结构</p><p>例如一个数组 <code>[1, &#39;a&#39;, &#39;2020年12月14日&#39;]</code>，它是由数字、字符、日期格式组合而成，也是一种数据结构</p><p>通俗来说，用一定格式组成的数据都是数据结构，我们比较常见的数据结构有字符串、数组、对象、堆、栈、链表、树、哈希表等等，你可能对着其中的一些数据结构并不了解，不要担心，你并不需要立刻知道它们都是什么，对于前端来说，我们使用 <code>JavaScript</code> 这个令我们又爱又恨的语言，它本身就存在的数据结构很少，那么对于像链表、树等等这些结构都是通过对象来模拟的，这点要先知道</p><p>在许多程序设计当中，数据结构的选择是一个基本的设计考虑因素，系统实现的困难程度和系统构造的质量都严重依赖于是否选择了最优的数据结构，选择最优的数据结构能够有效的提高运行的效率和节约存储空间的使用，但是要知道，没有十全十美的数据结构，每种数据结构都有局限性同样也有优点，要根据需求来选择合适的数据结构</p><h2 id="什么是算法"><a href="#什么是算法" class="headerlink" title="什么是算法"></a>什么是算法</h2><p>什么是算法，我们都知道 <code>1+2+3=6</code>，为什么等于 6 呢，你可能会说，1 加 2等于 3，两个 3 相加等于 6，这是小学生都会的数学常识，它就是广义上的算法</p><p>算法其实就是解决一个问题的完整步骤描述，是指完成一个任务准确而完整的步骤描述</p><p>算法的设计很多时候需要取决于数据结构，而算法的实现更依赖于采用的数据结构</p><p>提出一个问题的算法是一个从抽象到具体的过程</p><ul><li><p>分析问题，选择数据结构，得出初步的解决方法</p></li><li><p>将解决方法合理地拆分，整理成许多步骤</p></li><li><p>为重复的步骤选择合理的循环变量</p></li><li><p>使用易转化为程序实现的自然语言简练地描述算法</p></li></ul><p>了解了什么是算法之后，我们来看时间和空间复杂度，衡量不同算法之间的优劣我们通常从两个维度来考究</p><ul><li>时间维度：指执行代码所消耗的时间，即时间复杂度</li><li>空间维度：指执行代码所消耗的空间，即空间复杂度</li></ul><p>接下来就开始逐步剖析时间和空间复杂度了，先说时间复杂度</p><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>在说时间复杂度之前，我们首先要理解一个概念即代码执行次数，也可称之为语句频度或时间频度，用 <code>T(n)</code> 表示</p><p>我们用例子来一步一步阐述，首先我们来看函数 <code>fn1</code> </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn1</span>(<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;句末&quot;</span>)<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;isboyjc&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>我们来看这个函数中的语句会执行多少次</p><p>很明显此函数内部只有两个语句，即 <code>console.log(&quot;句末&quot;)</code> 和 <code>console.log(&quot;isboyjc&quot;)</code>，那么我们说这个函数体内代码执行次数是 2 </p><p>我们再来看函数 <code>fn2</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn2</span>(<span class="hljs-params">n</span>)</span>&#123;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;句末&quot;</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们先来看函数 <code>fn2</code> 中有几条可执行语句</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span><br>i &lt; n<br>i++<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;句末&quot;</span>)<br></code></pre></td></tr></table></figure><p>我们假设 <code>n = 3</code>，然后依次带入进去，看看各个执行语句执行了多少次</p><p><code>let i = 0</code> 此条声明语句只在第一次 <code>for</code> 循环声明时执行 1 次</p><p><code>i &lt; n</code> 此条语句执行次数根据形参 n 的大小变化，<code>n = 3</code> 时，即 <code>i=0,i=1,i=2,i=3</code> 时会执行，即此条语句执行次数为 <code>n + 1</code> 次</p><p><code>i++</code> 此条语句执行次数也是根据形参 n 的大小变化，<code>n = 3</code> 时，即 <code>i=0,i=1,i=2</code> 时会执行，即 n 次</p><p><code>console.log(&quot;句末&quot;)</code> 此条语句执行次数还是根据形参 n 的大小变化，<code>n = 3</code> 会执行 3 次，那么此语句在函数内部即会执行 n 次</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">1</span> + (n + <span class="hljs-number">1</span>) + n + n = (<span class="hljs-number">3n</span> + <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>那么函数 <code>fn2</code> 内共执行 <code>3n + 2</code> 次</p><p>一段代码的总执行次数我们通常会用 <code>T(n)</code> 来表示，那么调用一次上面 <code>fn1/fn2</code> 两函数的总执行次数即</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">T(n) = <span class="hljs-number">2</span><span class="hljs-comment">// fn1</span><br>T(n) = <span class="hljs-number">3n</span> + <span class="hljs-number">2</span> <span class="hljs-comment">// fn2</span><br></code></pre></td></tr></table></figure><p>上面的 n，指的是为问题的规模，即输入数据的大小或者说数量，你也可以简单的理解为 <code>T</code> 就是函数本身，<code>n</code> 就是参数，也就是说</p><p>函数 <code>fn1</code> 任何情况下执行次数都为 2</p><p>函数 <code>fn2</code> 的总执行次数会根据 n 的大小变化而产生一个变化</p><p>我们思考一下，我们可以使用一段代码的执行总次数来衡量执行速度吗？</p><p>答案当然是不行的，当代码行数比较多的时候，我们一条一条的数来计算执行总次数太麻烦了，例如函数中套用函数时、循环中套用循环时，想要精确计算执行次数都是非常麻烦的</p><p>所以，在算法中，我们一般用 <code>T(n)</code> 简化后的估算值来表达代码执行的速度，通常我们用大些字母 <code>O</code> 来表示，即大 <code>O</code> 表示法，由于是估算，它表示的是代码执行时间随数据规模增长的变化趋势，所以，也叫作渐进时间复杂度（asymptotic time complexity），简称时间复杂度</p><p>明确了这个概念以后，我们就可以来算时间复杂度了，还是用上面 <code>fn1/fn2</code> 两函数例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// fn1</span><br>T(n) = <span class="hljs-number">2</span><br><br><span class="hljs-comment">// fn2</span><br>T(n) = <span class="hljs-number">3n</span> + <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>首先我们来看函数 <code>fn1</code>，它的执行总次数为 2，一个 <code>常数(常数级)</code>，也就是说此函数无论何时它的总执行次数都是 2，是一个不变的值，那么我们使用时间复杂度 <code>O</code> 来表示时直接估算为 1 就可以，即时间复杂度为 <code>O(1)</code> </p><p>我们再来看函数 <code>fn2</code> ，它的执行次数 <code>T(n)</code> 是 <code>3n + 2</code> 即 <code>常数*n + 常数</code>，这里我们完全可以看成 <code>常数*n</code> 和 <code>+常数</code> 两部分，随着 n 的增大，只有前一个部分会有变化，后面是不变的，所以在表示时间复杂度时就可以忽略后面不变的常数，即 <code>常数*n</code>，而 <code>常数*n</code> 中过的常数我们也可以直接当做 1，或者说忽略掉这个作为系数的常数，那么最终可以得出函数 <code>fn2</code> 的时间复杂度为 n，即 <code>O(n)</code> </p><p><strong>PS：晓得可能有人把数学知识还给老师了，所以解释下</strong></p><p><strong>常数：</strong> 常数就是指平常的数值，可简单的理解为固定不变的数值</p><p><strong>系数：</strong>系数指代数式的单项式中的数字因数，例如 <code>a = 1 * a</code> ，则它的系数为 1，<code>2b = 2 * b</code> ，则它的系数为 2</p><p>我们再来举个例子，如下面这个多项式代指一个函数的 <code>T(n)</code>，求它的时间复杂度</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">T(n) = <span class="hljs-number">10n</span>^<span class="hljs-number">4</span> + <span class="hljs-number">100n</span>^<span class="hljs-number">2</span> + <span class="hljs-number">1000</span><br></code></pre></td></tr></table></figure><p>其实，对于多项式，我们只需要保留最高次项就行了，也就说，保留 n 的最高次方数就可以了，这个例子中保留的也就是 n 的 4 次方，系数和常数皆可以忽略，最终得到的时间复杂度即为 <code>O(n^4)</code> </p><p><strong>结论：</strong></p><p><code>T(n)</code> 为常数时，时间复杂度为 <code>O(1)</code> ，反之时间复杂度为 <code>O(保留T(n)的最高次项并去掉最高次项的系数)</code> </p><p>接下来，我们看几个例子来判断下几段代码的时间复杂度</p><p><strong>例1：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn01</span>(<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;你看这是啥&quot;</span>)<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;这是一个输出&quot;</span>)<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;哈哈哈&quot;</span>)<br>  <span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span><br>  <span class="hljs-keyword">return</span> a<br>&#125;<br></code></pre></td></tr></table></figure><p>上面这个函数 <code>fn01</code> 中只有一条条的语句，共执行 5 次，毫无变化，时间复杂度即 <code>O(1)</code> ，此为常数级时间复杂度</p><p><strong>例2：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn02</span>(<span class="hljs-params">n</span>)</span>&#123;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;这是一个输出🎓&quot;</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上，函数 <code>fn02</code> 同上文中的例子 <code>fn2</code>，一个循环，时间复杂度即为 <code>O(n)</code> ，此为线性级时间复杂度</p><p><strong>例3：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn03</span>(<span class="hljs-params">n</span>)</span>&#123;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;外层循环&quot;</span>)<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;内层循环&quot;</span>)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个题和上面就不太一样了，我们先单独看内部的循环，内部循环大概会执行 n 次，再来看外部循环又会执行 n 次，最终也就是 <code>n * n = n^2</code>，即函数 <code>fn03</code> 的时间复杂度为 <code>O(n^2)</code> ，此为平方级时间复杂度，如果是三层循环也就是时间复杂度为 <code>O(n^3)</code> 时，即立方级时间复杂度</p><p>从这里我们就可以看出来，一段代码有多少层循环，时间复杂度就是 n 的多少次方，所以尽量避免多层循环嵌套</p><p><strong>例4：</strong></p><p>我们再来看下面这个函数 <code>fn04</code> </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn04</span>(<span class="hljs-params">n</span>)</span>&#123;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;外层循环&quot;</span>)<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;内层循环&quot;</span>)<br>    &#125;<br>  &#125;<br>  <br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;哈哈哈&quot;</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此函数中有一个双循环，有一个单循环，即执行次数大概是 <code>n^2 + n</code>，根据我们上面说的保留最高次项，那么函数 <code>fn04</code> 的时间复杂度即为 <code>O(n^2)</code> </p><p><strong>例5：</strong></p><p>算法中肯定不只是上面那种寻常的循环，再来看下面这一个</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn05</span>(<span class="hljs-params">n</span>)</span>&#123;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;外层循环&quot;</span>)<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = i; j &lt; n; j++)&#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;内层循环&quot;</span>)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其实遇到这种，我们直接带入进去试一试即可知其规律</p><p>当 <code>i = 0</code> 时，里层循环会执行 n 次</p><p>当 <code>i = 1</code> 时，里层循环会执行 n - 1 次</p><p>当 <code>i = 2</code> 时，里层循环会执行 n - 2 次</p><p>当 <code>i = 3</code> 时，里层循环会执行 n - 3 次</p><p>这个时候我们就发现了规律，每当 i 增加 1，里层循环就少执行 1 次，那么就简单了</p><p>当 <code>i = n - 2</code> 时，里层循环会执行 2 次</p><p>当 <code>i = n - 1</code> 时，里层循环会执行 1 次</p><p>最终我们把 n 个里层循环的执行次数相加即可得出最终的一个不精确的总执行次数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">T(n) = n + (n - <span class="hljs-number">1</span>) + (n - <span class="hljs-number">2</span>) + ... + <span class="hljs-number">3</span> + <span class="hljs-number">2</span> + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>如上，这是一个等差数列，嗯，晓得，会补充</p><p>如果一个数列从第二项起，每一项与它的前一项的差等于同一个常数，这个数列就叫做等差数列，而这个常数叫做等差数列的公差，公差常用字母 d 表示</p><p>例如：<code>1,3,5,7,9……（2n-1)</code> ，等差数列 <code>S(n)</code> 的通项公式为：<code>S(n) = S1 + (n-1) * d</code>，前 n 项和公式如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">S(n) = n*S1 + n*(n - <span class="hljs-number">1</span>)*d/<span class="hljs-number">2</span><br><br><span class="hljs-comment">// 或</span><br><br>S(n) = n*(S1 + Sn)/<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>如此我们计算结果就成，我们上面的数列中，公差 d 为 -1，带入公式即可，第二个公式简单，用第二个好了，计算结果都是一样的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// n*(S1 + Sn)/2</span><br><br>n*(n + <span class="hljs-number">1</span>)/<span class="hljs-number">2</span> = (n^<span class="hljs-number">2</span> + n)/<span class="hljs-number">2</span> = (<span class="hljs-number">1</span>/<span class="hljs-number">2</span>)n^<span class="hljs-number">2</span> + (<span class="hljs-number">1</span>/<span class="hljs-number">2</span>)n<br></code></pre></td></tr></table></figure><p>最终我们得到了 <code>(1/2)n^2 + (1/2)n</code> ，按照上文中取最高次项去掉系数，即时间复杂度为 <code>O(n^2)</code> </p><p><strong>例6：</strong></p><p>再来看一个例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn06</span>(<span class="hljs-params">n</span>)</span>&#123;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; n; i *= <span class="hljs-number">2</span>)&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;isboyjc&quot;</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>还是老样子，如果你不晓得怎么看，可以先带入几个参数试一下，看一看规律</p><p>我们可以分别使用 <code>n=2, n=4, n=8, n=16</code>，观察其循环中打印次数，当然你也可以直接运行一下代码，过程不过多阐述了，我们直接看结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">n=<span class="hljs-number">2</span>时打印<span class="hljs-number">1</span>次 T(n)=<span class="hljs-number">1</span><br>n=<span class="hljs-number">4</span>时打印<span class="hljs-number">2</span>次 T(n)=<span class="hljs-number">2</span><br>n=<span class="hljs-number">8</span>时打印<span class="hljs-number">3</span>次 T(n)=<span class="hljs-number">3</span><br>n=<span class="hljs-number">16</span> 时打印<span class="hljs-number">4</span>次 T(n)=<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>对于执行次数产生主要影像的就是循环语句中的 <code>i*=2</code>，每次循环 i 都会变成自身的两倍，仔细观察我们就可以得出这样一个规律性结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">n=<span class="hljs-number">2</span>时打印<span class="hljs-number">1</span>次 T(n)=<span class="hljs-number">1</span> <span class="hljs-comment">// 2^1 = 2</span><br>n=<span class="hljs-number">4</span>时打印<span class="hljs-number">2</span>次 T(n)=<span class="hljs-number">2</span> <span class="hljs-comment">// 2^2 = 4</span><br>n=<span class="hljs-number">8</span>时打印<span class="hljs-number">3</span>次 T(n)=<span class="hljs-number">3</span> <span class="hljs-comment">// 2^3 = 8</span><br>n=<span class="hljs-number">16</span> 时打印<span class="hljs-number">4</span>次 T(n)=<span class="hljs-number">4</span> <span class="hljs-comment">// 2^4 = 16</span><br></code></pre></td></tr></table></figure><p>根据上面的规律我们不难发现，那么<code>2^执行次数=n</code>，即 <code>2^T(n)=n</code> ，我们求 <code>T(n)</code>，调个就行了，也就是以 2 为底 n 的对数，即 <code>T(n)=log_2 n</code> </p><p><strong>PS：又来补数学了</strong></p><p><strong>对数：</strong> 假如 <code>a^n=b</code>，即 a 的 n 次方等于 b，我们求 n 的值，那么这里为了方便表示就可以写成 <code>log_a b</code>，即以 a 为底 b 的对数，a 是底数，b 是真数，而 n 就是对数</p><p>你可能会在纠结为什么只观察循环中的打印次数而不计算其所有的执行次数，原因上面也说过了，这些固有的常数及系数完全可以忽略，好吧，我们再最后推一遍</p><p>中间输出为 <code>log_2 n</code> 次，<code>let i = 1</code> 只会执行一次，<code>i&lt;n</code> 会执行 <code>log_2 n + 1</code> 次，<code>i*=2</code> 也会执行 <code>log_2 n</code> 次，加起来就是 <code>log_2 n + log_2 n + 1 + log_2 n</code>，即 <code>3log_2 n + 2</code>，除去系数 3 和常数 2，我们得出了 <code>log_2 n</code> ，在时间复杂度的计算中 <code>log</code> 的底数也是可以省略的，所以最终函数 <code>fn06</code> 的时间复杂度为 <code>O(log n)</code> ，也就是对数级时间复杂度</p><p><strong>例7：</strong></p><p>最后在给大家来一个例子吧</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn07</span>(<span class="hljs-params">n,m</span>)</span>&#123;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>    <span class="hljs-keyword">while</span>(j &lt; m)&#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;你看懂了吗&quot;</span>)<br>      j = j * <span class="hljs-number">2</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上图，此函数有两个参数，对应了里外两个循环，我们先从内部循环看起，眼熟吗？其实内部循环和上题函数 <code>fn06</code> 中的循环是一样的，只是一个用的 <code>for</code> ，一个用的 <code>while</code>，上题中的时间复杂度我们就不再叙述了，那么内层循环时间复杂度为 <code>O(log n)</code></p><p>我们再来看外层循环，也是上面解释过的，单看外层循环时间复杂度是 <code>O(n)</code></p><p>两个循环是嵌套关系，相乘就可以了，所以函数 <code>fn07</code> 的时间复杂度即为 <code>O(n*log n)</code> ，也就是线性对数级时间复杂度</p><p>正如此函数输出，你看懂了吗？</p><p><strong>码字太累，看个图吧：</strong> </p><p>找了一张网图（侵删），使用图表来更加清晰的展示了常见的时间复杂度曲线</p><p><img src="https://cdn.jsdelivr.net/gh/isboyjc/PictureBed/other/image-20201215223821230.png"></p><p>如上图，横坐标为 n ，可以看到，不同时间复杂度随着 n 的增大操作次数或者说执行时间的递增趋势</p><p>常见的时间复杂度量级有</p><ul><li>常数级 <code>O(1)</code></li><li>对数级 <code>O(log n)</code></li><li>线性级 <code>O(n)</code></li><li>线性对数级 <code>O(n*log n)</code></li><li>平方级 <code>O(n^2)</code></li><li>立方级 <code>O(n^3)</code></li><li>K次方级 <code>O(n^k)</code></li><li>指数级 <code>O(2^n)</code></li></ul><p>上面从上到下依次时间复杂度越来越大，执行效率越来越低，大部分常用的在上面的图表中都有展示</p><p>所以在程序或是刷题中，我们应该尽量使用低时间复杂度的方法</p><p>时间复杂度就到此为止了，我们也列举了常见的时间复杂度，接下来我们来看看空间复杂度</p><h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>空间复杂度其实就是对一个算法或者说一段代码在运行过程中占用存储空间大小表达方式</p><p>我们上面讲过了时间复杂度，那么再来说空间复杂度会简单的很多</p><p>空间复杂度也就是 <code>S(n)</code> ，它同样会用大O表示法来表示，我们直接上例子</p><p><strong>例1：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn001</span>(<span class="hljs-params">n</span>)</span>&#123;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;空间复杂度&quot;</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先，我们知道，空间复杂度和存储空间有关，而存储空间是由什么决定的，肯定是声明的变量啊，我们直接来找函数 <code>fn001</code> 中的变量声明，只有一个 <code>i</code> ，也就是说此函数只有开辟了一块空间供 <code>i</code> 使用，那么空间复杂度 <code>S(n)</code> 即为 <code>O(1)</code> ，你可能会说 <code>i</code> 不是一直在变吗，是的它是在变，但是不管怎么变，它还是一个数字，占用空间大小都一致 </p><p>空间复杂度和时间复杂度一样，当代码里声明的变量是一个常量，不会根据传入值的变化而变化，那么也它的空间复杂度是 <code>O(1)</code> </p><p><strong>例2：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn002</span>(<span class="hljs-params">n</span>)</span>&#123;<br>  <span class="hljs-keyword">let</span> arr = []<br>  <span class="hljs-keyword">while</span>(n--)&#123;<br>    arr.push(n)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个例子中我们声明了一个数组，我们知道数组中是可以存各种类型的，在循环中，我们根据 <code>n</code> 的大小向数组 <code>arr</code> 中 <code>push</code> 元素，所以，<code>n</code> 多大，数组就有多少元素，就占用了多少空间，所以空间复杂度<code>S(n) = O(n)</code></p><p><strong>空间复杂度小结</strong></p><p>空间复杂度里，只列出了两个例子，是因为一般情况下，我们用不到其他的，空间复杂度一般只会是 <code>O(1)/O(n)/O(n^2)</code>，其它的很少见，当然也有，我们在知道了时间复杂度再分析空间复杂度也很好分析，就不过多赘述了</p><p>关于分析空间复杂度，其实我们直接从声明的变量入手就可以，看函数体内声明的变量根据传入值的变化而变化来分析</p><p>另外，这里我们没有列举递归情况，<strong>请注意</strong>，递归就是函数套函数，像俄罗斯套娃一样的，这中间其实有一个问题，我们知道，递归函数，每层递归里都会开辟一个递归栈，每次递归产生的变量等空间消耗都会存在递归栈中，这也是一个空间，不管你有没有声明变量，只要递归了递归栈它都存在，也就是说只要存在递归的情况，基本上最少的空间复杂度也是 <code>O(n)</code> 了，所以我们尽可能的在能使用迭代的情况下就不使用递归</p><h2 id="时间-VS-空间"><a href="#时间-VS-空间" class="headerlink" title="时间 VS 空间"></a>时间 VS 空间</h2><p>开头我们说了，评价一个算法的效率我们主要是从它的时间和空间两个维度看，但是，通常我们在算法中，时间和空间就是鱼和熊掌的关系，这时候可能一道算法题有两种解法，一种时间复杂度低，但空间复杂度稍高，另一种则反之</p><p>这个时候怎么办呢？细品就知道了，在开发中，我们一般都是时间优于空间的，你想啊，一个程序，用户不会关心的占用了多少内存，但是他会关心你这个程序他在使用时的执行速度，况且，空间也就是磁盘，现阶段磁盘我们可以花钱扩容，时间上就没这么简单了，所以某些相对的情况下，空间换时间是可以令人接受的</p><p>虽说空间换时间可行，但也不能一味的空间换时间，我们还是要尽可能降低两个维度的复杂度，少数对立情况下，可空间换时间</p><p>我们在刷算法的时候，不是刷完了就完事了，我们还要去分析我们的题解对应的时间及空间复杂度，可以分析多种题解之间的复杂度，对比找出最优解</p><p>在面试的时候，假如面试官给你一道算法题，当你知道好几种解法的时候，完全可以很装B的问一下，您喜欢时间至上还是空间至上呢，我都能解，奥利给，说完他就会让你都写了😄</p><p>开个玩笑哈，面试的时候尽量写出多种解法并给面试官解释各种解法时间及空间复杂度的不同，怎么说？就很棒</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>此文介绍算法一些理论基础，理解之后就可以刷题了，推荐按照数据结构类型来每天刷一题，建议上班无聊时刷题，上班摸鱼水群不如摸鱼刷道算法，百利无一害，坚持每天刷题吧，加油</p><p>GitHub建了个算法仓库，从零更算法题/文字/视频 题解ing，一块来刷吧 👉 <a href="https://github.com/isboyjc/DailyAlgorithms">GitHub传送门</a>  </p><p>准备算法每篇每题都录个视频版，主要是为了跟思路讲一遍手写下，讲的可能不好，此文视频详见 👉 <a href="https://www.bilibili.com/video/BV1T5411p7oN">B站传送门</a> </p><p>看到这里了，来个三连吧，如有错误请指正，也欢迎大家关注公众号「不正经的前端」，和算法群的朋友们组团刷算法</p>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>算法</tag>
      
      <tag>数据结构</tag>
      
      <tag>LeetCode</tag>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「硬核JS」令你迷惑的位运算</title>
    <link href="/blog/2020/12/01/js/%E3%80%8C%E7%A1%AC%E6%A0%B8JS%E3%80%8D%E4%BB%A4%E4%BD%A0%E8%BF%B7%E6%83%91%E7%9A%84%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <url>/blog/2020/12/01/js/%E3%80%8C%E7%A1%AC%E6%A0%B8JS%E3%80%8D%E4%BB%A4%E4%BD%A0%E8%BF%B7%E6%83%91%E7%9A%84%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>今天，我们来学习一下 JS 操作符中的位操作符</p><p>在 JS 这门语言的标准里，描述了一组可以用来操作数据值的操作符，其中包括 数学操作符、位操作符、关系操作符、相等操作符、布尔操作符、条件操作符以及ES7的指数操作符 等等，为什么叫操作符，因为它们都是符号构成。。。</p><p>在这一组操作符中，相比加减乘除、逻辑判断、相等、布尔等这些我们经常会用到的操作符，位运算操作符好像是极其特殊的一类，由于位操作符不是那么的直观导致很多刚入门甚至是老程序员都不太喜欢用它</p><p>大多数人都认为在写程序的过程中使用过多花里胡哨的位操作符对阅读体验是极其不好的，尽管它可能会为性能带来一些提升，但是相比下来一个项目要选择阅读体验和些许性能的话，大家大概率的会选择前者</p><p>话是这样说，但是这并不是大家不学习它的理由，假如大家都懂得位运算，那么这些 <code>骚操作</code> 就变成了常规操作，有的人可能会说就算懂得位运算，想要阅读一段位操作符组成的的代码还是需要时间来思考的，并不如通俗点写来的直观，嗯，也对，但是加上当量注释的话也还行</p><p>总之，你可以不用，但一定要会，存在即合理，任何说法都不是不学习它的理由</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">(!(~+[])+&#123;&#125;)[--[~+<span class="hljs-string">&quot;&quot;</span>][+[]]*[~+[]]+~~!+[]]+(&#123;&#125;+[])[[~!+[]]*~+[]]<br></code></pre></td></tr></table></figure><p>嗯，就以这一段网红代码为开头吧</p><p>看此文之前，请一定要先阅读这篇文章 </p><ul><li><a href="https://github.com/isboyjc/blog/issues/25">「硬核JS」数字之美</a> </li><li><a href="https://github.com/isboyjc/blog/issues/25">「硬核JS」数字之美</a> </li><li><a href="https://github.com/isboyjc/blog/issues/25">「硬核JS」数字之美</a> </li></ul><p>重要的事情说三遍，上面这篇文章就是给此文做准备的，文中讲了一些数字相关的东西，二进制转换、原码、反码、补码以及 JS 中的数字存储等等，看完上文再看此文会很 easy</p><p>也是给大家回顾下一些计算机基础常识，估计大家久征沙场这些基础都忘完了，不然直接啃会有点迷 😂</p><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p>来回顾一下，我们都知道，平常我们用来计算的是十进制的数值 <code>0~9</code> ，但是计算机是个机器，它只能识别二进制</p><p>根据国际 IEEE 754 标准，<code>JavaScript</code> 在存储数字时是始终以双精度浮点数来存储的，这种格式用 64 位二进制存储数值，64 位也就是 64 比特（bit），相当于 8 个字节，其中 0 到 51 存储数字（片段），52 到 62 存储指数，63 位存储符号</p><p>而在 JS 位运算中，并不会用 64 位来计算，它会先在后台把值转换为 32 位数值，再进行位运算操作，位运算计算完成后再将 32 位转为 64 位存储，整个过程就像在处理 32 位数值一样，所以我们了解位运算时，只需要关注这 32 位二进制整数就可以，因为 64 位存储格式是不可见的，但是也正是因为后台这个默认转换操作，给 JS 这门语言产生了一个副作用，即特殊值 NaN 和 Infinity 在位运算中都会直接被当作 0 来处理</p><p>其实不止是 JS ，很多语言的位运算都是如此</p><h3 id="有符号-amp-无符号"><a href="#有符号-amp-无符号" class="headerlink" title="有符号&amp;无符号"></a>有符号&amp;无符号</h3><p>穿插一个小知识点， <code>ECMAScript</code> 整数有两种类型，即有符号整数（允许用正数和负数）和无符号整数（只允许用正数）</p><p>在 ECMAScript 中，所有整数字面量默认都是有符号整数</p><p>有符号整数也就是上文所说，二进制左侧首位是符号位来表明该数字正负</p><p>而无符号整数就是没有符号位，没有了符号位置也就说它表达不了负数，同时因为没有了符号位置，它的存储范围也会比有符号整数存储范围大</p><p>现在我们我们正式开始说位运算符了，位运算符号一共分 7 个，我们一个个道来</p><h3 id="按位非-NOT（-）"><a href="#按位非-NOT（-）" class="headerlink" title="按位非 NOT（~）"></a>按位非 NOT（~）</h3><h4 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h4><p>按位非操作符也可以叫按位取反，它使用 <code>~</code> 符号表示，作用是对位取反，1 变成 0 ，0 变成 1</p><p>看过上文的小伙伴们可能就会发现，这好像是取的反码？</p><p>是的，我们就可以直接理解为按位非就是取其二进制的反码，只不过，反码是符号位不变其余位置取反，而按位非则是取反码后符号位也取反</p><p><strong>例如：</strong></p><p>我们以 8 位（bit）数字存储为例</p><p>求十进制数字 2 的按位非，十进制数字 2 的二进制是 <code>0000 0010</code>，那么它的二进制反码就是 <code>0111 1101</code>，符号位也取反则变成了 <code>1111 1101</code>，当然你也可以直接将数字 2 的二进制每一位取反，结果都是 <code>1111 1101</code> </p><p>我们知道符号位为 1 代表是负数，而计算机中存储负数是以补码的方式来存储的，所以我们对补码 <code>1111 1101</code> 求原码再转成十进制即可，对补码求原码就是使用此补码再求一遍补码，也就是先取反码再补 1 ，过程自算，得到了负数的二进制原码 <code>1000 00 11</code>，即十进制 <code>-3</code>  </p><p>同上所述</p><p>十进制数字 1 的按位非即十进制 <code>-2</code> </p><p>十进制数字 0 的按位非即十进制 <code>-1</code>  </p><p>上面说的都是正数，我们看一个负数的例子</p><p>十进制数字 -1 由于是负数，上文我们说过计算机中二进制存储负数为补码方式，所以我们要先求 -1 的补码，-1 二进制原码是 <code>1000 0001</code>，再求原码的反码即 <code>1111 1110</code> ，接着补 1 即可求补码即 <code>1111 1111</code>，那么我们得到了 -1 在二进制中存储的的最终补码形态即为 <code>1111 1111</code> ，最终我们将此二进制每一位都取反得到 <code>0000 0000 </code>，即十进制数字 0</p><p>诶！好像有规律，我们试了几次之后发现按位非的最终结果始终是对原数值取反并减一，如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span><br><span class="hljs-built_in">console</span>.log(~a == (-a) - <span class="hljs-number">1</span>) <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// 得到</span><br>~x = (-x) - <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>知道这个之后，我们遇到按位非操作符后可以根据这个规律来算结果，会比转二进制计算那样方便些</p><p>那么又有人说了，既然和 <code>(-x) - 1</code> 是一致的，那么为什么还要用按位非呢</p><p>很简单，原因有二，第一是位运算的操作是在数值底层表示上完成的，速度快。第二是因为它只用 2 个字符，比较方便。。。</p><h4 id="使用按位非-判断是否等于-1"><a href="#使用按位非-判断是否等于-1" class="headerlink" title="使用按位非 ~ 判断是否等于-1"></a>使用按位非 ~ 判断是否等于-1</h4><p>按位非在项目中的使用频率还是蛮高的</p><p>相信大家经常看到下面这种写法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;abcdefg&quot;</span><br><br><span class="hljs-keyword">if</span>(!~str.indexOf(<span class="hljs-string">&quot;n&quot;</span>))&#123;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;字符串 str 中不存在字符 n&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// 等同于</span><br><br><span class="hljs-keyword">if</span>(str.indexOf(<span class="hljs-string">&quot;n&quot;</span>) == <span class="hljs-string">&quot;-1&quot;</span>)&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;字符串 str 中不存在字符 n&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>如上所示，我们知道 <code>indexOf</code> 方法在找不到相同值时返回 -1，而 <code>~-1 == 0 == false</code> ，所以 <code>!~-1 == 1 == true</code> ，一般来说我们使用按位非的写法来校验 -1 是用的最多，也是位运算中最容易令大家接受的了，是不是特别简单方便呢</p><h4 id="使用按位非-取整"><a href="#使用按位非-取整" class="headerlink" title="使用按位非 ~ 取整"></a>使用按位非 ~ 取整</h4><p>按位非的骚操作中，还有一个比较普遍的就是位运算双非取整了，如下所示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">~~<span class="hljs-number">3.14</span> == <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>很多人知道这样可以取整，但是由于不知道具体是为什么而不敢用，所以我们来解释下为什么它为什么可以取整</p><p>上面我们说过，在 JS 位运算中，并不会用 64 位来计算，它会先在后台把值转换为 32 位整数，再进行位运算操作，位运算计算完成后再将 32 位转为 64 位存储，整个过程就像在处理 32 位数值一样，所以我们了解位运算时，只需要关注这 32 位二进制整数就可以</p><p>这里我们可以看到，32 位 <code>整数</code>，位运算操作的是整数，后台在进行 64 位到 32 位转换时，会忽略掉小数部分，只关注整数、整数、整数，记住了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">~<span class="hljs-number">3.14</span> == ~<span class="hljs-number">3</span><br>-<span class="hljs-number">5.89</span> == ~<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>如上所示，接着我们再按照上面的公式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">~x == (-x) - <span class="hljs-number">1</span><br><br>~~x == -((-x) - <span class="hljs-number">1</span>) -<span class="hljs-number">1</span> == -(-x) + <span class="hljs-number">1</span> -<span class="hljs-number">1</span> == x<br></code></pre></td></tr></table></figure><p>所以位运算中的双非 <code>~~</code> 即可取整，此取整是完全忽略小数部分</p><h3 id="按位与-AND（-amp-）"><a href="#按位与-AND（-amp-）" class="headerlink" title="按位与 AND（&amp;）"></a>按位与 AND（&amp;）</h3><h4 id="简述-1"><a href="#简述-1" class="headerlink" title="简述"></a>简述</h4><p>按位与操作符也就是符号 <code>&amp;</code> ，它有两个操作数，其实就是将两个操作数的二进制每一位进行对比，两个操作数相应的位都为 1 时，结果为 1，否则都为 0，如下</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20201122161948275.png"></p><p><strong>例如：</strong> </p><p>求 <code>25 &amp; 3</code> ，即求十进制 25 和 十进制 3 的与操作值</p><p>我们分别求出 25 和 3 的二进制进行比对即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">25</span> = <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0001</span> <span class="hljs-number">1001</span><br> <span class="hljs-number">3</span> = <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0011</span><br>--------------------------------------------<br>&amp;  = <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0001</span><br></code></pre></td></tr></table></figure><p>如上所示，最终我们比对的二进制结果为 <code>0000 ... 0001</code>，即十进制数字 1</p><h4 id="使用按位与-amp-判断奇偶数"><a href="#使用按位与-amp-判断奇偶数" class="headerlink" title="使用按位与 &amp; 判断奇偶数"></a>使用按位与 &amp; 判断奇偶数</h4><p>按位与这个东西平常用的不太多，我一般只会在判断奇偶数的才会用到，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">偶数 &amp; <span class="hljs-number">1</span> <span class="hljs-comment">// 0</span><br>奇数 &amp; <span class="hljs-number">1</span> <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><p>因为十进制数字 1 的二进制为 <code>0000 ... 0001</code>，只有最后一位为 1，其余位都是 0 ，所以任何数字和它对比除最后一位其余都是 0，那么当这个数字末位为 1 时，也就是奇数，那么结果就是 1，这个数字末位为 0 时，也就是偶数，那么结果就是 0，毕竟二进制只有 0 和 1</p><h4 id="使用按位与-amp-判断数字是否为2的整数幂"><a href="#使用按位与-amp-判断数字是否为2的整数幂" class="headerlink" title="使用按位与 &amp; 判断数字是否为2的整数幂"></a>使用按位与 &amp; 判断数字是否为2的整数幂</h4><p>判断数字是否为 2 的整数幂，使用 <code>n &amp; (n - 1) </code> </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = <span class="hljs-number">20</span>;<br><span class="hljs-keyword">let</span> b = <span class="hljs-number">32</span>;<br><br>a &amp; (a - <span class="hljs-number">1</span>) <span class="hljs-comment">// 16 a不是2的整数幂</span><br>b &amp; (b - <span class="hljs-number">1</span>) <span class="hljs-comment">// 0 b是2的整数幂</span><br></code></pre></td></tr></table></figure><p>如上所示，套用这个小公式，当结果等于 0 时，数值就是 2 的整数幂</p><p>其实原理也很简单，首先我们来看数值 2 的幂对应的二进制</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">0000</span> <span class="hljs-number">0001</span>  -&gt; <span class="hljs-number">1</span>  <span class="hljs-comment">// 2^0</span><br><span class="hljs-number">0000</span> <span class="hljs-number">0010</span>  -&gt; <span class="hljs-number">2</span><span class="hljs-comment">// 2^1</span><br><span class="hljs-number">0000</span> <span class="hljs-number">0100</span>  -&gt; <span class="hljs-number">4</span><span class="hljs-comment">// 2^2</span><br><span class="hljs-number">0000</span> <span class="hljs-number">1000</span>  -&gt; <span class="hljs-number">8</span><span class="hljs-comment">// 2^3</span><br><span class="hljs-number">0001</span> <span class="hljs-number">0000</span>  -&gt; <span class="hljs-number">16</span><span class="hljs-comment">// 2^4</span><br></code></pre></td></tr></table></figure><p>如上，2 的幂在二进制中只有一个 1 后跟一些 0，那么我们在判断一个数字是不是 2 的幂时，用 <code>n &amp; (n-1)</code>，如果 你是 2 的幂，n 减 1 之后的二进制就是原来的那一位 1 变成 0，后面的 0 全变成 1，这个时候再和自身做按位与对比时，每一位都不同，所以每一位都是 0，即最终结果为 0</p><p>刚好适用于 👉 <a href="https://leetcode-cn.com/problems/power-of-two/">LeetCode 231 题</a> </p><h3 id="按位或-OR（｜）"><a href="#按位或-OR（｜）" class="headerlink" title="按位或 OR（｜）"></a>按位或 OR（｜）</h3><h4 id="简述-2"><a href="#简述-2" class="headerlink" title="简述"></a>简述</h4><p>按位或用符号 <code>|</code> 来表示，它也有两个操作数，按位或也是将两个操作数二进制的每一位进行对比，只不过按位或是两边只要有一个 1 ，结果就是 1，只有两边都是 0 ，结果才为 0，如下</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20201122171909201.png"></p><p><strong>例如：</strong> </p><p>求 <code>25 ｜ 3</code> ，即求十进制 25 和 十进制 3 的或操作值</p><p>我们分别求出 25 和 3 的二进制进行比对即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">25</span> = <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0001</span> <span class="hljs-number">1001</span><br> <span class="hljs-number">3</span> = <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0011</span><br>--------------------------------------------<br>|  = <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0001</span> <span class="hljs-number">1011</span><br></code></pre></td></tr></table></figure><p>如上所示，最终我们比对的二进制结果为 <code>0000 ... 0001 1011</code>，即十进制数字 27</p><h4 id="使用按位或-｜-取整"><a href="#使用按位或-｜-取整" class="headerlink" title="使用按位或 ｜ 取整"></a>使用按位或 ｜ 取整</h4><p>取整的时候我们也可以使用按位或取整</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">1.111</span> | <span class="hljs-number">0</span> <span class="hljs-comment">// 1</span><br><span class="hljs-number">2.234</span> | <span class="hljs-number">0</span> <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>如上所示，只需要将小数同 0 进行按位或运算即可</p><p>原理也简单，位运算操作的是整数，相当于数值的整数部分和 0 进行按位或运算</p><p>0 的二进制全是 0 ，按位或对比时 1 和 0 就是 1 ，0 和 0 就是 0，得出的二进制就是我们要取整数值的整数部分</p><h4 id="使用按位或-代替Math-round"><a href="#使用按位或-代替Math-round" class="headerlink" title="使用按位或 | 代替Math.round()"></a>使用按位或 | 代替Math.round()</h4><p>我们上面知道按位或可以取整，其实四舍五入也就那么回事了，即正数加 0.5，负数减 0.5 进行按位或取整即可，道理就是这么简单，如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a1 = <span class="hljs-number">1.1</span><br><span class="hljs-keyword">let</span> a2 = <span class="hljs-number">1.6</span><br>a1 + <span class="hljs-number">0.5</span> | <span class="hljs-number">0</span> <span class="hljs-comment">// 1</span><br>a2 + <span class="hljs-number">0.5</span> | <span class="hljs-number">0</span> <span class="hljs-comment">// 2</span><br><br><span class="hljs-keyword">let</span> b1 = -<span class="hljs-number">1.1</span><br><span class="hljs-keyword">let</span> b2 = -<span class="hljs-number">1.6</span><br>b1 - <span class="hljs-number">0.5</span> | <span class="hljs-number">0</span> <span class="hljs-comment">// -1</span><br>b2 - <span class="hljs-number">0.5</span> | <span class="hljs-number">0</span> <span class="hljs-comment">// -2</span><br></code></pre></td></tr></table></figure><h3 id="按位异或-XOR（-）"><a href="#按位异或-XOR（-）" class="headerlink" title="按位异或 XOR（^）"></a>按位异或 XOR（^）</h3><h4 id="简述-3"><a href="#简述-3" class="headerlink" title="简述"></a>简述</h4><p>按位异或使用字符 <code>^</code> 来表示，按位异或和按位或的区别其实就是在比对时，按位异或只在一位是 1 时返回 1，两位都是 1 或者两位都是 0 都返回 0，如下</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20201122172631261.png"></p><p>异或的运算过程可以当作把两个数加起来，然后进位去掉，0 + 0 = 0，1 + 0 = 1，1 + 1 = 0，这样会好记些</p><p><strong>例如：</strong> </p><p>求 <code>25 ^ 3</code> ，即求十进制 25 和 十进制 3 的异或值</p><p>我们分别求出 25 和 3 的二进制进行比对即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">25</span> = <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0001</span> <span class="hljs-number">1001</span><br> <span class="hljs-number">3</span> = <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0011</span><br>--------------------------------------------<br>|  = <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0001</span> <span class="hljs-number">1010</span><br></code></pre></td></tr></table></figure><p>如上所示，最终我们比对的二进制结果为 <code>0000 ... 0001 1010</code>，即十进制数字 26</p><h4 id="使用按位异或-判断整数部分是否相等"><a href="#使用按位异或-判断整数部分是否相等" class="headerlink" title="使用按位异或 ^ 判断整数部分是否相等"></a>使用按位异或 ^ 判断整数部分是否相等</h4><p>按位异或可以用来判断两个整数是否相等，如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span><br><span class="hljs-keyword">let</span> b = <span class="hljs-number">1</span><br>a ^ b <span class="hljs-comment">// 0</span><br><br><span class="hljs-number">1</span> ^ <span class="hljs-number">1</span> <span class="hljs-comment">// 0</span><br><span class="hljs-number">2</span> ^ <span class="hljs-number">2</span> <span class="hljs-comment">// 0</span><br><span class="hljs-number">3</span> ^ <span class="hljs-number">3</span> <span class="hljs-comment">// 0</span><br></code></pre></td></tr></table></figure><p>这是因为按位异或只在一位是 1 时返回 1，两位都是 1 或者两位都是 0 都返回 0，两个相同的数字二进制都是一致的，所以都是 0</p><p>我们也可以用作判断两个小数的整数部分是否相等，如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">2.1</span> ^ <span class="hljs-number">2.5</span> <span class="hljs-comment">// 0</span><br><span class="hljs-number">2.2</span> ^ <span class="hljs-number">2.6</span> <span class="hljs-comment">// 0</span><br><span class="hljs-number">2.1</span> ^ <span class="hljs-number">3.1</span> <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><p>这是为什么？牢记位运算操作的是整数、是整数、是整数，也就是说上面这几个对比完全可以理解为同下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">2</span> ^ <span class="hljs-number">2</span> <span class="hljs-comment">// 0</span><br><span class="hljs-number">2</span> ^ <span class="hljs-number">2</span> <span class="hljs-comment">// 0</span><br><span class="hljs-number">2</span> ^ <span class="hljs-number">3</span> <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><h4 id="使用按位异或-来完成值交换"><a href="#使用按位异或-来完成值交换" class="headerlink" title="使用按位异或 ^ 来完成值交换"></a>使用按位异或 ^ 来完成值交换</h4><p>我们也可以使用按位异或来进行两个变量的值交换，如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span><br><span class="hljs-keyword">let</span> b = <span class="hljs-number">2</span><br>a ^= b<br>b ^= a<br>a ^= b<br><span class="hljs-built_in">console</span>.log(a)   <span class="hljs-comment">// 2</span><br><span class="hljs-built_in">console</span>.log(b)   <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><p>道理也很简单，我们先要了解一个东西</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 如果</span><br>a ^ b = c<br><span class="hljs-comment">// 那么</span><br>c ^ b = a<br>c ^ a = b<br></code></pre></td></tr></table></figure><p>现在你再品一下值交换为什么可以交换，细品</p><p>不过这里使用 <code>^</code> 来做值交换不如用 ES6 的解构，因为 ES6 解构更方便易懂</p><h4 id="使用按位异或-切换-0-和-1"><a href="#使用按位异或-切换-0-和-1" class="headerlink" title="使用按位异或 ^ 切换 0 和 1"></a>使用按位异或 ^ 切换 0 和 1</h4><p>切换 0 和 1，即当变量等于 0 时，将它变成 1，当变量等于 1 时，将它变成 0</p><p>常用于 <code>toggle </code> 开关状态切换，做开关状态更改时，普通小伙伴会如下这样做</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> toggle = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">if</span>(toggle)&#123;<br>  toggle = <span class="hljs-number">0</span><br>&#125;<span class="hljs-keyword">else</span>&#123;<br>  toggle = <span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure><p>聪明点的小伙伴会用三目运算符</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> toggle = <span class="hljs-number">0</span><br><br>toggle = toggle ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>使用按位异或更简单</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> toggle = <span class="hljs-number">0</span><br><br>toggle ^= <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>原理也简单， <code>toggle ^= 1</code> 等同于 <code>toggle = toggle ^ 1</code>，我们知道 <code>0 ^ 1</code> 等于 1，而 <code>1 ^ 1</code> 则为 0</p><h4 id="使用按位异或-判断两数符号是否相同"><a href="#使用按位异或-判断两数符号是否相同" class="headerlink" title="使用按位异或 ^ 判断两数符号是否相同"></a>使用按位异或 ^ 判断两数符号是否相同</h4><p>我们可以使用 <code>(a ^ b) &gt;= 0</code> 来判断两个数字符号是否相同，也就是说同为正或同为负</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span><br><span class="hljs-keyword">let</span> b = <span class="hljs-number">2</span><br><span class="hljs-keyword">let</span> c = -<span class="hljs-number">2</span><br><br>(a ^ b) &gt;= <span class="hljs-number">0</span> <span class="hljs-comment">// true</span><br>(a ^ c) &gt;= <span class="hljs-number">0</span> <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>原理也简单，正数二进制左首位也就是符号位是 0，而负数则是 1</p><p>按位异或在对比时，只有一正一负时才为 1，两位都是 0 或者都是 1 时结果为 0</p><p>所以，两个数值符号一样时按位异或对比后的二进制结果符号位肯定是 0，最终数值也就是 <code>&gt;=0</code>，反之则 <code>&lt;0</code> </p><h3 id="左移（-lt-lt-）"><a href="#左移（-lt-lt-）" class="headerlink" title="左移（&lt;&lt;）"></a>左移（&lt;&lt;）</h3><h4 id="简述-4"><a href="#简述-4" class="headerlink" title="简述"></a>简述</h4><p>左移用符号 <code>&lt;&lt;</code> 来表示，正如它的名字，即将数值的二进制码按照指定的位数向左移动，符号位不变</p><p>**例如： ** </p><p>求 <code>2 &lt;&lt; 5</code>，即求十进制数 2 左移 5 位的操作</p><p>我们先将十进制数字 2 转二进制再左移 5 位后如下图</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20201122175424438.png"></p><p>我们得到了一个新的二进制，转为 10 进制即为数值 64</p><p>数字 x 左移 y 位我们其实可以得到一个公式，如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">x &lt;&lt; y <br><br><span class="hljs-comment">// 等同于</span><br><br>x * <span class="hljs-number">2</span>^y<br></code></pre></td></tr></table></figure><h4 id="使用左移-lt-lt-取整"><a href="#使用左移-lt-lt-取整" class="headerlink" title="使用左移 &lt;&lt; 取整"></a>使用左移 &lt;&lt; 取整</h4><p>使用左移也可取整</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">1.111</span> &lt;&lt; <span class="hljs-number">0</span> <span class="hljs-comment">// 1</span><br><span class="hljs-number">2.344</span> &lt;&lt; <span class="hljs-number">0</span> <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>原理是位运算操作的是整数，忽略小数部分，等同于数值的整数部分，左移 0 位，结果还是整数部分</p><h3 id="有符号右移（-gt-gt-）"><a href="#有符号右移（-gt-gt-）" class="headerlink" title="有符号右移（&gt;&gt;）"></a>有符号右移（&gt;&gt;）</h3><h4 id="简述-5"><a href="#简述-5" class="headerlink" title="简述"></a>简述</h4><p>有符号右移用符号 <code>&gt;&gt;</code> 来表示，即将数值的二进制码按照指定的位数向右移动，符号位不变，它和左移相反</p><p><strong>例如：</strong></p><p>求 <code>64 &gt;&gt; 5</code>，即求十进制数 64 有符号右移 5 位的操作</p><p>我们先将十进制数字 64 转二进制再右移 5 位后如下图</p><p><img src="https://cdn.jsdelivr.net/gh/isboyjc/PictureBed/other/image-20201128163121995.png"></p><p>有符号右移时移动数位后会同样也会造成空位，空位位于数字的左侧，但位于符号位之后，<code>ECMAScript</code> 中用符号位的值填充这些空位</p><p>随后，我们就得到了一个新的二进制，转为 10 进制即为数值 2，其实就是左移的逆运算</p><p>同样，数字 x 有符号右移 y 位我们也可以得到一个公式，如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">x &gt;&gt; y <br><br><span class="hljs-comment">// 等同于</span><br><br>x / <span class="hljs-number">2</span>^y<br></code></pre></td></tr></table></figure><h4 id="使用右移-gt-gt-取整"><a href="#使用右移-gt-gt-取整" class="headerlink" title="使用右移 &gt;&gt; 取整"></a>使用右移 &gt;&gt; 取整</h4><p>使用右移和左移一样都可以取整</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">1.111</span> &gt;&gt; <span class="hljs-number">0</span> <span class="hljs-comment">// 1</span><br><span class="hljs-number">2.344</span> &gt;&gt; <span class="hljs-number">0</span> <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>原理还是那一个，位运算操作的是整数，忽略小数部分，等同于数值的整数部分，右移 0 位，结果还是整数部分</p><h3 id="无符号右移（-gt-gt-gt-）"><a href="#无符号右移（-gt-gt-gt-）" class="headerlink" title="无符号右移（&gt;&gt;&gt;）"></a>无符号右移（&gt;&gt;&gt;）</h3><h4 id="简述-6"><a href="#简述-6" class="headerlink" title="简述"></a>简述</h4><p>无符号右移使用 <code>&gt;&gt;&gt;</code> 表示，和有符号右移区别就是它是三个大于号，它会将数值的所有 32 位字符都右移</p><p>对于正数，无符号右移会给空位都补 0 ，不管符号位是什么，这样的话正数的有符号右移和无符号右移结果都是一致的</p><p>负数就不一样了，当把一个负数进行无符号右移时也就是说把负数的二进制码包括符号为全部右移，向右被移出的位被丢弃，左侧用0填充，由于符号位变成了 0，所以结果总是非负的</p><p>那么可能就有人要问了，如果一个负数无符号右移 0 位呢，我们可以测试一下</p><p>让十进制 -1 进行无符号右移 0 位</p><p>-1 是负数，在内存中二进制存储是补码即 <code>1111 .... 1111 1111</code>，32 位都是 1，我们在程序中写入 <code>-1 &gt;&gt;&gt; 0</code> 运行得到十进制数字 <code>4294967295</code> ，再使用二进制转换工具转为二进制得到的就是 32 位二进制 <code>1111 .... 1111 1111</code>，所以就算无符号右移 0 位，得出的依然是一个很大的正数</p><h4 id="使用无符号右移-gt-gt-gt-取整（正数）"><a href="#使用无符号右移-gt-gt-gt-取整（正数）" class="headerlink" title="使用无符号右移 &gt;&gt;&gt; 取整（正数）"></a>使用无符号右移 &gt;&gt;&gt; 取整（正数）</h4><p>无符号右移和有符号右移以及左移都差不多，移 0 位都可取整，只不过无符号右移只能支持正数的取整，至于原理，说过无数遍了，相信你已经记住了，如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">1.323</span> &gt;&gt;&gt; <span class="hljs-number">0</span> <span class="hljs-comment">// 1</span><br><span class="hljs-number">2.324</span> &gt;&gt;&gt; <span class="hljs-number">0</span> <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><h2 id="使用位运算管理权限"><a href="#使用位运算管理权限" class="headerlink" title="使用位运算管理权限"></a>使用位运算管理权限</h2><p>除了上文中每种位运算的使用场景外，还有一种稍微复杂那么一丢丢由多个位运算符组合使用的场景，那就是权限管理，本来没打算写着这个，但是应很多小伙伴要求，补充进来了</p><p>在我们熟知的 Vue 源码中，就用了位运算来做鉴权，那么我们就以 Vue 这部分源码为例子来解释</p><p>在 Vue 源码中，<a href="https://github.com/vuejs/vue-next/blob/master/packages/shared/src/patchFlags.ts">patchFlags</a>  文件是 <code>VisualDOM</code> 中对 <code>vnode</code> 的类型标记，作用是在更新 <code>DOM树</code> 的时候会根据 <code>vnode</code> 的类型来使用不同的更新策略（这块不懂不重要），我们来看这里对类型的定义</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// Patch flags can be combined using the | bitwise operator and can be checked</span><br><span class="hljs-comment">// using the &amp; operator, e.g.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//   const flag = TEXT | CLASS</span><br><span class="hljs-comment">//   if (flag &amp; TEXT) &#123; ... &#125;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Check the `patchElement` function in &#x27;./renderer.ts&#x27; to see how the</span><br><span class="hljs-comment">// flags are handled during diff.</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> enum PatchFlags &#123;<br>  TEXT = <span class="hljs-number">1</span>, <span class="hljs-comment">// 1 &lt;&lt; 0</span><br>  CLASS = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">1</span>,<br>  STYLE = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">2</span>,<br>  PROPS = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>,<br>  FULL_PROPS = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>,<br>  HYDRATE_EVENTS = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">5</span>,<br>  STABLE_FRAGMENT = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">6</span>,<br>  KEYED_FRAGMENT = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">7</span>,<br>  UNKEYED_FRAGMENT = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">8</span>,<br>  NEED_PATCH = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">9</span>,<br>  DYNAMIC_SLOTS = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">10</span>,<br><br>  <span class="hljs-comment">// SPECIAL FLAGS -------------------------------------------------------------</span><br><br>  <span class="hljs-comment">// Special flags are negative integers. They are never matched against using</span><br>  <span class="hljs-comment">// bitwise operators (bitwise matching should only happen in branches where</span><br>  <span class="hljs-comment">// patchFlag &gt; 0), and are mutually exclusive. When checking for a special</span><br>  <span class="hljs-comment">// flag, simply check patchFlag === FLAG.</span><br>  HOISTED = -<span class="hljs-number">1</span>,<br>  BAIL = -<span class="hljs-number">2</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上面我们可以看到，<code>PatchFlags</code> 中定义了 <code>TEXT、CLASS</code> 等共计 11种 类型，除了最后两种特殊类型外，其余每一种类型的值都是依次将 1 左移一位得到的</p><p>其实文档开头的注释里作者很贴心的给出了用法，可能有部分同学不爱看或者看不太懂英文</p><p>简单来说就是下面这些类型我们可以使用 <code>|</code> 来进行组合类型权限赋予，使用 <code>&amp;</code> 来进行类型权限校验</p><p>我们下面再从头理一遍</p><h3 id="左移（-lt-lt-）分配权限"><a href="#左移（-lt-lt-）分配权限" class="headerlink" title="左移（&lt;&lt;）分配权限"></a>左移（&lt;&lt;）分配权限</h3><p>首先，使用 1 的左移来分配各个类型权限，上文左移运算我们说过，左移就是将数值的二进制码按照指定的位数向左移动，符号位不变，那么这里即如下面这样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 1 的二进制为 00000001</span><br><br><span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">0</span>  <span class="hljs-comment">// 00000001</span><br><span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">1</span>  <span class="hljs-comment">// 00000010</span><br><span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">2</span>  <span class="hljs-comment">// 00000100</span><br><span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>  <span class="hljs-comment">// 00001000</span><br><span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>  <span class="hljs-comment">// 00010000</span><br><span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">5</span>  <span class="hljs-comment">// 00100000</span><br><br>...<br></code></pre></td></tr></table></figure><p>如上所示，所有的权限类型都是唯一的，已满足权限分配要求，除此之外，上面经过左移之后的二进制中都只有 1 位数字是 1，你发现了吗😄</p><h3 id="按位与AND（-amp-）校验权限"><a href="#按位与AND（-amp-）校验权限" class="headerlink" title="按位与AND（&amp;）校验权限"></a>按位与AND（&amp;）校验权限</h3><p>接着我们看类型权限校验，我们先初始化几个不同的用户权限角色</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> permission1 = <span class="hljs-number">0</span> <span class="hljs-comment">// 无任何权限</span><br><span class="hljs-keyword">let</span> permission2 = TEXT <span class="hljs-comment">// 1 &gt;&gt; 0 </span><br><span class="hljs-keyword">let</span> permission3 = CLASS <span class="hljs-comment">// 1 &gt;&gt; 1</span><br></code></pre></td></tr></table></figure><p>假如我们的条件是判断该用户角色有没有 <code>CLASS</code> 权限，即可以用 按位与 AND（&amp;）判断</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span>(permission1 &amp; CLASS) <span class="hljs-comment">// 00000000 &amp; 00000010 = 00000000 = 0 = false</span><br><span class="hljs-keyword">if</span>(permission2 &amp; CLASS) <span class="hljs-comment">// 00000001 &amp; 00000010 = 00000000 = 0 = false</span><br><span class="hljs-keyword">if</span>(permission3 &amp; CLASS) <span class="hljs-comment">// 00000010 &amp; 00000010 = 00000010 = 2 = true</span><br></code></pre></td></tr></table></figure><p>为什么呢？因为我们上面说过，&amp; 就是将两个操作数的二进制每一位进行对比，两个操作数相应的位都为 1 时，结果为 1，否则都为 0</p><h3 id="按位或OR（｜）赋予权限"><a href="#按位或OR（｜）赋予权限" class="headerlink" title="按位或OR（｜）赋予权限"></a>按位或OR（｜）赋予权限</h3><p>接下来看权限赋予以及组合类型权限</p><p>我们想要一个 <code>TEXT</code> 和 <code>CLASS</code> 的组合权限角色，按照 Vue 源码注释中所说，使用 <code>|</code> ，即按位或OR</p><p>按位或OR 我们上面也说过了，就是把二进制的每一位进行对比，两边只要有一个 1 ，结果就是 1，只有两边都是 0 ，结果才为 0</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 初始化一个新的用户角色 permission4 并初始化，初始化角色即无权限状态 0 </span><br><span class="hljs-keyword">let</span> permission4 = <span class="hljs-number">0</span><br><br><span class="hljs-comment">// 赋予 TEXT（1 &gt;&gt; 0） 权限</span><br>permission4 ｜= TEXT<br><br><span class="hljs-comment">// 赋予 CLASS（1 &lt;&lt; 1） 权限</span><br>permission4 ｜= CLASS<br><br><span class="hljs-comment">// 新的组合类型的用户角色权限即 00000011 ，如下</span><br>permission4 = <span class="hljs-number">0</span> ｜ TEXT ｜ CLASS<br><br><span class="hljs-comment">// 0 = 0000 0000</span><br><span class="hljs-comment">// TEXT   = 0000 0001</span><br><span class="hljs-comment">// CLASS  = 0000 0010</span><br><span class="hljs-comment">// -----------------------</span><br><span class="hljs-comment">// permission4 = 0000 0011</span><br><br><br><span class="hljs-comment">// 权限校验，&amp; 对比二进制操作位</span><br>permission4 &amp; TEXT <span class="hljs-comment">// 0000 0011 &amp; 0000 0001 = 0000 0001 = 1 = true</span><br>permission4 &amp; CLASS <span class="hljs-comment">// 0000 0011 &amp; 0000 0010 = 0000 0010 = 2 = true</span><br>permission4 &amp; STYLE <span class="hljs-comment">// 0000 0011 &amp; 0000 0100 = 0000 0000 = 0 = false</span><br></code></pre></td></tr></table></figure><p>到此我们就可以使用 <code>&lt;&lt;</code> 、<code>|</code> 、 <code>&amp;</code> 来愉快的进行权限管理了，你 <code>get</code> 到了吗?</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>其实目前位运算基础的使用场景并不广，基本上大多数人用就是上文所说那样子，权限管理、取整、判断奇偶、判断-1、切换 0/1 等等几个用途，如果你耐心的看完了文章，就会发现其实原理很简单，也就那回事，没有必要整天喊打喊杀，还是那句话，用不用全凭自己，但是不用不是不会的理由</p><p>到此就结束了，请不要吝啬你的赞，文章如有错误，请指出，共同进步，也欢迎大家关注公众号「不正经的前端」</p>]]></content>
    
    
    <categories>
      
      <category>硬核JS系列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「硬核JS」数字之美</title>
    <link href="/blog/2020/11/22/js/%E3%80%8C%E7%A1%AC%E6%A0%B8JS%E3%80%8D%E6%95%B0%E5%AD%97%E4%B9%8B%E7%BE%8E/"/>
    <url>/blog/2020/11/22/js/%E3%80%8C%E7%A1%AC%E6%A0%B8JS%E3%80%8D%E6%95%B0%E5%AD%97%E4%B9%8B%E7%BE%8E/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>一直都在佛系更新，这次佛系时间有点长，很久没发文了，有很多小伙伴滴我，其实由于换工作以及搬家的原因，节奏以及时间上都在调整，甚至还有那么一小段时间有点焦虑，你懂的，现已逐渐稳定，接下来频率应该就会高了，奥利给～</p><p>可能大家对一些看了能立即上手或者是面经类文章的更为倾向一些，说实话，你可能能瞒过面试官，终究瞒不过自己，应牢记 <strong>技术!=面试题</strong> ，应该有很多人会忽略一些基础的东西吧，殊不知决定楼有多高的是地基</p><p>前几天有朋友问我位运算相关的东西，其实本来是打算写篇位运算的文章，但描述位运算的前提是需要大家能够清晰的了解计算机中的 <code>数字</code>，数字和位运算又是不同的两个点，所以直接淦位运算可能并不太好，就拿出了此文修补一番发一下，也算是来补一补之前写一半就罢工的文章，随后再补发一篇位运算的文章</p><p>数字，很普通的东西，所有语言都有数字，本文的大部分知识点并不仅仅适用于 <code>JavaScript</code> ，其他语言也都类似，数字大家表面看来可能很简单，其实从计算机到语言本身对数字的处理还是比较复杂的，望本文能够体现出数字的精妙，故而取名 <code>数字之美</code> </p><h2 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h2><p>对于计算机只能存储二进制，想必是大家耳熟能详的知识了</p><p>我们都知道在计算机内部数据的存储和运算都采用二进制，是因为计算机是由很多晶体管组成的，而晶体管只有2种状态，恰好可以用二进制的 0 和 1 表示，并且采用二进制可以使得计算机内部的运算规则简单，稳定性高，但是由于我们平常并不直接使用二进制，所以可能有小伙伴能给十进制转二进制都忘了，这里就简单介绍一下，当作回顾</p><h3 id="整数转二进制"><a href="#整数转二进制" class="headerlink" title="整数转二进制"></a>整数转二进制</h3><p>关于十进制整数转二进制，其实很简单，记住一个秘诀，就可以了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">除 <span class="hljs-number">2</span> 取余，逆序排列<br></code></pre></td></tr></table></figure><p>就是用 2 整除十进制数，得到商和余数，再用 2 整除商，得到新的商和余数，一直重复直至商等于 0，将先得到的余数作为二进制数的高位，后得到的余数作为二进制数的低位，依次排序即可</p><p>例如，我们将十进制 55 转换为 2 进制</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">55</span> % <span class="hljs-number">2</span> <span class="hljs-comment">// 商 27 余 1</span><br><span class="hljs-number">27</span> % <span class="hljs-number">2</span> <span class="hljs-comment">// 商 13 余 1</span><br><span class="hljs-number">13</span> % <span class="hljs-number">2</span> <span class="hljs-comment">// 商  6 余 1</span><br><span class="hljs-number">6</span>  % <span class="hljs-number">2</span> <span class="hljs-comment">// 商  3 余 0</span><br><span class="hljs-number">3</span>  % <span class="hljs-number">2</span> <span class="hljs-comment">// 商  1 余 1</span><br><span class="hljs-number">1</span>  % <span class="hljs-number">2</span> <span class="hljs-comment">// 商  0 余 1</span><br></code></pre></td></tr></table></figure><p>取余逆序，那么十进制 55 转 2 进制的结果就是 <code>110111</code> </p><p>二进制一个数值是 1 位，也就是 1 比特（bit），那么如果我们需要得到 8 位二进制，那就在转换结果前补 0 即可</p><p>如十进制 55 的 8 位二进制即 <code>00110111</code>，那么可能还会有人为如果是 4 位怎么办呢，4 位是存不了 55 这么大值的，溢出了</p><h3 id="小数转二进制"><a href="#小数转二进制" class="headerlink" title="小数转二进制"></a>小数转二进制</h3><p>可能还有人不了解十进制小数是怎么转二进制的，其实也有方法口诀</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">乘 <span class="hljs-number">2</span> 取整，顺序排列<br></code></pre></td></tr></table></figure><p>用 2 乘十进制小数，可以得到积，将积的整数部分取出，再用 2 乘余下的小数部分，又得到一个积，再将积的整数部分取出，如此进行，直到积中的整数部分为零，或者整数部分为1，此时 0 或 1 为二进制的最后一位或者达到所要求的精度为止，然后把取出的整数部分按顺序排列起来，先取的整数作为二进制小数的高位有效位，后取的整数作为低位有效位</p><p>例如，将十进制小数 <code>0.625</code> 转二进制</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">0.625</span> * <span class="hljs-number">2</span> = <span class="hljs-number">1.250</span> <span class="hljs-comment">// 取整数 1</span><br><span class="hljs-number">0.25</span>  * <span class="hljs-number">2</span> = <span class="hljs-number">0.50</span>  <span class="hljs-comment">// 取整数 0</span><br><span class="hljs-number">0.5</span>   * <span class="hljs-number">2</span> = <span class="hljs-number">1</span><span class="hljs-comment">// 取整数 1 并结束</span><br></code></pre></td></tr></table></figure><p>取整顺序，那么十进制小数 <code>0.625</code> 的二进制即为 <code>0.101</code> </p><p>如果该十进制值是一个大于 1 的小数，那么整数部分和小数部分分别取二进制再拼接即可</p><p>例如，将十进制小数 <code>5.125</code> 转二进制</p><p>我们先计算整数 5 的二进制</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">5</span> % <span class="hljs-number">2</span> <span class="hljs-comment">// 商  2 余 1</span><br><span class="hljs-number">2</span> % <span class="hljs-number">2</span> <span class="hljs-comment">// 商  1 余 0</span><br><span class="hljs-number">1</span> % <span class="hljs-number">2</span> <span class="hljs-comment">// 商  0 余 1</span><br></code></pre></td></tr></table></figure><p>那么 5 的二进制即 <code>101</code>，再来看小数部分</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">0.125</span> * <span class="hljs-number">2</span> = <span class="hljs-number">0.250</span> <span class="hljs-comment">// 取整数 0</span><br><span class="hljs-number">0.25</span>  * <span class="hljs-number">2</span> = <span class="hljs-number">0.50</span>  <span class="hljs-comment">// 取整数 0</span><br><span class="hljs-number">0.5</span>   * <span class="hljs-number">2</span> = <span class="hljs-number">1</span><span class="hljs-comment">// 取整数 1 并结束</span><br></code></pre></td></tr></table></figure><p>那么小数部分 <code>0.125</code> 的二进制即 <code>001</code>，拼接可得出十进制数字 <code>5.125</code> 的二进制为 <code>101.001</code> </p><p>还会有一种情况，例如十进制小数 <code>0.1</code> 取其二进制</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">0.1</span> * <span class="hljs-number">2</span> = <span class="hljs-number">0.2</span> <span class="hljs-comment">// 取整数 0</span><br><span class="hljs-number">0.2</span> * <span class="hljs-number">2</span> = <span class="hljs-number">0.4</span> <span class="hljs-comment">// 取整数 0</span><br><span class="hljs-number">0.4</span> * <span class="hljs-number">2</span> = <span class="hljs-number">0.8</span> <span class="hljs-comment">// 取整数 0</span><br><span class="hljs-number">0.8</span> * <span class="hljs-number">2</span> = <span class="hljs-number">1.6</span> <span class="hljs-comment">// 取整数 1</span><br><span class="hljs-number">0.6</span> * <span class="hljs-number">2</span> = <span class="hljs-number">1.2</span> <span class="hljs-comment">// 取整数 1 -&gt; 到此我们看到开始无限循环了</span><br><span class="hljs-number">0.2</span> * <span class="hljs-number">2</span> = <span class="hljs-number">0.4</span> <span class="hljs-comment">// 取整数 0</span><br><span class="hljs-number">0.4</span> * <span class="hljs-number">2</span> = <span class="hljs-number">0.8</span> <span class="hljs-comment">// 取整数 0</span><br>...<br></code></pre></td></tr></table></figure><p>那么它的二进制就是 <code>0.0001100......</code> 这样反复循环，这也引出了我们在语言层面的问题，例如 JS 中被人诟病的 <code>0.1 + 0.2 != 0.3</code> 的问题，我们后面再说</p><h2 id="原码、反码和补码"><a href="#原码、反码和补码" class="headerlink" title="原码、反码和补码"></a>原码、反码和补码</h2><p>再说 JS 中的数字问题前，我们还需要补充了解下原码、反码和补码的概念，这里暂先不说结论，我们一步一步的来看，最后在总结什么是原码、反码和补码</p><h3 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h3><p>计算机里保存的是最原始的数字，也就是没有正和负的数字，我们称之为无符号数字</p><p>假如我们在内存中用 4 位（也就是4bit）去存放表示无符号数字，是下面这样子的</p><p><strong>PS：</strong> 这里也说了是假如，当然你也可以用 32 位来理解，这里只是为了解释原码、反码、补码的概念，多少位只有一个区别，那就是可存储的值范围大小不同，可存储位数越大，可以存储的值范围就越大，这点后面会说到，这都不重要，主要是 32 位画图太累。。。</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20201122183341034.png"></p><p>我们可能注意到了，这样好像没办法表达负数</p><p>So，为了表示正与负，先辈们就发明了 <strong>原码</strong>，把左边第一位腾出来，存放符号，正数用 0 来表示，负用 1 来表示</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20201117212137235.png"></p><p>上图就是正负数的 <code>原码</code>，你可能在疑惑为什么上面表里我只画到了数字 7，上面也说了，我们这里使用的示例是 4 位（bit）的存储方式，只存 4 位，还有一位是符号位，十进制 7 的二进制表达方式就是 0111 了，数字 8 二进制算上符号为是 01000，这就 5 位了，就不是 4 位二进制能存下的了，所以，在只有 4 位存储二进制时，原码的取值范围只有 <code>-7 ～ +7</code> </p><p><code>原码</code> 这种方式对人来说是很好理解的，但是机器不了解啊，表达值没问题，但是正负相加怎么加呢？</p><p>假如我们要用 <code>(+1) + (-1)</code> ，这个我们上过小学就知道等于 0，但是按照计算机的二进制计算方式，<code>0001 + 1001 = 1010</code> ，我们对比下原码表，也就是 -2</p><p>很明显，这样计算是不对的，还有就是我们会看到，原码中的 0 有两种表示：+0 和 -0，这明显也是不对的</p><p>为了解决正负相加等于 0 的问题，先辈们又在 <code>原码</code> 的基础上发明了 <code>反码</code></p><p>正数的反码还是等同于原码，<code>反码</code> 的表示方式其实就是用来处理负数的，也就是除符号位不变，其余位置皆取反存储，0 就存 1，1 就存 0</p><p>那么我们再来看</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20201122183505866.png"></p><p>同上，4 位反码的值存储范围也是 <code>-7 ～ +7</code></p><p>当 <code>原码</code> 变成了 <code>反码</code> ，我们看之前的（+1）和（-1）相加，变成了 <code>0001 + 1110 = 1111</code>，相加结果对比反码表， 1111 也就是 -0 ，就完美的解决了正负相加等于 0 的问题</p><p>但是，如果使用 <code>反码</code> 存储数值，还是存在那个问题，即 （+0）和（-0）这两个相同的值，存在两个不同的二进制表达方式</p><p>于是先辈们为了解决这个问题，又提出了 <code>补码</code> 的概念，也是针对 <code>负数</code> 来做处理的，即从原来 <code>反码</code> 的基础上，补充一个新的代码 1</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20201122183627781.png"></p><p>如上图所示，处理 <code>反码</code> 中的 -0 时，给 1111 再补上一个 1 之后，就变成了 10000，由于我们是 4 位存储，所以要丢掉除符号位的最左侧高位，也就是进位中的那一位，也就变成了 0000，刚好和左边正数的 0 相等</p><p>完美解决了（+0）和（-0）同时存在的问题</p><p>我们看补码表中由于 -0 的补码是 <code>0000</code> 等同于 +0，因为它补了 1嘛，我们发现 -0 就没有了意义，所以去掉了 -0 这个数字</p><p>我们再看负 7 的补码也就是反码加了 1 后的二进制表达方式为 <code>1001</code> ，以 4 位存储的方式我们发现补码表 <code>1001</code> 还可以再小一位，也就是 <code>1000</code> 即 -8，如下图</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20201117225925521.png"></p><p>于是补码的最后补上了一个 -8，也就是在 4 位存储中补码的值表达范围是 <code>-8 ～ +7</code> </p><p>同时，我们在使用 <code>补码</code> 时，正负相加等于 0 的问题也同样可以解决</p><p><strong>例：</strong></p><p>我们把（+4）和（-4）相加，0100 + 1100 =10000，有进位，把最高位丢掉，也就是 0000（0）</p><p>接下来我们就可以梳理总结下什么是原码、反码、补码了</p><h3 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h3><p>原码其实就是数值前面增加了一位符号位（即最高位为符号位），正数时符号位为 0</p><p>负数时符号位为 1（0有两种表示：+0 和 -0），其余位表示数值的大小</p><p><strong>例：</strong></p><p>我们这次使用 8 位（bit）二进制表示一个数，那么正 5 的原码为 <code>0000 0101</code>，负 5 的原码就是 <code>1000 0101</code>，区别只有符号位</p><h3 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h3><p>正数的反码与其原码相同</p><p>负数的反码是对其原码除符号位外，皆取反</p><p><strong>例：</strong></p><p>使用 12 位（bit）二进制来表示一个数值，那么正 5 的反码等同于原码即为 <code>0000 0000 0101</code>，负 5 的反码符号位为 1 ，其余取反即为 <code>1111 1111 1010</code> </p><h3 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h3><p>正数的补码与其原码相同</p><p>负数的补码是在其反码的末位加 1去掉最高进位</p><p><strong>例：</strong></p><p>使用 32 位（bit）二进制来表示，那么正 5 的补码等同于原码即为 <code>0000 0000 0000 0000 0000 0000 0000 0101</code>，负 5 的补码在反码末位补 1 去掉最高进位，由于负 5 的反码加 1 无进位，即为 <code>1111 1111 1111 1111 1111 1111 1111 1011</code> </p><h3 id="根据补码求原码"><a href="#根据补码求原码" class="headerlink" title="根据补码求原码"></a>根据补码求原码</h3><p>上文我们知晓了原码、反码、补码的概念后，应该已经了解了由原码转换为反码的过程，但是，若已知一个数的补码，求原码的操作呢？</p><p>其实，已知补码求原码的操作就是对这个补码再求补码</p><p>如果补码的符号位为 0，表示是一个正数，那么它的原码就是它的补码</p><p>如果补码的符号位为 1，表示是一个负数，那就直接对这个补码再求一遍它的的补码就是它的原码</p><p><strong>例：</strong> </p><p>求补码 <code>1001</code> 即十进制 -7 的原码</p><p>我们对补码再求补码，也就是先取反再补 1 ，取反得 <code>1110</code> ，再补一得 <code>1111</code>，我们对照上文中 -7 的原码，正是 <code>1111</code> </p><h3 id="二进制在内存中以补码存储"><a href="#二进制在内存中以补码存储" class="headerlink" title="二进制在内存中以补码存储"></a>二进制在内存中以补码存储</h3><p>如上述，此时再和大伙说最终结论，二进制数在内存中最终是以补码的形式存储的，现在知道为什么用补码存储了吗，你 GET 到了吗？</p><p>使用补码，我们可以很方便的将减法运算转化成加法运算，运算过程得到简化，正数的补码即是它所表示的数的真值，而负数的补码的数值部份却不是它所表示的数的真值，采用补码进行运算，所得结果仍为补码</p><p>与原码、反码不同，数值 0 的补码只有一个，4 位为例，即为 0000 </p><p>再次补充，32 位、12位、8 位和 4 位等的不同就是存储的值范围，就像 8 位存储原码和反码的有效值范围是 <code>-127 ～ +127</code>，补码范围是 <code>-128 ~ +127</code>，而 4 位原码和反码范围是 <code>-7 ～ +7</code>，补码范围是 <code>-8 ～ +7</code>，这下你大概了解到为什么 JS 会有最大和最小有效数字这个概念了吧</p><p>当然我们现在只考虑了整数，并没有说小数，是为了方便我们理解原码、反码和补码，接着来道</p><h2 id="JavaScript中数字存储"><a href="#JavaScript中数字存储" class="headerlink" title="JavaScript中数字存储"></a>JavaScript中数字存储</h2><p><code>JavaScript</code> 不是类型语言，它与许多其他编程语言不同，<code>JavaScript</code> 没有不同类型的数字，比如整数、短、长、浮点等等</p><p>在 <code>JavaScript</code> 中，数字不分为整数和浮点型，也就是所有的数字都是使用浮点型类型来存储，它采用 <a href="https://zh.wikipedia.org/wiki/IEEE_754">IEEE 754</a> 标准定义的 64 位浮点格式表示数字，如下图</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20201121184413568.png"></p><ul><li><p>第 63 位即 1 位符号位 S （sign）</p></li><li><p>52 ～ 62位即 11 位阶码 E （exponent bias）</p></li><li><p>0 ～ 51 位即 52 位尾数 M（Mantissa）</p></li></ul><p>符号位也就是上文说的，表示正负，0 为正，1 为负</p><p>符号位我们比较好理解，那么什么是尾数什么又是阶码呢？</p><h3 id="什么是尾数"><a href="#什么是尾数" class="headerlink" title="什么是尾数"></a>什么是尾数</h3><p>为了方便解释，我们直接使用例子，来看十进制数 5.2 的尾数</p><p>首先，我们把它整数部分和小数部分依次转为二进制，不过多重复这个过程，结果如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">101.00110011</span>... <span class="hljs-comment">// 小数部分 0011 无限循环</span><br></code></pre></td></tr></table></figure><p>一个浮点数的表示方式其实有很多，但规范中一般使用科学计数法，就像上面的 <code>101.00110011...</code> ，我们会使用 <code>1.0100110011.. * 2^2</code> 这种只留一位整数的表达方式，我们称之为规格化</p><p>二进制中只有 0 与 1，按照科学计数法，除了数字 0 ，其余所有规格化的数字首位只可能是1，对此 IEEE 754 直接省略了这个默认的 1 用来增加存储值的范围，所以有效尾数实际上是有 <code>52 + 1 = 53</code> 位的</p><p>上文说尾数即表达的是数字的小数部分，也就是说二进制数值 <code>1.0100110011.. * 2^2</code> 的尾数是 <code>0100110011...</code>，因为它是个无限循环小数，所以我们取最大 52 即可，剩余的就截断了，这样就会造成一定的精度损失，这也是为什么 JS 中 <code>0.1 + 0.2 != 0.3</code> 的原因，如果尾数不足 52 位则在后面补 0 即可</p><p>我们可能会疑惑，为什么除了 0 之外的数字转二进制后首位都是 1，比如 <code>0.0101</code> 这种 <code>0 &lt; 值 &lt; 1</code> 的二进制小数首位不就是 0 吗，我们说了是 规格化之后的，二进制小数 <code>0.0101</code> 在规格化之后是 <code>1.01 * 2^-2</code> ，所以省略首位 1 并不会混淆</p><h3 id="什么是阶码"><a href="#什么是阶码" class="headerlink" title="什么是阶码"></a>什么是阶码</h3><p>首先，我们要知道</p><p>阶码  =  阶码真值  +  偏移量 1023，偏移量 = <code>2^(k-1)-1</code>，k 表示阶码位数</p><p>阶码真值即为科学记数法中指数真实值的 2 进制表达，它表明了小数点在尾数中的位置</p><p>那么为什么阶码真值与偏移量相加得到阶码呢？</p><p>简单理解，阶码真值是实际指数中的二进制值，而阶码是指数偏移之后保存起来的二进制数值</p><p>还拿上面数值 5.2 来说，它的规格化二进制为 <code>1.0100110011.. * 2^2</code> ，2 的 2 次方，也就是说它的阶码真值为 2 ，那么加上偏移量 1023 即 1025，转二进制后的 11位阶码即为 <code>10000000001</code> </p><p>那么为什么要偏移呢？</p><h3 id="为什么阶码有偏移量-1023？"><a href="#为什么阶码有偏移量-1023？" class="headerlink" title="为什么阶码有偏移量 1023？"></a>为什么阶码有偏移量 1023？</h3><p>此时你可能会比较好奇为什么阶码会有偏移量这个概念，我们来推导一遍即可</p><p>11位的阶码，那么阶码可以存储的二进制值范围为 0～2047，除去 0 与 2047 两个非规格化情况（非规格化下面会说），变成 1～2046，这里指的是正数，因为还有负数，那指数范围就是 -1022～1023，如果没有偏移量的存在，指数就需引入符号位，因为有负数，还需要引入补码，无疑会使计算更加复杂，为了简化操作，才使用无符号的阶码，并引入偏移量的概念</p><h3 id="不同情况下的阶码-E"><a href="#不同情况下的阶码-E" class="headerlink" title="不同情况下的阶码 E"></a>不同情况下的阶码 E</h3><p>我们上面提到过规格化和非规格化的概念，那么它们是什么呢</p><p>规格化的情况其实就是上面我们说的一般情况，因为阶码不能为 0 也不能为 2047，所以指数不能为 -1023，也不会为 1024，只有这种情况尾数才会有隐含位 1 即默认忽略的那一位，如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">S + (E!=<span class="hljs-number">0</span> &amp;&amp; E!=<span class="hljs-number">2047</span>) + <span class="hljs-number">1.</span>M<br></code></pre></td></tr></table></figure><p>那么非规格化就是阶码全为 0，指数为 -1023 的特殊情况了，如果尾数全为 0，则浮点数表示正负 0，否则表示那些非常的接近于 0.0 的数，如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">S + <span class="hljs-number">00000000000</span> + M<br></code></pre></td></tr></table></figure><p>非规格化指的是阶码全为 0 ，那么表示了还有一种情况阶码全部为 1，指数就是 1024，在这种情况下，如果尾数全部为 0 ，那就是无穷大，若尾数不等于 0，那就是我们常说的 NaN 了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">无穷大：S + <span class="hljs-number">111</span> <span class="hljs-number">11111111</span> + <span class="hljs-number">00000000</span>...<br><br><span class="hljs-literal">NaN</span>：S + <span class="hljs-number">111</span> <span class="hljs-number">11111111</span> + (M!=<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><h3 id="测试一哈"><a href="#测试一哈" class="headerlink" title="测试一哈"></a>测试一哈</h3><p>可能大家还是有些迷惑，最好反复看一看，那么歇一歇脑子，接下来我们来一个小测试，计算一下十进制数 -15.125 在 JS 内存中的二进制表达方式是多少，动手试一试吧，做完再看答案</p><p>｜</p><p>｜</p><p>都看到这了，动动小手，点个赞吧 😄 </p><p>｜</p><p>｜</p><p>如上，求十进制数 -15.125 在 JS 内存中的二进制</p><p>首先，由于是负数，那么符号为就是 1</p><p>接着，将 15.125 的整数部分 15 和小数部分 0.125 分别转为二进制，计算过程不叙述了，整数除 2 取余逆序排列，小数乘 2 取整顺序排列，结果合到一块为 <code>1111.001</code> </p><p>按照科学技术法规格化结果为 <code>1.111001 * 2^3</code> </p><p>再接下来，计算阶码，3（阶码真值）+ 1023（偏移量）= 1026</p><p>将 1026 转为 11 位二进制 <code>100 0000 0010</code> ，即为阶码</p><p>尾数即规格化结果数去掉整数 1 的小数部分 <code>1110 01</code>，不足 52 位后补 0 尾数结果为 <code>1110 0100 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000</code></p><p>最后，拼接即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">符号位 + 阶码 + 尾数<br><span class="hljs-number">1</span> <span class="hljs-number">10000000010</span> <span class="hljs-number">1110010000000000000000000000000000000000000000000000</span><br></code></pre></td></tr></table></figure><h3 id="JS中数字范围"><a href="#JS中数字范围" class="headerlink" title="JS中数字范围"></a>JS中数字范围</h3><p>如果大家真的理解了上文，那么就会发现数字的范围其实有两个概念，最大正数和最小负数，最小正数和最大负数</p><p>而最终的数字范围即 <code>最小负数~最大负数</code> 并上 <code>最小正数~最大正数</code></p><p>从S、E、M即数符、阶码、尾数三个维度看，S 代表正负，阶码 E 的值远大于尾数 M 的个数，所以阶码  E 决定大小，尾数 M 决定精度</p><p>So，我们从阶码 E 入手分析</p><p>规格化下，当 E 最大值时，2046（最大阶码） - 1023（偏移量） = 1023（阶码真值）即 <code>011 11111111</code> </p><p>从阶码 E 的最大值求出的指数（阶码真值）来看，我们可以得到的数值范围是 <code>-2^1023 ~ 2^1023</code>，使用 JS 的求指函数 <code>Math.pow(2,1023)</code> 得出结果是 <code>8.98846567431158e+307</code>，那么如果尾数是 <code>1.11111111...</code>，则它就无限接近于 2，我们不算这么准确，就用 <code>8.98846567431158 x 2</code>   再合上原来的指数，约等于 <code>1.797693134862316e+308</code></p><p>大家还记得我们用 JS 常量 <code>Number.MAX_VALUE</code> 求到的最大数字值吗，现在就可以在控制台输出一下，即 <code>1.7976931348623157e+308</code>，和我们估算出来的值非常相近（因为为了简单我们把规格化的数字约等于了 2 来计算，算出的数值其实是大了一点的）</p><p>所以数字的最大正数和最小负数范围如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">1.7976931348623157e+308</span> ~ -<span class="hljs-number">1.7976931348623157e+308</span><br></code></pre></td></tr></table></figure><p>如果超过这个值，则数字太大就溢出了，在 JS 中会显示 <code>Infinity</code> 或 <code>-Infinity</code>，即无穷大与无穷小，学名叫做正向溢出</p><p>上面说的是规格化下，那么非规格化下，也就是指数为 0（最小阶码） - 1023 (偏移量) =  - 1023，即 <code>10000000001</code> </p><p>从指数来看，我们可以得出最小值是 <code>2^-1023</code> ，当如果尾数是 <code>0.00000...001</code> </p><p>也就是尾数不为 0 的情况，52 位尾数相当于小数点还能虚拟化的向右移动51，可以取得更小的 <code>2^-51</code> ,  所以最小值为为 <code>2^-1074</code>，我们再来计算下 <code>Math.pow(2,-1074)</code> 结果约等于  <code>5e-324</code> </p><p>而 JS 最小值常量 <code>Number.MIN_VALUE</code> 得出的值就是是 <code>5e-324</code> </p><p>所以数字的最小正数和最大负数范围即如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">5e-324</span> ~ -<span class="hljs-number">5e-324</span><br></code></pre></td></tr></table></figure><p>如果存了一个数值比可表示的最小数还要小，就显示成 0，学名反向溢出</p><h3 id="JS中整数的范围"><a href="#JS中整数的范围" class="headerlink" title="JS中整数的范围"></a>JS中整数的范围</h3><p>和数字大小不同，数字可以有小数，但是整数就只是单纯整数</p><p>我们从尾数 M 来分析，精度最多是 53 位（包含规格化的隐含位 1 ），精确整数的范围其实就是 M 的最大值，即 <code>1.11111111...111</code> ，也就是 <code>2^53-1</code> ， 使用 JS 函数 <code>Math.pow(2,53)-1</code> 计算得到数字 <code>9007199254740991</code></p><p>所以整数的范围其实就是</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">-<span class="hljs-number">9007199254740991</span> ~ <span class="hljs-number">9007199254740991</span><br></code></pre></td></tr></table></figure><p>我们也可以使用 JS 内部常量来获取下最大与最小安全整数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">Number</span>.MIN_SAFE_INTEGER  <span class="hljs-comment">// -9007199254740991</span><br><span class="hljs-built_in">Number</span>.MAX_SAFE_INTEGER  <span class="hljs-comment">//  9007199254740991</span><br></code></pre></td></tr></table></figure><p>恰好与我们所求一致</p><p>那么我们说如果整数是这个范围内，则是安全整数</p><p>一个整数是否是安全整数可以使用 JS 的内置方法 <code>Number.isSafeInteger()</code> 来验证</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>开发过程中不乏有找过安全范围的计算，这个时候我们就得要转为字符串计算了，当然不想自己转也可以使用开源库来计算，如 <a href="https://github.com/MikeMcl/bignumber.js">bignumber.js</a> 、<a href="http://mathjs.org/">Math.js</a> 等等</p><p>感谢大家的阅读，此文在之前最开始写的时候之所以停了就是因为写着写着让二进制搞得有点懵，所以大家一遍如果不太懂可以多看看，不要气馁，如果此文描述的不太恰当也可以看下文末参考链接中的文章辅助理解，如有不正，望指出，谢谢</p><p>也欢迎大家关注公众号「不正经的前端」，来个三连吧，感谢</p><p>更多精彩尽在 <a href="https://github.com/isboyjc/blog">github.com/isboyjc/blog</a> </p><blockquote><p>参考文章</p><p><a href="https://www.zhihu.com/question/20159860">原码、反码、补码的产生、应用以及优缺点有哪些？</a> </p><p><a href="https://www.cnblogs.com/xfca/p/10375645.html">原码、反码、补码之间的相互关系</a> </p><p><a href="https://www.cnblogs.com/yiyide266/p/7987037.html">[算法]浮点数在内存中的存储方式</a> </p><p><a href="https://juejin.cn/post/6844903680362151950">0.1 + 0.2不等于0.3？为什么JavaScript有这种“骚”操作？</a> </p><p><a href="https://zhuanlan.zhihu.com/p/53314373">JS中如何理解浮点数？</a> </p></blockquote>]]></content>
    
    
    <categories>
      
      <category>硬核JS系列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>让GIS三维可视化变得简单-Cesium地球初始化</title>
    <link href="/blog/2020/08/31/cesium/%E8%AE%A9GIS%E4%B8%89%E7%BB%B4%E5%8F%AF%E8%A7%86%E5%8C%96%E5%8F%98%E5%BE%97%E7%AE%80%E5%8D%95-Cesium%E5%9C%B0%E7%90%83%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <url>/blog/2020/08/31/cesium/%E8%AE%A9GIS%E4%B8%89%E7%BB%B4%E5%8F%AF%E8%A7%86%E5%8C%96%E5%8F%98%E5%BE%97%E7%AE%80%E5%8D%95-Cesium%E5%9C%B0%E7%90%83%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>开发中我们通常会需要一个干净的三维地球实例，本文将介绍 <code>Cesium</code> 如何初始化一个地球，包括地图控件的显示隐藏以及一些常用影像和标注的加载</p><p><a href="https://isboyjc.top/cesiumdemo/cesium-init/index.html">预览Demo</a> </p><p>Cesium 是一款面向三维地球和地图的，世界级的 <code>JavaScript</code> 开源产品，它提供了基于 <code>JavaScript</code> 语言的开发包，方便用户快速搭建一款零插件的虚拟地球 Web 应用，并在性能，精度，渲染质量以及多平台，易用性上都有高质量的保证</p><p>想了解更多 Cesium 的介绍请看 👉 <a href="https://juejin.im/post/6854573221191090189">让GIS三维可视化变得简单-初识Cesium</a> </p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>本文及后续文章启动环境皆是基于 <code>Vue-CLI3.X+</code> </p><p>使用我自己写的 <code>CLI</code> 插件 <code>vue-cli-plugin-cesium</code> 零配置搭建 <code>Cesium</code> 环境</p><p>具体环境搭建可看 👉 <a href="https://juejin.im/post/6854899697661394951">让GIS三维可视化变得简单-Vue项目中集成Cesium</a> </p><h2 id="地球初始化"><a href="#地球初始化" class="headerlink" title="地球初始化"></a>地球初始化</h2><h3 id="申请Token"><a href="#申请Token" class="headerlink" title="申请Token"></a>申请Token</h3><p>在正式开发之前，我们首先需要去注册一个免费的 <code>Cesium ion</code> 账户</p><p>步骤如下</p><p>首先，打开 <a href="https://cesium.com/ion/">https://cesium.com/ion/</a> 然后注册一个新的账户</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20200901115736912.jpeg"></p><p>注册成功后登录，点击 <code>Access Token</code>，跳转到 <em><strong>Access Tokens page</strong></em> 页面</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/Xnip2020-09-01_11-59-41.jpeg"></p><p>如上所示，选择 <em><strong>Default</strong></em> 默认的 <code>access token</code> 拷贝到内容中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">Cesium.Ion.defaultAccessToken = <span class="hljs-string">&#x27;&lt;YOUR ACCESS TOKEN HERE&gt;&#x27;</span><br></code></pre></td></tr></table></figure><p>当然，如果你只是写写demo，那不写 <code>Token</code> 也行</p><h3 id="默认初始化"><a href="#默认初始化" class="headerlink" title="默认初始化"></a>默认初始化</h3><p>环境准备就绪之后，我们就可以初始化Cesium实例了，也就是加载地球</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;map-box&quot;&gt;<br>    &lt;div id=&quot;cesiumContainer&quot;&gt;&lt;/div&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>var viewer = null<br>export default &#123;<br>  name: &quot;No01Init&quot;,<br>  data() &#123;<br>    return &#123;&#125;<br>  &#125;,<br>  mounted() &#123;<br>    Cesium.Ion.defaultAccessToken = &#x27;&lt;YOUR ACCESS TOKEN HERE&gt;&#x27;<br>    // viewer = new Cesium.CesiumWidget(&#x27;cesiumContainer&#x27;)<br>    viewer = new Cesium.Viewer(&quot;cesiumContainer&quot;)<br><br>    console.log(viewer)<br>  &#125;,<br>&#125;<br>&lt;/script&gt;<br>&lt;style scoped&gt;<br>.map-box &#123;<br>  width: 100%;<br>  height: 100%;<br>&#125;<br>#cesiumContainer &#123;<br>  width: 100%;<br>  height: 100%;<br>&#125;<br>&lt;/style&gt;<br><br></code></pre></td></tr></table></figure><p>如上所示，我们可以使用 <code>new Cesium.CesiumWidget</code> 或者 <code>new Cesium.Viewer</code> 的方式进行初始化，都可以，给一个容器挂载即可，运行项目后效果如下</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20200827232433642.jpeg"></p><p>可能细心的小伙伴注意到了我们初始化的 <code>viewer</code> 实例并没有写在 <code>data</code> 里，这是因为Vue中会为 <code>data</code> 中的属性做数据劫持，如果属性是一个对象，将会递归进行数据劫持，<code>viewer</code> 这个实例中的属性数量非常多，如果将它放置 <code>data</code> 中。。。只有一个下场，浏览器崩溃</p><p>我们可以在组件上放直接声明一个 <code>viewer</code> 变量，也可以使用 <code>window.viewer</code> 把 <code>viewer</code> 挂载到 <code>window</code> 上面，都可以避免这个问题</p><p>在 <code>Vue + Cesium</code> 开发中和实例有关的数据都不要放在data中，这点一定需要注意</p><h3 id="控件隐藏"><a href="#控件隐藏" class="headerlink" title="控件隐藏"></a>控件隐藏</h3><p>上面我们可以看到，在默认初始化里，页面上有很多控件，开发时我们基本用不到，但是还是先来介绍下这些控件的作用</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20200830164028938.jpeg"></p><p>在创建 <code>Cesium</code> 实例时，<code>new Cesium.Viewer</code> 构造函数有两个参数</p><ul><li>实例挂载的元素 必选项</li><li>options 初始化配置对象 可选项</li></ul><p>在 <code>options</code> 对象中，我们可以配置初始化的一些控件显示隐藏以及一些渲染配置，这里列举出一些常用的配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js">viewer = <span class="hljs-keyword">new</span> Cesium.Viewer(<span class="hljs-string">&quot;cesiumContainer&quot;</span>, &#123;<br>  <span class="hljs-attr">animation</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 隐藏动画控件</span><br>  <span class="hljs-attr">baseLayerPicker</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 隐藏图层选择控件</span><br>  <span class="hljs-attr">fullscreenButton</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 隐藏全屏按钮</span><br>  <span class="hljs-attr">vrButton</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 隐藏VR按钮，默认false</span><br>  <span class="hljs-attr">geocoder</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 隐藏地名查找控件</span><br>  <span class="hljs-attr">homeButton</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 隐藏Home按钮</span><br>  <span class="hljs-attr">infoBox</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 隐藏点击要素之后显示的信息窗口</span><br>  <span class="hljs-attr">sceneModePicker</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 隐藏场景模式选择控件</span><br>  <span class="hljs-attr">selectionIndicator</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 显示实体对象选择框，默认true</span><br>  <span class="hljs-attr">timeline</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 隐藏时间线控件</span><br>  <span class="hljs-attr">navigationHelpButton</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 隐藏帮助按钮</span><br>  <span class="hljs-attr">scene3DOnly</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 每个几何实例将只在3D中呈现，以节省GPU内存</span><br>  <span class="hljs-attr">shouldAnimate</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 开启动画自动播放</span><br>  <span class="hljs-attr">sceneMode</span>: <span class="hljs-number">3</span>, <span class="hljs-comment">// 初始场景模式 1：2D 2：2D循环 3：3D，默认3</span><br>  <span class="hljs-attr">requestRenderMode</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 减少Cesium渲染新帧总时间并减少Cesium在应用程序中总体CPU使用率</span><br>  <span class="hljs-comment">// 如场景中的元素没有随仿真时间变化，请考虑将设置maximumRenderTimeChange为较高的值，例如Infinity</span><br>  <span class="hljs-attr">maximumRenderTimeChange</span>: <span class="hljs-literal">Infinity</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>我们使用上面 <code>options</code> 配置，即可把页面上的控件全部隐藏掉，如下图所示</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/48991-Xnip2020-08-30_18-33-57.jpg"></p><p>可以看到，虽然控件已经没有了，但是屏幕下方还有 <code>Cesium</code> 的 <code>logo</code> 信息，我们需要让它也不显示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 隐藏下方Cesium logo</span><br>viewer.cesiumWidget.creditContainer.style.display = <span class="hljs-string">&quot;none&quot;</span><br></code></pre></td></tr></table></figure><p>如上所示，只需再来一行额外的配置隐藏 <code>logo</code> 信息，即可获得一个干净的地球实例，最终效果图如下</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/Xnip2020-08-30_18-40-24.jpeg"></p><h3 id="加载影像"><a href="#加载影像" class="headerlink" title="加载影像"></a>加载影像</h3><p><code>Cesium</code> 支持多种服务来源的高精度影像（地图）数据的加载和渲染，图层支持排序和透明混合，每个图层的亮度（brightness），对比度（ contrast），灰度（gamma），色调（hue），饱和度（saturation）都是可以动态修改的</p><p>这里我们忽略细节，先简单介绍下影像相关的几个类，然后直接写代码去添加一些不同的常用影像图层</p><p><strong>PS：Cesium是一个构造函数，在这个构造函数上又有无数个静态属性，它们也是不同作用的构造函数，按照OOP的方式理解，Cesium是一个父类，而它又有很多子类用来做不同的事情</strong> </p><h4 id="Cesium-ImageryProvider类"><a href="#Cesium-ImageryProvider类" class="headerlink" title="Cesium.ImageryProvider类"></a>Cesium.ImageryProvider类</h4><p>说到影像这块儿，首先，我们要了解一下 <code>imageryProvider</code> 这个类，<code>Imagery</code> 可以翻译为图像、影像，这里就统一称之为影像</p><p><code>ImageryProvider</code> 类及其子类封装了加载各种影像图层的方法，其中 <code>Cesium.ImageryProvider</code> 类是抽象类、基类或者可将其理解为接口，它不能被直接实例化</p><p>可以将 <code>ImageryProvider</code> 看作是影像图层的数据源，我们想使用哪种影像图层数据或服务就用对应的 <code>ImageryProvider</code> 类型去加载即可</p><p><code>ImageryProvider</code> 类包含的类型</p><ul><li>ArcGisMapServerImageryProvider<ul><li>ArcGIS Online和Server的相关服务</li></ul></li><li>BinaMapsImageryProvider<ul><li>Bing地图影像，可以指定mapStyle，详见BingMapsStyle类</li></ul></li><li>GoogleEarthEnterpriselmageryProvider<ul><li>企业级服务</li></ul></li><li>GridImageryProvider<ul><li>渲染每一个瓦片内部的格网，了解每个瓦片的精细度</li></ul></li><li>IonImageryProvider<ul><li>Cesium ion REST API提供的影像服务</li></ul></li><li>MapboxImageryProvider<ul><li>Mapbox影像服务，根据 mapId 指定地图风格</li></ul></li><li>MapboxStyleImageryProvider<ul><li>Mapbox影像服务，根据 styleId 指定地图风格</li></ul></li><li>createOpenStreetMapImageryProvider<ul><li>OpenStreetMap提供的影像服务</li></ul></li><li>SingleTilelmageryProvider<ul><li>单张图片的影像服务，适合离线数据或对影像数据要求并不高的场景下</li></ul></li><li>TileCoordinatesImageryProvider<ul><li>渲染每一个瓦片的围，方便调试</li></ul></li><li>TileMapServicelmageryProvider<ul><li>根据MapTiler规范，可自己下载瓦片，发布服务，类似ArcGIS影像服务的过程</li></ul></li><li>UrlTemplateImageryProvider<ul><li>指定url的format模版，方便用户实现自己的Provider，比如国内的高德，腾讯等影像服务，url都是一个固定的规范，都可以通过该Provider轻松实现。而OSM也是通过该类实现的</li></ul></li><li>WebMapServiceImageryProvider<ul><li>符合WMS规范的影像服务都可以通过该类封装，指定具体参数实现</li></ul></li><li>WebMapTileServicelmageryProvider<ul><li>服务WMTS1.0.0规范的影像服务，都可以通过该类实现，比如国内的天地图</li></ul></li></ul><h4 id="Cesium-ImageryLayer类"><a href="#Cesium-ImageryLayer类" class="headerlink" title="Cesium.ImageryLayer类"></a>Cesium.ImageryLayer类</h4><p>要知道，一份 <code>GIS</code> 数据会被组织成图层符号化并渲染，数据相当于内在血液、内脏，信息量丰富，而图层相当于外在皮毛、衣服，用于呈现给外界</p><p><code>Cesium</code> 同样将数据源组织成图层符号化并渲染，<code>Cesium.ImageryLayer</code> 类就用于表示 <code>Cesium</code> 中的影像图层，它就相当于皮毛、衣服，将数据源包裹，它需要数据源为其提供内在丰富的地理空间信息和属性信息</p><h4 id="Cesium-ImageryLayerCollection类"><a href="#Cesium-ImageryLayerCollection类" class="headerlink" title="Cesium.ImageryLayerCollection类"></a>Cesium.ImageryLayerCollection类</h4><p><code>Cesium.ImageryLayerCollection</code> 类是 <code>ImageryLayer</code> 实例的容器，它可以装载、放置多个 <code>ImageryLayer</code> 实例，而且它内部放置的 <code>ImageryLayer</code> 实例是有序的</p><p><code>Cesium.Viewer</code> 类对象中包含的 <code>imageryLayers</code> 属性就是 <code>ImageryLayerCollection</code> 类的实例，它包含了当前 <code>Cesium</code> 应用程序所有的 <code>ImageryLayer</code> 类对象，即当前地球上加载的所有影像图层</p><p>知道了影像图层基础的体系结构，那么影像加载就简单了，上面我们也可以看到 <code>ImageryProvider</code> 类种类非常多，列举出来是为了给大家展示下它可以加载什么影像，但是一一演示不现实，所以接下来我们就来看几个常见影像加载</p><h4 id="加载影像示例"><a href="#加载影像示例" class="headerlink" title="加载影像示例"></a>加载影像示例</h4><h5 id="加载天地图影像"><a href="#加载天地图影像" class="headerlink" title="加载天地图影像"></a>加载天地图影像</h5><p>按照上述所说，首先我们要加载影像图层的数据源，Cesium地球默认加载的是 <code>bing</code> 地图影像，所以我们要先从容器中删除这个默认影像</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">viewer.imageryLayers.remove(viewer.imageryLayers.get(<span class="hljs-number">0</span>))<br></code></pre></td></tr></table></figure><p>然后，我们加载影像图层的数据源</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> tianditu = <span class="hljs-keyword">new</span> Cesium.WebMapTileServiceImageryProvider(&#123;<br>  <span class="hljs-attr">url</span>:<span class="hljs-string">&quot;http://t0.tianditu.com/img_w/wmts?service=wmts&amp;request=GetTile&amp;version=1.0.0&amp;LAYER=img&amp;tileMatrixSet=w&amp;TileMatrix=&#123;TileMatrix&#125;&amp;TileRow=&#123;TileRow&#125;&amp;TileCol=&#123;TileCol&#125;&amp;style=default&amp;format=tiles&amp;tk=ebf64362215c081f8317203220f133eb&quot;</span>,<br>  <span class="hljs-attr">layer</span>: <span class="hljs-string">&quot;tdtBasicLayer&quot;</span>,<br>  <span class="hljs-attr">style</span>: <span class="hljs-string">&quot;default&quot;</span>,<br>  <span class="hljs-attr">format</span>: <span class="hljs-string">&quot;image/jpeg&quot;</span>,<br>  <span class="hljs-attr">tileMatrixSetID</span>: <span class="hljs-string">&quot;GoogleMapsCompatible&quot;</span>,<br>  <span class="hljs-attr">show</span>: <span class="hljs-literal">false</span>,<br>&#125;)<br></code></pre></td></tr></table></figure><p><code>url</code> 字段中的 <code>tk</code> 为天地图服务token，去天地图官网注册申请一个即可</p><p>随后，我们将数据源添加至 <code>ImageryLayer</code> 类容器进行符号化并渲染即可</p><p>将数据源添加至 <code>ImageryLayer</code> 类容器进行符号化并渲染有两种方法，第一种是在初始化 <code>viewer</code> 实例时的 <code>options</code> 配置中，你可以直接在 <code>options</code> 对象的 <code>imageryProvider</code> 属性中放置数据源即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> Cesium.Viewer(<span class="hljs-string">&quot;cesiumContainer&quot;</span>,&#123;<br>  <span class="hljs-attr">imageryProvider</span>: tianditu<br>&#125;)<br></code></pre></td></tr></table></figure><p>第二种方法，使用 <code>viewer</code> 实例中 <code>imageryLayers</code> 属性的 <code>addImageryProvider</code> 方法来添加即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> imagery = viewer.imageryLayers.addImageryProvider(tianditu)<br></code></pre></td></tr></table></figure><p>天地图影像预览如下</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/tianditu.jpeg"></p><h5 id="加载谷歌影像"><a href="#加载谷歌影像" class="headerlink" title="加载谷歌影像"></a>加载谷歌影像</h5><p>上面步骤已经知悉，我们就不一一叙说了，下面直接看代码就好</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">viewer.imageryLayers.remove(viewer.imageryLayers.get(<span class="hljs-number">0</span>))<br><span class="hljs-keyword">let</span> imagery = viewer.imageryLayers.addImageryProvider(<br>  <span class="hljs-keyword">new</span> Cesium.UrlTemplateImageryProvider(&#123;<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">&quot;http://mt1.google.cn/vt/lyrs=s&amp;hl=zh-CN&amp;x=&#123;x&#125;&amp;y=&#123;y&#125;&amp;z=&#123;z&#125;&amp;s=Gali&quot;</span>,<br>    <span class="hljs-attr">baseLayerPicker</span> : <span class="hljs-literal">false</span><br>  &#125;)<br>)<br></code></pre></td></tr></table></figure><p>谷歌影像预览如下</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/guge.jpeg"></p><h5 id="加载ArcGIS影像"><a href="#加载ArcGIS影像" class="headerlink" title="加载ArcGIS影像"></a>加载ArcGIS影像</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">viewer.imageryLayers.remove(viewer.imageryLayers.get(<span class="hljs-number">0</span>))<br><span class="hljs-keyword">let</span> imagery = viewer.imageryLayers.addImageryProvider(<br>  <span class="hljs-keyword">new</span> Cesium.ArcGisMapServerImageryProvider(&#123;<br>    <span class="hljs-attr">url</span>:<span class="hljs-string">&#x27;https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer&#x27;</span>,<br>    <span class="hljs-attr">baseLayerPicker</span> : <span class="hljs-literal">false</span><br>  &#125;)<br>)<br></code></pre></td></tr></table></figure><p>ArcGIS影像预览如下</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/arcgis.jpeg"></p><h5 id="加载高德影像"><a href="#加载高德影像" class="headerlink" title="加载高德影像"></a>加载高德影像</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">viewer.imageryLayers.remove(viewer.imageryLayers.get(<span class="hljs-number">0</span>))<br><span class="hljs-keyword">let</span> imagery = viewer.imageryLayers.addImageryProvider(<br>  <span class="hljs-keyword">new</span> Cesium.UrlTemplateImageryProvider(&#123;<br>    <span class="hljs-attr">maximumLevel</span>:<span class="hljs-number">18</span>,<span class="hljs-comment">//最大缩放级别</span><br>    <span class="hljs-attr">url</span> : <span class="hljs-string">&#x27;https://webst02.is.autonavi.com/appmaptile?style=6&amp;x=&#123;x&#125;&amp;y=&#123;y&#125;&amp;z=&#123;z&#125;&#x27;</span>,<br>    <span class="hljs-attr">style</span>: <span class="hljs-string">&quot;default&quot;</span>,<br>    <span class="hljs-attr">format</span>: <span class="hljs-string">&quot;image/png&quot;</span>,<br>    <span class="hljs-attr">tileMatrixSetID</span>: <span class="hljs-string">&quot;GoogleMapsCompatible&quot;</span><br>  &#125;)<br>)<br></code></pre></td></tr></table></figure><p>高德影像预览如下</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/gaode.jpeg"></p><h5 id="加载天地图标注"><a href="#加载天地图标注" class="headerlink" title="加载天地图标注"></a>加载天地图标注</h5><p>上述影像的加载，可以看到，地图上是没有标注的，我们需要额外加载标柱，同样的，它也是图层</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> label = viewer.imageryLayers.addImageryProvider(<br>  <span class="hljs-keyword">new</span> Cesium.WebMapTileServiceImageryProvider(&#123;<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">&quot;http://t0.tianditu.com/cia_w/wmts?service=wmts&amp;request=GetTile&amp;version=1.0.0&amp;LAYER=cia&amp;tileMatrixSet=w&amp;TileMatrix=&#123;TileMatrix&#125;&amp;TileRow=&#123;TileRow&#125;&amp;TileCol=&#123;TileCol&#125;&amp;style=default.jpg&quot;</span>+<span class="hljs-string">&quot;&amp;tk=&quot;</span>+<span class="hljs-string">&quot;19b72f6cde5c8b49cf21ea2bb4c5b21e&quot;</span>,<br>    <span class="hljs-attr">layer</span>: <span class="hljs-string">&quot;tdtAnnoLayer&quot;</span>,<br>    <span class="hljs-attr">style</span>: <span class="hljs-string">&quot;default&quot;</span>,<br>    <span class="hljs-attr">maximumLevel</span>: <span class="hljs-number">18</span>, <span class="hljs-comment">//天地图的最大缩放级别</span><br>    <span class="hljs-attr">format</span>: <span class="hljs-string">&quot;image/jpeg&quot;</span>,<br>    <span class="hljs-attr">tileMatrixSetID</span>: <span class="hljs-string">&quot;GoogleMapsCompatible&quot;</span>,<br>    <span class="hljs-attr">show</span>: <span class="hljs-literal">false</span>,<br>  &#125;)<br>)<br></code></pre></td></tr></table></figure><p>同样的，和天地图影像一样，不要忘了替换 <code>tk</code> 哦</p><p>天地图标注预览如下</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/tianditubiaozhu.jpeg"></p><h5 id="影像亮度调整"><a href="#影像亮度调整" class="headerlink" title="影像亮度调整"></a>影像亮度调整</h5><p>我们加载影像拿到影像实例 <code>imagery</code> 后，可以通过其 <code>brightness</code> 属性调节亮度，取值 <code>0～1</code> ，默认为1</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">imagery.brightness = <span class="hljs-number">0.9</span><br></code></pre></td></tr></table></figure><h4 id="影像小结"><a href="#影像小结" class="headerlink" title="影像小结"></a>影像小结</h4><p>上文中我们列举的 <code>ImageryProvider</code> 类支持的子类非常多，而上面的示例中</p><p>在加载高德影像服务时，我们使用的指定 <code>url</code> 的 <code>format</code> 模版来实现自己的 <code>Provider</code>，所以使用了 <code>UrlTemplateImageryProvider</code> 类来加载数据源</p><p>在加载 <code>ArcGIS</code> 影像用到了 <code>ArcGIS Server</code> 的相关服务所以使用了 <code>ArcGisMapServerImageryProvider</code> 类来加载数据源</p><p>在加载标柱影像时，因为我们加载的是一个Web Map Tile Service也就是 <code>WMTS</code> 服务，所以我们使用的是 <code>WebMapTileServiceImageryProvider</code> 类</p><p>这几个简单的小例子是为了告诉我们我们使用什么样的数据源，就使用对应的 <code>ImageryProvider</code> 来加载即可</p><p>影像加载这块由于本文重点描述的是初始化，所以只有怎样加载，并没有对应的数据服务相关知识，Get一个新的技能，首先是用起来，下一个阶段是扣一些细节然后用熟它，再接着是扩展，最后是学其原理，后续通过一些使用再来慢慢扩展概念性的东西</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>回顾本文，Cesium实例初始化，围绕着加载一个干净的三维地球实例展开，文中我们主要介绍了 Cesium 控件的现实隐藏以及影像的加载，一般来说为了界面美化，我们都是自己写控件或者直接隐藏掉，当然如果 Cesium 的初始化控件中恰巧有你需要的，但是又觉得默认的空间样式不太好看，其实我们是可以自己改样式的，因为控件只是普通元素节点，完全可以直接在控制台中选中元素，通过类名来修改对应控件的样式来达到自己想要的效果，相信这对于一个前端来说不是什么难事</p><p>到此其实就只做了加载出来地球和加载下影像，对于 Cesium 来说它仅仅一个开始，更多好玩的还在后面，其实不止是做Cesium开发的人群，做前端的同学学一学这些还是有些用处的，可以为你的页面或项目增色不少，后续内容请看暂定目录</p><ul><li><p><a href="https://juejin.im/post/6854573221191090189">让GIS三维可视化变得简单-初识Cesium</a> </p></li><li><p><a href="https://juejin.im/post/6854899697661394951">让GIS三维可视化变得简单-Vue项目中集成Cesium</a> </p></li><li><p><a href="">让GIS三维可视化变得简单-Cesium地球初始化</a> </p></li><li><p>暂定 - 让GIS三维可视化变得简单-Cesium坐标转换</p></li><li><p>暂定 - 让GIS三维可视化变得简单-Cesium球体自转</p></li><li><p>暂定 - 让GIS三维可视化变得简单-Cesium实体Entity及事件</p></li><li><p>暂定 - 让GIS三维可视化变得简单-Cesium模型数据之3DTiles</p></li><li><p>暂定 - 让GIS三维可视化变得简单-Cesium模型数据之gltf</p></li><li><p>暂定 - 让GIS三维可视化变得简单-Cesium模型数据之geojson</p></li><li><p>暂定 - 让GIS三维可视化变得简单-Cesium模型数据之czml</p></li><li><p>暂定 - 让GIS三维可视化变得简单-Cesium流动线绘制</p></li><li><p>暂定 - 让GIS三维可视化变得简单-Cesium气泡弹窗</p></li><li><p>暂定 - 让GIS三维可视化变得简单-Cesium粒子系统(火灾、雪花、喷水)</p></li><li><p>暂定 - 让GIS三维可视化变得简单-Cesium鹰眼图</p></li><li><p>暂定 - 让GIS三维可视化变得简单-Cesium结合Echarts</p></li></ul><p>Cesium国内教程很少，文档也是英文的，不太好入手，所以此系列只是简单入门以及一些效果制作（说白了就是介绍一些简单使用和一些好玩的例子），每一篇介绍一个点，挺难涉及到Cesium核心原理，因为我也在学习中，看后期个人学习情况，我是觉得什么好玩就想学。。。</p><p>没有专业的 GIS 基础知识积累真的好难，此系列不定期更新，暂时先排这么多，不定期插入，不定期更新，敬请期待</p><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>原创不易，看完点赞、养成习惯，此文收录在 GitHub，更多精彩请看 👉 <a href="https://github.com/isboyjc/blog/issues">isboyjc/blog/issues</a> </p><p>如有错误请指出，互相学习，先行谢过，一个前端的 <code>Cesium</code> 学习过程的积累分享，自知深度不够，不喜勿喷</p>]]></content>
    
    
    <categories>
      
      <category>Cesium系列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cesium</tag>
      
      <tag>数据可视化</tag>
      
      <tag>WebGIS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>让GIS三维可视化变得简单-Vue项目中集成Cesium</title>
    <link href="/blog/2020/07/29/cesium/%E8%AE%A9GIS%E4%B8%89%E7%BB%B4%E5%8F%AF%E8%A7%86%E5%8C%96%E5%8F%98%E5%BE%97%E7%AE%80%E5%8D%95-Vue%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%9B%86%E6%88%90Cesium/"/>
    <url>/blog/2020/07/29/cesium/%E8%AE%A9GIS%E4%B8%89%E7%BB%B4%E5%8F%AF%E8%A7%86%E5%8C%96%E5%8F%98%E5%BE%97%E7%AE%80%E5%8D%95-Vue%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%9B%86%E6%88%90Cesium/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>市面上的前端框架中，Vue+Cesium 可谓是最佳搭档，一般做 Cesium B 端产品的公司都会使用 Vue，所以后续内容都将基于 Vue</p><p>通常情况下，我们要在 Vue 中使用 Cesium，首先要安装 Cesium，然后要在 vue-cli 的 webpack 配置很多东西，对一些有经验的人来说只不过麻烦些，但是对 Cesium 的初学者来说会很痛苦，因为没有使用过，也不知到要怎么配置，只能搜索网上的教程，一步一步踩坑</p><p>其实不管是有经验或是初学者，每次写项目重复配置这些东西都很麻烦</p><p><code>vue-cli-plugin-cesium</code> 就是为了解决这个问题</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><code>vue-cli-plugin-cesium</code> 是一款针对 Cesium 的 VueCLI 扩展插件，使用它将会让我们在 VueCLI 中零配置使用 Cesium，基于 VueCLI3.0+ </p><p>其实就是我开始做 Cesium 的时候，觉得每次配置太麻烦，就写了个插件免配置从而节约开发时间，后来就发到几个 Cesium 开发群里给大家体验了一波，效果还不错</p><p>它会在我们已经创建好的 VueCLI 项目中做基于 Cesium 的扩展，截止目前它的功能也可以说它解决的问题如下</p><ul><li><p>自动安装 Cesium 并追加至 <code>package.json</code> 依赖项(可自选版本)</p></li><li><p>自动扩展 VueCLI 中 Cesium 相关的 webpack 配置</p><ul><li>添加一个 <code>cesium</code> 别名，以便我们在项目中轻松的引入 Cesium 文件资源</li><li>使 Cesium 对象实例可在每个 Vue 模块中使用而无须 import 引入</li><li>使 webpack 可正常打包 Cesium</li><li>允许 webpack 友好地在 Cesium 中使用 require，解决 require 引入警告</li><li>开发环境生成 sourcemap，生产环境取消 sourcemap</li><li>生产环境抽取公共模块执行压缩</li><li>生产环境 loader 切换到优化模式</li></ul></li><li><p>自动在全局 main.js 中引入<code>Widgets.css</code>，可选</p></li><li><p>自动在 <code>components/</code> 文件夹下生成示例文件，可选</p></li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><code>vue-cli-plugin-cesium</code> 是基于 VueCLI 的扩展插件，所以在使用前要先使用 VueCLI 创建一个 Vue 项目</p><p>如果您不了解 VueCLI 的使用，请移步 <a href="https://cli.vuejs.org/zh/guide/">VueCLI-官网</a></p><p>当前插件只支持 <code>VueCLI3.0+</code> 版本哦</p><p>创建好一个 Vue 项目后就可以按照以下步骤使用该插件了，同所有 VueCLI 插件一样，它有两种使用方式，推荐使用方式一</p><h3 id="使用方式一"><a href="#使用方式一" class="headerlink" title="使用方式一"></a>使用方式一</h3><p>推荐使用 <code>vue add</code> 这种方式安装，一步到位，简单便捷</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">vue add vue-cli-plugin-cesium<br><br><span class="hljs-comment">// 非全局安装的vue-cli可以</span><br>npx vue add vue-cli-plugin-cesium<br></code></pre></td></tr></table></figure><h3 id="使用方式二"><a href="#使用方式二" class="headerlink" title="使用方式二"></a>使用方式二</h3><p>首先安装 <code>vue-cli-plugin-cesium</code> 插件，推荐使用 yarn 安装，因为它更简洁</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// npm</span><br>npm install --save-dev vue-cli-plugin-cesium<br><br><span class="hljs-comment">// yarn</span><br>yarn add vue-cli-plugin-cesium<br></code></pre></td></tr></table></figure><p>安装完成后我们要使用 <code>vue invoke</code> 来初始化这个插件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">vue invoke vue-cli-plugin-cesium<br><br><span class="hljs-comment">// 非全局安装的vue-cli可以</span><br>npx vue invoke vue-cli-plugin-cesium<br></code></pre></td></tr></table></figure><h3 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h3><p>在 <code>vue invoke</code> 或 <code>vue add</code> 的过程中会有三个询问</p><p><strong>询问一</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">Please choose a version of &#x27;cesium&#x27; from this list<br>请在列表中选择 cesium 的版本<br></code></pre></td></tr></table></figure><p>在此选择想使用的 <code>Cesium</code> 版本</p><p><strong>询问二</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs txt">Whether to import styles globally. <br>This operation will automatically import widgets.css in main.js<br>是否全局引入样式,该操作将自动在main.js引入widgets.css？<br></code></pre></td></tr></table></figure><p>此项默认为 yes，该操作将自动在 main.js 引入 widgets.css，即全局引入 Cesium 的 css 样式</p><p>如果此项设置为 no，那么开发时我们要手动引入<code>widgets.css</code>样式文件，引入命令如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">import &quot;cesium/Widgets/widgets.css&quot;<br></code></pre></td></tr></table></figure><p><strong>询问三</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">Whether to add sample components to the project components directory<br>是否添加示例组件到项目components目录?<br></code></pre></td></tr></table></figure><p>此选项默认为 yes，该操作会自动在 <code>src/components</code> 文件夹下生成 <code>CesiumExample</code> 文件夹，此文件夹中包含一些 Cesium 的使用示例供参考</p><p>如果此项设置为 no，则不生成示例文件</p><p>生成的示例中每个文件为一个模块，可直接模块引入至项目中查看，欢迎大家PR示例模块</p><h3 id="GUI-安装"><a href="#GUI-安装" class="headerlink" title="GUI 安装"></a>GUI 安装</h3><p>如果我们使用 <code>vue ui</code> 创建项目，也可以直接在项目创建后的插件选项里搜索 <code>vue-cli-plugin-cesium</code> 并安装</p><p>如下所示：</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/gui005.png"></p><p>选中插件点击安装</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/gui002.png"></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>开发时如下，直接在模块中使用 Cesium 对象即可</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/code01.png"></p><p>查看示例组件，模块引入即可，如下</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/code02.png"></p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><p>当你顺顺利利安装好了插件后开始开发，使用 Cesium 对象时，可能会遇到下面这种错误</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">Error</span>：Cesium is no-undef<br></code></pre></td></tr></table></figure><p>前端小伙伴都应该知道，这好像是 Eslint 语法错误，没错，这是因为插件内部使用了 Webpack 的内置模块 <code>ProvidePlugin</code> 来做到使用 Cesium 对象时将不再需要 <code>import</code> 或 <code>require</code> 引入，而一般我们在使用 VueCLI 创建项目时会默认带上 Eslint，Eslint 语法检验会认为 Cesium 是一个未声明的变量，于是抛出了错误</p><p><strong>解决办法一</strong> </p><p><code>package.json</code> 中配置 Eslint 规则允许 <code>no-undef</code> ，如下所示，在 <code>package.json</code> 中 <code>eslintConfig</code> 字段下的 <code>rules</code> 配置 <code>&quot;no-undef&quot;: 0</code> ，在不关掉 Eslint 的情况下单独配置允许未声明的变量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-string">&quot;dependencies&quot;</span>: &#123;&#125;,<br>  <span class="hljs-string">&quot;devDependencies&quot;</span>: &#123;&#125;,<br>  <span class="hljs-string">&quot;eslintConfig&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;root&quot;</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-string">&quot;env&quot;</span>: &#123;<br>      <span class="hljs-string">&quot;node&quot;</span>: <span class="hljs-literal">true</span><br>    &#125;,<br>    <span class="hljs-string">&quot;extends&quot;</span>: [<br>      <span class="hljs-string">&quot;plugin:vue/essential&quot;</span>,<br>      <span class="hljs-string">&quot;eslint:recommended&quot;</span><br>    ],<br>    <span class="hljs-string">&quot;parserOptions&quot;</span>: &#123;<br>      <span class="hljs-string">&quot;parser&quot;</span>: <span class="hljs-string">&quot;babel-eslint&quot;</span><br>    &#125;,<br>    <span class="hljs-string">&quot;rules&quot;</span>: &#123;<br>      <span class="hljs-string">&quot;no-undef&quot;</span>: <span class="hljs-number">0</span><br>    &#125;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>解决办法二</strong> </p><p>我们可以通过在 <code>package.json</code> 中直接删除 <code>eslintConfig</code> 对象来直接关掉 Eslint</p><p>也可以在 <code>vue.config.js</code> 中配置关掉 Eslint，如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-attr">lintOnSave</span>: <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><p>修改之后重启服务即可，推荐使用第一种办法，Eslint 语法校验是一个极好的约束开发的工具，可以让我们同一个团队内的语法风格统一，最好还是不要关掉</p><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>安装完成后，就可以在 vue 项目中任意模块中使用 Cesium 了，你可以在每个 Vue 模块中直接使用 Cesium 对象实例而无须 import 引入，如果你想引入 cesium 包下的文件，我们为 Cesium 包的目录设置了别名，就叫 <code>cesium</code>，所以在引入 <code>Widgets.css</code> 时引入路径为 <code>cesium/Widgets/widgets.css</code> ，如果对您有所帮助，那么这将是我的荣幸</p><p>目前使用 VueCLI2.0 的应该很少了，当然如果你使用的脚手架 <code>&gt; VueCLI3.0</code> ，那么就不能使用这个插件了，不过不用担心，VueCLI2.0的配置也是有的，只不过需要你自己手动配置了，详情可以看 👉 <a href="https://mp.weixin.qq.com/s/DLnMMQqb8meMRXyKiUqUqA">VueCLI2.0集成Cesium</a> </p><p>后期也会慢慢完善此插件，并不停迭代，也欢迎大家提出建议，欢迎 PR</p><p>插件地址 👉 <a href="https://github.com/isboyjc/vue-cli-plugin-cesium">isboyjc/vue-cli-plugin-cesium</a> </p><p>文章收录在 GitHub，更多精彩请看 👉 <a href="https://github.com/isboyjc/blog/issues">isboyjc/blog/issues</a> </p><p>是前端，又不只是前端，所以不正经，认真分享干货，公众号「不正经的前端」，欢迎关注</p>]]></content>
    
    
    <categories>
      
      <category>Cesium系列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cesium</tag>
      
      <tag>数据可视化</tag>
      
      <tag>WebGIS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>让GIS三维可视化变得简单-初识Cesium</title>
    <link href="/blog/2020/07/27/cesium/%E8%AE%A9GIS%E4%B8%89%E7%BB%B4%E5%8F%AF%E8%A7%86%E5%8C%96%E5%8F%98%E5%BE%97%E7%AE%80%E5%8D%95-%E5%88%9D%E8%AF%86Cesium/"/>
    <url>/blog/2020/07/27/cesium/%E8%AE%A9GIS%E4%B8%89%E7%BB%B4%E5%8F%AF%E8%A7%86%E5%8C%96%E5%8F%98%E5%BE%97%E7%AE%80%E5%8D%95-%E5%88%9D%E8%AF%86Cesium/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20200715235121472.png"></p><p>从去年开始无脑接触 <code>Cesium</code> 三维 GIS 可视化，入坑之后一直到到现在，其实已经写了多个项目了，中间也遇到了很多坑点，很早就想分享其中所获了，只是觉得不太专业而且没有太多时间，拖到现在，从开始接触 <code>Cesium</code> ，加了一个QQ交流群，从刚开始的 200 人，到现在的 3000 人，好像使用 Cesium 做可视化方向的人越来越多了，并且其中很多人都是如我一样，从前端半路入坑</p><p>记得好像是公众号「Cesium中文网」曾发过一篇文章名叫「Cesium只剩可视化了吗」个人觉得写的很棒，虽然 Cesium 不止是可以做可视化这么简单，但是目前大部分选择投入其中的人是奔着可视化这个方向的，这点从 300 到 3000 足以证明</p><p>个人写作习惯篇幅很长，文章产出总是很慢，之所以还想要写这个系列的文章，大概有三点</p><ul><li>Cesium 毕竟是一个世界级 <code>JavaScript</code> 开源产品，做 CS 还好，但是做 BS，特别是可视化产品是需要扎实的前端基础的，相比较下专业的 GIS 对前端一些框架了解好像不太多，并不能很好的把自己丰富的 GIS 知识或者说一些很强大的功能在前端炫酷的展现出来，毕竟功能再强大，不经过雕琢和装饰总归还是不能被人推崇的</li><li>近两年前端同学半路入坑 Cesium 的人太多了，但是由于没有扎实的 GIS 基础，涉及深入一点的 GIS 核心的效果实现并不容易，一路上的磕磕绊绊实在是太多了，这个是亲身经历，且十分惨痛</li><li>关于 Cesium，一直是自己在摸索，项目也写不少了，但是肯定有很多地方在更为专业的人看来是闹着玩一样，所以水水文章看看进自己脑子的知识有哪些是炸弹，回顾一遍排排雷，查漏补缺</li></ul><p>其实我个人对 CS 方面完全没有经验，BS 做可视化有些项目经验，但是说实话，只懂皮毛，不过在前进的道路上爬了太多的坑，所以可以与大家分享些爬坑经验，也充实下自己，涉入 GIS 不会很深，不过一般的还是可以的，算带大家入入门吧，也希望可以和大家一起查漏补缺，正所谓山中无老虎，猴子称大王，没错，我就是那只猴子，谁让现在Cesium相关的技术帖辣么少呢</p><p>写的帖子目前想法是除了入门之外会更倾向于各种好玩炫酷的效果制作，所以它也会更倾向于实战系列，你也可以把它当作入门级教程，这个系列我尽量每文简短些，控制在5000字以内，让大家看着舒服 😄</p><p><strong>PS：</strong> </p><ul><li><p><strong>CS</strong> 指 <code>Client/Server</code>，客户端/服务器模式，桌面级应用，响应速度快，安全性强，个性化能力强，响应数据较快，兼容性差，不跨平台，开发成本高</p></li><li><p><strong>BS</strong> 指 <code>Browser/Server</code>，浏览器/服务器模式，Web应用，可以实现跨平台，客户端零维护，共享性强，但是个性化能力稍低，响应速度稍慢</p></li></ul><h2 id="得瑟一下"><a href="#得瑟一下" class="headerlink" title="得瑟一下"></a>得瑟一下</h2><p>看到这篇文章时，可能大家对 Cesium 有所了解，也可能一无所知，甚至不知道它能干什么，先给大家看一个我这边刚入坑时做的第一个基于 Cesium 的可视化产品，现在看其实挺一般的，不过当时刚做出来时确实是挺开心挺有成就感的，也让大家对 Cesium 加深下了解，当然这个项目中只是简单的运用了 Cesium，它远不止于此</p><ul><li><p><a href="http://villageapi.sdzhujialin.com/zjl_3d/index.html">线上预览</a>  电脑配置低的话还是查看GIF吧</p></li><li><p><a href="https://gitee.com/IsboyJC/PictureBed/raw/master/other/20190929_175200.2020-07-2723_56_55.gif">GIF预览</a>    压缩的比较厉害，高清预览视频可以到公众号「不正经的前端」查看</p></li></ul><p>那么接下来话不多说，赶紧来认识下 Cesium 吧</p><h2 id="Cesium简介"><a href="#Cesium简介" class="headerlink" title="Cesium简介"></a>Cesium简介</h2><h3 id="什么是Cesium"><a href="#什么是Cesium" class="headerlink" title="什么是Cesium"></a>什么是Cesium</h3><p>Cesium 是一款面向三维地球和地图的，世界级的 <code>JavaScript</code> 开源产品，它提供了基于 <code>JavaScript</code> 语言的开发包，方便用户快速搭建一款零插件的虚拟地球 Web 应用，并在性能，精度，渲染质量以及多平台，易用性上都有高质量的保证</p><p>Cesium是基于 <code>Apache2.0</code> 许可的开源程序，它可以免费的用于商业和非商业用途，它隶属于 AGI（Analytical Graphics Incorporation）公司，三位创始人曾在通用公司宇航部的供职工程师，提供 STK（System/Satellite Toolkit Kit）和 Cesium两款产品，该公司是航天分析软件的领导者，而 STK 则是该公司的旗舰产品，比如 <code>马航MH370</code> 搜救过程就采用了 STK 软件，经过多年来在时空数据的积累，AGI 公司逐渐掌握了大量 3D 可视化技术，也感受到各行各业对海量 3D 数据的强烈需求，因此于2011年创建了 CesiumJS 开源项目，围绕 Cesium 生态圈打造了一套安全可靠易扩展且平台独立的企业级解决方案</p><p>而 Chrome 也是在2011年2月份推出了支持 WebGL 的第一个版本，在这点上，Cesium算是第一个敢吃螃蟹的人，Cesium 原意是化学元素铯，铯是制造原子钟的关键元素，通过命名强调了 Cesium 产品专注于基于时空数据的实时可视化应用</p><p>至今，CesiumJS 的下载量超过 <code>1,000,000</code>，是一个为数百万用户提供了强大的应用程序</p><p>作为前端程序员，只是单纯做可视化，其实在我看来， Cesium 与 <code>Leaflet</code> 以及 <code>OpenLayer</code> 等没有本质的区别，只是Cesium支持三维场景等等，做的更漂亮</p><h3 id="Cesium可以做什么"><a href="#Cesium可以做什么" class="headerlink" title="Cesium可以做什么"></a>Cesium可以做什么</h3><p>支持全球级别的高精度的地形和影像服务</p><p>支持 <code>2D、2.5D、3D</code> 形式的地图展示，真正的二三维一体化</p><p>支持矢量、海量模型数据（倾斜，BIM，点云等）</p><p>支持基于时间轴的动态数据可视化展示</p><h3 id="Cesium的浏览器兼容性"><a href="#Cesium的浏览器兼容性" class="headerlink" title="Cesium的浏览器兼容性"></a>Cesium的浏览器兼容性</h3><p>学习和使用 Cesium 前，首先要检查一下你的浏览器是否支持 <code>WebGL</code>，目前，大多数平台和浏览器都支持WebGL，在这些环境下运行 Cesium 并没有太大的问题，但效果和性能是否能够满足不同的需求，就需要考虑很多细节和额外因素</p><p>大多数平台和浏览器都支持 <code>WebGL1.0</code> 标准，也就是 <code>OpenGL ES2.0</code> 规范，2017年年初，<code>Chrome</code> 新版本低调的支持 <code>WebGL2.0</code>，随着各硬件厂商 GPU 性能的提升和 <code>WebGL2.0</code> 规范的成熟，<code>WebGL</code> 技术会有更大的提升潜力，不过无论是 PC 还是移动端，<code>Chrome</code> 都是 <code>WebGL</code> 开发和应用的最佳平台，所以，如果没有特殊的硬性要求，建议大家使用 <code>Chrome</code> 学习和开发 Cesium</p><p>你可以在浏览器中访问 <a href="https://webglreport.com/">WebGL Report</a> 来查看你的浏览器支持情况</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20200715000329348.png"></p><p>如上图红框中显示，这个浏览器支持 <code>WebGL 1</code>，你也可以点击 <code>WebGL 2</code> 查看自己的浏览器支持情况</p><p>清单中除了显示了你的浏览器是否支持 <code>WebGL</code> 标准，还有很多，比如</p><ul><li>是否支持深度纹理</li><li>顶点着色器的最大属性数</li><li>是否支持ANGLE 扩展</li><li>等等</li></ul><h2 id="一个HelloWorld程序"><a href="#一个HelloWorld程序" class="headerlink" title="一个HelloWorld程序"></a>一个HelloWorld程序</h2><p>其实上面的都是废话，但是你又必须要知道，其实对我们写程序是没有一点帮助的，只是提供数据为了给大家了解下 Cesium 的强大</p><p>有的人可能认为学习 Cesium 之前应该学习学习 GIS 基础架构、坐标系、投影、存储类型等等等等，其实我觉得如果你有这些常识，那自然是极好的，但是如果没这些知识储备，在刚开始学习 Cesium 的时候，学习这些乱七八糟的，完全没必要</p><p>因为这些基础知识学起来很容易打磨积极性，还不如先写几个 demo 程序来的实在，毕竟总得先体会下它的魅力，就像你走在路上，你看到前面有个坑，那肯定会绕过去，但是如果坑上有些草，还有些漂亮的花，那就不一样了</p><p>SO，我们先搞个地球出来，后面哪里有需要再穿插说一些常识</p><h3 id="编译器选择"><a href="#编译器选择" class="headerlink" title="编译器选择"></a>编译器选择</h3><p>实力推荐 <code>VS Code</code> 一把梭，当然实在用不习惯其他编译器也都行，看个人习惯，实力强用记事本都没得关系</p><h3 id="下载Cesium包"><a href="#下载Cesium包" class="headerlink" title="下载Cesium包"></a>下载Cesium包</h3><p>首先，我们要下载 Cesium 包，官网下载即可，Cesium 每个月都会更新一个版本，一直在迭代，这点就足以证明它的活跃性以及未来，地址如下 👇</p><ul><li><a href="https://cesium.com/cesiumjs/">Cesium Download</a></li></ul><p>下载下来解压后你会发现有很多文件，如下图</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20200723003350308.png"></p><p>我们下载这个包里包括 Cesium API 源代码 Source 文件夹，以及编译后的 Build 文件夹，还有Demo、API文档、沙盒等等，这些都不用管</p><p>我们只需要 <code>Build</code> 文件夹下面的 <code>Cesium</code> 这个文件夹，它是编译后 Cesium 包的正式版本，开发的话只需要这个就完了</p><h3 id="初始化地球"><a href="#初始化地球" class="headerlink" title="初始化地球"></a>初始化地球</h3><p>首先，我们找地方新建一个目录，这里目录名为 <code>demo</code> ，我们把上面说的 Cesium 这个文件夹拖进来</p><p>接着，我们在 demo 目录下新建一个 <code>index.html</code> 文件，初始化一个地球，只需四步</p><p><strong>No.1</strong> 引入 <code>cesium.js</code>，该文件定义了 Cesium 对象，它包含了我们需要的一切</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./Cesium/Cesium.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>No.2</strong> 引入 <code>widgets.css</code>，为了能使用Cesium 各个可视化控件 </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@import</span> url(./Cesium/Widgets/widgets.css)<br></code></pre></td></tr></table></figure><p><strong>No.3</strong> 在 <code>HTML</code> 的 <code>body</code> 中我们创建一个 <code>div</code>，用来作为三维地球的容器</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;cesiumContainer&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>No.4</strong> 在 JS 中初始化 <code>CesiumViewer</code> 实例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> viewer = <span class="hljs-keyword">new</span> Cesium.Viewer(<span class="hljs-string">&#x27;cesiumContainer&#x27;</span>)<br></code></pre></td></tr></table></figure><p>完整代码如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./Cesium/Cesium.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"></span><br><span class="css">      <span class="hljs-keyword">@import</span> url(./Cesium/Widgets/widgets.css);</span><br><span class="css">      <span class="hljs-selector-tag">html</span>,<span class="hljs-selector-tag">body</span>,<span class="hljs-selector-id">#cesiumContainer</span> &#123;</span><br><span class="css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span><br><span class="css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;</span><br><span class="css">        <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;</span><br><span class="css">        <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;</span><br><span class="css">      &#125;</span><br><span class="css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;cesiumContainer&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">      <span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">        <span class="hljs-keyword">let</span> viewer = <span class="hljs-keyword">new</span> Cesium.Viewer(<span class="hljs-string">&quot;cesiumContainer&quot;</span>)</span><br><span class="javascript">      &#125;</span><br><span class="javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h3 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h3><p>平常我们写一个页面，浏览器打开 <code>html</code> 文件即可，在写 Cesium 程序的时候，不要本地双击浏览器运行，因为在实际工作中，它是需要运行在Web服务器上的</p><p>这里我们使用Node来搭建这个服务，首先你要在电脑装Node，这个不过多赘述，不了解自行百度安装即可</p><p>官网包括一般的教程里这个时候就要手写代码用 <code>express</code> 或者 <code>Koa</code> 简单的搭一个Web服务了，但是这也是没有必要的，这里我们只是写个 demo，没必要再去写后端代码什么的，太麻烦，我们装一个 <code>live-server</code> 就行了</p><p><code>live-server</code> 是一个具有实时加载功能的小型服务器，简单说，你装了它，直接在当前目录命令行运行命令这个服务就起来了</p><p>安装 <code>live-server</code> 命令如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">npm install -g live-server<br></code></pre></td></tr></table></figure><p>再次强调，这只是一个小 demo，一般来说正常项目开发中 <code>Vue+Cesium</code> 我觉得是最佳实践了，而使用 Vue 来开发的话  <code>Vue-CLI</code> 本身就是一个本地服务，我们如果要原生开发的话 <code>live-server</code> 就行了，虽然写个Web服务不难，但终归是浪费时间</p><p>当我们 Node 安装好了，也装上了 <code>live-server</code> 后，我们在终端  <code>cd</code> 到项目根目录下 ，执行下面命令</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">live-server<br></code></pre></td></tr></table></figure><p>默认启动的是8080端口，如下图</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20200723230404008.png"></p><p>紧接着，直接在浏览器输入 <code>http://127.0.0.1:8080</code> ，你的第一个 Cesium 程序就 👌 了</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/2020-07-27-cesiuminit-gif.gif"></p><p>如上所示，页面上就会呈现一个 3D 的地球了，是不是很简单，有没有勾起你入手的欲望呢？</p><p>这次就到这里，下次我们来说一说 Vue 里面使用 Cesium 开发以及一些注意事项，一步一步来，心急吃不了热豆腐，每篇文末会给大家列出我一些相关的学习地址</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>初识 Cesium 一定要知道的几个网站</p><ul><li><p><a href="https://cesium.com/docs/">Cesium 官方教程</a> Cesium出的官方教程，英文的，可以翻译着看看</p></li><li><p><a href="https://cesium.com/docs/cesiumjs-ref-doc/">Cesium API英文官方文档</a>  Cesium的API太多了，不过有遇到不知道API可以查一查，不过也是英文的</p></li><li><p><a href="http://cesium.xin/cesium/cn/Documentation1.62/">Cesium API中文文档</a> Cesium中文网翻译的API文档，不太全，不过初步肯定是够用的</p></li><li><p><a href="https://sandcastle.cesium.com/">Cesium Sandcastle 沙盒示例</a> Cesium官方的一些示例程序，没事可以多逛逛</p></li><li><p><a href="http://cesium.xin/">Cesium 中文网</a> Cesium中文网，里面有系列教程，部分是免费的，可以学习很多知识</p></li></ul><p>如果是刚接触Cesium，这些网站无论如何都要点进去看一看，先简单过一遍即可，后期会用上的</p><p>文章收录在 GitHub，更多精彩请看 <a href="https://github.com/isboyjc/blog/issues">isboyjc/blog/issues</a> </p><p>是前端，又不只是前端，所以不正经，认真分享干货，公众号「不正经的前端」，欢迎关注</p>]]></content>
    
    
    <categories>
      
      <category>Cesium系列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cesium</tag>
      
      <tag>数据可视化</tag>
      
      <tag>WebGIS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>努力、奋斗，写给自己、讲给你听</title>
    <link href="/blog/2020/07/26/other/%E5%8A%AA%E5%8A%9B%E3%80%81%E5%A5%8B%E6%96%97%EF%BC%8C%E5%86%99%E7%BB%99%E8%87%AA%E5%B7%B1%E3%80%81%E8%AE%B2%E7%BB%99%E4%BD%A0%E5%90%AC/"/>
    <url>/blog/2020/07/26/other/%E5%8A%AA%E5%8A%9B%E3%80%81%E5%A5%8B%E6%96%97%EF%BC%8C%E5%86%99%E7%BB%99%E8%87%AA%E5%B7%B1%E3%80%81%E8%AE%B2%E7%BB%99%E4%BD%A0%E5%90%AC/</url>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>好巧不巧又赶上了掘金征文，虽然是最后两天，还是凑一番热闹</p><p>日复一日的生活、日复一日的工作，时间久了，可能会有些厌恶，仿佛每天清晨起就在盼着黄昏来临，但每一天又是那样的漫长，有时候真的觉得度日如年四个字是那么中肯，所以现代社会才会有那么多的人想要放空自己、归于自然</p><p>日子虽然难熬，但不知不觉间无数个清晨和黄昏就过去了， 2020 年也已然过半，人生是很短暂也很漫长的，但很奇怪，没有人的内心里会认为在这段说长不长说短不短的人生中自己就是平庸的，相反，绝大多数的人在心中认为自己是生而不凡甚至不可或缺的，仿佛全世界都该为之驻足、为之瞩目，毕竟谁不希望自己是 SuperMan 呢</p><p>就像我们走在路上会不觉注意别人的眼神，生怕自己出糗而招人笑话、引人闲话一样，其实，我或者你并没有这么重要，就算是在大街上突然摔倒，也不会让人驻足，甚至他人都不会多看你一眼，这个世界多了你不多，少了你不少，所以做人，并不要把自己看的这么重要，会轻松许多，这算是前两天看「巴斯特·斯克鲁格斯的歌谣」带来的感悟，特此分享</p><h2 id="来碗鸡汤"><a href="#来碗鸡汤" class="headerlink" title="来碗鸡汤"></a>来碗鸡汤</h2><p>我们所有人都想在世间这片海中翻起朵哪怕小小的浪花，我亦是，但是说来惭愧，也很可惜，人海茫茫，我就是其中那一滴缺之无谓的水，平凡甚至平庸</p><p>是很平凡，一名前端，写博客时一般会用「isboyjc」这个ID，说到这个ID，也是年少轻狂时，现悔恨不已</p><p>是很平庸，没有硕士研究生、没有985或211，甚至没有双非本科，在当今这个硕士大把，本科遍地的年代，我只是一个小专科，家境堪忧、没车、没房、可以忽略不计的存款，在这个物质尤为重要的年代，我所剩的，好像只有 <strong>尚还年轻</strong> 四个字</p><p>小时候看电视总能看到人说北漂的苦和累、北漂的无奈心酸，没想到有一天，自己也成为了一个北漂，倒不觉得有多苦有多累，无奈可能会有一些吧，但是好像也不像别人说的那样，言语不能表达，只得自己体会</p><p>虽平凡没什么亮点，但好在我知道自己要干什么，知道自己想要什么</p><p>学历低，没必要抱怨，毕竟那是别人在年少时比你付出了更多努力换来的，也没必要气馁，付出加倍努力追赶上去就好了</p><p>缺乏物质，没有必要怨天不公，更没有必要羡慕富二代，想想未来你的儿子在和别人言谈时，可以自豪的说起我的父亲是靠着自己的努力白手起家，一步一步，做（zu）大做（zu）强，是不是也挺自豪的</p><h2 id="历程开始"><a href="#历程开始" class="headerlink" title="历程开始"></a>历程开始</h2><p>河南商丘的小愤青，之前在郑州工作了一段时间，19年二月份，怀揣着对一线大城市的高薪资、高品质生活的憧憬来到北京，到现在一年半了</p><p>我也还算幸运，先是投奔了在北京的好哥们儿，解决了住的地方，然后开始着手面试，刚开始的时候就傻了，本想着多投一投，像在郑州一天多时可以面3～4家，简直是异想天开，因为学历问题，其实接到的面试邀请不多，再加上北京这地方，每天跑两家面都够呛，时间全花在路上了</p><p>第一家面试的公司以失败告终，因为没多少工作经验，加上是第一次面试性格还内向的原因，整个面试过程比较忐忑，不过面试官问的技术问题不说回答的好不好，起码都答上来了，这让我下一次的面试多了一些信心，随后的几家面试，每成一家，下次面试薪资就会多要些，只能这样一家家试，因为不知道自己的水平和北京的行情 </p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20200725185126851.png"></p><p>上图是离开郑州时发的一个QQ空间截图，2.21号下午5点钟到的北京，22号开始正式投简历，抛去天安门玩了一天和中间有家公司去试岗了两天觉得公司技术实在是有些老就和领导提了下自己的观点然后撤了，一共面试了大概 10 来天，面了8家公司，由于学历问题面的都是一些中小公司，侥幸拿了 5 家 Offer，因为在哥们儿那一共住了半个月，挺不好意思的，所以在 3 月初选择入职了一家公司，一直做到了现在</p><p>之后开始租房，新公司、新环境、新同事、新住址，这一切都让我对未来充满希望、充满斗志</p><h2 id="认清自己"><a href="#认清自己" class="headerlink" title="认清自己"></a>认清自己</h2><p>这段有点俗，什么是认清自己，就是要想明白自己想要什么，该做什么，怎么来做</p><h3 id="想要什么"><a href="#想要什么" class="headerlink" title="想要什么"></a>想要什么</h3><p>想要什么，我想要钱，没错，很庸俗，但是也很现实，在这个物质的社会，钱不是万能的，但是没有钱是万万不能的</p><p>家里并不富裕甚至可以说很穷，我不是一个人，虽然在家排行老二，但是我是最先工作的，我需要养家，我还需要挣钱买房、买车，这些都只能靠自己，所以我需要钱</p><h3 id="该做什么"><a href="#该做什么" class="headerlink" title="该做什么"></a>该做什么</h3><p>该做什么，做前端，因为大学学的就是这个，除了这个我什么也不会，你可能会说，三百六十行、行行出状元，但是在当时的我可以选择的行业里，做前端，也就是 IT 行业，起码是一份比较体面的工作，况且我这个性格做其他的也做不来</p><p>有些人会把为了高薪入 IT 行业的人和所谓纯粹的技术人区分开，其实两者并不冲突，差异只是前者从一开始的目的就很明确，单纯是为了入行做几年 IT 攒点钱再转投它行，而纯粹的技术型人才，痴迷技术而不断学习、不断提升自己，那提升自己是为了什么的，升职加薪、为了更好的未来，说到底还是钱</p><p>我不是前者也不全是后者，我要做的是从各方面提升自己，因为喜欢又从事前端，所以我会更加侧重前端方面的提升，仅此而已</p><h3 id="怎么来做"><a href="#怎么来做" class="headerlink" title="怎么来做"></a>怎么来做</h3><p>怎么来做，从各方面提升自己，其实就是投资自己，说来惭愧，向往独居北京的品质生活，但是还是因为省钱选择了很多人的合租房，每天会为很多生活上的小事烦恼</p><p>来北京的一年多时间里，上班、下班、学习，也不怎么出去玩，没吃过王府井的小吃、没见过鼓楼的夜晚、没在景山公园看一看紫禁城、没体验过颐和园赏景的悠然自得、没看到过圆明园的断壁残垣、没有去十三陵看一眼皇家墓地、没有感受过南锣鼓巷的熙熙攘攘、更不知道三里屯的时尚繁华，哦对了，也没去看过儿时梦想的清华北大，可能几年后别人问起我在北京去过哪些地方，我也只能回答去过天安门、爬过长城</p><p>生活上不能说省吃俭用，但奢侈品、鞋子、表、衣服什么对我来说都无所谓，所以除了日常吃饭，换季买些衣服，没有其他大的开销</p><p>一年多来，对我来说开销最大的地方，电脑老旧换了台 Mac 花了上万元，为了能更好更快的提升自己，买了很多课程，花了上万元，不过这些在我认为都是值得的</p><p>前半年每天都是2～3点睡觉，明显感觉到身体素质日益渐下，所以后来就调整到每晚12点左右睡觉</p><p>坚持写博客，刚开始只是为了巩固自己所学的知识，因为我认为能用自己的理解把某个技术点写出来给别人看，并且让别也能看懂的东西自己才算真正学会，对自己对他人都是有利的</p><p>后来做公众号，因为网络上写一篇博客，不经同意被人拿走署名转发还好，比较搞笑的是有些人直接 <code>Copy</code> 后只在文末写一句文章来源网络，更气的是有些人直接 <code>Copy</code> 后写上自己名字，这种事情发生在自己头上感觉就是辛辛苦苦用心输出的成果被他人窃取了</p><p>做个人公众号，它算是一种渠道，一种可以树立起个人品牌的渠道，它可以为我慢慢积攒起流量，通过公众号交流群，也可以让我交到更多朋友积攒更多人脉，其实辛苦很久写的文章没人看是很无奈的，所以这是一种很好的方式，而且也正如 <a href="https://juejin.im/user/57bd1bdfd342d3006bf76a52">@前端劝退师</a> 所说，树立个人品牌可以抵消一些学历上的不足</p><p>当然也有很多技术类博主做以公众号为主的自由职业者、用它来盈利，这没法子评价，我的公众号刚起步，只有区区几百粉丝，我不确定未来我是否拿它盈利，但是至少短期内是肯定不会的，提到这了，简单说下，原因有三</p><ul><li>如果有一天想通过公众号盈利，我想我不会选择技术类，因为技术文章产出很慢，拿我自己举例子，我几乎每篇技术文章都在万字以上，平均一个月产出1～2篇，这个产出是很低的，对我来说高产意味着质量不好，因为我只能利用业余时间分出的一小块时间写，而且毕竟不是特厉害的大佬，很多东西我不会，我想写，我就要学，学需要时间，学完之后写需要时间，写完还要细细揣摩几天，毕竟个人理解的技术文章，我允许自己理解有误，但那也必须是经过深思熟虑后的，这是为了自己的技术增长和让他人认同，同样也是为了不浪费他人时间，而技术文章产出慢使得很多博主只能频繁的转发文章来维持，其实偶尔转发还好，转发多了就丧失了作为个人公众号的初衷，个人不太喜欢</li><li>我也算过，我知道的公众号盈利方式有微信流量主的方式就是在文末加一个小广告，用户在文章中点进广告就会有些钱，但是靠这个盈利，很难的，实在是没多少钱，发文推广才是技术公众号最主要的盈利方式，但是首先技术类公众号的用户群体就那么多，再加上是技术领域的前端领域，又少了一部分，最后再加上技术类公众号推文合作方向比较单一，好像只有培训或者技术课程之类的，这也是当下很多技术博主盈利的方式，正常说公众号运营到10W+阅读量是超级大 V 了，各种类别公众号里其实都有不少这种大V，但据我所知的技术类公众号平均阅读量超过 10W 的寥寥无几，专注前端领域的公众号的平均阅读超过1W的都没几个好像，还有就是文末赞赏和文章付费的渠道，这些盈利也都是寥寥的，总之技术类公众号盈利是挺难的</li><li>盈利的话，文末加个小广告还好，一旦硬推广告，很容易流失流量，因为以一个技术人的心态来说，喜欢学习的人就那么一撮，看公众号的也就那么一撮，喜欢学习又看技术类公众号肯定不会只关注一个号，我自己就关注了很多前端公众号，有时看到广告推文哪怕知道是广告我也会点进去一下，哪怕只点不看，也为他们增加下阅读量，但是有时候看到关注的很多技术公众号发同一个广告推文刷屏时也挺难受的，不太想成为他们的一员，公众号方面，我更多的是想要慢慢的树立个人品牌，像阮一峰先生的个人博客一样，十分仰慕</li></ul><p>当然上面说的知识我自己的观点，并没有评判什么，因为我自己也就是佛系玩一下，也不怎么转文章，见识可能也比较浅显，不太懂其中的门道，如有冒犯到，不胜见谅，其实遇到的所有做公众号或是坚持写技术博客的都是非常努力非常自律的一群人，不管目的如何，都很钦佩</p><p>自媒体运营还挺好玩的，说不定有一天我想盈利了会做一个写鸡汤文的公众号，盈利渠道和受众都广嘛，甚至我都想做一个励志的视频号了，因为我发现自己码码字还行，但是口才方面一直是弱项，刚好做视频号可以弥补，哈哈，有这个想法</p><p>关于「不正经的前端」这个技术号，可能未来的某一天我会因为坚持不下去公众号就不做了，也可能未来的某一天积攒起了流量我也会同大多数人一样开始盈利，害，管他呢，想这么多干嘛，未来的事情谁知道呢</p><p>不管怎么说，写博客或者说做技术公众号也是学习的一种方式，并且和我的职业是相辅相成的，也确实，写文章促成了我很多好习惯，也让我认识了很多很多朋友，我觉得每个技术人都应该坚持写一写，至少在你转行的时候，网络上有你曾经为之奋斗留下过的痕迹</p><p>为了弥补儿时不努力带来的学历差距，只能不断学习，只能比他人更努力，还好作为一个技术人员，只要技术硬，学历的影响没有其他行业那么大，一切的努力都是值得的</p><p>技术在更新，学习永不止，看过大圣老师，也就是 <a href="https://juejin.im/user/59532176f265da6c317d8e14">@蜗牛老湿</a> 的很多视频，也听他讲述了自己的一番经历，十分励志，很正的价值观，也正是因为他，我喜欢上了看书，也确实，书能给你无穷力量，书上的东西是经过很多人很长时间总结勘误后才形成的，很少有错误，每一本书都有值得观看的点，因为不可能有废话连篇还能写厚厚一本的书，不管是技术书籍还是其他的，没事多读没坏处</p><p>三八理论还是挺靠谱的，对于大多数正常人来说，每天8小时工作，8小时睡眠，那么剩下的8小时，决定的将是你人生走向，而我们这些在某一方面有缺陷（比如学历低的人），好好把握这8小时，甚至可以少睡2小时（睡眠不要低于6小时），长此以往，高低立判</p><h2 id="关于交流群"><a href="#关于交流群" class="headerlink" title="关于交流群"></a>关于交流群</h2><p>学习的方式其实挺多的，对我影响很大是技术交流群</p><p>刚入行时，我加了很多技术交流群，当我遇到一个深思熟虑后依然解决不了的技术问题时，我会百度、谷歌找答案，实在找不到了，会发到交流群里问别人</p><p>那时候在郑州，工作不忙，每当有空闲时我都会看看交流群，摸鱼？当然不是，我是在找各个交流群里大家发出的技术问题，有人发问题，我就看会不会，会的话给他解答发过去，不会的话百度谷歌一番，还是找不到答案的话我会把交流群1里人发的问题，转发到2、3、4、5等群，有人回答了，我再给1群的那个人转过去，当一个搬运工，你可能会觉得好贼啊，没错，我就是这么过来的</p><p>长此以往，我解决的问题，或者说我搬运的问题越来越多，各个方向，各种刁钻的问题都有，收获了什么？</p><ul><li><p>首先，给别人解决问题，收获了很多人情，那么我下次有问题时发群里他们也会乐意帮助我</p></li><li><p>其次，很多奇奇怪怪的问题，其实网上就有答案，只不过有些人拿捏不准关键词，搜不出来，搜索也是一门技术活，总能以最短时间找准问题的关键词搜索出来类似信息，这门儿不可言谈的功法好像被我练成了</p></li><li><p>最后，长期活跃于各个交流群，交流技术解决问题，这让我独立解决问题的能力蹭蹭蹭的上涨，企业为什么反感培训过、填鸭式学习的程序员，就是认为这部分人独立解决问题的能力不行，企业很看重这点技能，除此之外，技术面也在迅速扩张（因为好多问题都不是我擅长的，在寻找答案的过程中学习了很多各种各样的知识），还有就是最重要的一点，我交到了很多朋友，扩宽了人脉，这都是一些隐藏的财富，还是挺自豪的</p></li></ul><p>长期活跃在很多交流群，让我收获了很多友谊，认识了很多非常非常优秀的人，通过这些人我也学到了很多学习方法包括一些经验，没做公众号之前，我加了10来个前端交流群吧，做公众号之后，自己也建了交流群，更是数不清的群聊，最起码有50+，因为做公众号，加的好友比较多，有人发消息怕来不及回复忘掉，所以现在养成了不清理微信消息队列，现在基本上打开微信，划一划都是各种群聊，其实有一个很奇怪的现象，这些群聊中总是有那么一撮相同的人，何其优秀</p><h2 id="新的征途"><a href="#新的征途" class="headerlink" title="新的征途"></a>新的征途</h2><p>工作上，虽然通过自己的努力让公司技术负责人给予了认可，但是工作就是工作，工作中两点很重要，一是对自身成长，二是薪资，一年多过去，技术方面已经得不到太多的提升，薪资方面虽然也涨薪了，但是并不能达到我内心的要求，不管怎样，企业是不可能给某一个人大幅度涨薪的，一切还是要按照制度来，有个朋友说的挺对的，技术的增长，在你当前公司是看不到的，只能留给下家公司来评判，想离职很久了，也有些不舍，毕竟在公司交了几个好朋友，而且目前在职的这家公司对我的帮助挺大的，为此犹豫了很久很久，确实有些婆妈了</p><p>偶然间也发现有些朋友和我技术上应该差不多吧，有的甚至可能还不如我，但是薪资比我高很多，还不止一个，这一度令我很沮丧，自认为很努力了，事关自身成长，也会不计成本的砸钱买课学习等等来投资自己，可是生活总是那么爱开玩笑，这也是压死骆驼的最后一根稻草，所以疫情当下，我依然提出了离职，当然，我可能是我鼠目寸光，没有看到别人的努力，总而言之，我想试试看</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>你必须非常努力，才能看起来毫不费力，有时候，你努力得来的成果，在别人看来是运气好，随之而来的还有些讥讽，不要伤心、不要难过，因为他们不值得</p><p>你所赚的每一分钱，都是你对这个世界认知的变现，你所亏的每一分钱，都是因为对这个世界认知有缺陷，你永远赚不到超出你认知范围之外的钱，除非你靠运气，但是靠运气赚到的钱，最后往往又会靠实力亏掉，这是一种必然，这个社会最大的公平就在于：当一个人的财富大于自己认知的时候，这个社会有100个方法收割你，直到让你的认知和财富相匹配为止，这是我很喜欢也很坚信的一句话，也一直为之提升自己</p><p>知乎上曾有一个问题挺好的：为什么很多人在朋友圈假装努力？其实不管是朋友圈还是其他社交平台包括技术平台，都会有很多人分享努力奋斗史</p><p>而这个问题下的高赞评论中有一个是这样说的：因为你羡慕那些很努力的人，自己也想成为那样的人，决心下的很足，却在突然之间放弃之前的决心，内心还毫无波动，这就叫做懒惰与迷茫，望自己与屏幕前的你都不是</p><p>我是「isboyjc」，公众号「不正经的前端」，一个平凡无奇的前端开发程序员</p><p>正如此文的标题，努力、奋斗，写给未来的自己，也讲给当下的你听，多谢观看！</p><p><a href="https://juejin.im/post/5efc06715188252e7206ba07">掘金年度征文 | 2020 与我的年中总结征文活动正在进行中……</a> </p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>励志</tag>
      
      <tag>努力</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Wechaty Plugin|实现一个微信机器人几行代码即可</title>
    <link href="/blog/2020/07/14/other/Wechaty%20Plugin%7C%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%BE%AE%E4%BF%A1%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%87%A0%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%8D%B3%E5%8F%AF/"/>
    <url>/blog/2020/07/14/other/Wechaty%20Plugin%7C%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%BE%AE%E4%BF%A1%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%87%A0%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%8D%B3%E5%8F%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>晚到几个月的帖子，这几个月有些忙，没顾上，关于为什么要开发微信机器人、技术选型、Token申请、一期简单的开发可以看我4个月之前在掘金发布的文章</p><p><a href="https://juejin.im/post/5e5b2aeff265da5710438a1e">Wechaty|NodeJS基于iPad协议手撸一个简单的微信机器人助手</a> </p><p>开发一个微信机器人难吗？真的很简单，看之前那篇文章就知道了，5月30号的「Wechaty Plugin conference」，<code>wechaty</code> 正式推出了 <code>plugin</code> 系统，<code>wechaty</code> 的作者 <a href="https://github.com/huan">Huan (李卓桓)</a> 以及 <code>wechaty plugin</code> 系统的开发者同时也是开源项目 <code>Wepy</code> 作者 <a href="https://github.com/Gcaufy">Gcaufy</a> 的一番演讲挺让人很兴奋的，因为在开发上一版机器人时，虽然简单，但是会感觉有些功能写着不难，就是比较琐碎，并且所有的业务逻辑代码都堆积在一块，很难受</p><p>但是 <code>wechaty plugin</code> 系统的上线，完美解决了这个问题，一个插件一个功能，基于配置，简洁明了，并且后期<code>plugin</code> 生态足够强大了，可以随时随地的为我们的机器人配置各种想要的功能，开发起来也会更加顺滑和简单</p><h2 id="申请免费Token？"><a href="#申请免费Token？" class="headerlink" title="申请免费Token？"></a>申请免费Token？</h2><p>了解 <code>wechaty</code> 或者看了之前那篇帖子的朋友可能知道，<code>wechaty</code> 使用 <code>pad</code> 协议是需要申请 <code>token</code> 的，可能有很多人看到需要 <code>token</code> 直接就撤了，这没办法，毕竟句子团队的研发也是需要成本的，没有必要吐槽，不过你也可以参与开源激励计划来获取长期 <code>token</code>，这个世界上大佬占有量总是少数，可能更多的人看到开源激励计划这几个字就觉得和自己没关系，事实上没有想象的那么难</p><p>这么说吧， <code>wechaty plugin</code> 推出前，你只需拿着试用的 <code>token</code> 开发一个产品（不要会错意，官方也说了是MVP产品，最小可行化产品，按照我的理解来说，最小可行产品就是刚好具备能够帮助你表达产品的核心概念的部分功能的产品，简单来说，你想用它做什么东西，你把这个东西核心功能做出来，并且放到 <code>github</code> 中开源即可，没有简单复杂之分，可行的产品就ok，就比如我做的产品核心就是为了管理微信群组和自动加好友，我就简单实现了这样一个东西，仅此而已），开发出产品后把代码开源到 <code>github</code> 并且写一篇帖子就行了</p><p>那么 <code>wechaty plugin</code> 推出后，你只需要开发一个插件就可以了，你可能会说开发一个插件很难吧，其实并不是，插件有很多种类，取决于开发者的奇思妙想，像我这种比较笨的，开发了几个常规插件，自动邀人、入群欢迎、自动踢人、群签到等等，每一个插件最少的可能只需要十几行代码，一般来说，只要有点开发基础就能开发出来，不管插件简单还是并不是太实用，句子团队肯定是来者不拒的，因为这有利于 <code>wechaty</code> 生态的发展，毕竟对于一个项目来说，有更多的开发者愿意参与进来，相信对这个项目的发展只会有利无害，对项目的发起团队来说，肯定也是非常值得开心的</p><p>可能还会有人怕代码写的烂被人吐槽，我觉得这也没什么，我就不是一个大佬，代码写的也挺烂的，个人觉得对一个程序员来说，脸皮厚很重要，就像写一篇帖子，如果有人吐槽，吐槽的对，我改了就是还能汲取一波知识，吐槽的不对技不如人那就要原谅我直接回怼了，怎么想都是对我百利无一害的，程序员，简简单单，挺好</p><p>看到这你可能我像个推销产品的人，当然你怎么想对我来说都只是陌生人的遐想罢了，不痛不痒，站在我的立场上，我只是对微信机器人比较感兴趣，觉得好玩实用，对 <code>wechaty plugin</code> 也很关注，奈何目前开发插件的人和插件数量实在不多，所以给大家打一波鸡血，好玩的插件多了，那机器人会越来越好玩</p><p>另外，我觉得微信机器人对一些知名博主或者公众号的作者会很有用，毕竟可以有效管理群聊提升群聊的活跃性，当然很多公众号大 V 们都有自己的机器人，也是各种渠道吧，但是能够免费接入的应该不多吧，免费的也会有各种各样的限制，<code>wechaty</code> 就不一样了，身为程序员嘛，自己开发适合自己的机器人岂不是更好</p><h2 id="开发需求"><a href="#开发需求" class="headerlink" title="开发需求"></a>开发需求</h2><p>还是来简单介绍下我的需求，我这边因为在做公众号嘛，也有一些微信交流群，有兴趣的朋友也可以关注下「不正经的前端」，有人加交流群什么的这一套流程人为操作真的是很痛苦，我需要一个机器人来自动通过好友，关键字自动邀请入群，便捷的一些群管理以及活跃下群氛围什么的，都是一些很普通的需求</p><p>上一版的开发其实已经足够我日常的需求了，不过后期扩展都需要我自己开发，还是比较麻烦的，所以我就把上一版的一些需要用到的功能封装成插件发包了，这样的话使用简单，代码简洁，如果别人有这个模块需求也可以直接安装使用插件，除了使用我自己开发的一些插件外，还使用了几个官方的插件来丰富我的机器人，总之，不算插件配置项的话，整体的代码量也就10来行吧</p><h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><p>其实没什么好介绍的了，因为改用了插件体制，每个功能都是一个插件，插件即功能，我就直接把用到的所有插件给大家一一介绍下吧，有自己开发的、官方开发的、其他人开发的，也期待可以用到大家开发的插件</p><p>当然如果你不想看这些插件介绍，也可以直接点开项目地址，直接看代码，跑一下即可，抛开配置也没几行代码</p><p>➡️  <a href="https://github.com/isboyjc/wechaty-plugin-robot">isboyjc/wechaty-plugin-robot  - GitHub传送门</a> </p><h3 id="项目搭建-amp-插件使用"><a href="#项目搭建-amp-插件使用" class="headerlink" title="项目搭建 &amp; 插件使用"></a>项目搭建 &amp; 插件使用</h3><h4 id="初始化项目实例"><a href="#初始化项目实例" class="headerlink" title="初始化项目实例"></a>初始化项目实例</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> &#123; Wechaty &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;wechaty&quot;</span>) <span class="hljs-comment">// Wechaty核心包</span><br><span class="hljs-keyword">const</span> &#123; PuppetPadplus &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;wechaty-puppet-padplus&quot;</span>) <span class="hljs-comment">// padplus协议包</span><br><br><span class="hljs-comment">// 初始化</span><br><span class="hljs-keyword">const</span> bot = <span class="hljs-keyword">new</span> Wechaty(&#123;<br>  <span class="hljs-attr">puppet</span>: <span class="hljs-keyword">new</span> PuppetPadplus(&#123;<br>    <span class="hljs-attr">token</span>: PUPPET_PADPLUS_TOKEN, <span class="hljs-comment">// 你的token</span><br>  &#125;),<br>  <span class="hljs-attr">name</span>: ROBOT_NAME, <span class="hljs-comment">// 你的机器人名字</span><br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="使用插件并启动"><a href="#使用插件并启动" class="headerlink" title="使用插件并启动"></a>使用插件并启动</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> pluginTest = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;wechaty-plugin-test&quot;</span>) <span class="hljs-comment">// 引入插件</span><br><br><span class="hljs-comment">// 使用插件 options为插件配置对象</span><br>bot.use(pluginTest(options))<br><br><span class="hljs-comment">// 启动机器人</span><br>bot.start()<br></code></pre></td></tr></table></figure><h3 id="wechaty-plugin-contrib"><a href="#wechaty-plugin-contrib" class="headerlink" title="wechaty-plugin-contrib"></a>wechaty-plugin-contrib</h3><h4 id="重点介绍"><a href="#重点介绍" class="headerlink" title="重点介绍"></a>重点介绍</h4><p>当您发现自己在编写重复的代码时，就应该将其提取到插件中，通过调用 <code>Wechaty.use(WechatyPlugin())</code> ，我们可以很好地支持使用插件，微信插件是一个 <code>JavaScript</code> 函数，它返回一个接受微信实例的函数，第一个微信插件系统是由核心团队开发人员 <code>@gcaufy</code> 设计的，这个包是用来发布核心开发团队常用的微信插件的</p><p>上面这段话是官方对这个包的解释，简单来说，这个官方发布的包里有一些好玩的插件供我们大家使用，它是一个插件集合，我们直接安装这个包，就可以使用里面的所有插件，现在里面有十来个插件吧，大家也可以给这个包PR一些插件，但是要求每个功能插件代码量不超过100行代码，超过100行的插件官方是建议自己发包的</p><p>如果大家想要了解更多这个插件集合中的插件👇👇👇</p><p><a href="https://github.com/wechaty/wechaty-plugin-contrib">wechaty/wechaty-plugin-contrib - GitHub传送门</a> </p><p>我使用了其中几个插件，给大家分别阐述下具体功能，当然我们要先安装这个包</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">npm install wechaty-plugin-contrib<br><br><span class="hljs-comment">// or</span><br><br>yarn add wechaty-plugin-contrib<br></code></pre></td></tr></table></figure><h4 id="QRCodeTerminal"><a href="#QRCodeTerminal" class="headerlink" title="QRCodeTerminal"></a>QRCodeTerminal</h4><p>在机器人登录的时候，终端显示扫描二维码，之前我们需要自己安装 <code>qrcode-terminal</code> 插件，然后监听 <code>scan</code> 事件，现在使用插件，除了引用依赖，一行代码即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> &#123; QRCodeTerminal &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;wechaty-plugin-contrib&quot;</span>)<br><br>bot.use( QRCodeTerminal(&#123; <span class="hljs-attr">small</span>: <span class="hljs-literal">false</span> &#125;))<br></code></pre></td></tr></table></figure><p>诺，使用之后启动项目的时候就可以在终端打印二维码了，然后我们微信扫码登录即可</p><h4 id="EventLogger"><a href="#EventLogger" class="headerlink" title="EventLogger"></a>EventLogger</h4><p>官方解释是记录 “扫描”|“登录”|“消息”的微信事件…等，其实简单来说就是一个日志输出，登录之后的所有操作会在控制台打印日志，使用也很简单</p><p>提供事件日志：”dong” | “message” | “error” | “friendship” | “heartbeat” | “login” | “logout” | “ready” | “reset” | “room-invite” | “room-join” | “room-leave” | “room-topic” | “scan”</p><p>有一个参数 <code>options</code> ，数组类型，可自由选择打印事件日志，我没有填写此参数，默认就打印所有事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> &#123; EventLogger &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;wechaty-plugin-contrib&quot;</span>)<br><br>bot.use(EventLogger())<br></code></pre></td></tr></table></figure><h4 id="RoomConnector"><a href="#RoomConnector" class="headerlink" title="RoomConnector"></a>RoomConnector</h4><p>这个插件比较有意思，连接房间，把任何房间的信息广播到所有其他房间，因为微信群的上限是500人，为此可能很多公众号大大会创建多个群聊，但是它们的消息是不互通的，该插件就是为此而生的</p><p>它支持三种模式</p><ul><li>OneToManyRoomConnector    可以广播消息在一个房间到其他房间</li><li>ManyToOneRoomConnector    可以将各个房间的信息汇总到一个房间</li><li>ManyToManyRoomConnector  将把任何房间的所有信息广播到所有其他房间</li></ul><p>我这里使用了它的 <code>ManyToManyRoomConnector</code>  模式，把任何房间的所有信息广播到所有其他房间</p><p>具体配置如下，当然，想要了解更多可以点击上文这个插件集合包的 <code>github</code> 地址查看官方文档</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js">bot.use(<br>  ManyToManyRoomConnector(&#123;<br>    <span class="hljs-comment">// 黑名单</span><br>    <span class="hljs-attr">blacklist</span>: [<span class="hljs-keyword">async</span> () =&gt; <span class="hljs-literal">true</span>],<br>    <span class="hljs-comment">// 多个群聊列表</span><br>    <span class="hljs-attr">many</span>: [<br>      <span class="hljs-string">&quot;10614174865@chatroom&quot;</span>, <span class="hljs-comment">// Web圈0x01</span><br>      <span class="hljs-string">&quot;22825376327@chatroom&quot;</span>, <span class="hljs-comment">// Web圈0x02</span><br>      <span class="hljs-string">&quot;24661539197@chatroom&quot;</span>, <span class="hljs-comment">// 微信机器人</span><br>    ],<br>    <span class="hljs-comment">// 遍历并发送出的消息</span><br>    <span class="hljs-attr">map</span>: <span class="hljs-keyword">async</span> (message) =&gt; &#123;<br>      <span class="hljs-keyword">let</span> roomName = <span class="hljs-keyword">await</span> message.room().topic()<br>      <span class="hljs-keyword">let</span> name = <span class="hljs-keyword">await</span> message.room().alias(message.from())<br>      name ? <span class="hljs-literal">null</span> : (name = message.from().name())<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">`来自群聊【<span class="hljs-subst">$&#123;roomName&#125;</span>】的【<span class="hljs-subst">$&#123;name&#125;</span>】说 \n\n <span class="hljs-subst">$&#123;message.text()&#125;</span>`</span><br>    &#125;,<br>    <span class="hljs-comment">// 白名单</span><br>    <span class="hljs-attr">whitelist</span>: [<span class="hljs-keyword">async</span> (message) =&gt; message.type() === bot.Message.Type.Text],<br>  &#125;)<br>)<br></code></pre></td></tr></table></figure><h3 id="wechaty-voteout"><a href="#wechaty-voteout" class="headerlink" title="wechaty-voteout"></a>wechaty-voteout</h3><p><strong>简介</strong> </p><p>这个插件是 <code>Gcaufy</code> 开发的，它是一个微信投票插件，可以帮助您有一个投票和踢出功能为您的房间</p><p>就是说当你的群聊中有不当的发言者时，发送 <code>@用户 [关键字或表情]</code>，就可以发起投票了，可以设置数量，达到一定的数量会被移除群聊</p><p><strong>安装</strong> </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">npm install wechaty-voteout --save<br></code></pre></td></tr></table></figure><p><strong>使用</strong> </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> VoteOut = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;wechaty-voteout&#x27;</span>)<br><br>bot.use(VoteOut(&#123; <span class="hljs-comment">/* options */</span> &#125;))<br></code></pre></td></tr></table></figure><p><code>options</code> 配置请参考下面示例配置</p><p><strong>示例</strong> </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> options = &#123;<br>  <span class="hljs-comment">//您希望机器人与哪个房间一起工作</span><br><span class="hljs-comment">//可以是RegExp（用于主题）或函数（过滤室实例）</span><br><span class="hljs-comment">//例如 室：函数（室）&#123;room.topic（）。indexOf（&#x27;我的&#x27;）&gt; -1&#125;</span><br>  <span class="hljs-attr">room</span>: [<span class="hljs-regexp">/Room Topic 1/i</span>, <span class="hljs-string">&#x27;room_id@chatroom&#x27;</span>],<br>  <span class="hljs-comment">// 当达到目标时，就意味着他将被移出</span><br>  <span class="hljs-attr">threshold</span>: <span class="hljs-number">3</span>,<br>  <span class="hljs-comment">// 白名单，永远不会被投票移除的人</span><br>  <span class="hljs-comment">// 使用RegEx表示联系人姓名，使用字符串表示联系人ID</span><br>  <span class="hljs-attr">whitelist</span>: [],<br>  <span class="hljs-comment">// 不同的木偶得到不同的标志</span><br><span class="hljs-comment">// 我们运行更多的案例以查看它是什么符号，并在此处更新注释，就是表情符号</span><br>  <span class="hljs-attr">downEmoji</span>: [<br>    <span class="hljs-string">&#x27;[弱]&#x27;</span>,<br>    <span class="hljs-string">&#x27;[ThumbsDown]&#x27;</span>,<br>    <span class="hljs-string">&#x27;&lt;img class=&quot;qqemoji qqemoji80&quot; text=&quot;[弱]_web&quot; src=&quot;/zh_CN/htmledition/v2/images/spacer.gif&quot; /&gt;&#x27;</span>,<br>  ],<br>  <span class="hljs-comment">// 警告模板，设置为falsy以禁用警告消息</span><br>  <span class="hljs-attr">warn</span>: [<br>    <span class="hljs-string">&#x27;可能是因为你的聊天内容不当导致被用户投票，当前票数为 &#123;&#123; downNum &#125;&#125;，当天累计票数达到 &#123;&#123; threshold &#125;&#125; 时，你将被请出此群。&#x27;</span>,<br>  ]<br>  <span class="hljs-comment">// 弹出模板，设置为falsy来禁用消息</span><br>  <span class="hljs-attr">kick</span>: <span class="hljs-string">&#x27;经 &#123;&#123; voters &#125;&#125; 几人投票，你即将离开此群。&#x27;</span>,<br>  <span class="hljs-attr">repeat</span>: <span class="hljs-string">&#x27;你已经投票过 &#123;&#123; votee &#125;&#125; 了，无需再投。&#x27;</span>,<br>&#125;<br><br>bot.use(VoteOut(options))<br></code></pre></td></tr></table></figure><p>来看一个运行中的图片</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20200712204804871.png"></p><p>插件其实用法很简单，但是由于不是我开发的，所以大家想查看更多详细介绍请猛戳👇👇👇</p><p><a href="https://github.com/Gcaufy/wechaty-voteout">Gcaufy/wechaty-voteout  - GitHub传送门</a> </p><h3 id="wechaty-friend-pass"><a href="#wechaty-friend-pass" class="headerlink" title="wechaty-friend-pass"></a>wechaty-friend-pass</h3><p><strong>简介</strong> </p><p>此插件功能是，自动通过好友请求，或者设置一些关键字，通过好友申请时备注的关键字来校验是否要自动通过该好友申请，并且通过好友申请时自动回复一段话</p><p>当时没看到 <code>wechaty-plugin-contrib</code> 中有一个 <code>FriendshipAccepter</code> ，功能差不多，不过我还是使用了自己开发的， 大家也可以选择性使用</p><p><strong>安装</strong> </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">npm install wechaty-friend-pass<br><br><span class="hljs-comment">// or</span><br><br>yarn add wechaty-friend-pass<br></code></pre></td></tr></table></figure><p><strong>使用</strong> </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> WechatyFriendPass = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;wechaty-friend-pass&quot;</span>)<br><br>bot.use(WechatyFriendPass(options))<br></code></pre></td></tr></table></figure><p>如上所示，使用插件只要按需传入配置对象 <code>options</code> 即可</p><table><thead><tr><th>Options 参数属性</th><th>类型</th><th>简介</th></tr></thead><tbody><tr><td>keyword</td><td>String|Array</td><td>好友请求时备注自动通过的关键字，只有一个可以使用字符串类型，多个关键字使用数组类型，全部通过不用校验传入字符串 “*” 即可，不传即都不自动通过</td></tr><tr><td>blackId</td><td>String|Array</td><td>用户黑名单 ID，该项可填写用户的 ID 来识别用户，让此用户不被自动通过，也可不填</td></tr><tr><td>reply</td><td>String</td><td>自动通过用户好友申请后自动回复一句话，为空或不填则通过后不回复</td></tr></tbody></table><p><strong>示例</strong> </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> options = &#123;<br>  <span class="hljs-attr">keyword</span>: [<span class="hljs-string">&quot;加群&quot;</span>, <span class="hljs-string">&quot;前端&quot;</span>, <span class="hljs-string">&quot;后端&quot;</span>, <span class="hljs-string">&quot;全栈&quot;</span>],<br>  <span class="hljs-attr">blackId</span>: [<span class="hljs-string">&quot;*******@id&quot;</span>, <span class="hljs-string">&quot;*******@id&quot;</span>],<br>  <span class="hljs-attr">reply</span>: <span class="hljs-string">&quot;你好，我是机器人小助手圈子 \n 加入技术交流群请回复【加群】\n 联系小主请回复【123】&quot;</span>,<br>&#125;<br><br>bot.use(WechatyFriendPass(options))<br></code></pre></td></tr></table></figure><p>使用中如下图</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20200712200241111.png"></p><p>查看更多详细介绍请猛戳 👉 <a href="https://github.com/isboyjc/wechaty-friend-pass">isboyjc/wechaty-friend-pass - GitHub传送门</a> </p><h3 id="wechaty-room-invite"><a href="#wechaty-room-invite" class="headerlink" title="wechaty-room-invite"></a>wechaty-room-invite</h3><p><strong>简介</strong> </p><p>向机器人发送某些关键字，机器人会通过这些关键字邀请你进入对应的房间，当然，可以管理多个房间</p><p><strong>安装</strong> </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">npm install wechaty-room-invite<br><br><span class="hljs-comment">// or</span><br><br>yarn add wechaty-room-invite<br></code></pre></td></tr></table></figure><p><strong>使用</strong> </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> WechatyRoomInvite = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;wechaty-room-invite&quot;</span>)<br><br>bot.use(WechatyRoomInvite(options))<br></code></pre></td></tr></table></figure><p>如上所示，使用插件只要按需传入配置对象 <code>options</code> 即可</p><table><thead><tr><th>Options 参数属性</th><th>类型</th><th>简介</th></tr></thead><tbody><tr><td>keyword</td><td>String|Array</td><td>触发邀请该用户的关键字，只有一个可以使用字符串类型，多个关键字使用数组类型</td></tr><tr><td>roomList</td><td>Array</td><td>机器人管理的群聊列表，该项为必填项，数组对象中具体配置请看下面示例</td></tr><tr><td>reply</td><td>String</td><td>roomList 数组长度大于 1 时，视为管理多个群聊，那么 keyword 触发后会回复用户当前管理的群聊列表数据供用户选择进入某一个群，这个群聊数据列表为一段由 roomList 配置生成的话，roomList 数组长度等于 1 时，keyword 触发将会直接拉起群邀请，那么此字段也无用，reply 字段不是必选项，管理多个群聊时，建议直接使用默认文字，默认流程可看最后示例图片</td></tr></tbody></table><p>我们来看 <code>roomList</code> 数组的配置示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js">roomList: [<br>  &#123;<br>    <span class="hljs-comment">// 群聊名字，管理多个群聊时用户可通过群聊名字选择某个群聊</span><br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;微信机器人&quot;</span>,<br>    <span class="hljs-comment">// 群聊id</span><br>    <span class="hljs-attr">roomId</span>: <span class="hljs-string">&quot;22275855499@chatroom&quot;</span>,<br>    <span class="hljs-comment">// 群聊别名，建议简短，管理多个群聊时用户可通过别名选择某个群聊，叫它[编号]可能更好</span><br>    <span class="hljs-attr">alias</span>: <span class="hljs-string">&quot;A05&quot;</span>,<br>    <span class="hljs-comment">// 标签，用于在管理多个群聊时给各个群聊做一个简单的标识，方便用户选择</span><br>    <span class="hljs-attr">label</span>: <span class="hljs-string">&quot;新群&quot;</span>,<br>    <span class="hljs-comment">// 是否关闭进入，如果为true，则触发该群时，会提示该群不可进入</span><br>    <span class="hljs-attr">close</span>: <span class="hljs-literal">true</span>,<br>  &#125;,<br>  ...<br>]<br></code></pre></td></tr></table></figure><p><strong>示例</strong> </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> options = &#123;<br>  <span class="hljs-attr">keyword</span>: [<span class="hljs-string">&quot;加群&quot;</span>, <span class="hljs-string">&quot;入群&quot;</span>, <span class="hljs-string">&quot;群&quot;</span>],<br>  <span class="hljs-attr">roomList</span>: [<br>    &#123;<br>      <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Web圈0x01&quot;</span>,<br>      <span class="hljs-attr">roomId</span>: <span class="hljs-string">&quot;10614174865@chatroom&quot;</span>,<br>      <span class="hljs-attr">alias</span>: <span class="hljs-string">&quot;A01&quot;</span>,<br>      <span class="hljs-attr">label</span>: <span class="hljs-string">&quot;推荐&quot;</span>,<br>    &#125;,<br>    &#123;<br>      <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Web圈0x02&quot;</span>,<br>      <span class="hljs-attr">roomId</span>: <span class="hljs-string">&quot;22825376327@chatroom&quot;</span>,<br>      <span class="hljs-attr">alias</span>: <span class="hljs-string">&quot;A02&quot;</span>,<br>      <span class="hljs-attr">label</span>: <span class="hljs-string">&quot;新群&quot;</span>,<br>    &#125;,<br>    &#123;<br>      <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;微信机器人&quot;</span>,<br>      <span class="hljs-attr">roomId</span>: <span class="hljs-string">&quot;24661539197@chatroom&quot;</span>,<br>      <span class="hljs-attr">alias</span>: <span class="hljs-string">&quot;A04&quot;</span>,<br>      <span class="hljs-attr">label</span>: <span class="hljs-string">&quot;推荐&quot;</span>,<br>    &#125;,<br>    &#123;<br>      <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;男神开门群&quot;</span>,<br>      <span class="hljs-attr">roomId</span>: <span class="hljs-string">&quot;22275855499@chatroom&quot;</span>,<br>      <span class="hljs-attr">alias</span>: <span class="hljs-string">&quot;A05&quot;</span>,<br>      <span class="hljs-attr">label</span>: <span class="hljs-string">&quot;测试&quot;</span>,<br>      <span class="hljs-attr">close</span>: <span class="hljs-literal">true</span>,<br>    &#125;<br>  ],<br>  <span class="hljs-attr">reply</span>: <span class="hljs-string">&quot;&quot;</span>,<br>&#125;<br><br>bot.use(WechatyRoomInvite(options))<br></code></pre></td></tr></table></figure><p>管理多个群聊时，当用户给机器人发送【加群】，机器人默认会回复，当然你也可以自己设置</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20200712195955225.png"></p><p>查看更多详细介绍请猛戳 👉 <a href="https://github.com/isboyjc/wechaty-room-invite">isboyjc/wechaty-room-invite - GitHub传送门</a> </p><h3 id="wechaty-room-welcome"><a href="#wechaty-room-welcome" class="headerlink" title="wechaty-room-welcome"></a>wechaty-room-welcome</h3><p><strong>简介</strong> </p><p>这是一个及其简单的插件，就是用于监听群聊中新人员的加入，随后回复一个入群欢迎，可管理多个群聊</p><p><strong>安装</strong> </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">npm install wechaty-room-welcome<br><br><span class="hljs-comment">// or</span><br><br>yarn add wechaty-room-welcome<br></code></pre></td></tr></table></figure><p><strong>使用</strong> </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> WechatyRoomWelcome = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;wechaty-room-welcome&quot;</span>)<br><br>bot.use(WechatyRoomWelcome(options))<br></code></pre></td></tr></table></figure><p><code>options</code> 参数是一个对象，只有一个属性 <code>reply</code> </p><table><thead><tr><th>Options 参数属性</th><th>类型</th><th>简介</th></tr></thead><tbody><tr><td>reply</td><td>String|Array</td><td>reply参数为字符串时，机器人加入的所有群聊监听到新的加入都将回复此欢迎语，当为数组时，可自由配置管理的每个群聊要回复什么欢迎语，为数组类型的具体配置请看下文示例</td></tr></tbody></table><p><code>reply</code> 数组格式示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">reply: [<br>  &#123;<br>    <span class="hljs-comment">// 群聊名</span><br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;微信机器人&quot;</span>,<br>    <span class="hljs-comment">// 群聊id</span><br>    <span class="hljs-attr">roomId</span>: <span class="hljs-string">&quot;24661539197@chatroom&quot;</span>,<br>    <span class="hljs-comment">// 入群回复的欢迎词</span><br>    <span class="hljs-attr">reply</span>: <span class="hljs-string">`\n 你好，欢迎你的加入，请自觉遵守群规则，文明交流，最后，请向大家介绍你自己！😊`</span>,<br>  &#125;,<br>...<br>]<br></code></pre></td></tr></table></figure><p><strong>示例</strong> </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> options = &#123;<br>  <span class="hljs-attr">reply</span>: [<br>    &#123;<br>      <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Web圈0x01&quot;</span>,<br>      <span class="hljs-attr">roomId</span>: <span class="hljs-string">&quot;10614174865@chatroom&quot;</span>,<br>      <span class="hljs-attr">reply</span>: <span class="hljs-string">`\n 你好，欢迎你的加入，请自觉遵守群规则，文明交流，最后，请向大家介绍你自己！ 😊`</span>,<br>    &#125;,<br>    &#123;<br>      <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;微信机器人&quot;</span>,<br>      <span class="hljs-attr">roomId</span>: <span class="hljs-string">&quot;24661539197@chatroom&quot;</span>,<br>      <span class="hljs-attr">reply</span>: <span class="hljs-string">`\n 你好，欢迎你的加入，请自觉遵守群规则，文明交流，最后，请向大家介绍你自己！😊`</span>,<br>    &#125;,<br>    &#123;<br>      <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;男神开门群&quot;</span>,<br>      <span class="hljs-attr">roomId</span>: <span class="hljs-string">&quot;22275855499@chatroom&quot;</span>,<br>      <span class="hljs-attr">reply</span>: <span class="hljs-string">`男神你好，欢迎加入`</span>,<br>    &#125;,<br>  ],<br>&#125;<br><br>bot.use(WechatyRoomWelcome(options))<br></code></pre></td></tr></table></figure><p>使用如下图</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20200712200643675.png"></p><p>查看更多详细介绍请猛戳 👉 <a href="https://github.com/isboyjc/wechaty-room-welcome">isboyjc/wechaty-room-welcome - GitHub传送门</a> </p><h3 id="wechaty-room-remove"><a href="#wechaty-room-remove" class="headerlink" title="wechaty-room-remove"></a>wechaty-room-remove</h3><p><strong>简介</strong> </p><p>你可以在群聊中@一个违规的人并携带你所设置的关键字，机器人监听到后会帮你快捷的移除他并且给出提示，这比手动删除群聊中某一个人要方便的多</p><p><strong>安装</strong> </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">npm install wechaty-room-remove<br><br><span class="hljs-comment">// or</span><br><br>yarn add wechaty-room-remove<br></code></pre></td></tr></table></figure><p><strong>使用</strong> </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> WechatyRoomRemove = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;wechaty-room-remove&quot;</span>)<br><br>bot.use(WechatyRoomRemove(options))<br></code></pre></td></tr></table></figure><p>如上所示，使用插件只要按需传入配置对象 <code>options</code> 即可</p><table><thead><tr><th>Options 参数属性</th><th>类型</th><th>简介</th></tr></thead><tbody><tr><td>keyword</td><td>String|Array</td><td>触发移除该用户的关键字，只有一个可以使用字符串类型，多个关键字使用数组类型，默认为 [“飞机”, “踢”]</td></tr><tr><td>time</td><td>Number</td><td>触发移除后的延时/ms，默认3000，即3s</td></tr><tr><td>adminList</td><td>Array</td><td>可触发命令的管理员列表，一个数组对象，单个数组对象属性请看下面配置示例</td></tr><tr><td>replyInfo</td><td>String|Function</td><td>移除前@提示该用户的一句话，可为字符串类型，也可以是函数类型，函数类型时，有一个参数msg，即当前消息实例，函数最终需返回一个字符串function(msg){return …}，此项有默认值，请看下文示例</td></tr><tr><td>replyDone</td><td>String</td><td>移除成功提示，字符串类型，默认成功时返回done</td></tr><tr><td>replyNoPermission</td><td>String</td><td>无权限移除成员时机器人的回复，即当一个不在adminList配置中的用户发出命令时回复，默认不做出回复</td></tr></tbody></table><p>我们来看 <code>adminList</code> 数组的配置示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js">adminList: [<br>  &#123;<br>    <span class="hljs-comment">// 管理员昵称，用以区分，可选</span><br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;isboyjc&quot;</span>,<br>    <span class="hljs-comment">// 管理员id，必填</span><br>    <span class="hljs-attr">id</span>: <span class="hljs-string">&quot;wxid_nrsh4yc8yupm22&quot;</span>,<br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;工具人小杨&quot;</span>,<br>    <span class="hljs-attr">id</span>: <span class="hljs-string">&quot;wxid_vkovzba0b0c212&quot;</span>,<br>  &#125;,<br>  ...<br>]<br></code></pre></td></tr></table></figure><p><strong>示例</strong> </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> options = &#123;<br>  <span class="hljs-comment">// 触发关键字数组</span><br>  <span class="hljs-attr">keyword</span>: [<span class="hljs-string">&quot;飞机&quot;</span>, <span class="hljs-string">&quot;踢&quot;</span>, <span class="hljs-string">&quot;慢走&quot;</span>, <span class="hljs-string">&quot;不送&quot;</span>],<br>  <span class="hljs-comment">// 管理员列表</span><br>  <span class="hljs-attr">adminList</span>: [<br>    &#123;<br>      <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;isboyjc&quot;</span>,<br>      <span class="hljs-attr">id</span>: <span class="hljs-string">&quot;wxid_nrsh4yc8yupm22&quot;</span>,<br>    &#125;,<br>    &#123;<br>      <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;便便&quot;</span>,<br>      <span class="hljs-attr">id</span>: <span class="hljs-string">&quot;wxid_4mnet5yeqo5d21&quot;</span>,<br>    &#125;,<br>    &#123;<br>      <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;工具人小杨&quot;</span>,<br>      <span class="hljs-attr">id</span>: <span class="hljs-string">&quot;wxid_vkovzba0b0c212&quot;</span>,<br>    &#125;<br>  ],<br>  <span class="hljs-comment">// 延时</span><br>  <span class="hljs-attr">time</span>: <span class="hljs-number">3000</span>,<br>  <span class="hljs-comment">// 移除前提示，以下配置是默认配置，这里用来展示函数类型配置</span><br>  <span class="hljs-comment">// 可根据函数回调中msg消息实例参数自由发挥，也可直接填写一段字符串</span><br>  <span class="hljs-attr">replyInfo</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">msg</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`您可能违反了社群规则，并收到举报，<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.time <span class="hljs-regexp">/ 1000&#125;s后将您移出群聊，如有问题请联系管理！！！🚀\n\n移除原因：违反社群规则\n操作时间：$&#123;dateTimeFormat()&#125;\n操作管理员：$&#123;msg.from().name()&#125;\n\nYou may have violated the community rules and received a report. After $&#123;this.time /</span> <span class="hljs-number">1000</span>&#125;</span>S, you will be removed from the group chat. If you have any questions, please contact the management！！！🚀\n\nReason for removal：Violation of community rules\nOperation time：<span class="hljs-subst">$&#123;dateTimeFormat()&#125;</span>\nOperation administrator：<span class="hljs-subst">$&#123;msg.<span class="hljs-keyword">from</span>().name()&#125;</span>`</span><br>  &#125;,<br>  <span class="hljs-comment">// 移除成功后提示</span><br>  <span class="hljs-attr">replyDone</span>: <span class="hljs-string">&quot;移除成功&quot;</span>,<br>  <span class="hljs-comment">// 无权限人员触发命令后回复，可选项，默认不进行回复</span><br>  <span class="hljs-attr">replyNoPermission</span>: <span class="hljs-string">&quot;您暂时没有权限哦，联系管理员吧😊&quot;</span>,<br>&#125;<br><br>bot.use(WechatyRoomRemove(options))<br></code></pre></td></tr></table></figure><p>如下图</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20200712202937488.png"></p><p>查看更多详细介绍请猛戳 👉 <a href="https://github.com/isboyjc/wechaty-room-remove">isboyjc/wechaty-room-remove  - GitHub传送门</a> </p><h3 id="wechaty-room-clock"><a href="#wechaty-room-clock" class="headerlink" title="wechaty-room-clock"></a>wechaty-room-clock</h3><p><strong>简介</strong> </p><p>在群聊中打卡签到，每次打卡签到后累计打卡签到次数+1，积分+1，每日只可打卡一次，打卡总数/积分总数/打卡日志等等，可以用于积分赠送小礼品提升群活跃度什么的</p><p>你可能觉得这些操作需要用到数据库，但是在我的理解中，微信机器人越简单越便捷越好，而微信群聊的数据量不是很大，一个插件的使用，需要额外配置很多东西是很麻烦的，所以，此插件采用了本地存储，用了一个三方轻量化的基于 <code>Node</code> 的 <code>JSON</code> 文件数据库 <code>LOWDB</code>，避免了数据库这一繁琐的配置</p><p>插件会自动在项目根目录创建一个 <code>[机器人名字].clock-logs</code> 的文件夹，用以存放数据</p><p>其中 <code>clock-logs-[年份].json</code> 文件存储的是打卡日志，为避免读写操作数据量过大产生的负荷，所以每年会生成对应的 <code>json</code> 文件，这样每个群聊上限是 500 人，以5个群聊为基础，一年的打卡数据量也不会太大</p><p>其中 <code>clock-logs-main.json</code> 文件为主文件，存储的是对应群聊/对应用户的打卡签到数据等等</p><p>当然，如果你有更好的想法，请务必告知哦</p><p><strong>安装</strong> </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">npm install wechaty-room-clock<br><br><span class="hljs-comment">// or</span><br><br>yarn add wechaty-room-clock<br></code></pre></td></tr></table></figure><p><strong>使用</strong> </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> WechatyRoomClock = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;wechaty-room-clock&quot;</span>)<br><br>bot.use(WechatyRoomClock(options))<br></code></pre></td></tr></table></figure><p>如上所示，使用插件只要按需传入配置对象 <code>options</code> 即可</p><table><thead><tr><th>Options 参数属性</th><th>类型</th><th>简介</th></tr></thead><tbody><tr><td>keyword</td><td>String|Array</td><td>触发签到的关键字，只有一个可以使用字符串类型，多个关键字使用数组类型，默认为 [“签到”, “打卡”]</td></tr><tr><td>success</td><td>String|Function</td><td>打卡成功提示该用户的一句话，可为字符串类型，也可以是函数类型，函数类型时，有一个参数data，即当前群成员在本地数据库中的数据对象，函数最终需返回一个字符串function(data){return …}，此项默认值请看下文示例</td></tr><tr><td>repeat</td><td>String|Function</td><td>重复打卡时提示该用户的一句话，可为字符串类型，也可以是函数类型，函数类型时，有一个参数data，即当前群成员在本地数据库中的数据对象，函数最终需返回一个字符串function(data){return …}，此项默认值为 “今日已签到，请勿重复签到”</td></tr></tbody></table><p>参数 <code>success</code> 和 <code>repeat</code> 为函数类型时形参 <code>data</code> 示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-comment">// 该用户微信id</span><br>  <span class="hljs-string">&quot;CONTACTID&quot;</span>: <span class="hljs-string">&quot;wxid_nrsh4yc8yupm22&quot;</span>,<br>  <span class="hljs-comment">// 该用户昵称</span><br>  <span class="hljs-string">&quot;CONTACTNAME&quot;</span>: <span class="hljs-string">&quot;isboyjc&quot;</span>,<br>  <span class="hljs-comment">// 该用户打卡总数</span><br>  <span class="hljs-string">&quot;CLOCKNUM&quot;</span>: <span class="hljs-number">170</span>,<br>  <span class="hljs-string">&quot;CLOCKINFO&quot;</span>: &#123;<br>    <span class="hljs-comment">// 该用户2020年打卡总数</span><br>    <span class="hljs-string">&quot;2020&quot;</span>: <span class="hljs-number">69</span>,<br>    <span class="hljs-comment">// 该用户2019年打卡总数</span><br>    <span class="hljs-string">&quot;2019&quot;</span>: <span class="hljs-number">101</span><br>  &#125;,<br>  <span class="hljs-comment">// 该用户积分</span><br>  <span class="hljs-string">&quot;INTEGRALNUM&quot;</span>: <span class="hljs-number">170</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>示例</strong> </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> options = &#123;<br>  <span class="hljs-comment">// 此处为默认项配置，也可为一个字符串</span><br>  <span class="hljs-attr">keyword</span>: [<span class="hljs-string">&quot;签到&quot;</span>, <span class="hljs-string">&quot;打卡&quot;</span>],<br>  <span class="hljs-comment">// 此处为默认项配置，也可为一个字符串</span><br>  <span class="hljs-attr">success</span>: <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;\n签到成功\n&quot;</span><br>    <span class="hljs-built_in">Object</span>.keys(data.CLOCKINFO).map(<br>      <span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> (str += <span class="hljs-string">`<span class="hljs-subst">$&#123;v&#125;</span>年累计签到<span class="hljs-subst">$&#123;data.CLOCKINFO[v]&#125;</span>次\n`</span>)<br>    )<br>    <span class="hljs-keyword">return</span> str + <span class="hljs-string">`共累计签到<span class="hljs-subst">$&#123;data.CLOCKNUM&#125;</span>次\n拥有<span class="hljs-subst">$&#123;data.INTEGRALNUM&#125;</span>积分`</span><br>  &#125;,<br>  <span class="hljs-comment">// 此处为默认项配置，也可为一个字符串</span><br>  <span class="hljs-attr">repeat</span>: <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> <span class="hljs-string">`今日已签到，请勿重复签到`</span>,<br>&#125;<br><br>bot.use(WechatyRoomClock(options))<br></code></pre></td></tr></table></figure><p>使用如下图</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20200712201619049.png"></p><p>查看更多详细介绍请猛戳 👉 <a href="https://github.com/isboyjc/wechaty-room-clock">isboyjc/wechaty-room-clock  - GitHub传送门</a> </p><h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h3><p>看到这其实你可能回发现这个项目功能并不多，是的，所以 <code>plugin</code> 生态需要时间来发展，文中后面几个插件是我开发的，都是些简单的小插件，因为我的需求并不复杂，不过还是很希望接下来能自己做或者是说用上点好玩的插件 ，如果你有什么奇思妙想，可以直接在 <code>wechaty</code> 官方这个仓库的 <code>issuse</code> 中提出 👉  <a href="https://github.com/wechaty/wechaty-plugin-contrib/issues">wechaty/wechaty-plugin-contrib/issues</a> ，可能会有人帮你写插件来实现哦，当然你也可以在其中寻找插件创意来自己实现</p><p>后面想做的几个好玩的小插件，当然只是谋划阶段，因为要上班，业余时间不多</p><ul><li>黑名单<ul><li>最近老遇到有些人在群里大量加好友推销课程，所以寻思着做一个黑名单插件，通过记录微信ID来监听入群的人，校验是否在黑名单中，如果在的话直接移出，同时开放一个公共黑名单列表，大家一块来搞</li></ul></li><li>群数据推送<ul><li>每天有新人加群，有人退群，特别是退群的时候察觉不到，所以做一个插件每天定时推送群数据，这个数据可能包括日内新入群数量、退群数量、聊天人数量及聊天数、聊天最积极人及数量、群成员邀请好友入群数量等等</li></ul></li><li>QA问答<ul><li>技术交流群免不了的提问，所以准备开一个 <code>Github</code> 仓库，使用 <code>issuse</code> 管理每个问答，每个成功解决的问题将被收录其中，使用 <code>webhook</code> 每个 <code>issuse</code> 在提交的时候将会被监听到存放到列表中，在群聊中监听消息作为关键字，触发列表中标题关键字或相似，返回对应链接或解答</li></ul></li><li>可视化管理面板<ul><li>目前对机器人所有的更改都是直接在代码中，想做一个可视化的管理系统，管理机器人并拥有可视化的数据页面方便我们随时随地查看群数据，支持Web端和H5</li><li>现在已经有一个类似的了 👉 <a href="https://github.com/gengchen528/wechaty-web-panel">WebPanel</a>，大家也可以体验一下，我是想开发一个更简单便捷的，顺带做几个数据统计的页面，所以放到 TODO 里了，有时间再说</li></ul></li></ul><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>欢迎大家关注公众号「不正经的前端」，是前端，又不只是前端，所以叫不正经的前端</p><p>也可以加机器人助手「圈子」体验一波哦，同时也可以加入技术交流群</p><p>我们不应该只是为了工作和赚钱而敲代码，最后祝大家工作之余，玩得开心</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20200713201421436.png"></p>]]></content>
    
    
    <categories>
      
      <category>Web相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Wechaty</tag>
      
      <tag>NodeJS</tag>
      
      <tag>微信机器人</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>你真的了解跨域吗</title>
    <link href="/blog/2020/07/10/other/%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%E8%B7%A8%E5%9F%9F%E5%90%97/"/>
    <url>/blog/2020/07/10/other/%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%E8%B7%A8%E5%9F%9F%E5%90%97/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>相信每个前端对于跨域这两个字都不会陌生，在实际项目中应用也很多，但跨域方法的多种多样让人目不暇接，前段时间公司同事出现了跨域问题，又一时找不到问题所在，所以在此总结下跨域知识，一篇由浅入深的万字Web基操文</p><p>其实很早就开始写了，只不过刚开始写的时候理解不够深刻，后来慢慢就写其他觉得较高大尚较内涵的了，然后就又是觉得不够完美不够深刻又写一半，就此陷入强迫症患者明知不可为而为的死循环，SO，产出少，周期长（不过大家能看到的文章都是准备良久又反复斟酌后自认为还不错的）。。。</p><p>总之又是一篇由于各种原因半途而废的积压文，这里终于收尾了，长出一口气，哎，还是太年轻，吐槽结束，进入正文</p><p>文章收录地址： <a href="https://github.com/isboyjc/blog/issues/18">isboyjc/blog 传送门</a> </p><h2 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域"></a>什么是跨域</h2><p>简单来说跨域是指一个域下的文档或脚本想要去去请求另一个域下的资源</p><p>其实一些像A链接、重定向、表单提交的资源跳转，像 <code>&lt;link&gt;、&lt;script&gt;、&lt;img&gt;、&lt;frame&gt;</code> 等dom标签，还有样式中 <code>background:url()、@font-face()</code> 等嵌入的文件外链，又比如一些像  js 发起的ajax请求、dom 和 js 对象的跨域操作等等都是跨域</p><p>我们通常所说的跨域，大多是由浏览器同源策略限制引起的一类请求场景，这里你可能注意到了同源策略，那么浏览器的同源策略是什么呢？</p><h2 id="浏览器同源策略"><a href="#浏览器同源策略" class="headerlink" title="浏览器同源策略"></a>浏览器同源策略</h2><p>同源策略/SOP（Same origin policy）是一种约定，由 <code>Netscape</code> 公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到 <a href="https://developer.mozilla.org/en-US/docs/Web/Security/Types_of_attacks#Cross-site_request_forgery_CSRF">XSS、CSFR</a> 等攻击</p><p>同源同源，什么是源呢？源指的是 <code>协议、域名、端口</code> ，那么同源即三者相同，即便是不同的域名指向同一个ip地址，也不同源</p><p>我们来看一个域名组成，我们以 <code>http://www.hahaha.com/abc/a.js</code> 为例</p><ul><li>http://            –&gt;    协议</li><li>www              –&gt;    子域名</li><li>hahaha.com –&gt;    主域名</li><li>80                   –&gt;     端口（<code>http://</code> 默认端口是80）</li><li>abc/a.js         –&gt;     请求资源路径</li></ul><p>那么我们以这个域名的源为例，来与下面这些做下对比</p><table><thead><tr><th>URL</th><th>结果</th><th>原因</th></tr></thead><tbody><tr><td><code>http://www.hahaha.com/abc/b.js</code></td><td>同源</td><td>只有路径不同</td></tr><tr><td><code>http://www.hahaha.com/def/b.js</code></td><td>同源</td><td>只有路径不同</td></tr><tr><td><code>https://www.hahaha.com/abc/a.js</code></td><td>不同源</td><td>协议不同</td></tr><tr><td><code>http://www.hahaha.com:8081/abc/a.js</code></td><td>不同源</td><td>端口不同</td></tr><tr><td><code>http://aaa.hahaha.com/abc/a.js</code></td><td>不同源</td><td>主机不同</td></tr></tbody></table><p>而在不同源的情况下，同源策略限制了我们</p><ul><li>Cookie、LocalStorage、IndexedDB 等存储性内容无法读取</li><li>DOM 节点和 Js对象无法获得</li><li>AJAX 请求发送后，结果被浏览器拦截（注意是 <strong>请求发送出去了，也拿到结果了，只是被浏览器截胡了</strong>）</li></ul><p>到了这里，相信你对跨域已经有所了解了，那么我们如何有效的规避跨域呢，应该说如何解决跨域问题，因为我们在开发过程中免不了要跨域，针对不同的类型，解决跨域的方式也有很多</p><h2 id="不同类型的跨域解决方案"><a href="#不同类型的跨域解决方案" class="headerlink" title="不同类型的跨域解决方案"></a>不同类型的跨域解决方案</h2><h3 id="No-1-document-domain-iframe跨域"><a href="#No-1-document-domain-iframe跨域" class="headerlink" title="No.1 document.domain+iframe跨域"></a>No.1 document.domain+iframe跨域</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p><code>document.domain</code> 的方式实现跨域，适用场景仅在 <strong>主域名相同，子级域名不同</strong> 的情况下</p><p>例如，下面这两个页面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">http://aaa.hahaha.com/a.html<br>http://bbb.hahaha.com/b.html<br></code></pre></td></tr></table></figure><p>那么它可以做到什么呢</p><ul><li>两个页面设置相同的 <code>document.domain</code> ，共享Cookie</li><li>两个页面设置相同的 <code>document.domain</code> ，通过 <code>iframe</code> 实现两个页面的数据互通</li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><h5 id="共享Cookie"><a href="#共享Cookie" class="headerlink" title="共享Cookie"></a>共享Cookie</h5><p>首先，两个页面都设置相同的 <code>document.domain</code> </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">document</span>.domain = <span class="hljs-string">&#x27;hahaha.com&#x27;</span>;<br></code></pre></td></tr></table></figure><p>页面 a 通过脚本设置一个 Cookie</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">document</span>.cookie = <span class="hljs-string">&quot;test=a&quot;</span>;<br></code></pre></td></tr></table></figure><p>网页 b 读这个 Cookie</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> cookieA = <span class="hljs-built_in">document</span>.cookie;<br><span class="hljs-built_in">console</span>.log(cookieA)<br></code></pre></td></tr></table></figure><p>服务器也可以在设置Cookie的时候，指定Cookie的所属域名为一级域名，比如<code>.hahaha.com</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">Set</span>-Cookie: key=value; domain=.hahaha.com; path=/<br></code></pre></td></tr></table></figure><p>这样的话，二级域名和三级域名不用做任何设置，都可以读取这个Cookie</p><h5 id="共享数据"><a href="#共享数据" class="headerlink" title="共享数据"></a>共享数据</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--a页面--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://bbb.hahaha.com/b.html&quot;</span> <span class="hljs-attr">onload</span>=<span class="hljs-string">&quot;load()&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;frame&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">  <span class="hljs-built_in">document</span>.domain = <span class="hljs-string">&#x27;hahaha.com&#x27;</span>;</span><br><span class="javascript">  <span class="hljs-keyword">let</span> a = <span class="hljs-string">&quot;this is a&quot;</span>;</span><br><span class="javascript">  </span><br><span class="javascript">  <span class="hljs-comment">// 获取b页面数据</span></span><br><span class="javascript">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">load</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">    <span class="hljs-keyword">let</span> frame = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;frame&quot;</span>)</span><br><span class="javascript">    <span class="hljs-built_in">console</span>.log(frame.contentWindow.b) <span class="hljs-comment">// this is b</span></span><br><span class="javascript">  &#125;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--b页面--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">  <span class="hljs-built_in">document</span>.domain = <span class="hljs-string">&#x27;hahaha.com&#x27;</span>;</span><br><span class="javascript">  <span class="hljs-keyword">let</span> b = <span class="hljs-string">&quot;this is b&quot;</span></span><br><span class="javascript">  </span><br><span class="javascript">  <span class="hljs-comment">// 获取a页面数据</span></span><br><span class="javascript">  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">window</span>.parent.a); <span class="hljs-comment">// this is a</span></span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="局限"><a href="#局限" class="headerlink" title="局限"></a>局限</h4><ul><li>首先，仅在主域名相同，子级域名不同的情况下</li><li>只适用于 Cookie 和 iframe 窗口，LocalStorage 和 IndexDB 数据无法通过这种方法共享</li></ul><h3 id="No-2-location-hash-iframe跨域"><a href="#No-2-location-hash-iframe跨域" class="headerlink" title="No.2 location.hash + iframe跨域"></a>No.2 location.hash + iframe跨域</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>两个页面不同源，是无法拿到对方DOM的，典型的例子就是 <code>iframe</code> 窗口和 <code>window.open</code> 方法打开的窗口，它们与父窗口是无法通信的</p><p>比如，不同源的页面a和页面b，如果我们直接获取对方数据</p><p>页面a：<code>http://www.hahaha0.com/a.html</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://www.hahaha1.com/b.html&quot;</span> <span class="hljs-attr">onload</span>=<span class="hljs-string">&quot;load()&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;frame&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">  <span class="hljs-keyword">let</span> a = <span class="hljs-string">&quot;this is a&quot;</span></span><br><span class="javascript">  </span><br><span class="javascript">  <span class="hljs-comment">// 获取b页面数据</span></span><br><span class="javascript">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">load</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;frame&quot;</span>).contentWindow.b) </span><br><span class="javascript">    <span class="hljs-comment">// Uncaught DOMException: Blocked a frame from accessing a cross-origin frame.</span></span><br><span class="javascript">  &#125;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>页面b：<code>http://www.hahaha1.com/b.html</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--b--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">  <span class="hljs-keyword">let</span> b = <span class="hljs-string">&quot;this is b&quot;</span></span><br><span class="javascript">  </span><br><span class="javascript">  <span class="hljs-comment">// 获取a页面数据</span></span><br><span class="javascript">  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">window</span>.parent.a); <span class="hljs-comment">// 报错</span></span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>显而易见，都是获取不到的，因为都跨域了，上面我们讲到的 <code>document.domain</code>，只能在同主域名的情况下使用才能规避同源政策，而在主域名不相同的情况下是没有办法做到的</p><p>我们来了解另一种办法 <code>window.location.hash</code>，它拿到的是 URL 的<code>#</code>号后面的部分，它叫片段标识符（fragment identifier）</p><p>比如 <code>http://hahaha.com/a.html#fragment</code> 的 <code>#fragment</code> ，如果只是改变片段标识符，页面是不会重新刷新的，就像大名鼎鼎的Vue中的hash路由就是用的这种方式</p><p>通过 <code>location.hash</code> + <code>iframe</code> 我们可以做到在不同主域下也可以拿到对方的数据</p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><p>首先，我们要实现页面a和页面b的跨域相互通信，因为不同域所以利用 <code>iframe</code> 加上 <code>location.hash</code> 传值，但是这个传值是单向的，只能由一方向另一方传值，不同域时子页面并不能获取到父页面，也就不能相互通信，所以我们需要一个中间人页面c来帮忙</p><p>不同域之间利用 <code>iframe</code> 的<code>location.hash</code> 传值，相同域之间直接 JS 访问来通信</p><p>那么我们的逻辑就变成了下面这样</p><blockquote><p>a 与 b 不同域只能通过hash值单向通信，b 与 c 也不同域也只能单向通信，但 c 与 a 同域，所以 c 可通过parent.parent 访问 a 页面所有对象</p></blockquote><p>页面a：<code>http://www.hahaha0.com/a.html</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--a中通过iframe引入了b--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;frame&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://www.hahaha1.com/b.html&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">  <span class="hljs-keyword">let</span> frame = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;frame&#x27;</span>);</span><br><span class="javascript"></span><br><span class="javascript">  <span class="hljs-comment">// 向b传hash值</span></span><br><span class="javascript">  frame.src = frame.src + <span class="hljs-string">&#x27;#a=我是a&#x27;</span>;</span><br><span class="javascript"></span><br><span class="javascript">  <span class="hljs-comment">// 给同域c使用的回调方法</span></span><br><span class="javascript">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cb</span>(<span class="hljs-params">data</span>) </span>&#123;</span><br><span class="javascript">    <span class="hljs-built_in">console</span>.log(data) <span class="hljs-comment">// 打印 我是a+b</span></span><br><span class="javascript">  &#125;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>页面b：<code>http://www.hahaha1.com/b.html</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--b中通过iframe引入了中间人c--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;frame&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://www.hahaha0.com/c.html&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">  <span class="hljs-keyword">let</span> frame = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;frame&#x27;</span>);</span><br><span class="javascript"></span><br><span class="javascript">  <span class="hljs-comment">// 监听a传来的hash值，传给c.html</span></span><br><span class="javascript">  <span class="hljs-built_in">window</span>.onhashchange = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">    frame.src = frame.src + location.hash + <span class="hljs-string">&#x27;+b&#x27;</span>;</span><br><span class="javascript">  &#125;;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>页面c：<code>http://www.hahaha0.com/c.html</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">  <span class="hljs-comment">// 监听 b 的hash值变化</span></span><br><span class="javascript">  <span class="hljs-built_in">window</span>.onhashchange = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">    <span class="hljs-comment">// c调用父亲的父亲，来操作同域a的js回调，将结果传回</span></span><br><span class="javascript">    <span class="hljs-built_in">window</span>.parent.parent.cb(location.hash.replace(<span class="hljs-string">&#x27;#a=&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>));</span><br><span class="javascript">  &#125;;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="No-3-window-name-iframe跨域"><a href="#No-3-window-name-iframe跨域" class="headerlink" title="No.3 window.name + iframe跨域"></a>No.3 window.name + iframe跨域</h3><h4 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h4><p><code>window</code> 对象有一个 <code>name</code> 属性，该属性有一个特征，即在一个窗口的生命周期内，窗口载入所有的页面都是共享一个 <code>window.name</code> 的，每一个页面对 <code>window.name</code> 都有读写的权限</p><p><code>window.name</code> 是持久的存在于一个窗口载入的所有页面中的，并不会因为新的页面的载入而被重置，比如下例</p><p>页面a</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">  <span class="hljs-built_in">window</span>.name = <span class="hljs-string">&#x27;我是a&#x27;</span>;</span><br><span class="javascript">  <span class="hljs-built_in">setInterval</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">    <span class="hljs-built_in">window</span>.location = <span class="hljs-string">&#x27;b.html&#x27;</span>; <span class="hljs-comment">// 两秒后把一个新页面b.html载入到当前的window中</span></span><br><span class="javascript">  &#125;,<span class="hljs-number">2000</span>) </span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>页面b</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">window</span>.name); <span class="hljs-comment">// 我是a</span></span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>通过上面这个例子，我们可以很直观的看到，a 页面载入2s后，跳转到 b 页面，b 会在控制台输出 <code>我是a</code></p><p>不过 <code>window.name</code> 的值只能是字符串的形式，最大允许2M左右，具体取决于不同的浏览器，但是一般是够用了</p><p>那么我们就可以利用它这一特性来实现跨域，看标题就知道是使用 <code>window.name</code> 和 <code>iframe</code> ，那么你能想到要如何投机取巧，哦不，是巧妙的规避跨域而不留痕迹吗？</p><p>经历过上文的摧残我们知道，不同域情况下的 a 页面和 b 页面，使用 <code>iframe</code> 嵌入一个页面，数据也是互通不了的，因为会跨域，这里我们要使用 <code>window.name</code> + <code>iframe </code> 来实现跨域数据互通，显然我们不能直接在 a 页面中通过改变 <code>window.location</code> 来载入b 页面，因为我们现在需要实现的是 a 页面不跳转，但是也能够获取到 b 中的数据</p><blockquote><p>究竟要怎么实现呢？其实还是要靠一个中间人页面 c </p><p>首先中间人 c 要和 a 是同域</p><p>a 页面中通过 <code>iframe</code> 加载了 b ，在 b 页面中把数据留在了当前 <code>iframe</code> 窗口的  <code>window.name</code> 属性里</p><p>这个时候 a 是读取不了 <code>iframe</code> 的，因为不同域，但是我们可以在 a 中动态的把 <code>iframe</code> 的 <code>src</code> 改为 c </p><p>中间人 c 什么都不用写，因为它直接继承了 b 留下的 <code>window.name</code> </p><p>因为c 和 a因为是同域，所以 a 可以正常拿到子页面 c 中的 <code>window.name</code> 属性值</p><p>不得不说，这种做法还真挺让人叹为观止的，致敬前辈们</p></blockquote><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><p>页面a：<code>http://www.hahaha1.com/abc/a.html</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://www.hahaha2.com/abc/b.html&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;frame&quot;</span> <span class="hljs-attr">onload</span>=<span class="hljs-string">&quot;load()&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript"><span class="hljs-keyword">let</span> flag = <span class="hljs-literal">true</span></span><br><span class="javascript">  <span class="hljs-comment">// onload事件会触发2次</span></span><br><span class="javascript">  <span class="hljs-comment">// 第1次onload跨域页b成功后，留下数据window.name，后切换到同域代理页面</span></span><br><span class="javascript">  <span class="hljs-comment">// 第2次onload同域页c成功后，读取同域window.name中数据</span></span><br><span class="javascript">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">load</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">    <span class="hljs-keyword">if</span>(flag)&#123;</span><br><span class="javascript">      <span class="hljs-comment">// 第1次</span></span><br><span class="javascript">      <span class="hljs-keyword">let</span> frame = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;frame&#x27;</span>)</span><br><span class="javascript">      frame.src = <span class="hljs-string">&#x27;http://www.hahaha1.com/abc/c.html&#x27;</span></span><br><span class="javascript">      flag = <span class="hljs-literal">false</span></span><br><span class="javascript">    &#125;<span class="hljs-keyword">else</span>&#123;</span><br><span class="javascript">      <span class="hljs-comment">// 第二次</span></span><br><span class="javascript">      <span class="hljs-built_in">console</span>.log(frame.contentWindow.name) <span class="hljs-comment">// 我是b</span></span><br><span class="javascript">    &#125;</span><br><span class="javascript">  &#125;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>页面b：<code>http://www.hahaha2.com/abc/b.html</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">  <span class="hljs-built_in">window</span>.name = <span class="hljs-string">&#x27;我是b&#x27;</span>  </span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="No-4-window-postMessage跨域"><a href="#No-4-window-postMessage跨域" class="headerlink" title="No.4 window.postMessage跨域"></a>No.4 window.postMessage跨域</h3><h4 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h4><p>我们上面说的几种窗口跨域做法是可以适用相应场景且安全可靠的，但是它们都是属于投机取巧，不对，是另辟捷径，但是<code>HTML5 XMLHttpRequest Level 2</code>中为了解决这个问题，引入了一个全新的API：跨文档通信 API（Cross-document messaging）</p><p>这个API为 <code>window</code> 对象新增了一个 <code>window.postMessage</code> 方法，可以允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递</p><p>主流浏览器的兼容情况也非常可观</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20200708230157729.png"></p><p>我们来看下它的使用，先来看看它怎么发送数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">otherWindow.postMessage(message, targetOrigin, [transfer]);<br></code></pre></td></tr></table></figure><ul><li><strong>otherWindow</strong><ul><li>窗口的一个引用，比如 <code>iframe</code> 的 <code>contentWindow</code> 属性，执行 <code>window.open</code> 返回的窗口对象，或者是命名过的或数值索引的 <code>window.frames</code> </li></ul></li><li><strong>message</strong><ul><li>要发送到其他窗口的数据，它将会被 <a href="https://developer.mozilla.org/en-US/docs/DOM/The_structured_clone_algorithm">结构化克隆算法 </a> 序列化，这意味着你可以不受什么限制的将数据对象安全的传送给目标窗口而无需自己序列化</li></ul></li><li><strong>targetOrigin</strong><ul><li>通过窗口的 <code>origin</code> 属性来指定哪些窗口能接收到消息事件，指定后只有对应 <code>origin</code> 下的窗口才可以接收到消息，设置为通配符 <code>*</code> 表示可以发送到任何窗口，但通常处于安全性考虑不建议这么做，如果想要发送到与当前窗口同源的窗口，可设置为 <code>/</code> </li></ul></li><li><strong>transfer | 可选属性</strong> <ul><li>是一串和 <code>message</code> 同时传递的 <strong>Transferable</strong> 对象，这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权</li></ul></li></ul><p>它也可以监听 <code>message</code> 事件的发生来接收数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&quot;message&quot;</span>, receiveMessage, <span class="hljs-literal">false</span>)<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">receiveMessage</span>(<span class="hljs-params">event</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> origin= event.origin<br>  <span class="hljs-built_in">console</span>.log(event)<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来我们实战下跨域情况下，通过 <code>window.postMessage</code> 来互通数据</p><h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><p>还是以不同域的页面 a 和 b 为例子</p><p>页面a：<code>http://www.hahaha1.com/abc/a.html</code>，创建跨域 <code>iframe</code> 并发送信息</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://www.hahaha2.com/abc/b.html&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;frame&quot;</span> <span class="hljs-attr">onload</span>=<span class="hljs-string">&quot;load()&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">load</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">    <span class="hljs-keyword">let</span> frame = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;frame&#x27;</span>)</span><br><span class="javascript">    <span class="hljs-comment">// 发送</span></span><br><span class="javascript">    frame.contentWindow.postMessage(<span class="hljs-string">&#x27;哈喽，我是a&#x27;</span>, <span class="hljs-string">&#x27;http://www.hahaha2.com/abc/b.html&#x27;</span>)</span><br><span class="javascript">    </span><br><span class="javascript">    <span class="hljs-comment">// 接收</span></span><br><span class="javascript">    <span class="hljs-built_in">window</span>.onmessage = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;</span><br><span class="javascript">      <span class="hljs-built_in">console</span>.log(e.data) <span class="hljs-comment">// 你好，我是b</span></span><br><span class="javascript">    &#125;</span><br><span class="javascript">  &#125;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>页面b：<code>http://www.hahaha2.com/abc/b.html</code>，接收数据并返回信息</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">  <span class="hljs-comment">// 接收</span></span><br><span class="javascript">  <span class="hljs-built_in">window</span>.onmessage = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;</span><br><span class="javascript">    <span class="hljs-built_in">console</span>.log(e.data) <span class="hljs-comment">// 哈喽，我是a</span></span><br><span class="javascript">    <span class="hljs-comment">// 返回数据</span></span><br><span class="javascript">    e.source.postMessage(<span class="hljs-string">&#x27;你好，我是b&#x27;</span>, e.origin)</span><br><span class="javascript">  &#125;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="No-5-JSONP跨域"><a href="#No-5-JSONP跨域" class="headerlink" title="No.5 JSONP跨域"></a>No.5 JSONP跨域</h3><h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p>对于 <code>JSONP</code> 这块，虽然不常用，我们好好的提一下，因为遇到过一些初学者，把 <code>AJAX</code> 和 <code>JSONP</code> 混为一谈了，提起 <code>JSONP</code> ，会说很 easy，就是在 <code>AJAX</code> 请求里设置一下字段就行了，可能你用过 <code>JQuery</code> 封装后的 <code>JSONP</code> 跨域方式，确实只是在请求里加个字段，但是，那是 JQ 封装好的一种使用方式而已，可不能被表象迷惑，你真的懂它的原理吗（JQ：我可不背锅！！！）</p><h4 id="AJAX工作原理"><a href="#AJAX工作原理" class="headerlink" title="AJAX工作原理"></a>AJAX工作原理</h4><p><code>Ajax</code> 的原理简单来说通过浏览器的 <code>javascript</code> 对象 <code>XMLHttpRequest</code> （Ajax引擎）对象向服务器发送异步请求并接收服务器的响应数据，然后用 <code>javascript</code> 来操作 DOM 而更新页面</p><p>这其中最关键的一步就是从服务器获得请求数据，即用户的请求间接通过 <code>Ajax</code> 引擎发出而不是通过浏览器直接发出，同时 <code>Ajax</code> 引擎也接收服务器返回响应的数据，所以不会导致浏览器上的页面全部刷新</p><p>使用方式也很简单</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">一：创建XMLHttpRequest对象,也就是创建一个异步调用对象<br><br>二：创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息<br><br>三：设置响应HTTP请求状态变化的函数<br><br>四：发送HTTP请求<br><br>五：获取异步调用返回的数据<br></code></pre></td></tr></table></figure><h4 id="JSONP，JSON？"><a href="#JSONP，JSON？" class="headerlink" title="JSONP，JSON？"></a>JSONP，JSON？</h4><p><code>JSON（JavaScript Object Notation）</code> 大家应该是很了解，就是一种轻量级的数据交换格式，不了解的同学可以去<a href="http://www.json.org/json-zh.html">json.org </a> 上了解下，分分钟搞定</p><p>而 <code>JSONP（JSON with Padding）</code> ，它是一个 <strong>非官方</strong> 的协议，它允许在服务器端集成 <code>Script tags</code> 返回至客户端，通过 <code>javascript callback</code> 的形式实现跨域访问，这就是简单的JSONP实现形式，这么说可能不太明白，那我们来看下它到底是怎么个原理</p><h4 id="JSONP工作原理"><a href="#JSONP工作原理" class="headerlink" title="JSONP工作原理"></a>JSONP工作原理</h4><p>先来看个小例子，还是不同域的 a 和 b 两页面</p><p>页面a：<code>http://www.hahaha1.com/abc/a.html</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://www.hahaha2.com/abc/b.html&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">  <span class="hljs-built_in">console</span>.log(b) <span class="hljs-comment">// 我是b</span></span><br><span class="javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>页面b：<code>http://www.hahaha2.com/abc/b.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> b = <span class="hljs-string">&quot;我是b&quot;</span><br></code></pre></td></tr></table></figure><p>可以看到，虽然不同域，但是 a 页面中还是可以访问到并打印出了 b 页面中的变量</p><p>这个小例子我们可以很直观的看到 <code>&lt;script&gt;</code> 标签的 src 属性并不被同源策略所约束，所以可以获取任何服务器上脚本并执行它，这就是 <code>JSONP</code> 最核心的原理了，至于它如何传递数据，我们来简单实现一个</p><h4 id="JSONP的CallBack实现"><a href="#JSONP的CallBack实现" class="headerlink" title="JSONP的CallBack实现"></a>JSONP的CallBack实现</h4><p>刚才的例子说了跨域的原理，而且我们之前有讲到 <code>javascript callback</code> 的形式实现跨域访问，那我们就来修改下代码，如何实现 <code>JSONP</code> 的 <code>javascript callback</code> 的形式</p><p>页面a：<code>http://www.hahaha1.com/abc/a.html</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span><br><span class="javascript">  <span class="hljs-comment">//回调函数</span></span><br><span class="javascript">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cb</span>(<span class="hljs-params">res</span>) </span>&#123;</span><br><span class="javascript">      <span class="hljs-built_in">console</span>.log(res.data.b) <span class="hljs-comment">// 我是b</span></span><br><span class="javascript">  &#125;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://www.hahaha2.com/abc/b.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>页面b：<code>http://www.hahaha2.com/abc/b.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> b = <span class="hljs-string">&quot;我是b&quot;</span><br><br><span class="hljs-comment">// 调用cb函数，并以json数据形式作为参数传递</span><br>cb(&#123;<br>  <span class="hljs-attr">code</span>:<span class="hljs-number">200</span>, <br>  <span class="hljs-attr">msg</span>:<span class="hljs-string">&quot;success&quot;</span>,<br>  <span class="hljs-attr">data</span>:&#123;<br>    <span class="hljs-attr">b</span>: b<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>创建一个回调函数，然后在远程服务上调用这个函数并且将JSON 数据形式作为参数传递，完成回调，就是 <code>JSONP</code> 的简单实现模式，或者说是 <code>JSONP</code> 的原型，是不是很简单呢</p><p>将 <code>JSON</code> 数据填充进回调函数，现在懂为什么 <code>JSONP</code> 叫 <code>JSON with Padding</code> 了吧</p><p>上面这种实现很简单，通常情况下，我们希望这个 <code>script</code> 标签能够动态的调用，而不是像上面因为固定在 <code>HTML</code> 里面加载时直接执行了，很不灵活，我们可以通过 <code>javascript</code> 动态的创建 <code>script</code> 标签，这样我们就可以灵活调用远程服务了，那么我们简单改造下页面 a 如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span><br><span class="javascript">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cb</span>(<span class="hljs-params">res</span>) </span>&#123;</span><br><span class="javascript">    <span class="hljs-built_in">console</span>.log(res.data.b)  <span class="hljs-comment">// 我是b</span></span><br><span class="javascript">  &#125;</span><br><span class="javascript">  </span><br><span class="javascript">  <span class="hljs-comment">// 动态添加 &lt;script&gt; 标签方法</span></span><br><span class="javascript">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addScriptTag</span>(<span class="hljs-params">src</span>)</span>&#123;</span><br><span class="javascript">    <span class="hljs-keyword">let</span> script = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;script&#x27;</span>)</span><br><span class="javascript">    script.setAttribute(<span class="hljs-string">&quot;type&quot;</span>,<span class="hljs-string">&quot;text/javascript&quot;</span>)</span><br><span class="javascript">    script.src = src</span><br><span class="javascript">    <span class="hljs-built_in">document</span>.body.appendChild(script)</span><br><span class="javascript">  &#125;</span><br><span class="javascript"></span><br><span class="javascript">  <span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">    addScriptTag(<span class="hljs-string">&quot;http://www.hahaha2.com/abc/b.js&quot;</span>)</span><br><span class="javascript">  &#125;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如上所示，只是些基础操作，就不解释了，现在我们就可以优雅的控制执行了，再想调用一个远程服务的话，只要添加 <code>addScriptTag</code> 方法，传入远程服务的 src 值就可以</p><p>接下来我们就可以愉快的进行一次真正意义上的 <code>JSONP</code> 服务调取了</p><p>我们使用 <code>jsonplaceholder</code> 的 <code>todos</code> 接口作为示例，接口地址如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">https://jsonplaceholder.typicode.com/todos?callback=?<br></code></pre></td></tr></table></figure><p><code>callback=?</code> 这个拼在接口后面表示回调函数的名称，也就是将你自己在客户端定义的回调函数的函数名传送给服务端，服务端则会返回以你定义的回调函数名的方法，将获取的 <code>JSON</code> 数据传入这个方法完成回调，我们的回调函数名字叫 <code>cb</code>，那么完整的接口地址就如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">https://jsonplaceholder.typicode.com/todos?callback=cb<br></code></pre></td></tr></table></figure><p>那么话不多说，我们来试下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span><br><span class="javascript">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cb</span>(<span class="hljs-params">res</span>) </span>&#123;</span><br><span class="javascript">    <span class="hljs-built_in">console</span>.log(res)</span><br><span class="javascript">  &#125;</span><br><span class="javascript">  </span><br><span class="javascript">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addScriptTag</span>(<span class="hljs-params">src</span>)</span>&#123;</span><br><span class="javascript">    <span class="hljs-keyword">let</span> script = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;script&#x27;</span>)</span><br><span class="javascript">    script.setAttribute(<span class="hljs-string">&quot;type&quot;</span>,<span class="hljs-string">&quot;text/javascript&quot;</span>)</span><br><span class="javascript">    script.src = src</span><br><span class="javascript">    <span class="hljs-built_in">document</span>.body.appendChild(script)</span><br><span class="javascript">  &#125;</span><br><span class="javascript"></span><br><span class="javascript">  <span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">    addScriptTag(<span class="hljs-string">&quot;https://jsonplaceholder.typicode.com/todos?callback=cb&quot;</span>)</span><br><span class="javascript">  &#125;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>可以看到，页面在加载完成后，输出了接口返回的数据，这个时候我们再来看 JQ 中的 JSONP 实现</p><h4 id="JSONP的JQuery实现"><a href="#JSONP的JQuery实现" class="headerlink" title="JSONP的JQuery实现"></a>JSONP的JQuery实现</h4><p>还是用上面的接口，我们来看 JQ 怎么拿数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">$.ajax(&#123;<br>  <span class="hljs-attr">url</span>:<span class="hljs-string">&quot;https://jsonplaceholder.typicode.com/todos?callback=?&quot;</span>,   <br>  <span class="hljs-attr">dataType</span>:<span class="hljs-string">&quot;jsonp&quot;</span>,<br>  <span class="hljs-attr">jsonpCallback</span>:<span class="hljs-string">&quot;cb&quot;</span>,<br>  <span class="hljs-attr">success</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(res)<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>可以看到，为了让 JQ 按照 <code>JSONP</code> 的方式访问，<code>dataType</code> 字段设置为 <code>jsonp</code> ， <code>jsonpCallback</code> 属性的作用就是自定义我们的回调方法名，其实内部和我们上面写的差不多</p><h4 id="JSONP和AJAX对比"><a href="#JSONP和AJAX对比" class="headerlink" title="JSONP和AJAX对比"></a>JSONP和AJAX对比</h4><ul><li><p>调用方式上</p><ul><li><code>AJAX</code> 和 <code>JSONP</code> 很像，都是请求url，然后把服务器返回的数据进行处理</li><li>所以类 <code>JQuery</code> 的库只是把 <code>JSONP</code> 作为 <code>AJAX</code> 请求的一种形式进行封装，不要搞混</li></ul></li><li><p>核心原理上</p><ul><li><code>AJAX</code> 的核心是通过 <code>xmlHttpRequest</code> 获取非本页内容</li><li><code>JSONP</code>的核心是动态添加 <code>script</code> 标签调用服务器提供的 JS 脚本，后缀 <code>.json</code> </li></ul></li><li><p>两者区别上，</p><ul><li><code>AJAX</code> 不同域会报跨域错误，不过也可以通过服务端代理、<code>CORS</code> 等方式跨域，而 <code>JSONP</code> 没有这个限制，同域不同域都可以</li><li><code>JSONP</code> 是一种方式或者说非强制性的协议，<code>AJAX</code> 也不一定非要用 <code>json</code> 格式来传递数据　</li><li><code>JSONP</code> 只支持 <code>GET</code> 请求，<code>AJAX</code> 支持 <code>GET</code> 和 <code>POST</code> </li></ul></li></ul><p>最后，JSONP是很老的一种跨域方式了，现在基本没什么人用，所以，我们了解懂它即可</p><p>一般情况下，我们希望这个script标签能够动态的调用，而不是像上面因为固定在html里面所以没等页面显示就执行了，很不灵活。我们可以通过javascript动态的创建script标签，这样我们就可以灵活调用远程服务了</p><h3 id="No-6-CORS跨域资源共享"><a href="#No-6-CORS跨域资源共享" class="headerlink" title="No.6 CORS跨域资源共享"></a>No.6 CORS跨域资源共享</h3><h4 id="什么是CORS？"><a href="#什么是CORS？" class="headerlink" title="什么是CORS？"></a>什么是CORS？</h4><p>在出现 <code>CORS</code> 之前，我们都是使用 <code>JSONP</code> 的方式实现跨域，但是这种方式仅限于 <code>GET</code> 请求，而 <code>CORS</code> 的出现，为我们很好的解决了这个问题，这也是它成为一个趋势的原因 </p><p><code>CORS</code> 是一个W3C标准，全称是 <code>跨域资源共享（Cross-origin resource sharing）</code></p><p>它允许浏览器向跨源服务器，发出 <code>XMLHttpRequest</code> 请求，从而克服了 <code>AJAX</code> 只能同源使用的限制</p><p><code>CORS</code> 需要浏览器和服务器同时支持，目前基本所有浏览器都支持该功能，IE浏览器不低于 IE10 即可</p><p>整个 <code>CORS</code> 通信过程，都是浏览器自动完成，是不需要用户参与的，对于我们开发者来说，<code>CORS</code> 通信与同源的 <code>AJAX</code> 通信没有差别，代码完全一样，浏览器一旦发现 <code>AJAX</code> 请求跨源，就会自动添加一些附加的头信息，有的时候还会多出一次附加的请求，但这个过程中用户是无感的 </p><p>因此，实现 <code>CORS</code> 通信的关键是服务器，只要服务器设置了允许的 <code>CORS</code> 接口，就可以进行跨源通信，要了解怎么实现 <code>CORS</code> 跨域通信，我们还要先了解浏览器对每个请求都做了什么</p><p>浏览器会将 <code>CORS</code> 请求分成两类，简单请求（simple request）和非简单请求（not-so-simple request），浏览器对这两种请求的处理，是不一样的</p><h4 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h4><p>什么是简单请求，其实很好理解记住两条就好了</p><ul><li>请求方法是 <code>HEAD、GET、POST</code> 三种方法之一</li><li>HTTP的头信息不超出以下几种字段<ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Last-Event-ID</li><li>Content-Type（只限于三个值<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code>）</li></ul></li></ul><p>只要同时满足这两个条件，那么这个请求就是一个简单请求</p><p>对于简单请求来说，浏览器会直接发出CORS请求，就是在这个请求的头信息中，自动添加一个 <code>Origin</code> 字段来说明本次请求的来源（协议 + 域名 + 端口），而后服务器会根据这个值，决定是否同意这次请求</p><h4 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h4><p>知道了简单请求的定义，非简单请求就比较简单了，因为只要不是简单请求，它就是非简单请求</p><p>浏览器应对非简单请求，会在正式通信之前，做一次查询请求，叫预检请求（preflight），也叫 <code>OPTIONS</code> 请求，因为它使用的请求方式是 <code>OPTIONS</code> ，这个请求是用来询问的</p><p>浏览器会先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段，只有得到肯定答复，浏览器才会发出正式的 <code>XMLHttpRequest</code> 请求，否则就会报跨域错误</p><p>在这个预检请求里，头信息除了有表明来源的 <code>Origin</code> 字段外，还会有一个 <code>Access-Control-Request-Method</code> 字段和 <code>Access-Control-Request-Headers</code> 字段，它们分别表明了该浏览器 <code>CORS</code> 请求用到的 <code>HTTP</code> 请求方法和指定浏览器 <code>CORS</code> 请求会额外发送的头信息字段，如果你看的云里雾里，不要着急，我们看个例子</p><p>如下为一个 AJAX 请求示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> url = <span class="hljs-string">&#x27;http://www.hahaha.com/abc&#x27;</span><br><span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest()<br>xhr.open(<span class="hljs-string">&#x27;POST&#x27;</span>, url, <span class="hljs-literal">true</span>)<br>xhr.setRequestHeader(<span class="hljs-string">&#x27;X-Token&#x27;</span>, <span class="hljs-string">&#x27;YGJHJHGJAHSGJDHGSJGJHDGSJHS&#x27;</span>)<br>xhr.setRequestHeader(<span class="hljs-string">&#x27;X-Test&#x27;</span>, <span class="hljs-string">&#x27;YGJHJHGJAHSGJDHGSJGJHDGSJHS&#x27;</span>)<br>xhr.send()<br></code></pre></td></tr></table></figure><p>这个例子中，我们发送了一个POST请求，并在它的请求头中添加了一个自定义的 <code>X-Token</code> 和 <code>X-Test</code> 字段，因为添加了自定义请求头字段，所以它是一个非简单请求</p><p>那么这个非简单请求在预检请求头信息中就会携带以下信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs txt">// 来源<br>Origin: http://www.hahaha.com<br>// 该CORS请求的请求方法<br>Access-Control-Request-Method: POST<br>// 额外发出的头信息字段<br>Access-Control-Request-Headers: X-Token, X-Test<br></code></pre></td></tr></table></figure><h4 id="withCredentials属性"><a href="#withCredentials属性" class="headerlink" title="withCredentials属性"></a>withCredentials属性</h4><p>CORS 请求默认不发送 Cookie 和 HTTP 认证信息</p><p>如果要把 Cookie 发到服务端，首先要服务端同意，指定<code>Access-Control-Allow-Credentials</code> 字段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">Access-Control-Allow-Credentials: true<br></code></pre></td></tr></table></figure><p>其次，客户端必须在发起的请求中打开 <code>withCredentials</code> 属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">xhr = <span class="hljs-keyword">new</span> XMLHttpRequest()<br>xhr.withCredentials = <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>不然的话，服务端和客户端有一个没设置，就不会发送或处理Cookie</p><p>虽说浏览器默认不发送 Cookie 和 HTTP 认证信息，但是有的浏览器，还是会一起发送Cookie，这时你也可以显式关闭 <code>withCredentials</code> </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">xhr.withCredentials = <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>注意，如要发送 <code>Cookie</code>，<code>Access-Control-Allow-Origin</code> 字段就不能设为星号，必须指定明确的、与请求网页一致的域名，同时，<code>Cookie</code> 依然遵循同源政策，只有用服务器域名设置的 <code>Cookie</code> 才会上传，其他域名的 <code>Cookie</code> 并不会上传，且（跨源）原网页代码中的 <code>document.cookie</code> 也无法读取服务器域名下的 <code>Cookie</code> ，下面还会提到</p><h4 id="服务端CORS跨域配置"><a href="#服务端CORS跨域配置" class="headerlink" title="服务端CORS跨域配置"></a>服务端CORS跨域配置</h4><p>上面的东西只是为了让我们理解CORS，但是要解决它还是需要服务端配置的，不同语言的配置项语法上可能有差异，但是内容肯定都是一样的</p><p><strong>配置允许跨域的来源</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">Access-Control-Allow-Origin: *<br></code></pre></td></tr></table></figure><p><code>CORS</code> 跨域请求中，最关键的就是 <code>Access-Control-Allow-Origin</code> 字段，是必需项，它表示服务端允许跨域访问的地址来源，你可以写入需要跨域的域名，也可以设为星号，表示同意任意跨源请求</p><p>注意，将此字段设置为 <code>*</code> 是很不安全的，建议指定来源，并且设置为 <code>*</code> 号后，游览器将不会发送 <code>Cookie</code>，即使你的 <code>XHR</code> 设置了 <code>withCredentials</code>，也不会发送 <code>Cookie</code> </p><p><strong>配置允许跨域请求的方法</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">Access-Control-Allow-Methods: GET, POST, OPTIONS, PUT...<br></code></pre></td></tr></table></figure><p>该字段也是必需项，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法</p><p><strong>配置允许的请求头字段</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">Access-Control-Allow-Headers: x-requested-with,content-type...<br></code></pre></td></tr></table></figure><p>如果你的请求中有自定义的请求头字段，那么此项也是必须的，它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在预检中请求的字段</p><p><strong>配置是否允许发送Cookie</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">Access-Control-Allow-Credentials: true<br></code></pre></td></tr></table></figure><p>该字段可选，它的值是一个布尔值，表示是否允许发送Cookie，默认情况下，Cookie不包括在CORS请求之中</p><p>设为<code>true</code>，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器</p><p>该字段只能设为<code>true</code>，如果服务器不要浏览器发送Cookie，删除该字段即可</p><p><strong>配置本次预检请求的有效期</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">Access-Control-Max-Age: 1728000<br></code></pre></td></tr></table></figure><p>该字段可选，用来指定本次预检请求的有效期，单位为秒，上面结果中，有效期是20天（1728000秒），即允许缓存该条回应20天，在此期间如果你再次发出了这个接口请求，就不用发预检请求了，节省服务端资源</p><h4 id="常见的跨域预检请求抛错"><a href="#常见的跨域预检请求抛错" class="headerlink" title="常见的跨域预检请求抛错"></a>常见的跨域预检请求抛错</h4><p>对于我们开发时，在跨域中最容易碰钉子的地方就是预检请求，所以列举几个预检请求错误的原因，知道哪错了可以直接找后端同学理论，关于预检请求，最终目的只有一个，客户端发送预检，服务端允许并返回200即可</p><p><strong>OPTIONS 404</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">No &#x27;Access-Control-Allow-Origin&#x27; header is present on the requested resource<br>且 The response had HTTP status code 404<br></code></pre></td></tr></table></figure><p>服务端没有设置允许 <code>OPTIONS</code> 请求，那么在发起该预检请求时响应状态码会是404，因为无法找到对应接口地址</p><p>那么你可能需要找到后端，优雅的告诉他，请允许下 <code>OPTIONS</code> 请求</p><p><strong>OPTIONS 405</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">No &#x27;Access-Control-Allow-Origin&#x27; header is present on the requested resource<br>且 The response had HTTP status code 405<br></code></pre></td></tr></table></figure><p>服务端已经允许了 <code>OPTIONS</code> 请求，但是一些配置文件中（如安全配置）阻止了 <code>OPTIONS</code> 请求</p><p>那么你可能需要找到后端，优雅的告诉他，请关闭对应的安全配置</p><p><strong>OPTIONS 200</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">No &#x27;Access-Control-Allow-Origin&#x27; header is present on the requested resource<br>且 OPTIONS 请求 status 为 200<br></code></pre></td></tr></table></figure><p>服务器端允许了 <code>OPTIONS</code> 请求，配置文件中也没有阻止，但是头部匹配时出现不匹配现象</p><p>所谓头部匹配，就比如 <code>Origin</code> 头部检查不匹配，或者少了一些头部的支持（如 <code>X-Requested-With</code> 等）,然后服务端就会将 <code>Response</code> 返回给前端，前端检测到这个后就触发 <code>XHR.onerror</code> ，从而导致报错</p><p>那么你可能需要找到后端，优雅的告诉他，请增加对应的头部支持</p><p><strong>OPTIONS 500</strong> </p><p>这个就更简单了，服务端针对 <code>OPTIONS</code> 请求的代码出了问题，或者没有响应</p><p>那么你可能需要找到后端，将 <code>Network</code> 中的错误信息截一图发给他，优雅的告诉他，检测到预检请求时，请把它搞成200</p><h3 id="No-7-Nginx代理跨域"><a href="#No-7-Nginx代理跨域" class="headerlink" title="No.7 Nginx代理跨域"></a>No.7 Nginx代理跨域</h3><h4 id="iconfont跨域解决"><a href="#iconfont跨域解决" class="headerlink" title="iconfont跨域解决"></a>iconfont跨域解决</h4><p>浏览器跨域访问 <code>js/css/img</code> 等常规静态资源时被同源策略许可的，但 <code>iconfont</code> 字体文件比如 <code>eot|otf|ttf|woff|svg</code> 例外，此时可在 <code>Nginx</code> 的静态资源服务器中加入以下配置来解决</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs txt">location / &#123;<br>  add_header Access-Control-Allow-Origin *;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="反向代理接口跨域"><a href="#反向代理接口跨域" class="headerlink" title="反向代理接口跨域"></a>反向代理接口跨域</h4><p>我们知道同源策略只是 <strong>浏览器</strong> 的安全策略，不是 <code>HTTP</code> 协议的一部分， 服务器端调用 <code>HTTP</code> 接口只是使用 <code>HTTP</code> 协议，不会执行 JS 脚本，不需要同源策略，也就不存在跨越问题</p><p>通俗点说就是客户端浏览器发起一个请求会存在跨域问题，但是服务端向另一个服务端发起请求并无跨域，因为跨域问题归根结底源于同源策略，而同源策略只存在于浏览器</p><p>那么我们是不是可以通过 <code>Nginx</code> 配置一个代理服务器，反向代理访问跨域的接口，并且我们还可以修改 <code>Cookie</code> 中 <code>domain</code> 信息，方便当前域 <code>Cookie</code> 写入</p><p><code>Nginx</code> 其实就是各种配置，简单易学，就算没接触过，也很好理解，我们来看示例</p><p>首先假如我们的页面 a 在 <code>http://www.hahaha.com</code> 域下，但是我们的接口却在 <code>http://www.hahaha1.com:9999</code> 域下</p><p>接着我们在页面 a 发起一个 <code>AJAX</code> 请求时，就会跨域，那么我们就可以通过 <code>Nginx</code> 配置一个代理服务器，域名和页面 a 相同，都是 <code>http://www.hahaha.com</code> ，用它来充当一个跳板的角色，反向代理访问  <code>http://www.hahaha1.com</code>  接口</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># Nginx代理服务器</span><br><span class="hljs-section">server</span> &#123;<br>  <span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span>;<br>  <span class="hljs-attribute">server_name</span>  www.hahaha.com;<br><br>  <span class="hljs-attribute">location</span> / &#123;<br>    <span class="hljs-comment"># 反向代理地址</span><br>    <span class="hljs-attribute">proxy_pass</span>   http://www.hahaha1.com:9999;  <br>    <span class="hljs-comment"># 修改Cookie中域名</span><br>    <span class="hljs-attribute">proxy_cookie_domain</span> www.hahaha1.com www.hahaha.com; <br>    <span class="hljs-attribute">index</span>  index.html index.htm;<br><br>    <span class="hljs-comment"># 前端跨域携带了Cookie，所以Allow-Origin配置不可为*</span><br>    <span class="hljs-attribute">add_header</span> Access-Control-Allow-Origin http://www.hahaha.com;  <br>    <span class="hljs-attribute">add_header</span> Access-Control-Allow-Credentials <span class="hljs-literal">true</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>没错，这个代理配置相信没接触过 <code>Nginx</code> 也能看明白，大部分都是我们上文提到过的，是不是很简单呢</p><h3 id="No-8-Node代理跨域"><a href="#No-8-Node代理跨域" class="headerlink" title="No.8 Node代理跨域"></a>No.8 Node代理跨域</h3><p><code>Node</code> 实现跨域代理，与 <code>Nginx</code> 道理相同，都是启一个代理服务器，就像我们常用的 <code>Vue-CLI</code> 配置跨域，其实也是 <code>Node</code> 启了一个代理服务，接下来我们来看看是如何做的</p><h4 id="Vue-CLI中代理的多种配置"><a href="#Vue-CLI中代理的多种配置" class="headerlink" title="Vue-CLI中代理的多种配置"></a>Vue-CLI中代理的多种配置</h4><p>Vue-CLI 是基于 <code>webpack</code> 的，通过 <code>webpack-dev-server</code> 在本地启动脚手架，也就是在本地启动了一个 <code>Node</code> 服务，来实时监听和打包编译静态资源，由于都是封装好的，只需要配置即可，我们在 <code>vue.config.js</code> 中配置代理如下，写法很多，列几个常见的自行选择</p><p><strong>使用一</strong> </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-comment">//...</span><br>  <span class="hljs-attr">devServer</span>: &#123;<br>    <span class="hljs-attr">proxy</span>: &#123;<br>      <span class="hljs-string">&#x27;/api&#x27;</span>: <span class="hljs-string">&#x27;http://www.hahaha.com&#x27;</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上所示时，当你请求 <code>/api/abc</code> 接口时就会被代理到 <code>http://www.hahaha.com/api/abc</code> </p><p><strong>使用二</strong> </p><p>当然，你可能想将多个路径代理到同一个 <code>target</code> 下，那你可以使用下面这种方式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-comment">//...</span><br>  <span class="hljs-attr">devServer</span>: &#123;<br>    <span class="hljs-attr">proxy</span>: [&#123;<br>      <span class="hljs-attr">context</span>: [<span class="hljs-string">&#x27;/api1&#x27;</span>, <span class="hljs-string">&#x27;/api2&#x27;</span>, <span class="hljs-string">&#x27;/api3&#x27;</span>],<br>      <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;http://www.hahaha.com&#x27;</span>,<br>    &#125;]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>使用三</strong> </p><p>正如我们第一种使用方式代理时，代理了 <code>/api</code> ，最终的代理结果是 <code>http://www.hahaha.com/api/abc</code> ，但是有时我们并不想代理时传递 <code>/api</code>，那么就可以使用下面这种方式，通过 <code>pathRewrite</code> 属性来进行路径重写</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-comment">//...</span><br>  <span class="hljs-attr">devServer</span>: &#123;<br>    <span class="hljs-attr">proxy</span>: &#123;<br>      <span class="hljs-string">&#x27;/api&#x27;</span>: &#123;<br>        <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;http://www.hahaha.com&#x27;</span>,<br>        <span class="hljs-attr">pathRewrite</span>: &#123;<span class="hljs-string">&#x27;^/api&#x27;</span> : <span class="hljs-string">&#x27;&#x27;</span>&#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个时候，<code>/api/abc</code> 接口就会被代理到 <code>http://www.hahaha.com/abc</code>  </p><p><strong>使用四</strong> </p><p>默认情况下，我们代理是不接受运行在 <code>HTTPS</code> 上，且使用了无效证书的后端服务器的</p><p>如果你想要接受，需要设置 <code>secure: false</code> ，如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-comment">//...</span><br>  <span class="hljs-attr">devServer</span>: &#123;<br>    <span class="hljs-attr">proxy</span>: &#123;<br>      <span class="hljs-string">&#x27;/api&#x27;</span>: &#123;<br>        <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;https://www.hahaha.com&#x27;</span>,<br>        <span class="hljs-attr">secure</span>: <span class="hljs-literal">false</span><br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>使用五</strong> </p><p>配置一个字段 <code>changeOrigin</code> ，当它为 <code>true</code> 时，本地就会虚拟一个服务器接收你的请求并且代你发送该请求，所以如果你要代理跨域，这个字段是必选项</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-attr">devServer</span>: &#123;<br>    <span class="hljs-attr">proxy</span>: &#123;<br>      <span class="hljs-string">&quot;/api&quot;</span>: &#123;<br>        <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;http://www.hahaha.com&#x27;</span>,<br>        <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>,<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>使用六</strong> </p><p>如果你想配置多个不同的代理，也简单，如下所示，可以在任意代理中设置对应的代理规则</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-attr">devServer</span>: &#123;<br>    <span class="hljs-attr">proxy</span>: &#123;<br>      <span class="hljs-string">&quot;/api1&quot;</span>: &#123;<br>        <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;http://www.hahaha1.com&#x27;</span>,<br>        <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span><br>      &#125;,<br>      <span class="hljs-string">&quot;/api2&quot;</span>: &#123;<br>        <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;http://www.hahaha2.com&#x27;</span>,<br>        <span class="hljs-attr">pathRewrite</span>: &#123;<span class="hljs-string">&#x27;^/api2&#x27;</span> : <span class="hljs-string">&#x27;&#x27;</span>&#125;<br>      &#125;,<br>      <span class="hljs-string">&quot;/api3&quot;</span>: &#123;<br>        <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;http://www.hahaha3.com&#x27;</span>,<br>        <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">pathRewrite</span>: &#123;<span class="hljs-string">&#x27;^/api3&#x27;</span> : <span class="hljs-string">&#x27;&#x27;</span>&#125;<br>      &#125;<br>      <span class="hljs-comment">// ...</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，在本地配置代理跨域，只是解决开发时的跨域问题，当你的项目上线时，前端静态文件和后端在一个域下没有问题，如果并不在一个域下，依然会报跨域错误，这个时候还得需要后端配置跨域</p><h4 id="Node实现代理服务器"><a href="#Node实现代理服务器" class="headerlink" title="Node实现代理服务器"></a>Node实现代理服务器</h4><p>这里我们使用 <code>express + http-proxy-middleware</code> 来搭建一个代理服务器，使用 <code>http-proxy-middleware</code> 这个中间件没有别的意思，只是因为 <code>webpack-dev-server</code> 里就是使用的它</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-keyword">let</span> proxy = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http-proxy-middleware&#x27;</span>)<br><span class="hljs-keyword">let</span> app = express()<br><br>app.use(<span class="hljs-string">&#x27;/&#x27;</span>, proxy(&#123;<br>    <span class="hljs-comment">// 代理跨域目标接口</span><br>    <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;http://www.hahaha1.com:9999&#x27;</span>,<br>    <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>,<br><br>    <span class="hljs-comment">// 修改响应头信息，实现跨域并允许带cookie</span><br>    <span class="hljs-attr">onProxyRes</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">proxyRes, req, res</span>) </span>&#123;<br>        res.header(<span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="hljs-string">&#x27;http://www.hahaha.com&#x27;</span>)<br>        res.header(<span class="hljs-string">&#x27;Access-Control-Allow-Credentials&#x27;</span>, <span class="hljs-string">&#x27;true&#x27;</span>)<br>    &#125;,<br><br>    <span class="hljs-comment">// 修改响应信息中的cookie域名，为false时，表示不修改</span><br>    <span class="hljs-attr">cookieDomainRewrite</span>: <span class="hljs-string">&#x27;www.hahaha.com&#x27;</span><br>&#125;))<br><br>app.listen(<span class="hljs-number">3000</span>)<br></code></pre></td></tr></table></figure><h3 id="No-9-WebSocket跨域"><a href="#No-9-WebSocket跨域" class="headerlink" title="No.9 WebSocket跨域"></a>No.9 WebSocket跨域</h3><h4 id="WebSocket简介"><a href="#WebSocket简介" class="headerlink" title="WebSocket简介"></a>WebSocket简介</h4><p><code>WebSocket</code> 是一种在单个 TCP 连接上进行全双工通信的协议，2008年诞生，2011年被 IETF 定为标准 <code>RFC 6455</code>，并由 <code>RFC7936</code> 补充规范，<code>WebSocket API</code> 也被 W3C 定为标准</p><p><code>WebSocket</code> 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据， 在 <code>WebSocket API</code> 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输，同时，它也是跨域的一种解决方案</p><h4 id="WebSocket特点"><a href="#WebSocket特点" class="headerlink" title="WebSocket特点"></a>WebSocket特点</h4><ul><li><p>建立在 TCP 协议之上，服务器端的实现比较容易</p></li><li><p>与 HTTP 协议有着良好的兼容性，默认端口也是 80 和 443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器</p></li><li><p>数据格式比较轻量，性能开销小，通信高效</p></li><li><p>可以发送文本，也可以发送二进制数据</p></li><li><p>没有同源限制，客户端可以与任意服务器通信</p></li><li><p>协议标识符是 <code>ws</code>（如果加密，则为 <code>wss</code> ），服务器网址就是 URL</p></li></ul><p>如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">ws://www.hahaha.com:80/abc/def<br></code></pre></td></tr></table></figure><h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h4><p>每个服务端语言对 <code>websocket</code> 有相应的支持，写法不同罢了，这里我们使用 <code>Node</code> 做示例</p><p>在客户端我们可以直接使用 HTML5 的 <code>websocket API</code> ，服务端也可以使用 <code>nodejs-websocket</code> 实现 <code>websocket server</code> ，但是不建议这样做，因为原生 <code>WebSocket API</code> 使用起有些复杂，在浏览器的兼容性上还不够理想，所以我们使用 <code>Socket.io</code>，它很好地封装了 <code>webSocket</code> 接口，提供了更简单、灵活的接口，也对不支持 <code>webSocket</code> 的浏览器提供了向下兼容，使用 <code>Socket.io</code> 库实现 <code>websocket</code>，在发送数据时可以直接发送可序列化的对象，也可以自定义消息，利用事件字符串来区分不同消息，整个开发过程会舒服很多</p><p>想要了解更多看官网即可 <a href="https://socket.io/">Socket.io - 传送门</a> ，我们来看示例</p><p>客户端：<code>http://www.hahaha.com/a.html</code> </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/socket.io/socket.io.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">  <span class="hljs-keyword">let</span> socket = io.connect(<span class="hljs-string">&#x27;http://www.hahaha1.com:3000&#x27;</span>)</span><br><span class="javascript">  </span><br><span class="javascript">  socket.on(<span class="hljs-string">&#x27;my event&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;</span><br><span class="javascript">    <span class="hljs-built_in">console</span>.log(data) <span class="hljs-comment">// &#123; hello: &#x27;world&#x27; &#125;</span></span><br><span class="javascript">    </span><br><span class="javascript">    socket.emit(<span class="hljs-string">&#x27;my other event&#x27;</span>, &#123; <span class="hljs-attr">my</span>: <span class="hljs-string">&#x27;data&#x27;</span> &#125;)</span><br><span class="javascript">  &#125;)</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>服务端：<code>http://www.hahaha1.com:3000</code> </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> app = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>).createServer()<br><span class="hljs-keyword">const</span> io = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;socket.io&#x27;</span>)(app)<br><br>app.listen(<span class="hljs-number">3000</span>)<br><br>io.on(<span class="hljs-string">&#x27;connection&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;<br>  socket.emit(<span class="hljs-string">&#x27;my event&#x27;</span>, &#123; <span class="hljs-attr">hello</span>: <span class="hljs-string">&#x27;world&#x27;</span> &#125;)<br>  <br>  socket.on(<span class="hljs-string">&#x27;my other event&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(data) <span class="hljs-comment">// &#123; my: &#x27;data&#x27; &#125;</span><br>  &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><p>如上所示，使用了 <code>Socket.io</code> 之后的 <code>websocket</code> 连接是不是超级简单呢，跟着文档自己动手试试吧</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>欢迎大家关注公众号「不正经的前端」，时不时发一篇文章，也没有花里胡哨的推广和广告，希望可以让大家随意点开一篇文章，都可以看到满满的干货，也可以直接加机器人好友备注「加群 | 前端 | 后端 | 全栈」自动通过，通过后回复「加群」加入Web圈交流群，闲聊、吐槽、解决问题、交朋友都可以，当然技术为主</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20200713004935853.png"></p><p>按照时间线贴下了总结的比较全的几个帖子，还有其他的琐碎的文章，比较多就不贴了，这些文章都写的差不多，可能之间有互相抄袭，有互相借鉴，这些都是避免不了的，此文写的时候也借鉴了这些文章，只不过我手敲了一遍例子，又用我自己的理解码下来了，为此花了1周的业余时间，内容上与下面作者写的有些许雷同，那实属无奈，可以说是知识点就那么多，大家的总结稍有不同的地方就剩表达的语法，我也难受，还特意找了工具鉴别了下相似度，以免被误会，毕竟我也特别反感搬运工，嗯，又是一个深夜，终于收工了，睡觉喽</p><blockquote><p>参考文章</p><p><a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html">浏览器同源政策及其规避方法 - 阮一峰</a> - 2016.04</p><p><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html">跨域资源共享 CORS 详解 - 阮一峰 </a> - 2016.04</p><p><a href="https://segmentfault.com/a/1190000007326671">前端跨域整理 - 思否 damonare</a> - 2016.10</p><p><a href="https://segmentfault.com/a/1190000011145364">前端常见跨域解决方案（全）- 思否 安静de沉淀</a>  - 2017.07</p><p><a href="https://juejin.im/post/5a2f92c65188253e2470f16d#heading-18">正确面对跨域，别慌 - 掘金 Neal_yang </a> - 2017.12</p><p><a href="https://juejin.im/post/5c23993de51d457b8c1f4ee1">九种跨域方式实现原理（完整版）- 掘金 浪里行舟 </a> - 2019.01</p><p><a href="https://juejin.im/post/5d1ecb96f265da1b6d404433">9种常见的前端跨域解决方案（详解）- 掘金 小铭子</a> - 2019.07</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Web相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>浏览器</tag>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「一道面试题」输入URL到渲染全面梳理下-总结篇</title>
    <link href="/blog/2020/05/08/mianshi/%E3%80%8C%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98%E3%80%8D%E8%BE%93%E5%85%A5URL%E5%88%B0%E6%B8%B2%E6%9F%93%E5%85%A8%E9%9D%A2%E6%A2%B3%E7%90%86%E4%B8%8B-%E6%80%BB%E7%BB%93%E7%AF%87/"/>
    <url>/blog/2020/05/08/mianshi/%E3%80%8C%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98%E3%80%8D%E8%BE%93%E5%85%A5URL%E5%88%B0%E6%B8%B2%E6%9F%93%E5%85%A8%E9%9D%A2%E6%A2%B3%E7%90%86%E4%B8%8B-%E6%80%BB%E7%BB%93%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h2 id="要知道"><a href="#要知道" class="headerlink" title="要知道"></a>要知道</h2><p>此文是一道面试题，又不仅仅是一道面试题，你会发现，这题不论大厂小厂，都会问，为什么</p><p>因为它足够经典，连续写了三篇帖子，每篇都上万字，依然感觉不够细，涉及的点真的很考验一个人的知识覆盖率，还是多方面的考验，如果让我来面试的话，我觉得完全可以通过这一道题挖掘出面试者的基础知识储备量，延展性更是超强</p><p>SO，答好它可以让面试官眼前一亮，让你与众不同</p><p>此文是总结篇，没有看过前两篇的小伙伴建议先看看，然后自己总结总结，再来看这篇，因为前两文是为了能够看懂此文才写的</p><p><a href="https://juejin.im/post/5e9c48b2f265da47c558566b">「一道面试题」输入URL到渲染全面梳理上-网络通信篇</a> </p><p><a href="https://juejin.im/post/5e9f1db86fb9a03c85463560">「一道面试题」输入URL到渲染全面梳理中-页面渲染篇</a> </p><p>如果你都看过了，那就来一块总结吧，首先，还请为我的疯狂码字点个赞再看哦，最近打字速度都快了不少 😄</p><h2 id="回顾？"><a href="#回顾？" class="headerlink" title="回顾？"></a><del>回顾</del>？</h2><p>本来这块儿会简单回顾下前两文知识点再进行总结的，还有一个思维导图，原本已经写的差不多了，大概有个1万字了，后来写着写着被我删了大半重新写了</p><p>因为某天心血来潮，想把整篇文章换成一面试的问答帖，写帖嘛，我比较喜欢 <code>认真且随心所欲</code> ，就删了重来了，所以此文才会慢了些</p><p>下文会以一个面试官和面试者问答的过程来描述这些个问题，主体问题答完之后还会有一些比较常见的主体发散的问题，最近得空看完了电视剧 <code>鬓边不是海棠红</code> ，看的说话都有点被带跑偏了，用剧中 <code>老北京腔</code> 来说就是 <code>得，您瞧好吧！😄</code> ，好了，调侃完毕，开始正经了，干巴巴的万字小文来了，做好准备哦</p><p>首先请带入你自己，你就是一个面试者，仔细看每道题，先静心想一会，然后在心中回答，最后再看总结的答案 ( <strong>此答案也不一定对，个人感悟，只给大家做参考，也望大家给予补充或指正</strong> ) </p><h2 id="问-主体-：输入URL到页面渲染都经历了什么？"><a href="#问-主体-：输入URL到页面渲染都经历了什么？" class="headerlink" title="问(主体)：输入URL到页面渲染都经历了什么？"></a>问(主体)：输入URL到页面渲染都经历了什么？</h2><p><code>个人觉得</code> ，不要急着回答，先思考30秒，在心中形成一个大致步骤的轮廓，先概括，然后再慢慢道来，注意节奏，中间也可以短暂停顿思考，面试官不会因为你想了一会就 <code>pass</code> 掉你，相反，你直接脱口而出一堆内容，会让面试官觉得你像是背课文</p><p>对于主体问题，写了两种回答，觉得需要注意两点来选择性回答，至少我这么觉得</p><p><strong>面试官的状态</strong> </p><p>大致判断面试官是一个什么样的人，注意面试官这个人的状态，这很重要，通过对面试官当时状态的判断来决定精简回答或是轰炸式回答，这里的轰炸式回答不是说越多越好，说的是我们在回答的时候顺带牵出一些知识点来证明我们的知识量，但是不管怎样回答都要回答在点上，不要认为答得越多越好就扯一些有的没的，这大概就是察言观色吧</p><p><strong>你的状态</strong> </p><p>你的状态就比较容易理解了，如果你对一些知识点掌握不牢靠或有些紧张，这个时候就不要死撑还争取回答的面面俱到了 (面试官面前不太懂硬装做什么都懂，容易引起些许反感)，尽量精简，把你熟的地方多说一点，这样可以对面试官进行一个暗示引导，然后等待让面试官发散问你，通常你哪里说的多，面试官就会往哪个方向发散，如果你足够自信，那就尽情说好了，不在意他的发散，只要不说没用的就👌，绝大多数面试官对于这种情况应该都会喜欢</p><h3 id="一本正经的轰炸式回答"><a href="#一本正经的轰炸式回答" class="headerlink" title="一本正经的轰炸式回答"></a>一本正经的轰炸式回答</h3><p>面试官你好，这个问题是一个经典问题，我业余时间也有仔细阅读过一些相关书籍，做过一些总结，因为涉及到的知识点很多，所以可能会花一些时间，如果中间您有什么问题或者我的回答有不正确，还请您随时打断我，为我指出错误，谢谢</p><p>我觉得从URL输入到页面渲染大体上可以分为<code>网络通信</code> 和 <code>页面渲染</code> 两个阶段</p><p>首先是网络通信阶段，在互联网中网络设备之间的通信都会遵循 <code>TCP/IP四层协议</code>，通过 <code>TCP/IP</code> 网络分层顺序与对方进行通信，分层由高到低分别为：应用层、传输层、网络层、数据链路层，我们浏览器输入URL也就是发送端会从 <code>应用层</code> 往下走，接收端也就是服务器会从 <code>数据链路层</code> 往上走，通常我们会用五层协议来解释，数据链路层这一层会分成物理层和数据链路层两层</p><h4 id="浏览器输入URL"><a href="#浏览器输入URL" class="headerlink" title="浏览器输入URL"></a>浏览器输入URL</h4><p>输入URL按下回车后，就进入了 <code>应用层</code> 开始往下走，浏览器会开一个线程来处理，先对URL进行解析，一般包括 ( 协议头、主机域名或IP地址、端口号、请求路径、查询参数、hash等等 )，然后打开网络线程发出一个完整的请求</p><h4 id="应用层DNS解析域名"><a href="#应用层DNS解析域名" class="headerlink" title="应用层DNS解析域名"></a>应用层DNS解析域名</h4><p>这其中DNS解析，也就是 <code>域名或IP解析</code> 是因为我们输入的URL通常都是一个域名，计算机不认识域名只知道IP，所以需要DNS解析通过域名查询得到对应IP，对于DNS解析时</p><ul><li>首先会查看浏览器DNS缓存</li><li>没有的话就查询计算机本地DNS缓存</li><li>还没有就询问递归式DNS服务器（就是网络提供商，一般这个服务器都会有自己的缓存，所以IP查询大多都在这里完成）</li><li>如果依然没有缓存，那就需要通过 根域名服务器 和 TLD域名服务器 再到对应的 权威DNS服务器 找记录，并缓存到 递归式服务器，然后 递归服务器 再将记录返回给本地</li></ul><h4 id="应用层客户端发送HTTP请求"><a href="#应用层客户端发送HTTP请求" class="headerlink" title="应用层客户端发送HTTP请求"></a>应用层客户端发送HTTP请求</h4><p>IP地址有了，应用层的客户端想看页面，就会发一个 <code>HTTP</code> 请求，<code>HTTP</code> 请求分为 <code>请求报头</code> 和 <code>请求主体</code> ，请求主体就是客户端要发送给服务器或者服务器返回给客户端的内容，请求报头比较重要，包含通信方式也就是请求方法 (POST / GET / INPUT / DELETE等)、URI、协议版本号以及请求头部方法（Accept、Cache-Control…）</p><h4 id="传输层TCP传输报文"><a href="#传输层TCP传输报文" class="headerlink" title="传输层TCP传输报文"></a>传输层TCP传输报文</h4><p><code>应用层</code> 发送了一个请求后，为了传输方便，在 <code>传输层</code> 会把从 <code>应用层</code> 接收到的数据 ( 就是那个HTTP请求报文 ) 进行分割，并为每个报文编号后再转发给 <code>网络层</code>，编号就是方便服务器接收时能准确地还原报文信息，这里用到了我们常说的 <code>TCP协议</code> </p><p><code>TCP协议</code> 会通过 <code>三次握手</code> 保证传输的安全可靠，也可以这样说，客户端在 <code>传输层</code> 开始和服务器通过 <code>三次握手</code> 建立 <code>TCP/IP</code> 连接</p><p>所谓的 <code>三次握手</code> ，就是发送端先发送一个带有 <code>SYN</code> ( synchronize ) 标志的数据包给接收端，在一定的延迟时间内等待接收端的回复，接收端收到数据包后，传回一个带有 <code>SYN / ACK</code> 标志的数据包以表示传达确认信息，接收方收到后再发送一个带有 <code>ACK</code> 标志的数据包给接收端以表示握手成功，在这个过程中，如果发送端在规定延迟时间内没有收到回复则默认接收方没有收到请求，而再次发送，直到收到回复为止</p><p>也就是上一文说的</p><ul><li><p>小李 (客户端)：您好，您是xx的面试官吗？</p></li><li><p>面试官 (服务端)：嗯嗯，是的，你是昨天投简历的小李吗？</p></li><li><p>小李 (客户端)：嗯嗯，是的，我是</p></li></ul><h4 id="网络层IP协议查询MAC地址"><a href="#网络层IP协议查询MAC地址" class="headerlink" title="网络层IP协议查询MAC地址"></a>网络层IP协议查询MAC地址</h4><p>建立连接后 <code>网络层</code> IP协议会查询 <code>MAC地址</code> 进行数据包的传输</p><p>通俗来说，<code>IP协议</code> 负责把各种数据包传送给接收方，因为要保证确实能传输到对方，所以需要确定接收方的 <code>MAC地址</code> 也就是我们说的物理地址，<code>IP地址</code> 可以和 <code>MAC地址</code> 通过映射表一一配对上，一个网络设备的IP地址可以更换，但是MAC地址一般是固定不变的，而 <code>IP</code> 到 <code>MAC</code> 的解析过程则依赖于 <code>ARP协议</code>，它可以根据通信方的 <code>IP地址</code> 反查出对应的 <code>MAC地址</code> </p><p>因为一般通信双方是无法直接进行通信的（除非在同一局域网），会经过多台计算机或路由器来进行中转，所以也就需要 <code>ARP</code> 来一路确认下一个中转站，协助数据包的传输</p><h4 id="数据到达数据链路层"><a href="#数据到达数据链路层" class="headerlink" title="数据到达数据链路层"></a>数据到达数据链路层</h4><p>找到对方的 <code>MAC地址</code> 后，就会将数据发送到 <code>数据链路层</code>传输，到此客户端发送请求阶段就结束了</p><h4 id="服务器接收数据"><a href="#服务器接收数据" class="headerlink" title="服务器接收数据"></a>服务器接收数据</h4><p>而后接收端的服务器在 <code>数据链路层</code> 接收到数据包，再通过相反的方式将数据一层一层的还原回 <code>应用层</code> ，这过程中包括在运输层那里通过TCP协议将分段的数据包重新组成原来的HTTP请求报文</p><p>请求到了后台服务器，一般来说会有统一的验证，如安全验证、跨域验证等，验证未通过就直接返回相应的HTTP报文，验证通过后，就会进入后台代码，此时程序收到请求，然后会执行对应的操作</p><p>如果浏览器访问过，且缓存上有对应的资源，就会与服务器最后修改时间对比，一致便返回304，告诉浏览器可使用本地缓存</p><h4 id="服务器响应请求"><a href="#服务器响应请求" class="headerlink" title="服务器响应请求"></a>服务器响应请求</h4><p>服务器接收到客户端发送的HTTP请求后，会查找客户端请求的资源，并返回响应报文</p><p>另外现在很多网站都会有重定向功能，比如请求域名省去了 <code>www.</code>，它会给你重定向来添加上，这也就意味着第一次请求 <code>HTML</code> 的过程中我们是需要发起两次请求的</p><p>这样做的原因在于搜索引擎会认为 <code>www.xxx.com</code> 和 <code>xxx.com</code> 是两个网站，从而造成网站排名下降，还有如果两个地址都有打开过，会造成多余 ( 双倍 ) 的浏览器缓存</p><h4 id="服务器返回相应文件"><a href="#服务器返回相应文件" class="headerlink" title="服务器返回相应文件"></a>服务器返回相应文件</h4><p>请求成功后，服务器会返回相应的网页，浏览器接收到响应成功的报文后便开始下载网页，至此，网络通信结束</p><h4 id="解析HTML构建DOM-Tree"><a href="#解析HTML构建DOM-Tree" class="headerlink" title="解析HTML构建DOM Tree"></a>解析HTML构建DOM Tree</h4><p>拿到服务器返回的网页后，首先，根据顶部定义的DTD类型进行对应的解析方式，网页的解析将会被交给内部的GUI渲染线程处理</p><p>渲染线程中的HTML解释器，将HTML网页和资源从字节流解释转换成字符流，再通过词法分析器将字符流解释成词，之后经过语法分析器根据词构建成节点，最后通过这些节点组建一个DOM树</p><p>这个过程中，如果遇到的节点是 JS 代码，就会调用 <code>JS引擎</code> 对 JS代码进行解释执行，此时由于 <code>JS引擎</code> 和 <code>GUI渲染线程</code> 的互斥，<code>GUI渲染线程</code> 就会被挂起，渲染过程停止，如果 JS 代码的运行中对DOM树进行了修改，那么DOM的构建需要从新开始</p><p>如果节点需要依赖其他资源，图片/CSS等等，就会调用网络模块的资源加载器来加载它们，它们是异步的，不会阻塞当前DOM树的构建</p><p>如果遇到的是 JS 资源URL（没有标记异步），则需要停止当前DOM的构建，直到 JS 的资源加载并被 <code>JS引擎</code> 执行后才继续构建DOM</p><h4 id="解析CSS构建CSSOM-Tree"><a href="#解析CSS构建CSSOM-Tree" class="headerlink" title="解析CSS构建CSSOM Tree"></a>解析CSS构建CSSOM Tree</h4><p>CSS解释器会将CSS文件解释成内部表示结构，生成CSS规则树，这个过程也是和DOM解析类似的，<code>CSS</code> 字节转换成字符，接着词法解析与法解析，最后构成 <code>CSS对象模型(CSSOM)</code> 的树结构</p><p>构建的过程中浏览器得递归 <code>DOM</code> 树来确定元素到底是什么样式，为了 <code>CSSOM</code> 的完整性，只有等构建完毕才能进入到下一个阶段，所以就算 <code>DOM</code> 已经构建完了，也得等 <code>CSSOM</code>，然后才能进入下一个阶段</p><h4 id="构建渲染树-Render-Tree"><a href="#构建渲染树-Render-Tree" class="headerlink" title="构建渲染树 (Render Tree)"></a>构建渲染树 (Render Tree)</h4><p>接着 <code>CSSOM 树</code>和 <code>DOM 树</code> 合并成渲染树，也叫呈现树，<code>渲染树</code> 只包含渲染网页所需的节点，然后用于计算每个可见元素的布局，并输出给绘制流程，将像素渲染到屏幕上</p><h4 id="布局-Layout"><a href="#布局-Layout" class="headerlink" title="布局 (Layout)"></a>布局 (Layout)</h4><p><code>渲染树</code> 同时包含了屏幕上的所有可见内容及其样式信息，有了渲染树，再接着就会进入布局 ( layout ) 阶段了，到目前为止，浏览器计算了哪些节点应该是可见的以及它们的计算样式，但还没有计算它们在设备视口内的确切位置和大小，这就是 <code>布局</code> ( Layout ) 阶段，也称为 <code>自动重排</code> 或 <code>回流</code> ( Reflow )</p><p>此阶段一般意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树</p><h4 id="绘制-Painting"><a href="#绘制-Painting" class="headerlink" title="绘制 (Painting)"></a>绘制 (Painting)</h4><p>经由前几步我们知道了哪些节点可见、它们的计算样式以及几何信息，将这些信息及渲染树中的每个节点转换成屏幕上的实际像素，也就是俗称的 <code>绘制</code> 或 <code>栅格化</code> 阶段</p><h4 id="合成-Composite"><a href="#合成-Composite" class="headerlink" title="合成(Composite)"></a>合成(Composite)</h4><p>最后一步合成( <code>composite</code> )，这一步骤浏览器会将各层信息发送给GPU，GPU将各层合成，显示在屏幕上</p><p>至此上述的内容就是我理解的一个URL从解析到渲染的生命历程了</p><h3 id="干净简洁的概括式回答"><a href="#干净简洁的概括式回答" class="headerlink" title="干净简洁的概括式回答"></a>干净简洁的概括式回答</h3><p>PS：这里大体的点我觉得还是要答出来的，可以根据自己的了解进行某些方面的扩展，至少我觉得是这样子的，也是个人理解，欢迎探讨</p><p>面试管你好，URL输入到页面渲染，这是一个经典的话题，涉及的知识点也很多，我按照我的个人理解给您简单概括下，有不对的地方还请您指出</p><p>首先，客户端浏览器输入URL，由于是域名，应用层DNS开始解析域名</p><p>接着，应用层客户端发送一个HTTP请求，把拿到的应用层HTTP请求报文数据分割编号，为了方便安全的传输，传输层会通过TCP三次握手建立TCP/IP链接</p><p>建立连接后 <code>网络层</code> IP协议会查询服务器 <code>MAC地址</code> 也就是物理地址进行数据包的传输</p><p>找到对方的 <code>MAC地址</code> 后，将数据发送到 <code>数据链路层</code>传输，到此客户端发送请求阶段结束</p><p>接收端的服务器在 <code>数据链路层</code> 接收到数据包，再通过相反的方式将数据一层一层的还原回 <code>应用层</code> </p><p>服务器接收到客户端发送的HTTP请求后，会查找客户端请求的资源，并返回响应报文</p><p>请求成功后，服务器会返回相应的网页，浏览器接收到响应成功的报文后便开始下载网页，至此，网络通信结束</p><p>浏览器拿到网页文件后，首先根据顶部定义的DTD类型进行对应解析方式，网页解析会交给内部GUI渲染线程处理</p><p>接着构建DOM树和CSSOM树，过程中，如果遇到节点是 JS ，就会调用 <code>JS引擎</code> 对 JS代码进行解释执行，此时由于 <code>JS引擎</code> 和 <code>GUI渲染线程</code> 互斥，<code>GUI渲染线程</code> 会被挂起，渲染过程停止，如果 JS 代码的运行中对DOM树进行了修改，那么DOM构建要从新开始，然后DOM树和CSSOM树构建为渲染树</p><p>然后进入布局阶段，计算渲染树节点在设备视口内的确切位置和大小</p><p>再接着将渲染树中每个节点转换成屏幕上的实际像素，也就是绘制阶段</p><p>最后的合成阶段浏览器会将各层信息发送给GPU，GPU将各层合成，显示在屏幕上</p><h2 id="问：TCP-IP四、五层，OSI七层模型有什么区别？"><a href="#问：TCP-IP四、五层，OSI七层模型有什么区别？" class="headerlink" title="问：TCP/IP四、五层，OSI七层模型有什么区别？"></a>问：TCP/IP四、五层，OSI七层模型有什么区别？</h2><p>网络层次可划分为 <code>四层因特网协议栈</code> 和 <code>七层因特网协议栈</code> ，起初网络分层是标准的七层，也就是我们所说的 <code>OSI 七层模型</code> ，参考模型是国际标准化组织 <code>ISO</code> 制定的一个用于计算机或通信系统间互联的标准体系，一般称为 <code>OSI参考模型</code> 或 <code>七层模型</code> </p><p>所谓的 <code>TCP/IP 四层模型</code> 和 <code>TCP/IP 五层模型</code> 是以 <code>OSI 七层</code> 优化而来，把某些层进行合并了，本质上还是相同的，<code>OSI七层模型</code> 太过细化，有一定的参考意义，但实现起来比较繁琐，相比较而言，<code>TCP/IP模型</code> 比较简洁，具有较强的实际应用价值</p><p><code>TCP/IP</code> 将计算机网络分成了四个层次，一般资料或教程里都是结合 <code>OSI7层模型</code> 和 <code>TCP/IP4层模型</code>，将计算机网络按照5层的模型来讲，5层模型只是为了方便介绍计算机网络原理而设计的，而在实际应用中还是 <code>TCP/IP四层模型</code> </p><p>各层对应关系如下</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20200507215523088.png"></p><h2 id="问：DNS解析可优化吗，为什么优化又怎样优化？"><a href="#问：DNS解析可优化吗，为什么优化又怎样优化？" class="headerlink" title="问：DNS解析可优化吗，为什么优化又怎样优化？"></a>问：DNS解析可优化吗，为什么优化又怎样优化？</h2><h3 id="是否"><a href="#是否" class="headerlink" title="是否"></a>是否</h3><p>可以优化</p><h3 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h3><p>用户打开网站的整个流程中，DNS解析是第一环，当用户输入域名并敲回车后，系统调用 <code>DNS客户端</code>，寻找到用户配置或者自动分配的<code>DNS IP</code>，之后就开始整个解析过程，<code>DNS服务器</code> 完成解析到此域名的 <code>数字IP服务器</code>，一般情况下返回给定域名对应的IP地址会花费 <code>20~120毫秒</code> 的时间，而且在这个过程中浏览器什么都不会做直到DNS查询完毕</p><p>一旦解析完成，连接建立并保持，也就是顺利的访问以后，网页以后的下载速度就和DNS没关系了，直到下一次重新解析和发起访问请求</p><p>很多小型网站，DNS解析时间都接近 <code>0.5s</code>，有些甚至需要 <code>1s</code> 左右才可以解析出结果，一般网站用户的等待时间超过 <code>8s</code> 就会放弃访问，而对于电子商务网站，<code>4s</code> 就是用户忍耐极限，而一般经过优化的小型网站，DNS解析时间都可以控制在 <code>200ms</code> 左右，而带宽在 <code>100M</code> 左右的网站，经过优化，DNS解析时间可以控制在 <code>50~100ms</code> ，所以DNS优化还是很有必要的</p><h3 id="怎样"><a href="#怎样" class="headerlink" title="怎样"></a>怎样</h3><p><strong>DNS解析优化-善用缓存之TTL</strong> </p><p>DNS存在着多级缓存，每次找这么多级，很定耗时间，我们要尽量多的让用户直接从运营商的DNS缓存中拿到解析记录，这样就不需要走根域名服务器以下的这些过程，自然就节省了一些时间</p><p>购买域名做域名解析时，有一个 <code>TTL</code> 值，它指的是域名解析的生命周期 ( 秒为单位 )，简单来说它表示DNS服务器解析域名时记录在DNS服务器上的缓存时间，这个值的大小设置也是很有学问的，我们要在尽可能快的情况下又要保证当服务器出问题时能够尽快切换</p><ul><li>我们自己肯定清楚自己的服务器有没有多台或备份，若无备份，那服务器宕机时只能生抗，所以，<code>TTL</code> 时间对于你来说是越长越好，因为 <code>TTL</code> 短的目的是服务器发生问题时，可以及时切换，这个对于没有备份的网站基本利用不上，所以这时你的 <code>TTL</code> 设置就越长越好，当然了，也不能太长，一般设置 <code>TTL 3600</code> 即可</li><li>若有备份或多台服务器，会发生由于服务器宕机需要及时做切换，<code>TTL</code> 时间越短切换越及时，但是 <code>TTL</code> 时间越短，也就意味着运营商DNS经常缓存不住，一般用户，设置为 <code>TTL 600</code> 即可，如果对及时切换，要求特别苛刻的网站，设置 <code>TTL 120</code> 就行</li></ul><p><strong>DNS解析优化-负载均衡</strong> </p><p>在DNS服务器中为同一个主机名配置多个IP地址，在应答DNS查询时，DNS服务器对每个查询将以DNS文件中主机记录的IP地址按顺序返回不同的解析结果，将客户端的访问引导到不同的机器上去，使得不同的客户端访问不同的服务器，从而达到负载均衡的目的，可以根据每台机器的负载量或该机器离用户地理位置的距离入手</p><p>就像我们使用CDN厂商做域名解析，它也是利用DNS的重定向技术，DNS服务器会返回一个跟用户最接近的点的IP地址给用户，CDN节点的服务器负责响应用户的请求，提供所需的内容，CDN厂商的域名解析服务器用户量多被访问的次数也多，域名解析服务器的A记录基本上会被各地运营商的DNS一直缓存着，所以服务效果也是最好的</p><h2 id="问：TCP-IP协议与UDP协议优缺点及区别？"><a href="#问：TCP-IP协议与UDP协议优缺点及区别？" class="headerlink" title="问：TCP/IP协议与UDP协议优缺点及区别？"></a>问：TCP/IP协议与UDP协议优缺点及区别？</h2><p>首先请注意，这题目本身就是一个坑</p><p><code>TCP/IP协议</code> 是一个协议簇，它包括很多协议，<code>UDP协议</code> 只是其中的一个，之所以命名为 <code>TCP/IP协议</code>，是因为TCP和IP协议是两个很重要的协议，就用它两命名了，仅此而已，SO，这个题目是不正确的，正确的问法应该是TCP协议和UDP协议优缺点及区别 </p><p>你可能会说有面试官这样问吗？别说这抠字眼的题，还真有人因为忽略了这点被安排过 😄 </p><h2 id="问：TCP协议和UDP协议优缺点及区别？"><a href="#问：TCP协议和UDP协议优缺点及区别？" class="headerlink" title="问：TCP协议和UDP协议优缺点及区别？"></a>问：TCP协议和UDP协议优缺点及区别？</h2><p><strong>优缺点</strong> </p><p><code>TCP </code> 的优点： 稳定可靠， 这体现在TCP传递数据之前，会有三次握手来建立连接，且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约一些系统资源</p><p><code>TCP </code>的缺点：占用系统资源高，慢且效率低，TCP在传递数据之前，要先建连接，会消耗时间，在数据传递时，确认机制、重传机制、拥塞控制机制等都会消耗大量的时间，而且要在每台设备上维护所有的传输连接，每个连接都会占用系统的CPU、内存等硬件资源</p><p><code>UDP </code> 的优点： 快，UDP是一个无状态的传输协议，所以它在传递数据时非常快</p><p><code>UDP</code> 的缺点： 不可靠，不稳定，因为UDP没有TCP那些可靠的机制，在数据传递时，如果网络质量不好，就会很容易丢包</p><p>一般当我们对网络通讯质量有要求的时候，就应该使用TCP，要把整个数据准确无误的传递给对方，比如HTTP、HTTPS、FTP等协议，当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用UDP，如语音，视频等</p><p><strong>区别</strong> </p><ul><li><p>TCP协议基于连接UDP协议无连接</p></li><li><p>TCP协议面向字节流，简单说TCP把数据看成一连串无结构的字节流而UDP协议面向报文</p></li><li><p>TCP协议传送数据，无差错不丢失不重复，且按序到达，UDP不保证可靠交付和顺序，可能丢包</p></li><li><p>TCP首部开销20字节，UDP的首部开销较小，只有8个字节</p></li><li><p>TCP协议连接只能是点到点的，UDP支持一对一，一对多，多对一和多对多的交互通信</p></li></ul><h2 id="问：简单介绍下TCP三次握手四次挥手？"><a href="#问：简单介绍下TCP三次握手四次挥手？" class="headerlink" title="问：简单介绍下TCP三次握手四次挥手？"></a>问：简单介绍下TCP三次握手四次挥手？</h2><p><strong>三次握手 ( 网图侵删 )</strong></p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20200508171840510.png"></p><p><strong>PS：</strong>请认真看图并配合下面文字理解</p><p>开始时，双端处于 <code>CLOSE (关闭状态) </code>，服务端要提供服务，会主动监听某个端口，进入 <code>LISTEN (监听状态) </code></p><p>客户端主动发送连接的SYN包，之后进入 <code>SYN-SENT (同步已发送状态)</code> </p><p>服务端在收到客户端发来的SYN包后，回复SYN/ACK包，之后进入 <code>SYN-RCVD (同步收到状态)</code></p><p>客户端收到服务端发来的SYN/ACK包后，确认对方后回复ACK包，并进入 <code>ESTABLISHED (已建立连接状态)</code></p><p>当服务器收到客户端的确认后也进入 <code>ESTABLISHED (已建立连接状态)</code> ，此后双方就可以开始通信了</p><p><strong>四次挥手 ( 网图侵删 )</strong></p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20200508172006324.png"></p><p><strong>PS：</strong>请认真看图并配合下面文字理解</p><p>开始时双端还都处于 <code>ESTABLISHED (已建立连接状态)</code> 并传输数据，某一端可以主动发起 FIN 包准备断开连接，上图为客户端发起 FIN 请求，在发出FIN后，客户端进入 <code>FIN-WAIT-1 (终止等待状态1)</code></p><p>服务端收到 FIN 消息后，回复 ACK 表示知道了，并从<code> ESTABLISHED (已建立连接状态)</code>进入 <code>CLOSED-WAIT (关闭等待状态)</code>，开始做一些断开连接前的准备工作</p><p>客户端收到之前FIN的回复 ACK 消息后，进入 <code>FIN-WAIT-2  (终止等待状态2)</code>，当服务端做好断开前的准备工作后，也会发送一个 FIN/ACK 的消息給客户端，表示我也好了，请求断开连接，并在发送消息后，服务端进入 <code>LAST-ACK (最后确认状态)</code></p><p>客户端在收到 FIN/ACK 消息后，会立即回复 ACK ，表示知道了，并进入 <code>TIME_WAIT ( 时间等待状态)</code>，为了稳定和安全考虑，客户端会在 <code>TIME-WAIT ( 时间等待状态)</code> 等待 2MSL ( 最长报文段寿命 ) 的时长，最终进入 <code>CLOSED ( 关闭状态 )</code></p><p>服务端收到客户端回复的 ACK 消息后，直接从 <code>LAST-ACK (最后确认状态)</code> 状态进入 <code>CLOSED ( 关闭状态 )</code></p><p>四次挥手之后，双端都进入 <code>CLOSED ( 关闭状态 )</code>，在此之后，双端正式断开了连接</p><p><strong>PS：</strong>  MSL ( Maximum Segment Lifetime ) 为 <code>最长报文段寿命</code>，它指的是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃，TCP允许不同的实现可以设置不同的 MSL 值</p><h2 id="问：为什么建立连接是三次握手，关闭连接确是四次挥手？"><a href="#问：为什么建立连接是三次握手，关闭连接确是四次挥手？" class="headerlink" title="问：为什么建立连接是三次握手，关闭连接确是四次挥手？"></a>问：为什么建立连接是三次握手，关闭连接确是四次挥手？</h2><p>建立连接的时候， 服务器在  <code>LISTEN (监听状态) </code> ，收到建立连接请求的 SYN 报文后，把 ACK 和 SYN 放在一个报文里发送给客户端就可以了</p><p>而关闭连接时，服务器收到对方的 FIN 报文时，仅代表对方不再发送数据了但是还能接收数据，而自己未必全部数据都发送给对方了，所以自己可以立即关闭，也可以发送一些数据给对方后，再发送 FIN 报文给对方来表示同意现在关闭连接，因此，己方 ACK 和 FIN 一般都会分开发送，从而导致多了一次</p><h2 id="问：为什么要三次握手创建链接，最后一次确认有必要吗？"><a href="#问：为什么要三次握手创建链接，最后一次确认有必要吗？" class="headerlink" title="问：为什么要三次握手创建链接，最后一次确认有必要吗？"></a>问：为什么要三次握手创建链接，最后一次确认有必要吗？</h2><p>防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误</p><p>如果使用两次握手建立连接，假如客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于 TCP 的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，然后客户端和服务器经过两次握手完成连接，传输数据后关闭连接，此时之前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手机制就会让客户端和服务器再次建立连接，会导致不必要的错误和资源的浪费</p><p>采用三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认，由于服务器收不到确认，就会知道客户端并没有请求连接</p><p>为什么不用四次握手就更简单了，三次就可以创建安全无误的连接为什么用四次，那不是浪费资源嘛</p><h2 id="问：三次握手过程中可以携带数据吗？"><a href="#问：三次握手过程中可以携带数据吗？" class="headerlink" title="问：三次握手过程中可以携带数据吗？"></a>问：三次握手过程中可以携带数据吗？</h2><p>第一次、第二次握手不可以携带数据，因为一握二握时还没有建立连接，会让服务器容易受到攻击</p><p>而第三次握手，此时客户端已经处于 <code>ESTABLISHED (已建立连接状态)</code> ，对于客户端来说，已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据也是没问题的</p><h2 id="问：四次挥手为什么客户端最后还要等待2MSL？"><a href="#问：四次挥手为什么客户端最后还要等待2MSL？" class="headerlink" title="问：四次挥手为什么客户端最后还要等待2MSL？"></a>问：四次挥手为什么客户端最后还要等待2MSL？</h2><p>第一，保证客户端发送的最后一个 ACK 报文能够到达服务器，因为这个 ACK 报文可能丢失，站在服务器的角度看来，我已经发送了 <code>FIN+ACK</code> 报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个 2MSL 时间段内收到这个重传的报文，接着给出回应报文，并且会重启 2MSL 计时器</p><p>第二，比如上面提到了的 <code>已经失效的连接请求报文段</code> 出现在连接中这种状况，客户端发送完最后一个确认报文后，在这个 2MSL 时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，这样新连接中就不会出现旧连接的请求报文</p><h2 id="问：如果已经建立了连接，但客户端突然故障怎么办？"><a href="#问：如果已经建立了连接，但客户端突然故障怎么办？" class="headerlink" title="问：如果已经建立了连接，但客户端突然故障怎么办？"></a>问：如果已经建立了连接，但客户端突然故障怎么办？</h2><p>TCP 还设有一个保活计时器，客户端如果出现故障，服务器总不能一直等下去，白白浪费资源啊，服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时</p><p>若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，然后每隔75秒就会再发送一次，10次探测报文后仍然没反应的话，服务器就认为客户端出了故障，接着就关闭连接</p><h2 id="问：HTTP-的请求方法？"><a href="#问：HTTP-的请求方法？" class="headerlink" title="问：HTTP 的请求方法？"></a>问：HTTP 的请求方法？</h2><p>HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD方法</p><p>HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法</p><table><thead><tr><th align="left">序号</th><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">GET</td><td align="left">请求指定的页面信息，并返回实体主体</td></tr><tr><td align="left">2</td><td align="left">HEAD</td><td align="left">类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头</td></tr><tr><td align="left">3</td><td align="left">POST</td><td align="left">向指定资源提交数据进行处理请求 ( 例如提交表单或者上传文件 )，数据被包含在请求体中，POST 请求可能会导致新的资源的建立和/或已有资源的修改</td></tr><tr><td align="left">4</td><td align="left">PUT</td><td align="left">从客户端向服务器传送的数据取代指定的文档的内容</td></tr><tr><td align="left">5</td><td align="left">DELETE</td><td align="left">请求服务器删除指定的页面</td></tr><tr><td align="left">6</td><td align="left">CONNECT</td><td align="left">HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器</td></tr><tr><td align="left">7</td><td align="left">OPTIONS</td><td align="left">允许客户端查看服务器的性能</td></tr><tr><td align="left">8</td><td align="left">TRACE</td><td align="left">回显服务器收到的请求，主要用于测试或诊断</td></tr><tr><td align="left">9</td><td align="left">PATCH</td><td align="left">是对 PUT 方法的补充，用来对已知资源进行局部更新</td></tr></tbody></table><h2 id="问：HTTP-状态码分别代表什么？"><a href="#问：HTTP-状态码分别代表什么？" class="headerlink" title="问：HTTP 状态码分别代表什么？"></a>问：HTTP 状态码分别代表什么？</h2><p>状态码有五类分别代表</p><ul><li><strong>1xx</strong>: 协议处理中状态，还需后续操作</li><li><strong>2xx</strong>: 成功状态</li><li><strong>3xx</strong>: 重定向状态，资源位置发生变动，需要重新请求</li><li><strong>4xx</strong>: 请求报文有误</li><li><strong>5xx</strong>: 服务器端错误</li></ul><p>详细状态码就不啰嗦了，直接 copy 菜鸟教程了一份，看一看吧，心中有个印象</p><table><thead><tr><th>状态码</th><th>英文名称</th><th>描述</th></tr></thead><tbody><tr><td>100</td><td>Continue</td><td>继续。客户端应继续其请求</td></tr><tr><td>101</td><td>Switching Protocols</td><td>切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</td></tr><tr><td></td><td></td><td></td></tr><tr><td>200</td><td>OK</td><td>请求成功。一般用于GET与POST请求</td></tr><tr><td>201</td><td>Created</td><td>已创建。成功请求并创建了新的资源</td></tr><tr><td>202</td><td>Accepted</td><td>已接受。已经接受请求，但未处理完成</td></tr><tr><td>203</td><td>Non-Authoritative Information</td><td>非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</td></tr><tr><td>204</td><td>No Content</td><td>无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td></tr><tr><td>205</td><td>Reset Content</td><td>重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</td></tr><tr><td>206</td><td>Partial Content</td><td>部分内容。服务器成功处理了部分GET请求</td></tr><tr><td></td><td></td><td></td></tr><tr><td>300</td><td>Multiple Choices</td><td>多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</td></tr><tr><td>301</td><td>Moved Permanently</td><td>永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td></tr><tr><td>302</td><td>Found</td><td>临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td></tr><tr><td>303</td><td>See Other</td><td>查看其它地址。与301类似。使用GET和POST请求查看</td></tr><tr><td>304</td><td>Not Modified</td><td>未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td></tr><tr><td>305</td><td>Use Proxy</td><td>使用代理。所请求的资源必须通过代理访问</td></tr><tr><td>306</td><td>Unused</td><td>已经被废弃的HTTP状态码</td></tr><tr><td>307</td><td>Temporary Redirect</td><td>临时重定向。与302类似。使用GET请求重定向</td></tr><tr><td></td><td></td><td></td></tr><tr><td>400</td><td>Bad Request</td><td>客户端请求的语法错误，服务器无法理解</td></tr><tr><td>401</td><td>Unauthorized</td><td>请求要求用户的身份认证</td></tr><tr><td>402</td><td>Payment Required</td><td>保留，将来使用</td></tr><tr><td>403</td><td>Forbidden</td><td>服务器理解请求客户端的请求，但是拒绝执行此请求</td></tr><tr><td>404</td><td>Not Found</td><td>服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</td></tr><tr><td>405</td><td>Method Not Allowed</td><td>客户端请求中的方法被禁止</td></tr><tr><td>406</td><td>Not Acceptable</td><td>服务器无法根据客户端请求的内容特性完成请求</td></tr><tr><td>407</td><td>Proxy Authentication Required</td><td>请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</td></tr><tr><td>408</td><td>Request Time-out</td><td>服务器等待客户端发送的请求时间过长，超时</td></tr><tr><td>409</td><td>Conflict</td><td>服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突</td></tr><tr><td>410</td><td>Gone</td><td>客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</td></tr><tr><td>411</td><td>Length Required</td><td>服务器无法处理客户端发送的不带Content-Length的请求信息</td></tr><tr><td>412</td><td>Precondition Failed</td><td>客户端请求信息的先决条件错误</td></tr><tr><td>413</td><td>Request Entity Too Large</td><td>由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</td></tr><tr><td>414</td><td>Request-URI Too Large</td><td>请求的URI过长（URI通常为网址），服务器无法处理</td></tr><tr><td>415</td><td>Unsupported Media Type</td><td>服务器无法处理请求附带的媒体格式</td></tr><tr><td>416</td><td>Requested range not satisfiable</td><td>客户端请求的范围无效</td></tr><tr><td>417</td><td>Expectation Failed</td><td>服务器无法满足Expect的请求头信息</td></tr><tr><td></td><td></td><td></td></tr><tr><td>500</td><td>Internal Server Error</td><td>服务器内部错误，无法完成请求</td></tr><tr><td>501</td><td>Not Implemented</td><td>服务器不支持请求的功能，无法完成请求</td></tr><tr><td>502</td><td>Bad Gateway</td><td>作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</td></tr><tr><td>503</td><td>Service Unavailable</td><td>由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</td></tr><tr><td>504</td><td>Gateway Time-out</td><td>充当网关或代理的服务器，未及时从远端服务器获取请求</td></tr><tr><td>505</td><td>HTTP Version not supported</td><td>服务器不支持请求的HTTP协议的版本，无法完成处理</td></tr></tbody></table><h2 id="问：HTTP与HTTPS的区别？"><a href="#问：HTTP与HTTPS的区别？" class="headerlink" title="问：HTTP与HTTPS的区别？"></a>问：HTTP与HTTPS的区别？</h2><p>HTTP协议传输的数据都是未加密的，也就是明文的，所以使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了 <code>SSL（Secure Sockets Layer）</code> 协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS</p><p>简单来说，HTTPS协议是由 <code>SSL+HTTP</code> 协议构建的可进行加密传输、身份认证的网络协议，要比 HTTP 协议安全，更多HTTP和HTTPS内容请自行百度，这里就不长篇大论了</p><p>那么简单总结下有区别</p><ul><li><p>HTTPS协议需要到 CA 申请证书，一般免费证书较少，因而需要一定费用</p></li><li><p>HTTP是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 SSL 加密传输协议</p></li><li><p>HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443</p></li><li><p>HTTP的连接很简单，是无状态的，HTTPS协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比HTTP协议安全</p></li></ul><h2 id="问：什么是简单请求和非简单请求？"><a href="#问：什么是简单请求和非简单请求？" class="headerlink" title="问：什么是简单请求和非简单请求？"></a>问：什么是简单请求和非简单请求？</h2><p>CORS（cross-origin resource sharing），跨源资源共享，就是广大前端同学所说的跨域，想必大家都了解，不了解这也不做介绍了，不了解可以看 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS">HTTP访问控制（CORS）- MDN传送门</a>  😄</p><p>CORS中把请求定义为了两类</p><ul><li>简单请求</li><li>非简单请求</li></ul><p>那么什么是简单请求什么是非简单请求呢？其实也很简单，我们只需要知道什么是简单请求，其余的就都是非简单的了，而简单请求需要满足的条件是</p><ul><li>请求方式只能是GET、POST、HEAD三种</li><li>HTTP头部信息不超过一下几种字段<ul><li>无自定义头部字段</li><li>Accept、Accept-Language、Content-Language、Last-Event-ID</li><li>Content-Type只有三个值 application/x-www-form-urlencoded、multipart/form-data、text/plain</li></ul></li></ul><p>简单请求需要满足上面的条件，其实平常也就是传统的表单请求了，看了上面的简单请求条件，那么非简单请求是不是就呼之欲出了呢，比如下面这些只要满足一个就是非简单请求</p><ul><li><p>请求方式是PUT、DELETE</p></li><li><p>自定义头部字段</p></li><li><p>发送JSON格式数据等等</p></li></ul><p>非简单请求的 CORS 请求，会在正式通信之前，增加一次 HTTP 查询请求，请求方式为 OPTIONS，称为 <code>预检请求 (preflight)</code> </p><p>浏览器会先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些 HTTP 方法和头信息字段，得到肯定答复，浏览器才会发出正式的 <code>XMLHttpRequest</code> 请求，否则就会报错，这是为了防止这些新增的请求，对传统的没有 CORS 支持的服务器形成压力，给服务器一个提前拒绝的机会，防止服务器收到大量 DELETE 和 PUT请求，这些传统的表单不可能跨域发出的请求</p><h2 id="问：CSS-资源加载会阻塞渲染怎样优化？"><a href="#问：CSS-资源加载会阻塞渲染怎样优化？" class="headerlink" title="问：CSS 资源加载会阻塞渲染怎样优化？"></a>问：CSS 资源加载会阻塞渲染怎样优化？</h2><p>优化DOM树，DOM尽可能的小</p><p>CSS尽量用 <code>id</code> 和 <code>class</code> 少直接用标签，因为标签节点样式是可以继承的，所以在构建的过程中浏览器得递归 <code>DOM</code> 树来确定元素到底是什么样式</p><p>对于首屏渲染需要用到的CSS代码加入Inline CSS ( 内联样式 ) </p><p>对于首屏渲染不需要用到的CSS，可以使用文件形式并在页面内容渲染完成后再加载</p><h2 id="问：什么是回流和重绘以及区别？"><a href="#问：什么是回流和重绘以及区别？" class="headerlink" title="问：什么是回流和重绘以及区别？"></a>问：什么是回流和重绘以及区别？</h2><p>要知道，生成DOM树时是包括 <code>display:none</code> 的节点的，DOM树和CSSOM树的基础上根据节点的集合属性 <code>margin/padding/width/height等</code> 生成渲染树 ( render ) ，渲染树不包括 <code>display:none</code> 的节点和 <code>head </code> 等节点，但是包括 <code>visibility:hidden</code> 的节点</p><p>当渲染树节点因为大小边距等问题发生改变而需要重建的过程，叫做 <code>回流 (Reflow)</code> </p><p>元素发生的改变只是影响了元素的一些外观之类的时候 ( 例如，背景色，边框颜色，文字颜色等 )，此时只需要应用新样式绘制这个元素就可以了，称之为 <code>重绘 (Repaint)</code> </p><p>回流必将引起重绘，而重绘不一定会引起回流，很明显 <code>回流</code> 代价较大</p><h2 id="问：什么会引起回流？"><a href="#问：什么会引起回流？" class="headerlink" title="问：什么会引起回流？"></a>问：什么会引起回流？</h2><ul><li><p>页面渲染初始化</p></li><li><p>DOM结构改变，比如删除了某个节点</p></li><li><p>render树变化，比如减少了 padding ( 内边距 )</p></li><li><p>窗口 <code>resize</code> 事件触发时</p></li><li><p>某些 JS 属性，引发回流，很多浏览器会对回流做优化，等到数量足够时做一次批处理回流， 但除了 <code>render树</code> 的直接变化，当获取一些属性时，浏览器为了获得正确的值也会触发回流，这样使得浏览器优化无效</p><ul><li>offset ( Top/Left/Width/Height )</li><li>scroll ( Top/Left/Width/Height )</li><li>cilent ( Top/Left/Width/Height )</li><li>width, height</li><li>调用了 <code>getComputedStyle()</code> 或者IE的 <code>currentStyle</code></li></ul></li></ul><h2 id="问：如何减少和避免回流重绘？"><a href="#问：如何减少和避免回流重绘？" class="headerlink" title="问：如何减少和避免回流重绘？"></a>问：如何减少和避免回流重绘？</h2><p>减少逐项更改样式，最好一次性更改 <code>style</code>，或者将样式定义为 <code>class</code> 并一次性更新</p><p>避免循环操作DOM，让DOM离线后再修改</p><ul><li>创建一个 <code>documentFragment</code> ，在它上面应用所有DOM操作，最后再把它添加到 <code>window.document</code></li><li>先把DOM节点 <code>display:none</code> ( 会触发一次 <code>reflow</code>)，然后做修改后，再把它显示出来</li><li>克隆一个DOM节点在内存里，修改之后，与在线的节点相替换</li></ul><p>避免多次读取offset等属性，无法避免则将它们缓存到变量</p><p>将复杂的元素绝对定位或固定定位，使得它脱离文档流，否则回流代价会很高</p><p>改变字体大小也会引发回流，所以尽可能减少这种操作</p><p>table布局，一个小改动会造成整个table的重新布局，所以，少用为好</p><h2 id="问：你了解普通图层和复合图层吗？"><a href="#问：你了解普通图层和复合图层吗？" class="headerlink" title="问：你了解普通图层和复合图层吗？"></a>问：你了解普通图层和复合图层吗？</h2><p>浏览器渲染的图层一般包含两大类：<code>普通图层</code> 以及 <code>复合图层</code></p><p>普通文档流可以理解为一个复合图层，我们叫它<code>默认复合层</code>，因为里面不管添加多少元素，其实都是在同一个复合图层中，<code>absolute</code> 布局、 <code>fixed</code> 也一样，虽然可以脱离普通文档流，但它仍然属于 <code>默认复合层</code></p><p>复合图层，可以独立于普通文档流中，改动后可以避免整个页面重绘，从而提升性能，但也不能大量使用复合图层，否则由于资源消耗过度，页面反而会变的更卡，因小失大</p><p>GPU中，各个复合图层是单独绘制的，所以也互不影响，通过 <code>硬件加速</code> 的方式，会声明一个 <code>新的复合图层</code> ，它会单独分配资源，当然也会脱离普通文档流，这样一来，不管这个复合图层中怎么变化，也不会影响 <code>默认复合层</code> 里的回流重绘</p><p><strong>PS：</strong> 硬件加速技术是指使用 GPU 的硬件能力来帮助渲染网页</p><h2 id="问：浏览器页面渲染优化？"><a href="#问：浏览器页面渲染优化？" class="headerlink" title="问：浏览器页面渲染优化？"></a>问：浏览器页面渲染优化？</h2><ul><li><p>HTML文档结构层次尽量少，最好不深于六层</p></li><li><p>JS 脚本尽量后放</p></li><li><p>样式结构层次尽量简单</p></li><li><p>少量首屏样式使用内联方式放在标签内</p></li><li><p>在脚本中尽量减少DOM操作，尽量访问离线DOM样式信息，避免过度触发回流</p></li><li><p>减少通过 JS 代码修改元素样式，尽量使用修改 <code>class</code> 名方式操作样式或动画</p></li><li><p>尽量减少浏览器重排和重绘的一些情况发生</p></li><li><p>2020年了！就不要使用 <code>table</code> 布局了</p></li><li><p>CSS 动画中尽量只使用 <code>transform</code> 和 <code>opacity</code> ，不会发生重排和重绘</p></li><li><p>隐藏在屏幕外，或在页面滚动时，尽量停止动画</p></li><li><p>尽可能只使用 CSS 做动画，CSS动画肯定比 JS 动画要好很多</p></li><li><p>避免浏览器的隐式合成</p></li><li><p>改变复合层的尺寸</p></li></ul><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>对您有帮助的话，动动小手，点个赞鼓励下吧，当然，个人理解，本文因为比较忙，写的时间较长，断断续续的写，所以可能有些地方衔接的不好，不太通顺或者有不正的地方，欢迎指出，不胜感激</p><p>哦，还有，可以加个好友加下群一起交流噻，公众号【不正经的前端】也欢迎关注呦 😄 </p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20200512231111406.png"></p>]]></content>
    
    
    <categories>
      
      <category>一道面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>网络</tag>
      
      <tag>浏览器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「一道面试题」输入URL到渲染全面梳理中-页面渲染篇</title>
    <link href="/blog/2020/04/22/mianshi/%E3%80%8C%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98%E3%80%8D%E8%BE%93%E5%85%A5URL%E5%88%B0%E6%B8%B2%E6%9F%93%E5%85%A8%E9%9D%A2%E6%A2%B3%E7%90%86%E4%B8%AD-%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E7%AF%87/"/>
    <url>/blog/2020/04/22/mianshi/%E3%80%8C%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98%E3%80%8D%E8%BE%93%E5%85%A5URL%E5%88%B0%E6%B8%B2%E6%9F%93%E5%85%A8%E9%9D%A2%E6%A2%B3%E7%90%86%E4%B8%AD-%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>此文是一道面试题，又不仅仅是一道面试题，不同的是这道题分了三篇来说，嗯。。可想而知</p><p>接上文，上文我们讲了网络通信的部分，那么该说说页面渲染的流程了，也就是当输入一个 URL 拿到了页面后，浏览器怎么解析，怎么呈现</p><p>首先要了解这块内容，需要对下面这些知识点有一个简单认知</p><ul><li>线程/进程概念及区别</li><li>多线程/多进程概念</li><li>浏览器的主要进程</li><li>浏览器为什么是多进程</li><li>渲染进程 Renderer 的主要线程<ul><li>GUI 渲染线程</li><li>JS 引擎线程</li><li>事件触发线程</li><li>定时触发线程</li><li>异步 http 请求线程</li></ul></li><li>渲染进程的各个线程之间关系及配合</li></ul><p>之前写的一篇帖子 <a href="https://juejin.im/post/5e22b391f265da3e204d8c14">「硬核 JS」一次搞懂 JS 运行机制 - 传送门</a> 里有介绍到，下面我们还是重新来一遍吧，花不了多长时间，全当复习一遍，大家也可以自行去看下来了解了解，当然如果你都清楚的话可以直接去看渲染过程</p><h3 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h3><h4 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程"></a>什么是进程</h4><p>我们都知道，<code>CPU</code>是计算机的核心，承担所有的计算任务</p><p>官方说法，<code>进程</code>是<code>CPU</code>资源分配的最小单位</p><p>字面意思就是进行中的程序，我将它理解为一个可以独立运行且拥有自己的资源空间的任务程序</p><p><code>进程</code>包括运行中的程序和程序所使用到的内存和系统资源</p><p><code>CPU</code> 可以有很多进程，我们的电脑每打开一个软件就会产生一个或多个 <code>进程</code> ，为什么电脑运行的软件多就会卡，是因为 <code>CPU</code> 给每个 <code>进程</code> 分配资源空间，但是一个 <code>CPU</code> 一共就那么多资源，分出去越多，越卡，每个<code>进程</code>之间是相互独立的， <code>CPU</code> 在运行一个 <code>进程</code> 时，其他的进程处于非运行状态，<code>CPU</code> 使用 <a href="%5Bhttps://baike.baidu.com/item/%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC%E8%B0%83%E5%BA%A6%5D(https://baike.baidu.com/item/%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC%E8%B0%83%E5%BA%A6)">时间片轮转调度算法</a> 来实现同时运行多个进程</p><h4 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h4><p><code>线程</code> 是 <code>CPU</code> 调度的最小单位</p><p><code>线程</code> 是建立在 <code>进程</code> 的基础上的一次程序运行单位，通俗点解释 <code>线程</code> 就是程序中的一个执行流，一个 <code>进程</code> 可以有多个 <code>线程</code></p><p>一个 <code>进程</code> 中只有一个执行流称作 <code>单线程</code> ，即程序执行时，所走的程序路径按照连续顺序排下来，前面的必须处理好，后面的才会执行</p><p>一个 <code>进程</code> 中有多个执行流称作 <code>多线程</code>，即在一个程序中可以同时运行多个不同的 <code>线程</code> 来执行不同的任务， 也就是说允许单个程序创建多个并行执行的 <code>线程</code> 来完成各自的任务</p><h4 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h4><p>进程是操作系统分配资源的最小单位，线程是程序执行的最小单位</p><p>一个 <code>进程</code> 由一个或多个 <code>线程</code> 组成，<code>线程</code> 可以理解为是一个进程中代码的不同执行路线</p><p><code>进程</code> 之间相互独立，但同一进程下的各个 <code>线程</code> 间共享程序的内存空间 (包括代码段、数据集、堆等) 及一些进程级的资源 (如打开文件和信号)</p><p>调度和切换：线程上下文切换比进程上下文切换要快得多</p><h4 id="多进程和多线程"><a href="#多进程和多线程" class="headerlink" title="多进程和多线程"></a>多进程和多线程</h4><p><strong>多进程：</strong> 多进程指的是在同一个时间里，同一个计算机系统中如果允许两个或两个以上的进程处于运行状态。多进程带来的好处是明显的，比如大家可以在网易云听歌的同时打开编辑器敲代码，编辑器和网易云的进程之间不会相互干扰</p><p><strong>多线程：</strong> 多线程是指程序中包含多个执行流，即在一个程序中可以同时运行多个不同的线程来执行不同的任务，也就是说允许单个程序创建多个并行执行的线程来完成各自的任务</p><h3 id="JS-为什么是单线程"><a href="#JS-为什么是单线程" class="headerlink" title="JS 为什么是单线程"></a>JS 为什么是单线程</h3><p>JS 的单线程，与它的用途有关，作为浏览器脚本语言，JavaScript 的主要用途是与用户互动，以及操作 DOM，这决定了它只能是单线程，否则会带来很复杂的同步问题</p><p>比如，假定 <code>JavaScript</code> 同时有两个线程，一个线程在某个 DOM 节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？</p><p>还有人说 <code>js</code> 还有 <code>Worker</code> 线程，对的，为了利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 <code>JavaScript</code> 脚本创建多个线程，但是子线程是完 全受主线程控制的，而且不得操作 DOM</p><p>所以，这个标准并没有改变 JavaScript 是单线程的本质</p><p>了解了进程和线程之后，接下来看看浏览器解析，浏览器之间也是有些许差距的，不过大致是差不多的，下文我们皆用市场占有比例最大的 Chrome 为例</p><h3 id="浏览器相关"><a href="#浏览器相关" class="headerlink" title="浏览器相关"></a>浏览器相关</h3><h4 id="浏览器是多进程的"><a href="#浏览器是多进程的" class="headerlink" title="浏览器是多进程的"></a>浏览器是多进程的</h4><p>作为前端，免不了和浏览器打交道，浏览器是多进程的，拿 <code>Chrome</code> 来说，我们每打开一个 Tab 页就会产生一个进程，我们使用 <code>Chrome</code> 打开很多标签页不关，电脑会越来越卡，不说其他，首先就很耗 CPU</p><h4 id="浏览器包含哪些进程"><a href="#浏览器包含哪些进程" class="headerlink" title="浏览器包含哪些进程"></a>浏览器包含哪些进程</h4><ul><li>Browser 进程<ul><li>浏览器的主进程(负责协调、主控)，该进程只有一个</li><li>负责浏览器界面显示，与用户交互。如前进，后退等</li><li>负责各个页面的管理，创建和销毁其他进程</li><li>将渲染(Renderer)进程得到的内存中的 Bitmap(位图)，绘制到用户界面上</li><li>网络资源的管理，下载等</li></ul></li><li>第三方插件进程<ul><li>每种类型的插件对应一个进程，当使用该插件时才创建</li></ul></li><li>GPU 进程<ul><li>该进程也只有一个，用于 3D/动画绘制等等</li></ul></li><li>渲染进程(重)<ul><li>即通常所说的浏览器内核(Renderer 进程，内部是多线程)</li><li>每个 Tab 页面都有一个渲染进程，互不影响</li><li>主要作用为页面渲染，脚本执行，事件处理等</li></ul></li></ul><h4 id="为什么浏览器要多进程"><a href="#为什么浏览器要多进程" class="headerlink" title="为什么浏览器要多进程"></a>为什么浏览器要多进程</h4><p>我们假设浏览器是单进程，那么某个 Tab 页崩溃了，就影响了整个浏览器，体验有多差</p><p>同理如果插件崩溃了也会影响整个浏览器</p><p>当然多进程还有其它的诸多优势，不过多阐述</p><p>浏览器进程有很多，每个进程又有很多线程，都会占用内存</p><p>这也意味着内存等资源消耗会很大，有点拿空间换时间的意思</p><p>到此可不只是为了让我们理解为何 Chrome 运行时间长了电脑会卡，哈哈，第一个重点来了</p><h4 id="简述渲染进程-Renderer-重"><a href="#简述渲染进程-Renderer-重" class="headerlink" title="简述渲染进程 Renderer(重)"></a>简述渲染进程 Renderer(重)</h4><p>页面的渲染，JS 的执行，事件的循环，都在渲染进程内执行，所以我们要重点了解渲染进程</p><p>渲染进程是多线程的，我们来看渲染进程的一些常用较为主要的线程</p><h4 id="渲染进程-Renderer-的主要线程"><a href="#渲染进程-Renderer-的主要线程" class="headerlink" title="渲染进程 Renderer 的主要线程"></a>渲染进程 Renderer 的主要线程</h4><h5 id="GUI-渲染线程"><a href="#GUI-渲染线程" class="headerlink" title="GUI 渲染线程"></a>GUI 渲染线程</h5><ul><li>负责渲染浏览器界面，解析 HTML，CSS，构建 DOM 树和 RenderObject 树，布局和绘制等<ul><li>解析 html 代码(HTML 代码本质是字符串)转化为浏览器认识的节点，生成 DOM 树，也就是 DOM Tree</li><li>解析 css，生成 CSSOM(CSS 规则树)</li><li>把 DOM Tree 和 CSSOM 结合，生成 Rendering Tree(渲染树)</li></ul></li><li>当我们修改了一些元素的颜色或者背景色，页面就会重绘(Repaint)</li><li>当我们修改元素的尺寸，页面就会回流(Reflow)</li><li>当页面需要 Repaing 和 Reflow 时 GUI 线程执行，绘制页面</li><li>回流(Reflow)比重绘(Repaint)的成本要高，我们要尽量避免 Reflow 和 Repaint</li><li>GUI 渲染线程与 JS 引擎线程是互斥的<ul><li>当 JS 引擎执行时 GUI 线程会被挂起(相当于被冻结了)</li><li>GUI 更新会被保存在一个队列中等到 JS 引擎空闲时立即被执行</li></ul></li></ul><h5 id="JS-引擎线程"><a href="#JS-引擎线程" class="headerlink" title="JS 引擎线程"></a>JS 引擎线程</h5><ul><li>JS 引擎线程就是 JS 内核，负责处理 Javascript 脚本程序(例如 V8 引擎)</li><li>JS 引擎线程负责解析 Javascript 脚本，运行代码</li><li>JS 引擎一直等待着任务队列中任务的到来，然后加以处理<ul><li>浏览器同时只能有一个 JS 引擎线程在运行 JS 程序，所以 js 是单线程运行的</li><li>一个 Tab 页(renderer 进程)中无论什么时候都只有一个 JS 线程在运行 JS 程序</li></ul></li><li>GUI 渲染线程与 JS 引擎线程是互斥的，js 引擎线程会阻塞 GUI 渲染线程<ul><li>就是我们常遇到的 JS 执行时间过长，造成页面的渲染不连贯，导致页面渲染加载阻塞(就是加载慢)</li><li>例如浏览器渲染的时候遇到``标签，就会停止 GUI 的渲染，然后 js 引擎线程开始工作，执行里面的 js 代码，等 js 执行完毕，js 引擎线程停止工作，GUI 继续渲染下面的内容。所以如果 js 执行时间太长就会造成页面卡顿的情况</li></ul></li></ul><h5 id="事件触发线程"><a href="#事件触发线程" class="headerlink" title="事件触发线程"></a>事件触发线程</h5><ul><li>属于浏览器而不是 JS 引擎，用来控制事件循环，并且管理着一个事件队列(task queue)</li><li>当 js 执行碰到事件绑定和一些异步操作(如 setTimeOut，也可来自浏览器内核的其他线程，如鼠标点击、AJAX 异步请求等)，会走事件触发线程将对应的事件添加到对应的线程中(比如定时器操作，便把定时器事件添加到定时器线程)，等异步事件有了结果，便把他们的回调操作添加到事件队列，等待 js 引擎线程空闲时来处理。</li><li>当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待 JS 引擎的处理</li><li>因为 JS 是单线程，所以这些待处理队列中的事件都得排队等待 JS 引擎处理</li></ul><h5 id="定时触发器线程"><a href="#定时触发器线程" class="headerlink" title="定时触发器线程"></a>定时触发器线程</h5><ul><li><code>setInterval</code> 与 <code>setTimeout</code> 所在线程</li><li>浏览器定时计数器并不是由 JavaScript 引擎计数的 (因为 JavaScript 引擎是单线程的，如果处于阻塞线程状态就会影响记计时的准确)</li><li>通过单独线程来计时并触发定时(计时完毕后，添加到事件触发线程的事件队列中，等待 JS 引擎空闲后执行)，这个线程就是定时触发器线程，也叫定时器线程</li><li>W3C 在 HTML 标准中规定，规定要求<code>setTimeout</code>中低于 4ms 的时间间隔算为 4ms</li></ul><h5 id="异步-http-请求线程"><a href="#异步-http-请求线程" class="headerlink" title="异步 http 请求线程"></a>异步 http 请求线程</h5><ul><li>在 XMLHttpRequest 在连接后是通过浏览器新开一个线程请求</li><li>将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中再由 JavaScript 引擎执行</li><li>简单说就是当执行到一个 http 异步请求时，就把异步请求事件添加到异步请求线程，等收到响应 (准确来说应该是 http 状态变化)，再把回调函数添加到事件队列，等待 js 引擎线程来执行</li></ul><p>了解了上面这些基础后，接下来我们开始进入今天的正题，输入 URL 拿到资源之后，如何渲染，又经历了那些过程？</p><h2 id="渲染过程"><a href="#渲染过程" class="headerlink" title="渲染过程"></a>渲染过程</h2><h3 id="Webkit-渲染流程图"><a href="#Webkit-渲染流程图" class="headerlink" title="Webkit 渲染流程图"></a>Webkit 渲染流程图</h3><p>我们都知道，浏览器之间的渲染流程是有些细微差别的，我们这里介绍的一些知识点是基于 Chrome 的，也就是 Webkit，毕竟它是主流，先来看一下 Webkit 的渲染流程图</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20200421232942705.png"></p><p>大家如果第一次看到这张图，可能会有点迷茫，不知从哪看起，别急，先大致过一眼，我们下面会慢慢介绍，一步步的分析，如果大家完整的阅读完此文，不妨回过头来再看一遍这张图，会清晰很多</p><h3 id="解析-HTML-构建-DOM-树"><a href="#解析-HTML-构建-DOM-树" class="headerlink" title="解析 HTML 构建 DOM 树"></a>解析 HTML 构建 DOM 树</h3><p>浏览器渲染，那么浏览器肯定就拿到页面内容了，肯定要先解析 HTML 的</p><p>话不多说，我们直接来看 HTML 解析的图 ( 网图侵删 )</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20200408224734313.png" alt="image-20200408224734313"></p><p>如果是第一次看到这张图可能看不懂，没关系，慢慢道来</p><p>先来看图中解析 DOM 的这几个大过程</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">Bytes(字节) -&gt; Characters(字符) -&gt; Tokens(词) -&gt; Nodes(节点) -&gt; DOM(DOM树)<br></code></pre></td></tr></table></figure><p>首先，发起请求拿到页面 HTML 内容，这个内容它是 0/1 这样的原始 <code>字节流</code></p><p>接着，浏览器拿到这些 HTML 的原始字节，根据文件的指定编码 (例如 UTF-8) 将它们转换成各个 <code>字符</code></p><p>现在字节流变成了 <code>字符流</code> ，也就是一大串字符串</p><p>为了把 <code>字符流</code> 解析成正确的 <code>DOM</code> 结构，浏览器还要继续努力</p><p>接着进行 <code>词法解析</code> ，把字符流初步解析成我们可理解的 <code>词</code>，学名叫 <code>token</code></p><p><strong>嗯？什么是词 (Token)？</strong></p><p><code>词</code> 是编译原理中的最小单元，如标签开始、属性、标签结束、注释、CDATA 节点</p><p><code>Token</code> 会标识出当前 <code>Token</code> 的种类，有点绕，怎么说方便理解呢，举个例子</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;haha&quot;</span>&gt;</span>haha<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如上，这是一个标签它有一个 class 属性 (废话)，但是浏览器拿到的只是字符串，它不知道这都是什么标签有啥属性要做什么，那么得给它一点一点拆开读，就是词法解析，怎么解析，就像下面这样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">1.</span> &lt;div# 哦，看到了&lt;div，这是一个div标签的开始<br><span class="hljs-number">2.</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;haha&quot;</span> # 这是一个<span class="hljs-class"><span class="hljs-keyword">class</span>属性</span><br><span class="hljs-class">3. &gt;# 哦，到这儿是一个完整的<span class="hljs-title">div</span>开始标签</span><br><span class="hljs-class">4. <span class="hljs-title">haha</span># 嗯，这是一个文本</span><br><span class="hljs-class">5. &lt;/<span class="hljs-title">div</span>&gt;# 奥，看到了&lt;/<span class="hljs-title">div</span>&gt;，整个<span class="hljs-title">div</span>标签结束了</span><br></code></pre></td></tr></table></figure><p><code>词法解析</code> 是编译原理中的概念，上面是极度简化版本 (防大佬死磕)，只是为了方便大家理解</p><p>现在理解了吗，<code>Tokens</code> 这个阶段中会标识出当前 <code>Token</code> 是 <code>开始标签</code> 或是 <code>结束标签</code> 亦或是 <code>文本</code> 等信息</p><p>那么我们收回思路，接着上面的步骤，经历 <code>词法解析</code> 我们把字符流解析成了 词 (Token)</p><p>接着在每个 <code>Token</code> 被生成后，会立刻消耗这个 <code>Token</code> 创建出节点对象，就是 节点 (Nodes) 阶段</p><p>把开始结束标签配对、属性赋值好、父子关系这些都连接好了，最终就构成了 <code>DOM</code> 树</p><p>后面这两小步也可称为 <code>语法解析</code> ，到此 <code>DOM Tree</code> 就解析完了</p><p>另外多嘴一句，<code>DOM树(DOM Tree) | 文档对象模型</code> ，这些东西说的都是 <code>DOM树</code></p><h3 id="解析-CSS-构建-CSSOM-树"><a href="#解析-CSS-构建-CSSOM-树" class="headerlink" title="解析 CSS 构建 CSSOM 树"></a>解析 CSS 构建 CSSOM 树</h3><p>有 <code>HTML</code> 解析，那肯定有 <code>CSS</code> 解析，比如我们构建 <code>DOM</code> 的时候遇到了 <code>link</code> 标记，该标记引用一个外部 <code>CSS</code> 样式表，那么浏览器会认为它需要这个外部样式资源，就会立即发出对该资源的请求，并返回样式内容，也是字节流</p><p>与处理 <code>HTML</code> 时一样，将收到的 <code>CSS</code> 规则转换成某种浏览器能够理解和处理的东西，基本步骤重复 <code>HTML</code> 过程，不过是构建 CSS 而不是 HTML</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20200408234346575.png" alt="image-20200408234346575"></p><p><code>CSS</code> 字节转换成字符，接着词法解析与法解析，最后构成 <code>CSS对象模型(CSSOM)</code> 的树结构</p><p>我们都知道，节点样式是可以继承的，所以在构建的过程中浏览器得递归 <code>DOM</code> 树来确定元素到底是什么样式，为了 <code>CSSOM</code> 的完整性，只有等构建完毕才能进入到下一个阶段，所以就算 <code>DOM</code> 已经构建完了，也得等 <code>CSSOM</code>，然后才能进入下一个阶段</p><p>所以 <code>CSS</code> 的加载速度与构建 <code>CSSOM</code> 的速度会影响首屏渲染速度，这就是我们常说的 <code>CSS</code> 资源的加载会阻塞渲染</p><p>怎么优化？DOM 树要小，CSS 尽量用 <code>id</code> 和 <code>class</code> 少直接用标签 😄</p><h3 id="解析-JavaScript-脚本"><a href="#解析-JavaScript-脚本" class="headerlink" title="解析 JavaScript 脚本"></a>解析 JavaScript 脚本</h3><p>这个解析 <code>JS</code> 的步骤是不固定的，因为在构建 DOM 树的过程中，当 <code>HTML</code> 解析器遇到一个 <code>script</code> 标记时，即遇到了 js，立即阻塞 DOM 树的构建，就会将控制权移交给 <code>JavaScript</code> 引擎，等到 <code>JavaScript</code> 引擎运行完毕，浏览器才会从中断的地方恢复 DOM 树的构建</p><p>为什么上面也说了，<strong>JS 会对 DOM 节点进行操作，浏览器无法预测未来的 DOM 节点的具体内容，为了防止无效操作，节省资源，只能阻塞 DOM 树的构建</strong></p><p>例如，若不阻塞 DOM 树的构建，若 JS 删除了某个 DOM 节点 A，那么浏览器为构建此节点 A 花费的资源就是无效的</p><p>若在 HTML 头部加载 JS 文件，由于 JS 阻塞，会推迟页面的首绘，所以为了加快页面渲染，一般将 JS 文件放到 HTML 底部进行加载，或是对 JS 文件执行 <code>async</code> 或 <code>defer</code> 加载</p><ul><li><code>async</code> 是异步执行，异步下载完毕后就会执行，不确保执行顺序，一定在 <code>onload</code> 前，但不确定在 <code>DOMContentLoaded</code> 事件的前或后</li><li><code>defer</code> 是延迟执行，在浏览器看起来的效果像是将脚本放在了 <code>body</code> 后面一样（虽然按规范应该是在 <code>DOMContentLoaded</code> 事件前，但实际上不同浏览器的优化效果不一样，也有可能在它后面）</li></ul><h3 id="构建渲染树-呈现树-Render-Tree"><a href="#构建渲染树-呈现树-Render-Tree" class="headerlink" title="构建渲染树/呈现树(Render Tree)"></a>构建渲染树/呈现树(Render Tree)</h3><p>渲染树 ( Render Tree ) 由 <code>DOM树</code>、<code>CSSOM树</code> 合并而成，但并不是必须等 <code>DOM树</code> 及 <code>CSSOM树</code> 加载完成后才开始合并构建 <code>渲染树</code>，三者的构建并无先后条件，也并非完全独立，而是会有交叉，并行构建，因此会形成一边加载，一边解析，一边渲染的工作现象</p><p><code>CSSOM 树</code>和 <code>DOM 树</code> 合并成渲染树，<code>渲染树</code> 只包含渲染网页所需的节点，然后用于计算每个可见元素的布局，并输出给绘制流程，将像素渲染到屏幕上</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20200418220809467.png" alt="image-20200418220809467"></p><p>如上图 ( 网图侵删 ) ，为了构建渲染树，我们看看浏览器都做了什么</p><ul><li>浏览器首先会从 DOM 树的根节点开始遍历每个可见节点<ul><li>例如脚本标记、元标记等有些节点不可见，因为它们不会体现在渲染输出中，所以会被忽略</li><li>某些节点通过 CSS 隐藏，因此在渲染树中也会被忽略，例如上图的其中一个 <code>span</code> 标签有 <code>display: none</code> 属性，也会被忽略</li></ul></li><li>对于每个可见节点，找到其对应的的 CSSOM 规则并应用它们</li><li>输出可见节点，连同其内容和计算的样式</li></ul><h3 id="布局-Layout"><a href="#布局-Layout" class="headerlink" title="布局(Layout)"></a>布局(Layout)</h3><p><code>渲染树</code> 同时包含了屏幕上的所有可见内容及其样式信息，有了渲染树，再接着就要进入布局 ( layout ) 阶段了，到目前为止，我们计算了哪些节点应该是可见的以及它们的计算样式，但我们还没有计算它们在设备 <a href="https://developers.google.com/web/fundamentals/design-and-ux/responsive?hl=zh-cn#set-the-viewport">视口</a> 内的确切位置和大小，这就是 <code>布局</code> ( Layout ) 阶段，也称为 <code>自动重排</code> 或 <code>回流</code> ( Reflow )</p><p>此阶段一般意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树</p><p>简单举个例子，我们看下面这段代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width,initial-scale=1&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>hahaha<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width: 50%&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width: 50%&quot;</span>&gt;</span>Hello world<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上面代码网页的正文包含两个嵌套 div：第一个父 div 将节点的显示尺寸设置为视口宽度的 50%，父 div 包含的第二个 div 将其宽度设置为其父项的 50%，即视口宽度的 25% （网图侵删）</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20200418223841109.png" alt="image-20200418223841109"></p><p>布局流程的输出是一个 <code>盒模型</code>，它会精确地捕获每个元素在视口内的确切位置和尺寸，当然，所有相对测量值都转换为屏幕上的绝对像素</p><p>我们先往下看，稍后还会给大家介绍</p><h3 id="绘制-Painting"><a href="#绘制-Painting" class="headerlink" title="绘制(Painting)"></a>绘制(Painting)</h3><p>经历了以上种种步骤，终于来到了 <code>绘制</code> ，这一步听名字就能想到其作用了</p><p>经由前几步我们知道了哪些节点可见、它们的计算样式以及几何信息，我们将这些信息传递给最后一个阶段将渲染树中的每个节点转换成屏幕上的实际像素，也就是俗称的 <code>绘制</code> 或 <code>栅格化</code></p><p><code>绘制</code> 过程中有一种绘制叫 <code>重绘</code>，也就是下我们要说的</p><h4 id="重绘-Repaint"><a href="#重绘-Repaint" class="headerlink" title="重绘(Repaint)"></a>重绘(Repaint)</h4><p>元素发生的改变只是影响了元素的一些外观之类的时候（例如，背景色，边框颜色，文字颜色等），此时只需要应用新样式绘制这个元素就可以了，这叫做 <code>重绘</code> ( Repaint )</p><h4 id="回流-Reflow"><a href="#回流-Reflow" class="headerlink" title="回流 (Reflow)"></a>回流 (Reflow)</h4><p>上面我们已经说过了 <code>回流</code> ，当然也叫 <code>重排</code> ，要知道，<code>回流</code> 一定伴随着 <code>重绘</code> ，<code>重绘</code> 却可以单独出现，对比来看，显然回流的成本开销要高于重绘，而且一个节点的回流往往还会导致子节点以及同级节点的回流，所以优化方案中一般都包括，尽量避免 <code>回流</code></p><h4 id="什么会引起回流"><a href="#什么会引起回流" class="headerlink" title="什么会引起回流"></a>什么会引起回流</h4><ul><li><p>页面渲染初始化</p></li><li><p>DOM 结构改变，比如删除了某个节点</p></li><li><p>render 树变化，比如减少了 padding</p></li><li><p>窗口 <code>resize</code></p></li><li><p>某些 JS 属性，引发回流，很多浏览器会对回流做优化，等到数量足够时做一次批处理回流，<br>但除了 <code>render树</code> 的直接变化，当获取一些属性时，浏览器为了获得正确的值也会触发回流，这样使得浏览器优化无效</p></li><li><p>offset ( Top/Left/Width/Height )</p><ul><li>scroll ( Top/Left/Width/Height )</li><li>cilent ( Top/Left/Width/Height )</li><li>width, height</li><li>调用了 <code>getComputedStyle()</code> 或者 IE 的 <code>currentStyle</code></li></ul></li></ul><h4 id="如何减少和避免回流重绘"><a href="#如何减少和避免回流重绘" class="headerlink" title="如何减少和避免回流重绘"></a>如何减少和避免回流重绘</h4><p>上面我们说到，回流开销太大了，那么我们肯定是要优化的，接着看，其实就是尽量避免上面那些操作</p><ul><li>减少逐项更改样式，最好一次性更改 <code>style</code>，或者将样式定义为 <code>class</code> 并一次性更新</li><li>避免循环操作 DOM，让 DOM 离线后再修改<ul><li>创建一个 <code>documentFragment</code> ，在它上面应用所有 DOM 操作，最后再把它添加到 <code>window.document</code></li><li>先把 DOM 节点 <code>display:none</code> ( 会触发一次 <code>reflow</code>)，然后做修改后，再把它显示出来</li><li>克隆一个 DOM 节点在内存里，修改之后，与在线的节点相替换</li></ul></li><li>避免多次读取 offset 等属性，无法避免则将它们缓存到变量</li><li>将复杂的元素绝对定位或固定定位，使得它脱离文档流，否则回流代价会很高</li><li>改变字体大小也会引发回流，所以尽可能减少这种操作</li><li>table 布局，一个小改动会造成整个 table 的重新布局，所以，少用为好</li></ul><p>总之，说来说去，回流重绘，特别是回流，特别耗费资源，尽量避免就好，关于一些 CSS 属性会引起的回流重绘，可以去这个网站查查看 <a href="https://csstriggers.com/">https://csstriggers.com/</a></p><h3 id="合成-Composite"><a href="#合成-Composite" class="headerlink" title="合成(Composite)"></a>合成(Composite)</h3><p>终于来到了最后一个点 <code>合成</code> ，我们先来总结一下上面的步骤，到目前我们经历渲染过程如下</p><ul><li>首先解析 <code>HTML</code> 文档，形成 DOM 树</li><li>接着解析 <code>CSS</code>，产生 CSSOM 树</li><li>在 DOM 和 CSSOM 树解析过程中，遇到 JS，会立即阻塞 DOM 树的构建，JS 解析完成，接着走上面两步</li><li>再接着，浏览器通过 DOM 和 CSSOM 树构建渲染树 ( Render 树 )<ul><li>这个过程中，DOM 中不可见标签元素不会放到渲染树中，就像<code>&lt;head&gt;&lt;/head&gt; 或 display:none</code></li><li>CSSOM 树规则会附加给渲染树的每个元素上</li></ul></li><li>渲染树构建完成，浏览器会对这些元素进行定位和布局，这一步也叫 重排/回流 ( <code>Reflow</code>) 或 布局(<code>Layout</code> )</li><li>接下来绘制这些元素的样式，颜色，背景，大小及边框等，这一步也叫做 重绘 (<code>Repaint</code>)</li><li>再接下来是我们这最后一步合成( <code>composite</code> )，浏览器会将各层信息发送给 GPU，GPU 将各层合成，显示在屏幕上</li></ul><p>关于合成这一步骤，准备细聊一下子，让大家对其有个基本概念，因为刚开始忽略了它</p><p>首先，我们需要简单了解一些基本概念</p><h4 id="浏览器渲染方式"><a href="#浏览器渲染方式" class="headerlink" title="浏览器渲染方式"></a>浏览器渲染方式</h4><p>浏览器在渲染图形的时候，有一个绘图上下文，绘图上下文又分成两种类型</p><ul><li>第一种是用来绘制 2D 图形的上下文，称之为 2D 绘图上下文（GraphicsContext）</li><li>第二种是绘制 3D 图形的上下文，称之为 3D 绘图上下文（GraphicsContext3D）</li></ul><p>网页也有三种渲染方式</p><ul><li>软件渲染（CPU 内存）</li><li>使用软件绘图的合成化渲染（GPU 内存）CSS3D、WebGL</li><li>硬件加速的合成化渲染（GPU 内存）</li></ul><p>当然，这些我们也不需要深入理解，知道它们的存在即可</p><h4 id="软件渲染技术"><a href="#软件渲染技术" class="headerlink" title="软件渲染技术"></a>软件渲染技术</h4><p>Webkit 在不需要硬件加速内容的时候（包括但不限于 <code>CSS3 3D变形</code>、<code>CSS3 3D变换</code> 、 <code>WebGL</code> 和 <code>视频</code>），它就可以使用 <code>软件渲染技术</code> 来完成页面绘制</p><p>上面我们看到了软件渲染技术，它是什么呢？我们接着看</p><p>对于每个渲染对象，需要三个阶段绘制自己</p><ul><li>第一阶段是绘制该层中所有块的背景和边框</li><li>第二阶段是绘制浮动内容</li><li>第三阶段是前景 ( Foreground ) ，也就是内容部分、轮廓、字体颜色、大小等 ( 内嵌元素的背景、边框等发生在这一阶段 )</li></ul><h4 id="硬件加速技术"><a href="#硬件加速技术" class="headerlink" title="硬件加速技术"></a>硬件加速技术</h4><p>硬件加速技术是指使用 GPU 的硬件能力来帮助渲染网页 ( GPU 的作用主要是用来绘制 3D 图形并且性能很 nice )</p><h4 id="普通图层和复合图层"><a href="#普通图层和复合图层" class="headerlink" title="普通图层和复合图层"></a>普通图层和复合图层</h4><p>浏览器渲染的图层一般包含两大类：<code>普通图层</code> 以及 <code>复合图层</code></p><p>普通文档流大家就可以理解为一个复合图层，我们叫它<code>默认复合层</code>，因为里面不管添加多少元素，其实都是在同一个复合图层中，<code>absolute</code> 布局、 <code>fixed</code> 也一样，虽然可以脱离普通文档流，但它仍然属于 <code>默认复合层</code></p><p>复合图层，可以独立于普通文档流中，改动后可以避免整个页面重绘，提升性能，但也不要大量使用复合图层，否则由于资源消耗过度，页面反而会变的更卡，因小失大</p><p>GPU 中，各个复合图层是单独绘制的，所以也互不影响，通过 <code>硬件加速</code> 的方式，会声明一个 <code>新的复合图层</code> ，它会单独分配资源，当然也会脱离普通文档流，这样一来，不管这个复合图层中怎么变化，也不会影响 <code>默认复合层</code> 里的回流重绘</p><h4 id="何为复合图层-硬件加速"><a href="#何为复合图层-硬件加速" class="headerlink" title="何为复合图层/硬件加速"></a>何为复合图层/硬件加速</h4><p>复合图层或者说硬件加速，其实就是仅触发合成 <code>composite</code> ，那么也就必须符合以下三个条件</p><ul><li>不影响文档流</li><li>不依赖文档流</li><li>不会造成重绘</li></ul><p>寻思一下，可以做到这种情况得还真的不多 ( Chrome )</p><ul><li>最常用的方式是 <code>transform</code></li><li><code>opacity</code> 属性 / 过渡动画 (需要动画执行的过程中才会创建合成层，动画没有开始或结束后元素还会回到之前的状态)</li><li><code>will-chang</code> 属性 (这个比较偏僻)，一般配合 <code>opacity</code> 与 <code>translate</code> 使用，除了上述可以引发硬件加速的属性外，其它属性并不会变成复合层，作用是提前告诉浏览器要变化，这样浏览器会开始做一些优化工作 (最好用完后就释放)</li><li><code>&lt;canvas&gt; &lt;webgl&gt;</code> 等元素</li><li>还有以前的 <code>flash</code> 插件等等</li></ul><p>通俗一点，假如我们给一个元素加了 <code>transform</code> 属性吧，那么该元素就不会影响也不会依赖文档流，也不会造成重绘，就变成了一个复合图层，也就可以说我们对它使用了传说中的 <code>硬件加速技术</code></p><h4 id="absolute？"><a href="#absolute？" class="headerlink" title="absolute？"></a>absolute？</h4><p>到了这里，大家可能有些迷惑，我们不是常说 <code>absolute</code> 是脱离文档流吗，为什么上面复合图层或者说硬件加速中没有 <code>absolute</code> 呢</p><p>其实，<code>absolute</code> 虽然可以脱离普通文档流，但是无法脱离默认复合层，就像它的 <code>left</code> 属性可以使用百分比的值，依赖于它的 <code>offset parent</code></p><p>所以，就算 <code>absolute</code> 中信息改变时不会改变普通文档流中的 <code>渲染树</code> ，但浏览器最终绘制时，是整个复合层绘制的，所以 <code>absolute</code> 中信息改变，仍会影响整个复合层的绘制，浏览器还是会重绘它，如果复合层中内容多，<code>absolute</code> 带来的绘制信息变化过大，资源消耗也非常严重</p><p>而我们上面说的硬件加速，那直接就是在另一个复合层了，所以它的信息改变不会影响默认复合层，当然内部肯定会影响属于自己的复合层，仅仅是引发最后的合成渲染</p><h2 id="页面渲染优化"><a href="#页面渲染优化" class="headerlink" title="页面渲染优化"></a>页面渲染优化</h2><p>浏览器对上文介绍的关键渲染步骤进行了很多优化，针对每一次变化产生尽量少的操作，还有优化判断重新绘制或布局的方式等等，据上文所述，总结下页面渲染这块的优化实践，不分先后，大家也可一块来补充</p><ul><li><p>HTML 文档结构层次尽量少，最好不深于六层</p></li><li><p>JS 脚本尽量后放</p></li><li><p>样式结构层次尽量简单</p></li><li><p>少量首屏样式使用内联方式放在标签内</p></li><li><p>在脚本中尽量减少 DOM 操作，尽量访问离线 DOM 样式信息，避免过度触发回流</p></li><li><p>减少通过 JS 代码修改元素样式，尽量使用修改 <code>class</code> 名方式操作样式或动画</p></li><li><p>尽量减少浏览器重排和重绘的一些情况发生</p></li><li><p>2020 年了！就不要使用 <code>table</code> 布局了</p></li><li><p>CSS 动画中尽量只使用 <code>transform</code> 和 <code>opacity</code> ，不会发生重排和重绘</p></li><li><p>隐藏在屏幕外，或在页面滚动时，尽量停止动画</p></li><li><p>尽可能只使用 CSS 做动画，CSS 动画肯定比 JS 动画要好很多</p></li><li><p>避免浏览器的隐式合成</p></li><li><p>改变复合层的尺寸</p></li></ul><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>上面讲的有些随意，最后再来波官方点的总结吧</p><p>发起一个请求，我们拿到了页面，下载完的网页将被交给浏览器内核（渲染进程）进行处理</p><ul><li>首先，根据顶部定义的 DTD 类型进行对应的解析方式</li><li>渲染进程内部是多线程的，网页的解析将会被交给内部的 GUI 渲染线程处理</li><li>渲染线程中的 HTML 解释器，将 HTML 网页和资源从字节流解释转换成字符流</li><li>再通过词法分析器将字符流解释成词</li><li>之后经过语法分析器根据词构建成节点，最后通过这些节点组建一个 DOM 树</li><li>这个过程中，如果遇到的 DOM 节点是 JS 代码，就会调用 <code>JS引擎</code> 对 JS 代码进行解释执行，此时由 <code>JS引擎</code> 和 <code>GUI渲染线程</code> 的互斥，<code>GUI渲染线程</code> 就会被挂起，渲染过程停止，如果 JS 代码的运行中对 DOM 树进行了修改，那么 DOM 的构建需要从新开始</li><li>如果节点需要依赖其他资源，图片/CSS 等等，就会调用网络模块的资源加载器来加载它们，它们是异步的，不会阻塞当前 DOM 树的构建</li><li>如果遇到的是 JS 资源 URL（没有标记异步），则需要停止当前 DOM 的构建，直到 JS 的资源加载并被 <code>JS引擎</code> 执行后才继续构建 DOM</li><li>对于 CSS，CSS 解释器会将 CSS 文件解释成内部表示结构，生成 CSS 规则树</li><li>然后合并 CSS 规则树和 DOM 树，生成 Render 渲染树，也叫呈现树</li><li>最后对 Render 树进行布局和绘制，并将结果通过 IO 线程传递给浏览器控制进程进行显示</li></ul><p>页面渲染篇到此就结束了，又是上万字，好像也没讲太多东西，大家还是只能以庞观的方式去了解，私下想深入的话还是要多看些相关资料，此文也是我看了很多资料输出的，看完本文，再去看资料或深入应该也会容易了解一些吧，这几篇帖子的核心都脱离不了那道经典面试题，那么看到了这里基本的一些知识点都已经给大家阐述过了，可以自己尝试总结一番了，一定要自己总结再看下文总结篇，这样大家也算没白浪费时间</p><p>下一文「一道面试题」输入 URL 到渲染全面梳理下-总结篇，待续哦。。</p><p>对您有帮助的话，动动小手，点个赞鼓励下吧，当然，个人理解，如有不正，欢迎指出，不胜感激</p><p>哦，还有，可以加个好友加下群一起交流噻，公众号【不正经的前端】也欢迎关注呦 😄</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20200508193235095.png"></p><blockquote><p>参考 ( 参考了很多帖子，贴了三个认为比较好的，推荐大家看一看 )</p><ol><li><p><a href="https://segmentfault.com/a/1190000013662126">从输入 URL 到页面加载的过程？如何由一道题完善自己的前端知识体系</a></p></li><li><p><a href="https://segmentfault.com/a/1190000012925872">从浏览器多进程到 JS 单线程，JS 运行机制最全面的一次梳理</a></p></li><li><p><a href="https://segmentfault.com/a/1190000008015671">一篇文章说清浏览器解析和 CSS（GPU）动画优化</a></p></li></ol></blockquote>]]></content>
    
    
    <categories>
      
      <category>一道面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>网络</tag>
      
      <tag>浏览器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「一道面试题」输入 URL 到渲染全面梳理上-网络通信篇</title>
    <link href="/blog/2020/04/15/mianshi/%E3%80%8C%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98%E3%80%8D%E8%BE%93%E5%85%A5URL%E5%88%B0%E6%B8%B2%E6%9F%93%E5%85%A8%E9%9D%A2%E6%A2%B3%E7%90%86%E4%B8%8A-%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E7%AF%87/"/>
    <url>/blog/2020/04/15/mianshi/%E3%80%8C%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98%E3%80%8D%E8%BE%93%E5%85%A5URL%E5%88%B0%E6%B8%B2%E6%9F%93%E5%85%A8%E9%9D%A2%E6%A2%B3%E7%90%86%E4%B8%8A-%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>此文是一道面试题，又不仅仅是一道面试题</p><p>从输入 <code>URL</code> 到页面渲染发生了什么？比如在浏览器输入了 <code>www.qq.com</code> 后浏览器是怎么把最终的页面呈现，这是一个非常经典的面试题，不管是大公司还是小公司甚至前端或后端的面试中命中率都极高，因为涉及到的知识点和可挖掘的地方比较多，而且这中间几乎每一步都是可以优化的</p><p>既然大家刷到了这篇帖子，希望大家花点时间耐心看完，不会让你失望的，此文从网络五层模型详解析及浏览器页面渲染机制等多方面来认识 URL 从输入到页面渲染的整个过程，内容还是满充实的</p><p>写着写着发现有点长，就分成三篇了 😄</p><p>前两篇文章都是帮助大家理解整个过程，所以并没有直接给出答案，而是给大家梳理解释一些相关琐碎的知识，目的不是答题，而是彻底理解此间流程，大家只要认真看到最后一篇就可以骄傲的回答这道题了，自己心中给自己一个答案，再看最后一篇我个人通过这些知识总结的答案 ( 如果你的总结更加充实/细致，请在评论区分享出来，我们一起查漏补缺 ) ，先看后思考，再总结相互讨论，效果最佳</p><p>URL 从输入到页面渲染这整个过程可以分为 <code>网络通信</code> 和 <code>页面渲染</code> 两个方面，一般后端程序猿回答这个问题侧重网络通信就行了，但是前端页面渲染也得了解，总之回答的越详细分值越高</p><p>那么开始吧，这篇文章我们先来看网络通信方面，可能前端同学大家对网络方面的认知应该没有后端同学强，其实这道面试题最能突出自己的也是网络方面，因为它涉及到了很多网络通信原理的知识，所以这块咱们慢慢梳理</p><h2 id="网络分层的由来"><a href="#网络分层的由来" class="headerlink" title="网络分层的由来"></a>网络分层的由来</h2><p>不晓得大家知不知道网络分层，网络其实有很多层，层与层之间又有好多协议存在，还有各种各样的数据包，这玩意干巴巴的，很没意思，这么多层太麻烦了，为什么有这么多层呢？为什么不直接一层呢？</p><p>起初计算机与计算机之间的通信只需要一根线就可以完成通信，但是世界那么大，那么多计算机，距离太远了，而且这线还老容易被无良的人偷偷剪断</p><p>后来就出来了无线网，虽然其中网关、路由之间也需要连线，但不是让每台计算机两两连接，而是一个区域为单位计算机相互连接通信</p><p>后来发现计算机之间的连线只能传送 0/1 信号，另一台计算并不知道那么多 0/1 代表什么，就像 <code>010101010101111000111011010</code> 你知道这一大串是什么意思吗，计算机也不知道，不同厂商生产的计算机连线实现通信也是很麻烦的，干脆定义一套规则吧，不管是哪个牌子的计算机，都必须遵守这套规则，这套规则就是我们经常说的 <code>网络协议</code></p><p>哦哦，是在说 <code>网络分层</code> ，不是讲 <code>网络协议</code> ，继续继续，接着我们上面的话题，问题来了，计算机之间通过连线传送 0/1 信号的问题虽然规定了通信规则，但是除了像 0/1 这种无意义的信号之外，网络中还存在着其他各种各样的问题</p><ul><li>两个计算机之间怎么进行识别？</li><li>怎么才能知道对方的地址？</li><li>不同计算机应用程序怎么知道是给自己传递的数据？</li><li>不同的通信数据格式怎么来规定等等一系列的问题</li></ul><p>如果各种问题都写成一套协议来规定双方通信的规则，但是万一其中哪些规则通信中出现问题，影响到了其他规则，最常见的就是数据包，一个数据包中如果包含各种各样的协议，呀呀呀</p><p>如果我们对网络进行分层，每一层负责一项具体的工作，然后把数据传送到下一层，那么往来通信和网络互联这一复杂的问题是不是就变得较为简单化了呢</p><p>可能大家没有太明白，没关系，接着看</p><h2 id="TCP-IP-五层模型"><a href="#TCP-IP-五层模型" class="headerlink" title="TCP/IP 五层模型"></a>TCP/IP 五层模型</h2><p>既然要分层，那么分为几层才好呢？</p><p>目前的网络层次可划分为 <code>四层因特网协议栈</code> 和 <code>七层因特网协议栈</code> ，其实起初网络分层是标准的七层，也就是我们所说的 <code>OSI 七层模型</code> ，参考模型是国际标准化组织 <code>ISO</code> 制定的一个用于计算机或通信系统间互联的标准体系，一般称为 <code>OSI参考模型</code> 或 <code>七层模型</code></p><p>可能对网络有些了解的同学知道还有 <code>TCP/IP 四层模型</code> 和 <code>TCP/IP 五层模型</code> ，这又是怎么出来的呢？</p><p>其实所谓的 <code>TCP/IP 四层模型</code> 和 <code>TCP/IP 五层模型</code> 是以 <code>OSI 七层</code> 优化而来，把某些层进行合并了，本质上还是相同的，<code>OSI七层模型</code> 太过细化，有一定的参考意义，但实现起来比较繁琐，相比较而言，<code>TCP/IP模型</code> 比较简洁，具有较强的实际应用价值</p><p>我们来看一个模型的图片 ( 网图侵删 )</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20200407141628775.png" alt="image-20200407141628775"></p><p><code>TCP/IP</code> 将计算机网络分成了四个层次，一般资料或教程里都是结合 <code>OSI7层模型</code> 和 <code>TCP/IP4层模型</code>，将计算机网络按照 5 层的模型来讲，5 层模型只是为了方便介绍计算机网络原理而设计的，而在实际应用中还是 <code>TCP/IP四层模型</code> ，这点大家要明白</p><p>这里我们同样用五层来解释，比较好理解些，当然，这里只能让大家脑海里有一个具体的网络分层结构的认知，作为面试回答了解这些足够，而后推荐大家继续深入，可以看相关的书籍和资料，此文也能够起到一个引导的作用</p><p><strong>PS：</strong> 作为一个前端或者是后端，我们都是软件开发，所以侧重点放在网络层以上就可以了，物理层和数据链路层都是硬件相关的，所以这两个层下面不会过多叙述，了解即可</p><h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><p>物理层，顾名思义，通过物理手段 ( 网线，光纤，无线 ) 将设备连接在一起，传输 0/1 电信号 ( 也叫比特流 ) ，就像我们上边讲到的计算机之间的物理连线</p><p>主要用来传输 0/1 信号，因为 0/1 信号没有任何的现实意义，所以用另一层用来规定不同 0/1 组合的意义</p><h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><p>还是上面说的，<code>010101010101111000111011010</code> ，像这么一串数据计算机并不知道是什么意思</p><p>下层的物理层不能规定不同 0/1 组合的信号代表什么意义，所以在数据链路层规定了一套协议，专门给 0/1 信号进行分组，规定不同的组代表的是什么意思，从而让双方计算机都能够进行识别，这个协议就是我们常说的 <code>以太网协议</code></p><h4 id="以太网协议"><a href="#以太网协议" class="headerlink" title="以太网协议"></a>以太网协议</h4><p>以太网协议规定一组电信号构成一个数据包，我们把这个数据包称为 <code>帧</code> ，每一个帧由 <code>标头</code> 和 <code>数据</code> 两部分组成</p><p>帧的大小一般为 <code>64 - 1518</code> 个字节 较大的数据则需要分成多个桢</p><p>标头 <code>Head</code> ，18 个字节组成，标头中包含这个 <code>桢</code> 是由谁发送、发送给谁这些信息，所以标头主要是一些说明数据 例如发送者/接受者等信息</p><p>数据 <code>Data</code> ，46-1500 个字节组成，里面主要是发送者想给接收者的内容</p><p>把一台计算机的数据通过物理层和数据链路层发送给另外一台计算机，怎么标识对方以及怎么知道对方的地址呢？ 唯一标示 <code>MAC地址</code> 出现了</p><h4 id="MAC-地址"><a href="#MAC-地址" class="headerlink" title="MAC 地址"></a>MAC 地址</h4><p>进入网络的每一台计算机，都会有网卡接口，每一个网卡都会有一个唯一的地址，就是所谓的 <code>MAC地址</code> ，它就是网络中每台计算机设备的唯一标识，是一串由 48 个字节组成的十六进制数，每台计算机在厂商生产出来的时候就标识好了，所以我们用 <code>MAC地址</code> 来标识对方</p><p>再来看一个图 ( 网图侵删 )</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20200407141654052.png" alt="image-20200407141654052"></p><p>如上图所示，如计算机 A 知道了计算机 B 的 MAC 地址，然后计算机 A 想要给计算机 B 传送数据，虽然计算机 A 知道了计算机 B 的 MAC 地址，可是 A 要怎么给 B 传送数据呢？</p><p>计算机 A 不仅连着计算机 B，而且计算机 A 也连接着计算机 C 和 D，虽然计算机 A 知道计算机 B 的 MAC 地址，但是却不知道 B 是在哪一路上，所以为了解决这个问题，<code>广播</code> 这个概念就出现了</p><h4 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h4><p>在同一子网络，就是我们常说的局域网中，计算机通过广播来通信，即向同子网中全部计算机发送数据包，其它计算机根据数据包中接收者的 <code>MAC地址</code> 来判断是否接收数据包</p><p>通俗来讲，就是 A 会同时给 B/C/D 发送数据包，这个数据包中会包含着接收者的 <code>MAC地址</code> 信息，当 B/C/D 接收到了数据包，会取出数据包中的 <code>MAC地址</code> 与自身的 <code>MAC地址</code> 对比，如相同就接收这个数据包，否则就丢弃这个数据包 ( 丢包 )，这种方式我们称之为 <code>广播</code></p><p>就像，你和女友在人群中走散了，你大喊一声她的名字，听到的人会自己匹配，是自己就会理会，不是自己就当你是傻子不理你</p><p>那么到了目前，我们知道了计算机之间的标示和如何通信，但是还有一个问题，要怎么知道对方的 <code>MAC地址</code> 呢 ？这又牵出了 <code>ARP协议</code> ，通过 <code>ARP协议</code> 来得知对方的 <code>MAC地址</code> ，这个协议是网络层的一个协议，所以我们暂且搁置，先接着往下看</p><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>看了物理层和数据链路层的作用，可能大家会觉得好像已经可以完成正常通信了，那么网络层又是做什么的呢？</p><p>其实我们所处的网络，是由无数个子网络 ( 局域网 ) 构成的，广播的时候，也只有同一个子网里的计算机能够收到，如过没有子网这种东西，计算机 A 通过广播的方式发一个数据包给计算机 B，那么全世界所有的计算机都能收到这个数据包，然后进行对比再舍弃，那么多台计算机后果可想而知，子网也因此而产生</p><p>那么问题又来了，我们要怎么区分 <code>Mac地址</code> 是属于同一个子网的呢？假如是同一个子网，我们就用广播的形式把数据传送给对方，如果不是同一个子网的，我们就会把数据发给网关，让网关进行转发</p><p>怎么判断两台计算机是否在同一个子网中呢，这就是网络层干的事情，为了解决这个问题，就有了 <code>IP协议</code> 的概念</p><h4 id="IP-协议"><a href="#IP-协议" class="headerlink" title="IP 协议"></a>IP 协议</h4><p><code>IP协议</code>所定义的地址，就是我们常说的 <code>IP地址</code> ，<code>IP协议</code> 有两个版本，<code>ipv4 / ipv6</code>，目前用的最多的还是 ipv4，这个地址由 32 位的二进制数组成，我们一般把它分成 4 段的十进制表示，地址范围在 <code>0.0.0.0 ~ 255.255.255.255</code> ，这个我们应该都很常见</p><p>每一台想要联网的计算机都会有一个 <code>IP地址</code> ，这个 <code>IP地址</code> 分为两部分，前面一部分代表网络，后面一部分代表主机，但是网络部分和主机部分所占用的二级制位数是不固定的</p><p>假如两台计算机的网络部分是一模一样的，我们就说这两台计算机是属于同一个子网 ( 局域网 ) 中，例如 <code>192.168.17.1</code> 和 <code>192.168.17.2</code> ， 假如这两个 <code>IP地址</code> 的网络部分为 24 位，主机部分为 8 位，那么他们的网络部分都为 <code>192.168.43</code> ， 所以我们说这两台计算机处于同一个子网中</p><p>问题又随之而来了，给我们两个 <code>IP地址</code> ，鬼知道网络部分占几位，主机部分又占几位呢？</p><p>这就又引出了我们另一个关键词 <code>子网掩码</code></p><h4 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h4><p><code>子网掩码</code> 和 <code>IP地址</code> 一样也是 32 位二进制数，但是它的网络部分规定全部为 1，主机部分规定全部为 0，也就是说假如上面那两个 IP 地址 的网络部分为 24 位，主机部分为 8 位的话，那他们的子网掩码为</p><p><code>11111111.11111111.11111111.00000000</code> ，也就是 <code>255.255.255.0</code></p><p>有了子网掩码，怎么来判断 <code>IP地址</code> 是否处于同一个子网中呢？</p><p>显然，知道了子网掩码，相当于我们知道了网络部分是几位，主机部分是几位，我们只需要把 <code>IP地址</code> 与他的子网掩码做一个 ( and ) 运算，然后把各自的结果进行比较就行了，如果比较的结果相同，则代表的是同一子网，否则不是同一子网</p><p>也就是说有了两台计算机的 <code>IP地址</code> 和 <code>子网掩码</code> ，我们就可以判断他们是否处在同一子网当中了</p><p>假设他们处在同一子网当中，计算机 A 要和计算机 B 发送数据时，我们通过是 <code>ARP协议</code> 来得到计算机的 <code>MAC地址</code></p><h4 id="ARP-协议"><a href="#ARP-协议" class="headerlink" title="ARP 协议"></a>ARP 协议</h4><p><code>ARP协议</code> 也是通过广播的形式，给同一个子网中每个电脑发送一个数据包，这个数据包会包含接收者的 <code>IP地址</code>，对方收到这个数据之后，会取出 <code>IP地址</code> 与自身的对比，相同则会把自己的 <code>MAC地址</code> 回复给对方，否则就丢弃这个数据包，这样计算机 A 就知道计算机 B 的 <code>MAC地址</code> 了</p><p>可能大家会问，知道了 <code>MAC地址</code> 后，发送数据是通过广播的形式发送，询问对方的 <code>MAC地址</code> 也是通过广播的形式来发送，那其他计算机怎么知道你是要传输数据还是询问 <code>MAC地址</code> 呢？</p><p>其实在询问 <code>MAC地址</code> 的数据包里，在对方的 <code>MAC地址</code> 这儿填的是一个特殊的 <code>MAC地址</code> ，其他计算机看到这个特殊的 <code>MAC地址</code> 后，就知道广播是在询问了</p><p>如果两台计算机的 IP 不是处于同一个子网之中，这个时候我们就会把数据包发送给网关，然后让网关帮我们进行转发</p><h3 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h3><p>通过 <code>物理层</code> / <code>数据链路层</code> 以及 <code>网络层</code> 的互相协调，我们成功的把数据从计算机 A 传到了计算机 B，可是计算机 B 里面有各式各样的应用程序，计算机是如何知道这个数据是发给哪个应用程序的呢？</p><p>这个时候，<code>端口</code> 就上场了，当计算机 A 传输给计算机 B 的时候，还得指定一个端口，以供特定的应用程序来接收处理，作为程序员的我们对端口就更熟悉了，端口范围：<code>0~65535</code>，其中前 1023 个端口被系统占用</p><p>那么也就是说，传输层的功能就是建立端口到端口的通信，而相比之下网络层的功能是建立主机到主机的通信</p><p>有了 <code>IP</code> 和 <code>端口</code> ，我们才能准确通信，我们输入的 IP 有些并没有指定端口号，其实是有些传输协议，设定了一些默认端口，例如 <code>HTTP</code> 默认是 80，<code>HTTPS</code> 默认 443，这些端口信息也会包含在数据包里面</p><p>传输层最常见了两大协议就是 <code>TCP协议</code> 和 <code>UDP协议</code></p><h4 id="UDP-协议"><a href="#UDP-协议" class="headerlink" title="UDP 协议"></a>UDP 协议</h4><p><code>UDP协议</code> 全称是用户数据报协议，是一种无连接的协议，与 TCP 协议一样用于处理数据包</p><p>UDP 数据包分 <code>标头</code> (8 个字节) 和 <code>数据</code> (加标头不超过 65535 个字节)， UDP 数据包放在 IP 数据包的 <code>数据</code> 中，标头主要包括发出端口和接收端口</p><p>UDP 有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的</p><h4 id="UDP-协议特点"><a href="#UDP-协议特点" class="headerlink" title="UDP 协议特点"></a>UDP 协议特点</h4><ul><li><p>面向无连接</p><ul><li>UDP 想发数据就可以开始发送了，不需要连接，它只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作</li><li>在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了</li><li>在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作</li></ul></li><li><p>有单播、多播、广播</p><ul><li>UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能</li></ul></li><li><p>面向报文</p><ul><li>发送方的 UDP 对应用程序交下来的报文，在添加首部后就向下交付 IP 层</li><li>UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界</li><li>因此，应用程序必须选择合适大小的报文</li></ul></li><li><p>不可靠性</p><ul><li>不可靠性首先体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠</li><li>收到什么数据就传什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了</li><li>网络环境时好时坏，但 UDP 没有拥塞控制，一直会以恒定的速度发送数据，即使网络条件不好，也不会对发送速率进行调整，这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景 ( 比如电话会议 ) 就需要使用 UDP 而不是 TCP</li></ul></li><li><p>头部开销小，传输数据报文高效</p><ul><li>UDP 头部包含了以下几个数据<ul><li>两个十六位的端口号，分别为发出端口和接收端口</li><li>整个数据报文的长度</li><li>整个数据报文的检验和（IPv4 可选字段），该字段用于发现头部信息和数据中的错误</li></ul></li><li>所以 UDP 的头部开销小，只有 8 字节，相比 TCP 的至少 20 字节要少得多，在传输数据报文时是很高效的</li></ul></li></ul><h4 id="TCP-协议"><a href="#TCP-协议" class="headerlink" title="TCP 协议"></a>TCP 协议</h4><p>当一台计算机想要与另一台计算机通讯时，两台计算机之间的通信需要畅通且可靠，这样才能保证正确收发数据</p><ul><li><p>例如你想查看网页或查看电子邮件时，希望完整且按顺序查看网页，而不丢失任何内容</p></li><li><p>又例如当你下载文件时，希望获得的是完整的文件，而不仅仅是文件的一部分</p></li></ul><p>如果数据丢失或乱序，都不是你希望得到的结果，于是就用到了 <code>TCP</code></p><p><code>TCP协议</code> 全称是传输控制协议是一种面向连接的、可靠的、基于字节流的传输层通信协议，<code>TCP</code> 是面向连接的、可靠的流协议，什么是流？流就是指不间断的数据结构，可以把它想象成排水管中的水流</p><p>TCP 三次握手建立连接，四次挥手断开连接又是一个话题，接下来我们就简单说一下</p><h4 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h4><p>三次握手建立链接，为方便理解，仿一次电面</p><ul><li><p>小李 (客户端)：您好，您是 xx 的面试官吗？</p></li><li><p>面试官 (服务端)：嗯嗯，是的，你是昨天投简历的小李吗？</p></li><li><p>小李 (客户端)：嗯嗯，是的，我是</p></li></ul><p>接着，小李和面试官开始愉快的侃起了大山</p><p>根据上面的内容，我们再来看下图 (网图侵删)</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/tcpip3.jpg" alt="tcpip3"></p><p>按正规流程来说建立连接的三次握手如下</p><ul><li><strong>第一次握手</strong> 客户端向服务端发送连接请求报文段，该报文段中包含自身的数据通讯初始序号，请求发送后，客户端便进入 <code>SYN-SENT</code> 状态</li><li><strong>第二次握手</strong> 服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 <code>SYN-RECEIVED</code> 状态</li><li><strong>第三次握手</strong> 当客户端收到连接同意的应答后，还要向服务端发送一个确认报文，客户端发完这个报文段后便进入 <code>ESTABLISHED</code> 状态，服务端收到这个应答后也进入 <code>ESTABLISHED</code> 状态，此时连接建立成功</li></ul><p>可能大家会有疑惑，为什么 TCP 建立连接需要三次握手，而不是两次？</p><p>其实这是为了防止出现失效的连接请求报文段被服务端接收的情况，从而产生错误</p><h4 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a>TCP 四次挥手</h4><p>四次挥手断开链接，接着仿电面 😄</p><ul><li><p>面试官 (主动方)：嗯，你的情况我这边了解了，等通知吧 ( 我想挂了 )</p></li><li><p>小李 (被动方)：嗯嗯，好的 ( 这就想挂了？我还没侃够 )</p></li><li><p>小李 (被动方)：那希望有机会能和您一块共事 ( 拜拜吧您嘞 )</p></li><li><p>面试官 (主动方)：嘀…嘀…嘀…嘀</p></li></ul><p>再看正经的过程图 (网图侵删)</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/tcpip4.jpg" alt="tcpip4"></p><p>TCP 是双向的，所以在断开连接时两端都需要发送 FIN 和 ACK</p><ul><li><p><strong>第一次握手</strong> 若客户端 A 认为数据发送完成，则它需要向服务端 B 发送连接释放请求</p></li><li><p><strong>第二次握手</strong> B 收到连接释放请求后，会告诉应用层要释放 TCP 链接，然后会发送 <code>ACK</code> 包，并进入 <code>CLOSE_WAIT</code> 状态，此时表明 A 到 B 的连接已经释放，不再接收 A 发的数据了，但是因为 TCP 连接是双向的，所以 B 仍旧可以发送数据给 A</p></li><li><p><strong>第三次握手</strong> B 如果此时还有没发完的数据会继续发送，完毕后会向 A 发送连接释放请求，然后 B 便进入 <code>LAST-ACK</code> 状态</p></li><li><p><strong>第四次握手</strong> A 收到释放请求后，向 B 发送确认应答，此时 A 进入<code>TIME-WAIT</code> 状态，该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃）时间，若该时间段内没有 B 的重发请求的话，就进入 <code>CLOSED</code> 状态，当 B 收到确认应答后，也便进入 <code>CLOSED</code> 状态</p></li></ul><h4 id="为何客户端最后还等待-2MSL"><a href="#为何客户端最后还等待-2MSL" class="headerlink" title="为何客户端最后还等待 2MSL"></a>为何客户端最后还等待 2MSL</h4><p>客户端需要保证最后一次发送的 <code>ACK</code> 报文到服务器，如果服务器未收到，可以请求客户端重发，这样客户端还有时间再发，重启 2MSL 计时</p><h4 id="TCP-IP-的并发限制"><a href="#TCP-IP-的并发限制" class="headerlink" title="TCP/IP 的并发限制"></a>TCP/IP 的并发限制</h4><p>其实浏览器对同一域名下并发的 TCP 连接是有限制的（2-10 个不等）</p><p>而且在 <code>HTTP1.0</code> 中往往一个资源下载就需要对应一个 TCP/IP 请求</p><h4 id="TCP-协议特点"><a href="#TCP-协议特点" class="headerlink" title="TCP 协议特点"></a>TCP 协议特点</h4><ul><li><p>面向连接</p><ul><li>面向连接，是指发送数据之前必须在两端建立连接，建立连接的方法就是 <code>三次握手</code>，这样能建立可靠的连接，为数据的可靠传输打下了基础</li></ul></li><li><p>仅支持单播传输</p><ul><li>每条 TCP 传输连接只能有两个端点，只能进行点对点的数据传输，不支持多播和广播传输方式</li></ul></li><li><p>面向字节流</p><ul><li>TCP 不像 UDP 一样那样一个个报文独立传输，而是在不保留报文边界的情况下以字节流方式进行传输</li></ul></li><li><p>可靠传输</p><ul><li>对于可靠传输，判断丢包，误码靠的是 TCP 的段编号以及确认号，TCP 为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收</li><li>然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)，如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传</li></ul></li><li><p>提供拥塞控制</p><ul><li>当网络出现拥塞的时候，TCP 能够减小向网络注入数据的速率和数量，缓解拥塞</li></ul></li><li><p>TCP 提供全双工通信</p><ul><li>TCP 允许通信双方的应用程序在任何时候都能发送数据，因为 TCP 连接的两端都设有缓存，用来临时存放双向通信的数据</li><li>当然，TCP 可以立即发送一个数据段，也可以缓存一段时间以便一次发送更多的数据段（最大的数据段大小取决于 MSS）</li></ul></li></ul><h4 id="UDP-协议和-TCP-协议区别"><a href="#UDP-协议和-TCP-协议区别" class="headerlink" title="UDP 协议和 TCP 协议区别"></a>UDP 协议和 TCP 协议区别</h4><p>到了现在，大家应该对 UDP 和 TCP 都有些了解了，我们直接对比其作用再进行总结</p><table><thead><tr><th align="left">对比</th><th align="left">UDP</th><th align="left">TCP</th></tr></thead><tbody><tr><td align="left">是否连接</td><td align="left">无连接</td><td align="left">面向连接</td></tr><tr><td align="left">是否可靠</td><td align="left">不可靠传输，不使用流量控制和拥塞控制</td><td align="left">可靠传输，使用流量控制和拥塞控制</td></tr><tr><td align="left">连接个数</td><td align="left">支持一对一，一对多，多对一和多对多通信</td><td align="left">只能一对一通信</td></tr><tr><td align="left">传输方式</td><td align="left">面向报文</td><td align="left">面向字节流</td></tr><tr><td align="left">首部开销</td><td align="left">首部开销小，仅 8 字节</td><td align="left">首部最小 20 字节，最大 60 字节</td></tr><tr><td align="left">适用场景</td><td align="left">适用于实时应用 ( IP 电话、视频会议、直播等 )</td><td align="left">适用于要求可靠传输的应用，例如文件传输</td></tr></tbody></table><ul><li>TCP 向上层提供面向连接的可靠服务 ，UDP 向上层提供无连接不可靠服务</li><li>虽然 UDP 并没有 TCP 传输来的准确，但是也能在很多实时性要求高的地方有所作为</li><li>对数据准确性要求高，速度可以相对较慢的，可以选用 TCP</li></ul><p>TCP 我们就简单说到这里，接下来我们接着来看应用层</p><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>应用层是最接触用户的，上面几层我们收到了传输层收到的数据，TCP/UDP 协议可以传递各种程序的数据包，就像邮箱/网页/FTP 等等，所以就需要不同的协议来规定数据的格式，收到后才能渲染解读，应用层就是由这些协议构成，它的数据包放在 UDP 包/TCP 包的 <code>数据</code> 中</p><p>我们遨游网络时经常用到的 HTTP 协议、文件传输用的 FTP 协议、电子邮件发送的 SMTP、域名解析的 DNS 协议、远程登录的 Telnet 协议等等都是属于应用层的</p><p>还有 Socket，它是在应用层和传输层之间的一个抽象层，它把 TCP/IP 层复杂的操作封装成几个简单的接口供应用层调用，从而实现进程在网络中的通信</p><p>上面我们已经基本了解到了计算机的一些通信基础，可以说到目前为止从一个 IP 到通信结束都已经知道了，但是我们输入的是域名不是 IP，那么它是怎么变成 IP 通信的呢？这就要详细说说 <code>DNS</code> 了</p><h4 id="DNS-是什么"><a href="#DNS-是什么" class="headerlink" title="DNS 是什么"></a>DNS 是什么</h4><p><code>Domain Name System</code> 简写 <code>DNS</code> ，翻译过来就是域名系统的意思，它是一种组织成域层次结构的计算机和网络服务命名系统，用于 <code>TCP/IP</code> 网络，作为将域名和 IP 地址相互映射的一个分布式数据库，它所提供的服务是用来将 <code>主机名</code> 和 <code>域名</code> 转换为 <code>IP地址</code> 的工作</p><p>简单来说，<code>IP地址</code> 就像门牌号一样，我们在输入域名访问网站时，数据服务器是不认识你这个域名的，它只认识 IP，你的域名会通过 <code>DNS服务器</code> 解析成 IP 值，通过这个门牌号 (IP 值) 向数据服务器查找你的网站数据并给你返回到浏览器上</p><h4 id="为什么需要-DNS"><a href="#为什么需要-DNS" class="headerlink" title="为什么需要 DNS"></a>为什么需要 DNS</h4><p>上面我们说，网络通讯大部分是基于 TCP/IP 的，而 TCP/IP 是基于 IP 地址的，所以计算机在网络上进行通讯时只能识别如 <code>252.94.131.12</code> 之类的 IP 地址，而不能认识域名</p><p>我们没办法记住 10 个以上 IP 地址的网站 ( 你要说记性好那俺就乖乖闭嘴了 😄 )，一般我们访问网站时，更多的是在浏览器地址栏中输入域名，就能看到所需要的页面，这是因为有一个叫 <code>DNS服务器</code> 的计算机自动把我们的域名 <code>翻译</code> 成了相应的 IP 地址，然后通过 <code>IP地址</code> 返回所对应的网页</p><h4 id="域名结构"><a href="#域名结构" class="headerlink" title="域名结构"></a>域名结构</h4><p>先来简单介绍下域名结构，有些前端同学可能不太了解，域名是在 <code>Internet</code> 上用于解决 IP 地址的一种方法，一个完整的域名由 2 个或 2 个以上的部分组成，各部分之间用英文的句号 <code>.</code> 来分隔</p><p>拿 <code>www.qq.com.</code> 来说，等等，是不是多打了一个点，当然不是多打，这个最后的 <code>.</code> 代表的是根域名，默认情况下所有的网址的最后一位都是 <code>.</code>，只不过为了方便用户，通常都会省略，浏览器在 <code>DNS解析</code> 时会自动加上的，<code>com</code>是顶级域名，<code>qq</code> 是二级域名，<code>www</code> 是三级域名，如果 <code>www</code> 前还有，那就四级等等</p><p>那么我们在解析时的顺序就是</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">.  -&gt; .com -&gt; qq.com -&gt; www.qq.com<br></code></pre></td></tr></table></figure><h4 id="DNS-获取流程"><a href="#DNS-获取流程" class="headerlink" title="DNS 获取流程"></a>DNS 获取流程</h4><p>DNS 是应用层协议，用于将用户提供的主机名解析为 ip 地址，它的获取流程大致分为下面这五步</p><ul><li><p>用户主机上运行着 DNS 客户端，就是我们的 PC 机或者手机客户端运行着 DNS 客户端</p></li><li><p>浏览器将接收到的 URL 中抽取出域名字段，就是访问的主机名，例如 <code>http://www.qq.com</code></p></li><li><p>DNS 客户机端向 DNS 服务器端发送一份查询报文，报文中包含着要访问的主机名字段，中间还包括一些列缓存查询以及分布式 DNS 集群的工作</p></li><li><p>该 DNS 客户机最终会收到一份回答报文，其中包含有该主机名对应的 IP 地址</p></li><li><p>一旦该浏览器收到来自 DNS 的 IP 地址，就可以向该 IP 地址定位的 HTTP 服务器发起 TCP 连接</p></li></ul><h4 id="DNS-解析过程"><a href="#DNS-解析过程" class="headerlink" title="DNS 解析过程"></a>DNS 解析过程</h4><p>假如我们要访问 <code>www.qq.com</code> ，那么要经历什么呢，先来看一张图 ( 网图侵删 )</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other//image-20200407141726887.png"></p><p>先简单的瞄一眼这张图，看不懂也没关系，结合文字再看</p><p>上图主要分为三个段</p><ul><li>DNS 客户机，就是我们主机上运行的 DNS 客户端，PC 机或者手机客户端都有</li><li>客户机到服务器，这个服务器可以简单理解为我们当前所处网络环境的路由器</li><li>服务器到服务器，最后这个服务器指的是 <code>互联网服务提供商服务器/根域名服务器/顶级域名服务器/主域名服务器</code></li></ul><p>DNS 获取流程有很多步骤，这个过程中存在多个请求，如果每次都经过这么多步骤，那就太耗时间了，所以 DNS 有多级缓存的概念，接下来我们来简单描述下这个过程</p><ul><li><p>浏览器缓存</p><ul><li>当用户通过浏览器访问 <code>www.qq.com</code> 时，浏览器首先会在自己缓存中查找是否有该域名对应的 IP 地址</li><li>若曾经访问过该域名且没有清空缓存便存在，不存在则继续下一步</li></ul></li><li><p>系统缓存</p><ul><li>当浏览器缓存中无域名对应 IP 则会自动检查用户计算机系统 <code>Hosts</code> 文件 DNS 缓存是否有该域名对应 IP</li></ul></li><li><p>路由器缓存</p><ul><li>当浏览器及系统缓存中均无域名对应 IP 则进入路由器缓存中检查，以上三步均为客服端的 DNS 缓存</li></ul></li><li><p>互联网服务提供商 ( ISP ) DNS 缓存</p><ul><li>当在用户客服端查找不到域名对应 IP 地址，则将进入互联网服务提供商 ( ISP ) DNS 缓存中进行查询</li><li>比如你用的是电信的网络，则会进入电信的 DNS 缓存服务器中进行查找</li></ul></li><li><p>根域名服务器</p><ul><li>当以上均未完成，则进入根服务器进行查询</li><li>根域名服务器收到请求后会查看区域文件记录，若无则将其管辖范围内顶级域名 ( <code>.com</code> ) 服务器 IP 告诉本地 DNS 服务器</li></ul></li><li><p>顶级域名服务器</p><ul><li>顶级域名服务器收到请求后查看区域文件记录，若无则将其管辖范围内主域名（ <code>qq.com</code> ）服务器的 IP 地址告诉本地 DNS 服务器</li></ul></li><li><p>主域名服务器</p><ul><li>主域名服务器接受到请求后查询自己的缓存，如果没有则进入下一级域名服务器（ <code>www.qq.com</code> ）进行查找，并重复该步骤直至找到正确纪录</li></ul></li><li><p>保存结果至缓存</p><ul><li>本地域名服务器把返回的结果保存到缓存，以备下一次使用，同时将该结果反馈给客户端，客户端通过这个 IP 地址与 Web 服务器建立链接</li></ul></li></ul><p>DNS 客户机可通过从以前查询获得的缓存信息就地应答查询，DNS 服务器可使用其自身的资源记录信息缓存来应答查询，也可代表请求客户机来查询或联系其他 DNS 服务器，以完全解析该名称，并随后将应答返回至客户机，这个过程称为 <code>递归查询</code></p><p>客户机自己尝试联系其他的 DNS 服务器来解析名称，如果客户机这么做，它会使用基于服务器应答的独立和附加的查询，该过程称作迭代，即 DNS 服务器之间的交互查询就是 <code>迭代查询</code></p><p>这就是 DNS 的整个过程了，是这道面试题的第一步，面试官可能还会问 DNS 解析要怎么优化，不急，慢慢来</p><h4 id="为什么要优化-DNS-解析"><a href="#为什么要优化-DNS-解析" class="headerlink" title="为什么要优化 DNS 解析"></a>为什么要优化 DNS 解析</h4><p>用户打开网站的整个流程中，DNS 解析是第一环，当用户输入域名并敲回车后，系统调用 <code>DNS客户端</code>，寻找到用户配置或者自动分配的<code>DNS IP</code>，之后就开始整个解析过程，<code>DNS服务器</code> 完成解析到此域名的 <code>数字IP服务器</code>，一般情况下返回给定域名对应的 IP 地址会花费 <code>20~120毫秒</code> 的时间，而且在这个过程中浏览器什么都不会做直到 DNS 查询完毕</p><p>一旦解析完成，连接建立并保持，也就是顺利的访问以后，网页以后的下载速度就和 DNS 没关系了，直到下一次重新解析和发起访问请求</p><p>很多小型网站，DNS 解析时间都接近 <code>0.5s</code>，有些甚至需要 <code>1s</code> 左右才可以解析出结果，一般网站用户的等待时间超过 <code>8s</code> 就会放弃访问，而对于电子商务网站，<code>4s</code> 就是用户忍耐极限，而一般经过优化的小型网站，DNS 解析时间都可以控制在 <code>200ms</code> 左右，而带宽在 <code>100M</code> 左右的网站，经过优化，DNS 解析时间可以控制在 <code>50~100ms</code></p><p>那么，你现在知道为什么要优化 DNS 解析了吧，怎么优化呢？我们接着看</p><h4 id="DNS-解析优化-善用缓存之-TTL"><a href="#DNS-解析优化-善用缓存之-TTL" class="headerlink" title="DNS 解析优化-善用缓存之 TTL"></a>DNS 解析优化-善用缓存之 TTL</h4><p>上买我们也看了，DNS 存在着多级缓存，每次找这么多级，很定耗时间，我们要尽量多的让用户直接从运营商的 DNS 缓存中拿到解析记录，这样就不需要走根域名服务器以下的这些过程，自然就节省了一些时间</p><p>我们购买域名做域名解析时，有一个 <code>TTL</code> 值 ( 如下图阿里云域名解析中所示 )</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20200407201056309.png"></p><p>它指的是域名解析的生命周期 ( 秒为单位 )，简单来说它表示 DNS 服务器解析域名时记录在 DNS 服务器上的缓存时间，这个值的大小设置也是很有学问的，我们要在尽可能快的情况下又要保证当服务器出问题时能够尽快切换</p><ul><li>大家自己肯定清楚自己的服务器有没有多台或备份，若无备份，那服务器宕机时只能生抗，所以，<code>TTL</code> 时间对于你来说是越长越好，因为 <code>TTL</code> 短的目的是服务器发生问题时，可以及时切换，这个对于没有备份的网站基本利用不上，所以这时你的 <code>TTL</code> 设置就越长越好，当然了，也不能太长，一般设置 <code>TTL 3600</code> 即可</li><li>若有备份或多台服务器，会发生由于服务器宕机需要及时做切换，<code>TTL</code> 时间越短切换越及时，但是 <code>TTL</code> 时间越短，也就意味着运营商 DNS 经常缓存不住，一般用户，设置为 <code>TTL 600</code> 即可，如果对及时切换，要求特别苛刻的网站，设置 <code>TTL 120</code> 就行</li></ul><h4 id="DNS-解析优化-负载均衡"><a href="#DNS-解析优化-负载均衡" class="headerlink" title="DNS 解析优化-负载均衡"></a>DNS 解析优化-负载均衡</h4><p>在 DNS 服务器中为同一个主机名配置多个 IP 地址，在应答 DNS 查询时，DNS 服务器对每个查询将以 DNS 文件中主机记录的 IP 地址按顺序返回不同的解析结果，将客户端的访问引导到不同的机器上去，使得不同的客户端访问不同的服务器，从而达到负载均衡的目的，可以根据每台机器的负载量或该机器离用户地理位置的距离入手</p><p>就像我们使用 CDN 厂商做域名解析，它也是利用 DNS 的重定向技术，DNS 服务器会返回一个跟用户最接近的点的 IP 地址给用户，CDN 节点的服务器负责响应用户的请求，提供所需的内容，CDN 厂商的域名解析服务器用户量多被访问的次数也多，域名解析服务器的 A 记录基本上会被各地运营商的 DNS 一直缓存着，所以服务效果也是最好的</p><h4 id="HTTP-amp-HTTPS"><a href="#HTTP-amp-HTTPS" class="headerlink" title="HTTP &amp; HTTPS"></a>HTTP &amp; HTTPS</h4><p>说完 DNS，本来还想写段 HTTP 和 HTTPS，这块也能说好久，但是后来又感觉写在这有些不太合适，那就下次有机会单独写吧</p><h2 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h2><p>网络通信篇到此结束，虽然此文写了上万字，但只能说整合了内容讲了个大概，怎么说呢，网络通信相关的一些知识都有提到，但并未深入，所以面试前临阵磨枪或查漏补缺可以，不要妄想通过看此文或者某一篇帖子就认为自己懂了网络通信，TCP/IP/DNS/HTTP/HTTPS 这些内容随便挑出来一个都可以长篇大论</p><p>当然，和大多数帖子一样，此文庞观的为大家梳理了一下网络通信的内容，并用通俗易懂的语气为大家描述，这也是为了大多数非科班出身的小伙伴，有错误的地方望海涵也望提出</p><p>如果大家想进一步了解网络通信，也可以此文为引子，深入看一些相关知识，第三文总结也为大家整理出来了网络和浏览器方面知识的思维导图，哪里不会自己去查资料找答案即可</p><p>下一文「一道面试题」输入 URL 到渲染全面梳理中-页面渲染篇，待续哦。。</p><p>哦，还有，可以加个好友加下群一起交流噻，公众号【不正经的前端】也欢迎关注呦 😄</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20200508193235095.png"></p>]]></content>
    
    
    <categories>
      
      <category>一道面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>网络</tag>
      
      <tag>浏览器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「一道面试题」小程序与H5的区别</title>
    <link href="/blog/2020/03/29/mianshi/%E3%80%8C%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98%E3%80%8D%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%8EH5%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/blog/2020/03/29/mianshi/%E3%80%8C%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98%E3%80%8D%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%8EH5%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="抛砖"><a href="#抛砖" class="headerlink" title="抛砖"></a>抛砖</h2><p>此文是一道面试题，又不仅仅是一道面试题</p><p>面试题，在各个技术社区里都是一个永不落伍的话题，好像大多数人临面试前都会狂刷面试题，恨不得把所有面试题都看一遍，要说有用没，当然有用，因为大部分面试题确实可以助力面试者，而且刷面试题对技术积累和视野提升也是有真实帮助的，可不只是面试有用</p><p>其实大家面试前都刷面试题，可能几个人去面试前刷的面试题题解都是一样的，这种情况无疑增加了面试者筛选的难度，同样的，这也是为什么不仅仅是大公司，中小公司面试题也越来难，甚至严重不符合岗位水准的原因之一，大家每次面试回来都会感叹一句 <code>俺可能配不上这个职位，这道题太难了！</code></p><p>也不能全怪那些出面试题的人，因为市面上面试题越来越多，想要鉴别一个人的真本事还是有些难度的，所以面的时候只能往深了问，借此筛掉一些人</p><p>这种情况是我们不能避免的，除非从此网上再无面试题解，可能面试时问题难度系数就会相对降低了</p><p>SO，大家看的都差不多，回答也差不多，怎么突出 <code>我们不一样呢</code> ，还是要从面试题下手</p><h2 id="引玉"><a href="#引玉" class="headerlink" title="引玉"></a>引玉</h2><p>首先，大家面试喜欢找什么样的题解？肯定是各个博主统一收集整理的面试题库了，看着方便、种类多、不用网上反复找零碎的面试题</p><p>其实这样好也不好，好处是可以快速了解市面上常见面试题，坏处嘛，各个博主其实碍于篇幅，给出的题解都是最精简的(此处意思是，一道面试题，给出对应的经典题解，并无太多相关知识点，而面试过程中是需要发散思维的)</p><p>想要突出和别人的不一样也简单，不能只刷面试题，每一个面试题都有它独特的考察意义，每刷一个面试题，不管它的难易程度，都认真看一看这道面试题相关技术的帖或文档，这样在问到这个面试题的时候起码不会被面试官随意一发散思维就 Pass 掉，在回答的时候也能从多个角度回答，而不仅限于此道面试题</p><p>还有就是大家方向都在研究各种复杂的题，这种题能答出来，面试官可能会觉得不错，但简单的题就不一样了</p><p>千万不要小瞧那些简单的面试题，简单的题大家回答都简单，但是你要能回答的很复杂，高低立判</p><p>说不得太开，需要自己理解，嘿嘿</p><p>我平常也会刷一刷面试题，提升提升视野，看看大前端行业内的水又深了多少 ( 着实怕呛水 )</p><p>这两天看一些博主发的阿里面试帖里都会看到一个题，就是本文标题，其实它就可以算一个例子</p><p>你说它难？刚入行的前端都能说出来几条</p><p>那它不难？刚看到的时候我认真想了想，如果我去面试被问到这个题了，显然我心中的答案并不能突出我比别人强</p><p>所以好好想了下怎么回答后就写了此文</p><h2 id="回归正题"><a href="#回归正题" class="headerlink" title="回归正题"></a>回归正题</h2><p>小程序与 H5 有什么区别？</p><h3 id="解析题目"><a href="#解析题目" class="headerlink" title="解析题目"></a>解析题目</h3><p>小程序与 H5 的区别，首先我们要看这道题问的侧重点在哪 ( 通俗讲就是先想一下这个题要考的是什么 )？</p><p>如果想挖你对 H5 的理解，我觉得不需要这么问，而问两者区别小程序在前，两者相对来说小程序是比较新的，很明显侧重点在小程序这块，通过与 H5 的对比来挖你对小程序的了解，那么回答的时候就要侧重小程序这块发散，要让面试官觉得，嗯，这小伙子对小程序还是有些了解的</p><p>接下来就侧重小程序尝试从各个方面对比来解答这个问题</p><h3 id="运行环境方面"><a href="#运行环境方面" class="headerlink" title="运行环境方面"></a>运行环境方面</h3><p>从运行环境方面开看，<code>H5</code> 的宿主环境是浏览器，只要有浏览器，就可以使用，包括 APP 中的 <code>web-view</code> 组件，以及小程序提供的 <code>web-view</code> 组件</p><p>小程序就不一样了，它运行于特定的移动软件平台 (Wechat / 支付宝 / 字节跳动 / 百度 / QQ 等)</p><p>拿微信小程序来说，它是基于浏览器内核重构的内置解析器，它并不是一个完整的浏览器，官方文档中重点强调了脚本内无法使用浏览器中常用的 <code>window</code> 对象和 <code>document</code> 对象，就是没有 <code>DOM</code> 和 <code>BOM</code> 的相关的 <code>API</code>，这一条就干掉了 <code>JQ</code> 和一些依赖于 <code>BOM</code> 和 <code>DOM</code> 的 NPM 包</p><h3 id="运行机制方面"><a href="#运行机制方面" class="headerlink" title="运行机制方面"></a>运行机制方面</h3><p><code>H5</code> 的运行就是一个网页的运行，这里不过多叙述</p><p>小程序还是以微信小程序举例</p><p>启动</p><ul><li><p>如果用户已经打开过某小程序，在一定时间内再次打开该小程序，此时无需重新启动，只需将后台态的小程序切换到前台，整个过程就是所谓的 <code>热启动</code></p></li><li><p>如果用户首次打开或小程序被微信主动销毁后再次打开的情况，此时小程序需要重新加载启动，就是 <code>冷启动</code></p></li></ul><p>销毁</p><ul><li>当小程序进入后台一定时间，或系统资源占用过高，或者是你手动销毁，才算真正的销毁</li></ul><h3 id="系统权限方面"><a href="#系统权限方面" class="headerlink" title="系统权限方面"></a>系统权限方面</h3><p>H5 最被诟病的地方在哪？系统权限不够，比如网络通信状态、数据缓存能力、通讯录、或调用硬件的，如蓝牙功能等等一些 APP 有的功能，H5 就没有这些系统权限，因为它重度依赖浏览器能力</p><p>依旧是微信小程序举例，微信客户端的这些系统级权限都可以和微信小程序无缝衔接，官方宣称拥有 <code>Native App</code> 的流畅性能</p><h3 id="开发语言方面"><a href="#开发语言方面" class="headerlink" title="开发语言方面"></a>开发语言方面</h3><p><code>H5</code> 开发大家都知道，标准的 <code>HTML、CSS、JavaScript</code> ，万变不离其三剑客</p><p>小程序不同， (Wechat / 支付宝 / 字节跳动 / 百度 / QQ 等)不同的小程序都有自己定义独特的语言</p><p>最常用的微信小程序，自定义的 <code>WXML</code>、<code>WXSS</code>，<code>WXML</code> 中全部是微信自定义的标签，<code>WXSS</code>、<code>JSON</code> 和 <code>JS</code> 文件中的写法都稍有限制，官方文档中都有明确的使用介绍，虽容易上手，但还是有区别的</p><blockquote><p>不同系小程序的开发语言都有些区别，说到这，来个题外话</p><p>随着微信小程序越来越火百度阿里字节这些大厂都出了对应的小程序，但是问题来了，小程序技术标准越来越碎片化，去年 9 月，万维网联盟 ( <code>World Wide Web Consortium</code>，简称 W3C ) 针对这一行业问题，正式对外发布由阿里巴巴主导发起并联合 W3C 中国及国内外厂商起草的《小程序国际标准化白皮书》( <a href="https://w3c.github.io/mini-app-white-paper/#graphics-and-media">链接</a> )</p><p>其实就是阿里准备牵头搞小程序标准了，阿里百度字节这些企业都有参与，但是一说小程序都是微信小程序，微信才是大头啊，腾讯好像并没有理它们，哈哈 (题外话，适当皮一下，如觉不妥请联系我删掉 😂)</p></blockquote><p>从开发语言的不同，就引出了开发成本这个问题了</p><h3 id="开发成本方面"><a href="#开发成本方面" class="headerlink" title="开发成本方面"></a>开发成本方面</h3><p>还是先说 <code>H5</code>，开发一个 <code>H5</code> ，我们要考虑什么，首先开发工具 ( <code>vscode/webstorm/atom/sublim</code>等 )，其次是开发框架 ( <code>Vue/React/Angular</code>等 )， 接着考虑模块化工具 ( <code>Webpack/Gulp/Parcel</code>等 )，再然后 UI 库、各种包的选择，更是数不胜数，还要考虑兼容问题，成本还是比较高的</p><p>这块小程序的话不用再去考虑浏览器兼容性，拿微信小程序举例子，没有兼容性问题后，只需要看着文档在微信开发工具里写就行了，小程序独还立出来了很多原生 APP 的组件，在 H5 需要模拟才能实现的功能，小程序里可以直接调用组件，都是封装好的，你也可以使用转译框架来写小程序，也有很多 UI 库选择，单论开发成本的话，小程序应该是胜出的</p><p>不过小程序再简单也是需要学习过程的，坑肯定也多，因为它还在逐步变强的过程中嘛，毕竟是和 H5 不一样的东西</p><h3 id="更新机制方面"><a href="#更新机制方面" class="headerlink" title="更新机制方面"></a>更新机制方面</h3><p><code>H5</code> 的话想怎么更新就怎么更新，更新后抛开 CDN/浏览器缓存啥的，基本上更新结束刷新就可以看到效果</p><p>小程序不同，还是微信举例，嘿嘿，微信小程序更新啥的是需要通过审核的</p><p>而且开发者在发布新版本之后，无法立刻影响到所有现网用户，要在发布之后 24 小时之内才下发新版本信息到用户</p><p>小程序每次 <code>冷启动</code> 时，都会检查有无更新版本，如果发现有新版本，会异步下载新版本代码包，并同时用客户端本地包进行启动，所以新版本的小程序需要等下一次 <code>冷启动</code> 才会应用上，当然微信也有 <code>wx.getUpdateManager</code> 可以做检查更新</p><h3 id="渲染机制方面"><a href="#渲染机制方面" class="headerlink" title="渲染机制方面"></a>渲染机制方面</h3><p>H5 就是 <code>web</code> 渲染，浏览器渲染</p><p>微信小程序的宿主环境是微信，宿主环境为了执行小程序的各种文件：<code>wxml</code>文件、<code>wxss</code>文件、<code>js</code>文件，提供了<code>双线模型</code> ，什么是双线程模型呢，先看一张官方图</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20200327233031052.png" alt="image-20200327233031052"></p><p>小程序的渲染层和逻辑层分别由 2 个线程管理</p><ul><li>渲染层：界面渲染相关的任务全都在 <code>WebView</code> 线程里执行，一个小程序存在多个界面，所以渲染层存在多个 <code>WebView</code>线程</li><li>逻辑层：一个单独的线程执行 JavaScript，在这个环境下执行的都是有关小程序业务逻辑的代码，就是通过图中的 <code>JsCore</code> 线程来运行 <code>JS</code> 脚本</li><li>这两个线程都会经过微信客户端( <code>Native</code> )中的 <code>WeixinJsBridage</code> 进行中转通信，逻辑层把数据变化通知到视图层，触发视图层页面更新，视图层把触发的事件通知到逻辑层进行业务处理</li></ul><p>小程序的渲染逻辑</p><ul><li>在渲染层将 <code>WXML</code> 先转换为 <code>js</code> 对象也就是虚拟 <code>DOM</code></li><li>在逻辑层将虚拟 <code>DOM</code> 对象生成真实 <code>DOM</code> 树，交给渲染层渲染</li><li>当视图有数据需更新时，逻辑层调用小程序宿主环境提供的 <code>setData</code> 方法将数据从逻辑层传递到渲染层</li><li>经过对比前后差异 ( diff 算法 )，把差异应用在真实的 <code>Dom</code> 树上，渲染出正确的 UI 界面完成视图更新</li></ul><p>虽然小程序是通过 <code>Native</code> 原生渲染的，但是小程序也支持 web 渲染，就是 <code>web-view</code> 组件，在 <code>web-view</code> 中加载 <code>H5</code> 页面，而我们开发小程序时，通常会使用 <code>hybrid</code> 的方式，根据具体情况选择部分功能用小程序原生的代码来开发，部分功能通过 <code>web-view</code> 加载 <code>H5</code> 页面来实现，<code>Native</code> 与 <code>Web 渲染</code> 混合使用，实现项目最优解</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>嗯，就到这了，内容不多，当作回答我觉得讲个 5 ～ 10 分钟就够了，上面就是个大概，先把上面讲一下，然后你得给面试官问的机会，而他问的东西肯定是你讲的这些内容中发散出来的</p><p>所以你还需要按照上文讲述的大致内容看些相关文档，起码是要对上面自己发散出来的东西有一些了解的，能够突出亮点的其实都在渲染机制那里，也是这个问题的重点 ( 这里最能吹 ) ，而面试官发散的点也极大可能是双线程/渲染这里</p><p>最后，此文写的比较快，内容为个人理解，可能会有些片面，如有不当或补充，还请指出，互相讨论，多谢</p><p>对你有用的话，点个赞吧</p><p>哦，还有，可以加个好友加下群一起交流噻，公众号【不正经的前端】也欢迎关注呦 😄</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/new1.png" alt="new1"></p>]]></content>
    
    
    <categories>
      
      <category>一道面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>小程序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Wechaty|NodeJS基于iPad协议手撸一个简单的微信机器人助手</title>
    <link href="/blog/2020/03/01/other/Wechaty%7CNodeJS%E5%9F%BA%E4%BA%8EiPad%E5%8D%8F%E8%AE%AE%E6%89%8B%E6%92%B8%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%BE%AE%E4%BF%A1%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%8A%A9%E6%89%8B/"/>
    <url>/blog/2020/03/01/other/Wechaty%7CNodeJS%E5%9F%BA%E4%BA%8EiPad%E5%8D%8F%E8%AE%AE%E6%89%8B%E6%92%B8%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%BE%AE%E4%BF%A1%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%8A%A9%E6%89%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>我是一名前端，平时也喜欢写技术博客和交朋友，为此我也创建了微信技术交流群和微信公众号，一般我都会在文章下面贴出公众号和我的个人二维码，给有兴趣的小伙伴们添加微信然后我再拉他们进群这些，但是不停的同意微信好友验证，再发送群邀请真的是太痛苦了，相信很多做公众号的小伙伴都和我一样，作为一名开发，这种重复劳动是绝对不能忍受的</p><p>我知道也见过有些博主的微信小号是机器人，很方便，如果我也能有一个机器人小号，只是自动通过好友验证，然后关键字回复直接发送群邀请就已经非常实用了，嗯～，想想还有些兴奋</p><p>SO，大概在 19 年 10 月吧，就陆陆续续开始了我的微信机器人之旅</p><p><del>首先，我找了几个微信机器人平台，奈何价格实在不美丽</del></p><p>笑话，咱可是一名正八经的开发，这种非技术手段我会用？( 其实是没得钱噻！😅 )</p><p>说干就干，不过要从 0 到 1 的开发不太现实，所以就开始 Github 上寻找开源作品</p><p>对比了几个比较知名的几个开源微信机器人项目</p><ul><li>itchat<ul><li><code>itchat</code>是一个开源的微信个人号接口，基于 python 调用微信</li><li>使用不到三十行的代码，你就可以完成一个能够处理所有信息的微信机器人</li></ul></li><li>wechaty<ul><li><code>Wechaty</code>是适用于微信个人的 Bot SDK ，可以使用 6 行 js 创建一个机器人</li><li>具有包括<code>linux</code>，<code>Windows</code>，<code>MacOS</code>和 <code>Docker</code> 在内的跨平台支持，基于 Node.js</li></ul></li><li>Vbot<ul><li>是基于微信 web 版的接口，使用<code>http</code>协议以及轮询方式实现</li><li><code>Vbot</code>的亮点在于通过匿名函数，能够实现多种有趣的玩法</li><li>通过 API，更方便的打造属于自己的网页版微信，基于 PHP</li></ul></li></ul><p>上面这些都是项目官方的简述，直接 <code>copy</code> 来的，刚看到这三款作品时，想都没想，果断选择<code>wechaty</code></p><p>为什么？单论第一印象</p><ul><li>对于一名前端来说，Node.js 的亲和力自然不用多说</li><li><code>itchat</code>官方说不到三十行代码实现，<code>Vbot</code>就没说多少行，<code>Wechaty</code>抛开 JS ，官方说只用 6 行</li></ul><p>没错，就是因此，我开始了 <code>wechaty</code> 的第一次亲密接触</p><h2 id="第一次接触-wechaty"><a href="#第一次接触-wechaty" class="headerlink" title="第一次接触 wechaty"></a>第一次接触 wechaty</h2><p>Wechaty 是基于<code>NodeJS+TS</code>实现</p><p>当然开发时我们不一定非要使用 TS，js 也可以的，这也是我个人很喜欢<code>Wechaty</code>团队的一点，因为官方给的示例都是基于 js 的而不是 ts，不习惯 ts 的小伙伴有福了</p><p>开发前，肯定是要先查看 wechaty 文档的，一看还别说，感觉还真挺容易上手的</p><ul><li><a href="https://github.com/wechaty/wechaty">wechaty-Github</a></li></ul><p>简单的看了一下文档后，我开始下载官方给的示例项目 <a href="https://github.com/wechaty/wechaty-getting-started">wechaty/wechaty-getting-started</a></p><p>下载完之后就是安装依赖运行</p><p>首次运行很慢的，还有可能不成功，因为中间要安装运行<code>Puppeteer</code>，有人可能要试好多次</p><p>然而这些我都没遇到，运行很成功，一切都很顺利，完全没有意外发生，哈哈哈</p><p>运行成功后如下图，就可以扫码登录了</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other//image-20200226180859522.png" alt="image-20200226180859522"></p><p>然后，意外就发生了 😬</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other//image-20200226181313773.png" alt="image-20200226181313773"></p><p>登录不成功，真是尴尬</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-string">&quot;为了你的帐号安全，此微信号不能登录网页微信。你可以使用Windows微信或Mac微信在电脑端登录。Windows微信下载地址：https://pc.weixin.qq.com  Mac微信下载地址：https://mac.weixin.qq.com&quot;</span><br></code></pre></td></tr></table></figure><h2 id="网页版微信登录不成功"><a href="#网页版微信登录不成功" class="headerlink" title="网页版微信登录不成功"></a>网页版微信登录不成功</h2><p>当初其实卡在这里很久，我重复试了好多次都不行</p><p>原因是因为目前我们使用的是基于 web 端的微信 API 接口，可能是 web 端接口什么的都不太安全吧</p><p>微信官方在慢慢收缩 web 端微信的使用，官方对网页版微信进行了动态安全策略调整</p><p>如登录网页版微信收到安全提示，则不支持登录网页版微信</p><p>2017 年之后注册的微信号都无法登录网页版微信，而 2017 年之前注册得微信账号也有很大几率登录不上</p><p>我赶紧试了试我的所有微信号，都是很早就注册的那种，可是依旧是登录不上，跑起来了登不上，这岂不是凉了</p><p>到了最后终于使用我一个朋友的微信号登上了，但是那是朋友的大号，人家要用的</p><p>后来我就到处找这个东西的解决办法，连带上花钱收可以登录网页版微信的号，拖了好些天依旧无果</p><p>检验你的微信号只不支持 web 端微信，尝试登录一下网页版微信就好了</p><ul><li><a href="https://wx.qq.com/">https://wx.qq.com/</a></li></ul><p>就这个链接，PC 端进入然后手机扫码登录，可以登上就是可用 web 微信</p><p>早期其实 <code>Vbot</code> 和 <code>itchat</code> 这两个项目都挺火的，但是它们都是基于网页版微信实现的</p><p>特别是<code>itchat</code> 项目的<code>Github issuse</code>中第一个就写着</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other//image-20200226191429357.png" alt="image-20200226191429357"></p><p>登录不上去的在这里劝大家一句，不要在这个问题上纠结太久</p><p>有渠道的小伙伴可以尝试收一个可以登录网页版微信的号，不过亲测很难</p><p>没有号的小伙伴就不要纠结了，没什么用又浪费时间，亲身经历(某人曾明知道官方限制，还依旧偏执的找解决方案找了好多天 😭)</p><p>看到这里你可能会说：看了这么多了你跟我说不行？</p><p>不要着急，如果你使用<code>Vbot</code>和<code>itchat</code>，没有可登录的微信号确实是往下进行不了</p><p>但是我们现在使用的是<code>wechaty</code>，接下来就可以体现<code>wechaty</code>的过人之处了</p><p>当然如果你可以登录，那就可以看着官方文档或示例开发了，很省事</p><p>你也可以继续看看下文我写的一个小 demo，虽然协议不同，不过 API 和思路都是一致的</p><p>如果你登录不上，那就更要看下解决办法了</p><h2 id="wechaty-puppet-padplus"><a href="#wechaty-puppet-padplus" class="headerlink" title="wechaty-puppet-padplus"></a>wechaty-puppet-padplus</h2><p>网页版微信登录不上？收可登录微信号又收不到？</p><p>不要着急</p><p><code>wechaty-puppet-padplus</code>同是<code>wechaty</code>团队开发，不同于上文基于微信 web 端，它是基于 iPad 协议</p><ul><li><a href="https://github.com/wechaty/wechaty-puppet-padplus">wechaty-puppet-padplus</a></li></ul><p>使用这个包是需要 <code>Token</code> 令牌的，官方说</p><blockquote><p>Our Mission: Make it easy to build a WeChat Chatbot for developers.</p><p>We provide a <strong>free</strong> access using <a href="https://github.com/wechaty/wechaty-puppet-padplus">iPad protocol</a> for the developers who have a strong will and ability to build a valuable chatbot for users.</p><p>Any developers can add JuziBOT Inc’s staff ( <strong>Wechat number : botorange_yeah</strong> ) as a Wechat friend. You will receive a review form after adding. If you pass the review and willing to write a blog in Wechaty , you can use our iPad protocol for free！</p><p>我们的使命：轻松为开发人员构建微信聊天机器人</p><p>我们为有强烈意愿和能力为用户构建有价值的聊天机器人的开发人员提供了使用<a href="https://github.com/wechaty/wechaty-puppet-padplus">iPad 协议</a>的<strong>免费</strong>访问权限</p><p>任何开发人员都可以将 JuziBOT Inc 的工作人员（<strong>微信编号：botorange_yeah</strong>）添加为微信好友。添加后，您将收到一份审查表。如果您通过审查并愿意在 Wechaty 中写博客，则可以免费使用我们的 iPad 协议！</p></blockquote><p>大概意思就是我们提交审查表后，会获得为期 15 天的免费 Token</p><p>想要获取长期有效的免费 token，那就参加所谓的开源激励计划，就是在 15 天后，需要提交一个 MVP(最小可行化产品)的 Github 仓库，Wechaty 会将其 fork 到社区中的同时，会提供一个长期免费 Token</p><p>反之，就需要继续协商讨论后续的合作形式，我觉得是很良心了</p><p>没错，这篇帖子就是我申请的 15 天免费 token 下的一个输出</p><p>当然，我是有时间就会写一些，毕竟时间不多，所以开发出来的东西功能也不多，后期慢慢改进吧</p><p>讲了这么多，接下来才是正经的分享，比较简单，算是入门级，供大家参考吧</p><h2 id="基于-ipad-协议的微信机器人"><a href="#基于-ipad-协议的微信机器人" class="headerlink" title="基于 ipad 协议的微信机器人"></a>基于 ipad 协议的微信机器人</h2><h3 id="明确需求"><a href="#明确需求" class="headerlink" title="明确需求"></a>明确需求</h3><p>开发之前，我们要先明确下需求，就是我需要机器人来做什么</p><ul><li>自动通过好友验证<ul><li>当有人添加机器人时，判断验证消息关键字后通过或直接通过</li><li>通过验证后自动回复并介绍机器人功能</li></ul></li><li>私聊关键字回复<ul><li>例如回复 <code>加群</code> 推送群聊邀请</li><li>例如回复 <code>作者微信</code> 推送作者微信名片</li></ul></li><li>自动聊天<ul><li>群聊中通过 <code>@[机器人]xxx</code> 可以和机器人聊天</li><li>私聊发送消息即可聊天</li></ul></li><li>加入群聊自动欢迎<ul><li>当新的小伙伴加入群聊后自动 <code>@[新的小伙伴]</code> 发一个文字欢迎</li></ul></li></ul><p>OK，先实现这几个简单的功能吧，还是比较有用的，后期再说后期的事嘛</p><h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><p>功能比较简单，分多个就是为了不让所有代码都在一个文件，简单分开下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">|-- src/<br>|---- index.js# 入口文件<br>|---- config.js  # 配置文件<br>|---- onScan.js# 机器人需要扫描二维码时监听回调<br>|---- onRoomJoin.js # 进入房间监听回调<br>|---- onMessage.js# 消息监听回调<br>|---- onFriendShip.js# 好友添加监听回调<br>|-- package.json<br></code></pre></td></tr></table></figure><h3 id="初期准备"><a href="#初期准备" class="headerlink" title="初期准备"></a>初期准备</h3><p>首先新建文件夹，初始化</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">npm init -y<br></code></pre></td></tr></table></figure><p>接着我们安装比较重要的核心包</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// Wechaty核心包</span><br>npm install --save wechaty<br><br><span class="hljs-comment">// padplus协议包</span><br>npm install --save wechaty-puppet-padplus<br></code></pre></td></tr></table></figure><p>我们在开发过程中，还需要用到<code>qrcode-terminal</code>这个包，作用就是将二维码输出在终端来供我们扫码登录</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">npm install --save qrcode-terminal<br></code></pre></td></tr></table></figure><p>然后就可以愉快的开发了，没错就是这么简单</p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>所谓的配置文件，就是那个 <code>config.js</code> ，只是把我们需要用到的一些可配置参数拿出来</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-comment">// puppet_padplus Token</span><br>  <span class="hljs-attr">token</span>: <span class="hljs-string">&quot;你自己申请的ipad协议token&quot;</span>,<br>  <span class="hljs-comment">// 你的机器人名字</span><br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;圈子&quot;</span>,<br>  <span class="hljs-comment">// 房间/群聊</span><br>  <span class="hljs-attr">room</span>: &#123;<br>    <span class="hljs-comment">// 管理群组列表</span><br>    <span class="hljs-attr">roomList</span>: &#123;<br>      <span class="hljs-comment">// 群名字(用于发送群名字加群):群id，后面会介绍到</span><br>      Web圈: <span class="hljs-string">&quot;*****@chatroom&quot;</span>,<br>      男神群: <span class="hljs-string">&quot;*****@chatroom&quot;</span>,<br>    &#125;,<br>    <span class="hljs-comment">// 加入房间回复</span><br>    <span class="hljs-attr">roomJoinReply</span>: <span class="hljs-string">`你好，欢迎加入`</span>,<br>  &#125;,<br>  <span class="hljs-comment">// 私人</span><br>  <span class="hljs-attr">personal</span>: &#123;<br>    <span class="hljs-comment">// 好友验证自动通过关键字</span><br>    <span class="hljs-attr">addFriendKeywords</span>: [<span class="hljs-string">&quot;加群&quot;</span>, <span class="hljs-string">&quot;前端&quot;</span>],<br>    <span class="hljs-comment">// 是否开启加群</span><br>    <span class="hljs-attr">addRoom</span>: <span class="hljs-literal">true</span>,<br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="入口文件"><a href="#入口文件" class="headerlink" title="入口文件"></a>入口文件</h3><p>入口文件，也就是我们 <code>src</code> 目录下的 <code>index.js</code> 文件</p><p>这里做的很简单，没有逻辑</p><p>首先引入我们包</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> &#123; Wechaty &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;wechaty&quot;</span>) <span class="hljs-comment">// Wechaty核心包</span><br><span class="hljs-keyword">const</span> &#123; PuppetPadplus &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;wechaty-puppet-padplus&quot;</span>) <span class="hljs-comment">// padplus协议包</span><br><span class="hljs-keyword">const</span> config = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./config&quot;</span>) <span class="hljs-comment">// 配置文件</span><br></code></pre></td></tr></table></figure><p>接着初始化我们的 bot</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 初始化</span><br><span class="hljs-keyword">const</span> bot = <span class="hljs-keyword">new</span> Wechaty(&#123;<br>  <span class="hljs-attr">puppet</span>: <span class="hljs-keyword">new</span> PuppetPadplus(&#123;<br>    <span class="hljs-attr">token</span>: config.token,<br>  &#125;),<br>  <span class="hljs-attr">name</span>: config.name,<br>&#125;)<br></code></pre></td></tr></table></figure><p>接下来一段链式调用，监听，启动，完事</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> onScan = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./onScan&quot;</span>)<br><span class="hljs-keyword">const</span> onRoomJoin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./onRoomJoin&quot;</span>)<br><span class="hljs-keyword">const</span> onMessage = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./onMessage&quot;</span>)<br><span class="hljs-keyword">const</span> onFriendShip = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./onFriendShip&quot;</span>)<br><br>bot<br>  .on(<span class="hljs-string">&quot;scan&quot;</span>, onScan) <span class="hljs-comment">// 机器人需要扫描二维码时监听</span><br>  .on(<span class="hljs-string">&quot;room-join&quot;</span>, onRoomJoin) <span class="hljs-comment">// 加入房间监听</span><br>  .on(<span class="hljs-string">&quot;message&quot;</span>, onMessage(bot)) <span class="hljs-comment">// 消息监听</span><br>  .on(<span class="hljs-string">&quot;friendship&quot;</span>, onFriendShip) <span class="hljs-comment">// 好友添加监听</span><br>  .start()<br></code></pre></td></tr></table></figure><p>上面代码都有注释，<code>scan, room-join, message, friendship</code> 这些都是我们各个阶段的事件监听</p><ul><li>scan 机器人需要扫描二维码时监听</li><li>room-join 加入房间监听</li><li>message 消息监听</li><li>friendship 好友添加监听</li></ul><p>这些事件监听我只做简单解释，因为没啥说的，api 文档都有</p><p>不由的想起尤大的那个表情包：请仔细阅读我们的文档！！！</p><p>这些个监听后面的回调，我这里只不过把他们单独拿出去了，也就是上文目录结构中的那几个文件</p><p>这里的<code>onMessage</code>是做了一个方法调用，其实还是返回一个回调函数，只不过我们在消息监听中用到了<code>bot</code>实例，所以用这种方式传值而已</p><p>接下来我们按顺序来解释下这几个文件做了什么</p><h3 id="onScan"><a href="#onScan" class="headerlink" title="onScan"></a>onScan</h3><p><code>onScan</code> 文件是我们在机器人需要扫描二维码时的监听回调</p><p>这里面的代码超级简单</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> Qrterminal = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;qrcode-terminal&quot;</span>)<br><br><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onScan</span>(<span class="hljs-params">qrcode, status</span>) </span>&#123;<br>  Qrterminal.generate(qrcode, &#123; <span class="hljs-attr">small</span>: <span class="hljs-literal">true</span> &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>首先引入 <code>qrcode-terminal</code> 包</p><p>这个回调中其实做的很简单，回调接收了两个参数</p><ul><li>qrcode qr 码</li><li>status 状态</li></ul><p>我们借助<code>Qrterminal.generate</code>这个 API 将 qr 码输出到终端而已，后面那个<code>small</code>参数是因为<code>qrcode-terminal</code> 这个包默认输出的二维码太大了，给它变小一些</p><h3 id="onFriendShip"><a href="#onFriendShip" class="headerlink" title="onFriendShip"></a>onFriendShip</h3><p>onFriendShip 是 friendship 事件监听的回调，好友添加监听</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> &#123; Friendship &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;wechaty&quot;</span>)<br><span class="hljs-comment">// 配置文件</span><br><span class="hljs-keyword">const</span> config = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./config&quot;</span>)<br><span class="hljs-comment">// 好友添加验证消息自动同意关键字数组</span><br><span class="hljs-keyword">const</span> addFriendKeywords = config.personal.addFriendKeywords<br><br><span class="hljs-comment">// 好友添加监听回调</span><br><span class="hljs-built_in">module</span>.exports = <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onFriendShip</span>(<span class="hljs-params">friendship</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> logMsg<br>  <span class="hljs-keyword">try</span> &#123;<br>    logMsg = <span class="hljs-string">&quot;添加好友&quot;</span> + friendship.contact().name()<br>    <span class="hljs-built_in">console</span>.log(logMsg)<br>    <span class="hljs-keyword">switch</span> (friendship.type()) &#123;<br>      <span class="hljs-comment">/**</span><br><span class="hljs-comment">       * 1. 新的好友请求</span><br><span class="hljs-comment">       * 设置请求后，我们可以从request.hello中获得验证消息,</span><br><span class="hljs-comment">       * 并通过`request.accept（）`接受此请求</span><br><span class="hljs-comment">       */</span><br>      <span class="hljs-keyword">case</span> Friendship.Type.Receive:<br>        <span class="hljs-comment">// 判断配置信息中是否存在该验证消息</span><br>        <span class="hljs-keyword">if</span> (addFriendKeywords.some(<span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> v == friendship.hello())) &#123;<br>          logMsg = <span class="hljs-string">`自动通过验证，因为验证消息是&quot;<span class="hljs-subst">$&#123;friendship.hello()&#125;</span>&quot;`</span><br>          <span class="hljs-comment">// 通过验证</span><br>          <span class="hljs-keyword">await</span> friendship.accept()<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          logMsg = <span class="hljs-string">&quot;不自动通过，因为验证消息是: &quot;</span> + friendship.hello()<br>        &#125;<br>        <span class="hljs-keyword">break</span><br><br>      <span class="hljs-comment">/**</span><br><span class="hljs-comment">       * 2. 友谊确认</span><br><span class="hljs-comment">       */</span><br>      <span class="hljs-keyword">case</span> Friendship.Type.Confirm:<br>        logMsg = <span class="hljs-string">&quot;friend ship confirmed with &quot;</span> + friendship.contact().name()<br>        <span class="hljs-keyword">break</span><br>    &#125;<br>    <span class="hljs-built_in">console</span>.log(logMsg)<br>  &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>    logMsg = e.message<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上所示，我们想加好友时，验证消息填写我们指定的文字可以自动通过</p><p>So，我们从配置文件中拿到这个参数，在新的好友请求过来时做一个判断即可</p><h3 id="onRoomJoin"><a href="#onRoomJoin" class="headerlink" title="onRoomJoin"></a>onRoomJoin</h3><p>onRoomJoin，也就是进入房间监听回调</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 配置文件</span><br><span class="hljs-keyword">const</span> config = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./config&quot;</span>)<br><span class="hljs-comment">// 加入房间回复</span><br><span class="hljs-keyword">const</span> roomJoinReply = config.room.roomJoinReply<br><span class="hljs-comment">// 管理群组列表</span><br><span class="hljs-keyword">const</span> roomList = config.room.roomList<br><br><span class="hljs-comment">// 进入房间监听回调 room-群聊 inviteeList-受邀者名单 inviter-邀请者</span><br><span class="hljs-built_in">module</span>.exports = <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onRoomJoin</span>(<span class="hljs-params">room, inviteeList, inviter</span>) </span>&#123;<br>  <span class="hljs-comment">// 判断配置项群组id数组中是否存在该群聊id</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.values(roomList).some(<span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> v == room.id)) &#123;<br>    <span class="hljs-comment">// let roomTopic = await room.topic()</span><br>    inviteeList.map(<span class="hljs-function">(<span class="hljs-params">c</span>) =&gt;</span> &#123;<br>      <span class="hljs-comment">// 发送消息并@</span><br>      room.say(roomJoinReply, c)<br>    &#125;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>需求是在我们需要管理的群聊中，只要有新人加入，我们就发一个欢迎词并@他下</p><p>当然这些东西还是在 config 中配置好的，在这里拿到就可以</p><p>此回调接收三个参数</p><ul><li>room 群聊实例</li><li>inviteeList 受邀者名单</li><li>inviter 邀请者</li></ul><p>有了房间，受邀者，邀请者，那么这里也就非常 easy 了</p><p>做一下判断就可以了，这里的<code>room.id</code>就是我们配置的管理群组列表对象的 value 值</p><p>为什么要有管理群组列表对象呢？因为我们在登录了一个微信号时，群组进入监听是针对微信号中所有群组的</p><p>我的需求是要管理我的群组，所以事先跑了下程序，输出了<code>room</code>，然后群里发个消息，就拿到了我想管理的群组所有信息，id 自然也在里面，然后写到了配置里</p><p>接下来就是，监听到新加入，把受邀者列表遍历一下，使用<code>room.say</code>方法发送群消息即可，受邀者列表里存的就是加入的微信号实例，<code>say</code> 方法第一个参数就是要发送的消息，第二个参数就是为了@此人一下。。。感觉我的叙述毫无营养，还是那句话，这里只是说它是什么意思，具体 API 阅读文档吧，文档都有，也很简单</p><h3 id="message"><a href="#message" class="headerlink" title="message"></a>message</h3><p>最后就是 message 回调了，这个是代码最多的一个地方了，消息监听回调嘛</p><p>这也是代码中稍微有些逻辑的地方，因为要有各种判断</p><p>先不说程序逻辑，机器人嘛，总得能聊天不是，所以网上找了个免费的机器人聊天接口对接了一下</p><p>该接口详细请看</p><ul><li><a href="https://drea.cc/mm.php">https://drea.cc/mm.php</a></li></ul><p>其实就是一个 API，我们做一下封装，调用传入消息，返回消息，仅此而已</p><p>因为有请求，所以这块用了一个请求包，一个参数解码包，所以还要安装并引入下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">npm install --save request<br>npm install --save urlencode<br></code></pre></td></tr></table></figure><p>把接口封装下，因为是免费机器人，所以肯定不是太好，不过个人用足够了，如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// node-request请求模块包</span><br><span class="hljs-keyword">const</span> request = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;request&quot;</span>)<br><span class="hljs-comment">// 请求参数解码</span><br><span class="hljs-keyword">const</span> urlencode = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;urlencode&quot;</span>)<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description </span>机器人请求接口 处理函数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;String&#125;</span> </span>info 发送文字</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;Promise&#125;</span> </span>相应内容</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">requestRobot</span>(<span class="hljs-params">info</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> url = <span class="hljs-string">`https://open.drea.cc/bbsapi/chat/get?keyWord=<span class="hljs-subst">$&#123;urlencode(info)&#125;</span>`</span><br>    request(url, <span class="hljs-function">(<span class="hljs-params">error, response, body</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (!error &amp;&amp; response.statusCode == <span class="hljs-number">200</span>) &#123;<br>        <span class="hljs-keyword">let</span> res = <span class="hljs-built_in">JSON</span>.parse(body)<br>        <span class="hljs-keyword">if</span> (res.isSuccess) &#123;<br>          <span class="hljs-keyword">let</span> send = res.data.reply<br>          <span class="hljs-comment">// 免费的接口，所以需要把机器人名字替换成为自己设置的机器人名字</span><br>          send = send.replace(<span class="hljs-regexp">/Smile/g</span>, name)<br>          resolve(send)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-keyword">if</span> (res.code == <span class="hljs-number">1010</span>) &#123;<br>            resolve(<span class="hljs-string">&quot;没事别老艾特我，我还以为爱情来了&quot;</span>)<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            resolve(<span class="hljs-string">&quot;你在说什么，我听不懂&quot;</span>)<br>          &#125;<br>        &#125;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        resolve(<span class="hljs-string">&quot;你在说什么，我脑子有点短路诶！&quot;</span>)<br>      &#125;<br>    &#125;)<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>接着就可以写消息监听回调的逻辑了，这里就不文字叙述了，太费劲了，注释都是按行写的，哈哈</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> &#123; Message &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;wechaty&quot;</span>)<br><span class="hljs-comment">// 配置文件</span><br><span class="hljs-keyword">const</span> config = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./config&quot;</span>)<br><span class="hljs-comment">// 机器人名字</span><br><span class="hljs-keyword">const</span> name = config.name<br><span class="hljs-comment">// 管理群组列表</span><br><span class="hljs-keyword">const</span> roomList = config.room.roomList<br><br><span class="hljs-comment">// 消息监听回调</span><br><span class="hljs-built_in">module</span>.exports = <span class="hljs-function">(<span class="hljs-params">bot</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onMessage</span>(<span class="hljs-params">msg</span>) </span>&#123;<br>    <span class="hljs-comment">// 判断消息来自自己，直接return</span><br>    <span class="hljs-keyword">if</span> (msg.self()) <span class="hljs-keyword">return</span><br><br>    <span class="hljs-comment">// 判断此消息类型是否为文本</span><br>    <span class="hljs-keyword">if</span> (msg.type() == Message.Type.Text) &#123;<br>      <span class="hljs-comment">// 判断消息类型来自群聊</span><br>      <span class="hljs-keyword">if</span> (msg.room()) &#123;<br>        <span class="hljs-comment">// 获取群聊</span><br>        <span class="hljs-keyword">const</span> room = <span class="hljs-keyword">await</span> msg.room()<br><br>        <span class="hljs-comment">// 收到消息，提到自己</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">await</span> msg.mentionSelf()) &#123;<br>          <span class="hljs-comment">// 获取提到自己的名字</span><br>          <span class="hljs-keyword">let</span> self = <span class="hljs-keyword">await</span> msg.to()<br>          self = <span class="hljs-string">&quot;@&quot;</span> + self.name()<br>          <span class="hljs-comment">// 获取消息内容，拿到整个消息文本，去掉 @+名字</span><br>          <span class="hljs-keyword">let</span> sendText = msg.text().replace(self, <span class="hljs-string">&quot;&quot;</span>)<br>          <span class="hljs-comment">// 请求机器人接口回复</span><br>          <span class="hljs-keyword">let</span> res = <span class="hljs-keyword">await</span> requestRobot(sendText)<br>          <span class="hljs-comment">// 返回消息，并@来自人</span><br>          room.say(res, msg.from())<br>          <span class="hljs-keyword">return</span><br>        &#125;<br><br>        <span class="hljs-comment">// 收到消息，没有提到自己  忽略</span><br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 回复信息是关键字 “加群”</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">await</span> isAddRoom(msg)) <span class="hljs-keyword">return</span><br>        <span class="hljs-comment">// 回复信息是所管理的群聊名</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">await</span> isRoomName(bot, msg)) <span class="hljs-keyword">return</span><br>        <span class="hljs-comment">// 请求机器人聊天接口</span><br>        <span class="hljs-keyword">let</span> res = <span class="hljs-keyword">await</span> requestRobot(msg.text())<br>        <span class="hljs-comment">// 返回聊天接口内容</span><br>        <span class="hljs-keyword">await</span> msg.say(res)<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;消息不是文本！&quot;</span>)<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description </span>回复信息是关键字 “加群” 处理函数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Object&#125;</span> </span>msg 消息对象</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;Promise&#125;</span> <span class="hljs-variable">true</span></span>-是 false-不是</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isAddRoom</span>(<span class="hljs-params">msg</span>) </span>&#123;<br>  <span class="hljs-comment">// 关键字 加群 处理</span><br>  <span class="hljs-keyword">if</span> (msg.text() == <span class="hljs-string">&quot;加群&quot;</span>) &#123;<br>    <span class="hljs-keyword">let</span> roomListName = <span class="hljs-built_in">Object</span>.keys(roomList)<br>    <span class="hljs-keyword">let</span> info = <span class="hljs-string">`<span class="hljs-subst">$&#123;name&#125;</span>当前管理群聊有<span class="hljs-subst">$&#123;roomListName.length&#125;</span>个，回复群聊名即可加入哦\n\n`</span><br>    roomListName.map(<span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> &#123;<br>      info += <span class="hljs-string">&quot;【&quot;</span> + v + <span class="hljs-string">&quot;】&quot;</span> + <span class="hljs-string">&quot;\n&quot;</span><br>    &#125;)<br>    msg.say(info)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description </span>回复信息是所管理的群聊名 处理函数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Object&#125;</span> </span>bot 实例对象</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Object&#125;</span> </span>msg 消息对象</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;Promise&#125;</span> <span class="hljs-variable">true</span></span>-是群聊 false-不是群聊</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isRoomName</span>(<span class="hljs-params">bot, msg</span>) </span>&#123;<br>  <span class="hljs-comment">// 回复信息为管理的群聊名</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.keys(roomList).some(<span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> v == msg.text())) &#123;<br>    <span class="hljs-comment">// 通过群聊id获取到该群聊实例</span><br>    <span class="hljs-keyword">const</span> room = <span class="hljs-keyword">await</span> bot.Room.find(&#123; <span class="hljs-attr">id</span>: roomList[msg.text()] &#125;)<br><br>    <span class="hljs-comment">// 判断是否在房间中 在-提示并结束</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">await</span> room.has(msg.from())) &#123;<br>      <span class="hljs-keyword">await</span> msg.say(<span class="hljs-string">&quot;您已经在房间中了&quot;</span>)<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br><br>    <span class="hljs-comment">// 发送群邀请</span><br>    <span class="hljs-keyword">await</span> room.add(msg.from())<br>    <span class="hljs-keyword">await</span> msg.say(<span class="hljs-string">&quot;已发送群邀请&quot;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><p>然后就可以本地启动试试了</p><p>就到这了，也希望对你能有些帮助，给点鼓励可以点个赞噻</p><p>看着文件和代码都不少，其实就只是一些逻辑判断而已</p><p>看一眼 API 文档，怎么发挥就看你自己了，消息监听这里的判断也只做了文本消息的判断而已</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>你如果想用我这些东西，拉下代码<code>config.js</code>里换下 token 和一些配置信息就可以，当然我在不停更新，功能会越来越多，所以仓库中代码和文中会有些不一样，使用时简单看下代码，都写了详细注释，也很简单</p><ul><li><a href="https://github.com/isboyjc/wechaty-Robot">https://github.com/isboyjc/wechaty-Robot</a></li></ul><p>目前实现的都是一些基础的小功能，登出和容错等一些处理也没有，因为这几天太忙了，后期慢慢加吧，这里就是为了给有想做但还不知道的小伙伴简单介绍下 wechaty，简单好用，快去试试吧，我这边介绍的只是冰山一角，喜欢 Python 的同学，wechat 团队也维护了一个 Python 版本，也可以尝试的 😄</p><p>还可以实现更多好玩的功能(我想到的功能只是针对我个人需求，只是为了和公众号、我的群聊等实现下无缝对接，你当然也可以做其他的嘛，例如做一个定时任务给女友定时发信息啥的)，我现在能想到的后期要加的功能如下</p><ul><li>推送<ul><li>例如每日早 8 点，拉取当日 <code>IT界新闻/掘金热门文章</code>发送至群聊</li><li>群聊中可通过 <code>@[机器人]关键字</code> 查看新闻及文章等</li><li>可设置定时任务，定时给自己/群聊发送消息</li></ul></li><li>群聊功能消息管理<ul><li>监听群聊中消息，有不正当言论时或不文明用语对其警告</li><li>记录同一人警告次数，每月清空记录，当月达到一定警告次数后自动将其移出群聊</li></ul></li><li>群聊投票功能<ul><li>可通过机器人发起对某件事的群投票</li></ul></li><li>群聊游戏<ul><li>猜字迷</li><li>等等</li></ul></li><li>后台管理系统(可视化配置及群聊数据统计)<ul><li>可视化配置机器人的已实现功能，包括登录等所有功能在 web 端可视化操作处理</li><li>统计群聊中的成员活跃度/人员加入情况/警告等系列数据</li></ul></li></ul><p>来吧，生命在于折腾，好玩的东西总要试一试，毕竟费不了多少时间，你也可以加下我的小助手【圈子】微信体验下呦，验证消息写【前端】可以直接通过，和他聊聊天，或者回复【加群】加技术交流群我们一块玩耍都可以的</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other//WechatIMG127.jpeg" alt="WechatIMG127"></p><p>如果你加小助手微信遇到了问题，也可以通过以下方式联系我或加群</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other//image-20200407143156331.png" alt="image-20200407143156331"></p>]]></content>
    
    
    <categories>
      
      <category>Web相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Wechaty</tag>
      
      <tag>NodeJS</tag>
      
      <tag>微信机器人</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「硬核JS」深入了解异步解决方案</title>
    <link href="/blog/2020/02/14/js/%E3%80%8C%E7%A1%AC%E6%A0%B8JS%E3%80%8D%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E5%BC%82%E6%AD%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <url>/blog/2020/02/14/js/%E3%80%8C%E7%A1%AC%E6%A0%B8JS%E3%80%8D%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E5%BC%82%E6%AD%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Javascript 语言的执行环境是<code>单线程</code>(single thread，指一次只能完成一件任务，如果有多个任务，就必须排队，前面一个任务完成，再执行后面一个任务，以此类推)</p><p>这种模式的好处是实现起来比较简单，执行环境相对单纯，坏处是只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行，常见的浏览器无响应(假死)，往往就是因为某一段 Javascript 代码长时间运行(比如死循环)，导致整个页面卡在这个地方，其他任务无法执行</p><p>为了解决这个问题，Javascript 将任务的执行模式分成两种：同步(Synchronous)和异步(Asynchronous)</p><p><code>同步模式</code> 就是后一个任务等待前一个任务结束，然后再执行，程序的执行顺序与任务的排列顺序是一致的、同步的</p><p><code>异步模式</code>则完全不同，每一个任务有一个或多个回调函数(callback)，前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的，在浏览器端，耗时很长的操作都应该异步执行，避免浏览器失去响应，最好的例子就是 Ajax 操作。在服务器端，<code>异步模式</code>甚至是唯一的模式，因为执行环境是单线程的，如果允许同步执行所有 http 请求，服务器性能会急剧下降</p><p>前面都是些无用的话，因为大家都对此很清楚，那么，问题来了，你了解几种异步解决方案？</p><p>本文会由浅入深的叙述下面几种已知的异步解决方案，以及它们的区别</p><ul><li>回调函数(callback)</li><li>事件监听(发布/订阅)解析</li><li>Promise 解析及从 0 ～ 1 的源码体验</li><li>Generator 全面解析</li><li>Async/Await 解析</li></ul><p>赶上春节不出门为国家做贡献，写了这篇帖子，本文有点长，因为本来要写四篇文章分别叙述，但是我觉得还是在一块看比较容易对比理解，大概有两万字左右，如果你肯花 20 分钟的时间阅读本文，定会有所收获，我在耐心写，也希望大家可以耐心看完，基础不太好的同学可以分块看，已详细注明各级标题，希望通过本文可以让大家对大 JS 异步编程加深了解</p><p>哦对了，先赞在看，养成习惯，毕竟码字不易，大家的每一个赞和评论都将为我码下一篇文章添一些动力，多谢 😁</p><h2 id="回调函数-callback"><a href="#回调函数-callback" class="headerlink" title="回调函数(callback)"></a>回调函数(callback)</h2><h3 id="简述回调函数"><a href="#简述回调函数" class="headerlink" title="简述回调函数"></a>简述回调函数</h3><p>回调函数大家都应该清楚，简单理解就是一个函数被作为参数传递给另一个函数</p><p>回调并不一定就是异步，并没有直接关系，只不过回调函数是异步的一种解决方案</p><p>我们用例子来简单说明下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn1</span>(<span class="hljs-params">callback</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;1&quot;</span>)<br>  callback &amp;&amp; callback()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn2</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;2&quot;</span>)<br>&#125;<br><br>fn1(fn2)<br></code></pre></td></tr></table></figure><p>如上代码所示，函数 fn1 参数为一个回调，调用 fn1 时传进入了函数 fn2，那么在函数 fn1 执行到 callback 函数调用时会调用 fn2 执行，这是一个典型的回调函数，不过是同步的，我们可以利用这点来解决异步，如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-title">fn1</span>(<span class="hljs-params">callback</span>)</span>&#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    callback &amp;&amp; callback()<br>  &#125;, <span class="hljs-number">1000</span>)<br>&#125;<br><br>fn1(<span class="hljs-function">()=&gt;</span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;1&quot;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p>如上所示，我们使用 setTimeout 在函数 fn1 中模拟了一个耗时 1s 的任务，耗时任务结束会抛出一个回调，那么我们在调用时就可以做到在函数 fn1 的耗时任务结束后执行回调函数了</p><p>采用这种方式，我们把同步操作变成了异步操作，fn1 不会堵塞程序运行，相当于先执行程序的主要逻辑，将耗时的操作推迟执行</p><h3 id="回调函数优-缺"><a href="#回调函数优-缺" class="headerlink" title="回调函数优/缺"></a>回调函数优/缺</h3><p><strong>优点</strong></p><p>一句话，回调函数是异步编程最基本的方法，其优点是简单、容易理解和部署</p><p><strong>缺点</strong></p><p>回调函数最大的缺点是不利于代码的阅读和维护，各个部分之间高度耦合(Coupling)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">fun1(<span class="hljs-function">() =&gt;</span> &#123;<br>  fun2(<span class="hljs-function">() =&gt;</span> &#123;<br>    fun3(<span class="hljs-function">() =&gt;</span> &#123;<br>      fun4(<span class="hljs-function">() =&gt;</span> &#123;<br>        fun5(<span class="hljs-function">() =&gt;</span> &#123;<br>          fun6()<br>        &#125;)<br>      &#125;)<br>    &#125;)<br>  &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><p>上面这种代码在之前使用 AJAX 请求时很常见，因为业务上在一个请求结束后发起另一个请求的需求太多了，代码不优雅，不易阅读维护，高耦合，层层嵌套造成这种<strong>回调地狱</strong></p><p>异步回调中，回调函数的执行栈与原函数分离开，外部无法抓住异常，异常会变得不可控</p><p>虽然缺点多，但回调函数日常开发中也不可或缺，使用时注意就好了</p><p>回调函数比较简单常用，就先介绍到这里，接下来我们看事件监听</p><h2 id="事件监听-发布订阅模式"><a href="#事件监听-发布订阅模式" class="headerlink" title="事件监听(发布订阅模式)"></a>事件监听(发布订阅模式)</h2><p>解决异步，可以采用事件驱动，任务的执行不取决于代码的顺序，而取决于某个事件是否发生</p><p>在阮一峰老师早期发布的 <strong>Javascript 异步编程的 4 种方法(参考链接【1】)</strong> 一文中，把事件监听和发布订阅作为了不同的两种解决方案，但是我个人觉得这两种完全可以并为一种，都是利用了发布订阅模式的事件驱动，所以就放一块解释了</p><h3 id="JQuery-实现事件监听"><a href="#JQuery-实现事件监听" class="headerlink" title="JQuery 实现事件监听"></a>JQuery 实现事件监听</h3><p>jquery 实现比较简单，因为 jq 为我们封装好了方法，使用即可，只是 JQ 不常用了，简单了解下</p><p>我们可以使用 jquery 中的<code>on</code>来监听事件，使用<code>trigger</code>触发事件，如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-string">&quot;body&quot;</span>).on(<span class="hljs-string">&quot;done&quot;</span>, fn2)<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn1</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    $(<span class="hljs-string">&quot;body&quot;</span>).trigger(<span class="hljs-string">&quot;done&quot;</span>)<br>  &#125;, <span class="hljs-number">2000</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn2</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;fn2执行了&quot;</span>)<br>&#125;<br>fn1()<br></code></pre></td></tr></table></figure><p>我们使用 jq 的<code>on</code>监听了一个自定义事件<code>done</code>，传入了 fn2 回调，表示事件触发后立即执行函数 fn2</p><p>在函数 fn1 中使用 setTimeout 模拟了耗时任务，setTimeout 回调中使用<code>trigger</code>触发了<code>done</code>事件</p><p>我们可以使用<code>on</code>来绑定多个事件，每个事件可以指定多个回调函数</p><h3 id="JavaScript-实现事件监听"><a href="#JavaScript-实现事件监听" class="headerlink" title="JavaScript 实现事件监听"></a>JavaScript 实现事件监听</h3><p>在 JS 中我们要自己实现类似 JQ 的<code>on</code>和<code>trigger</code>了</p><p>实现的过程中用到了一个设计模式，也就是发布订阅模式，所以简单提一下</p><h4 id="简述发布订阅模式-观察者模式"><a href="#简述发布订阅模式-观察者模式" class="headerlink" title="简述发布订阅模式(观察者模式)"></a>简述发布订阅模式(观察者模式)</h4><p>发布订阅模式(publish-subscribe pattern)，又叫观察者模式(observer pattern)，定义了对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知</p><p>来看一个比较挫的例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">小李辛辛苦苦做了两年程序猿，攒了些钱，内心激动，要去售楼部买一个心仪已久的房型<br><br>到售楼部问了下，售楼部说暂时没有这种房型的房源了，怎么办呢，下次再来吧<br><br>但是小李不知道这种房型什么时候有房源，总不能每天打电话到售楼部问吧，小李就把电话和房型信息留到售楼部了，什么时候有这种房源了，售楼部会短信通知<br><br>要知道，售楼部不会只通知小李一个人，售楼部会把预留信息所有房型信息一致的人都通知一遍<br><br>在这个比较挫的例子中，小李包括每个买房的人都是订阅者，而售楼部就是发布者<br></code></pre></td></tr></table></figure><p>其实我们都用过发布订阅模式，比如我们在 DOM 节点上绑定一个事件函数，就已经使用了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">document</span>.body.addEventListener(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p>但是这只是对发布订阅模式最简单的使用，在很多场景下我们经常会实现一些自定义事件来满足我们的需求</p><p>比如我们下面要防照 JQ 那种来写一个自定义事件监听器，需要监听一个事件，在该事件触发时执行其监听回调</p><h4 id="发布订阅模式实现事件监听器"><a href="#发布订阅模式实现事件监听器" class="headerlink" title="发布订阅模式实现事件监听器"></a>发布订阅模式实现事件监听器</h4><p>发布订阅模式有很多种实现方式，下面我们用<code>class</code>来简单实现下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Emitter</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-comment">// _listener数组，key为自定义事件名，value为执行回调数组-因为可能有多个</span><br>    <span class="hljs-built_in">this</span>._listener = []<br>  &#125;<br><br>  <span class="hljs-comment">// 订阅 监听事件</span><br>  <span class="hljs-function"><span class="hljs-title">on</span>(<span class="hljs-params">type, fn</span>)</span> &#123;<br>    <span class="hljs-comment">// 判断_listener数组中是否存在该事件命</span><br>    <span class="hljs-comment">// 存在将回调push到事件名对应的value数组中，不存在直接新增</span><br>    <span class="hljs-built_in">this</span>._listener[type]<br>      ? <span class="hljs-built_in">this</span>._listener[type].push(fn)<br>      : (<span class="hljs-built_in">this</span>._listener[type] = [fn])<br>  &#125;<br><br>  <span class="hljs-comment">// 发布 触发事件</span><br>  <span class="hljs-function"><span class="hljs-title">trigger</span>(<span class="hljs-params">type, ...rest</span>)</span> &#123;<br>    <span class="hljs-comment">// 判断该触发事件是否存在</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>._listener[type]) <span class="hljs-keyword">return</span><br>    <span class="hljs-comment">// 遍历执行该事件回调数组并传递参数</span><br>    <span class="hljs-built_in">this</span>._listener[type].forEach(<span class="hljs-function">(<span class="hljs-params">callback</span>) =&gt;</span> callback(...rest))<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上所示，我们创建了一个<code>Emitter</code>类，并且添加了两个原型方法<code>on</code>和<code>trigger</code>，上面代码中均有注释，所以不过多解释了，基础不好的同学多看几遍自己敲一下，比较简单</p><p>使用时</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 创建一个emitter实例</span><br><span class="hljs-keyword">const</span> emitter = <span class="hljs-keyword">new</span> Emitter()<br><br>emitter.on(<span class="hljs-string">&quot;done&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arg1, arg2</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(arg1, arg2)<br>&#125;)<br><br>emitter.on(<span class="hljs-string">&quot;done&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arg1, arg2</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(arg2, arg1)<br>&#125;)<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn1</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;我是主程序&quot;</span>)<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    emitter.trigger(<span class="hljs-string">&quot;done&quot;</span>, <span class="hljs-string">&quot;异步参数一&quot;</span>, <span class="hljs-string">&quot;异步参数二&quot;</span>)<br>  &#125;, <span class="hljs-number">1000</span>)<br>&#125;<br><br>fn1()<br></code></pre></td></tr></table></figure><p>如上所示，我们先创建一个 emitter 实例，接着注册事件，再触发事件，用法和上面 JQ 雷同，均解决了异步问题</p><p>Vue 的实现就是一个比较复杂的发布订阅模式，使用 Vue 的同学，上面的这个事件监听器，把<code>trigger</code>名字改成<code>emit</code>是不是就眼熟多了，当然我们这个比较简单，毕竟代码就那么六七行，不过理是这么个理</p><h3 id="事件监听优-缺"><a href="#事件监听优-缺" class="headerlink" title="事件监听优/缺"></a>事件监听优/缺</h3><p><strong>优点</strong></p><p>发布订阅模式实现的事件监听，我们可以绑定多个事件，每个事件也可以指定多个回调函数，还是比较符合模块化思想的，我们自写监听器时可以做很多优化从而更好的监控程序运行</p><p><strong>缺点</strong></p><p>整个程序变成了事件驱动，流程上来说或多或少都会有点影响，每次使用还得注册事件监听再进行触发挺麻烦的，代码也不太优雅，并不是事件驱动不好，毕竟需求只是 <strong>解决异步问题</strong> 而已，何况有更优解</p><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><h3 id="Promise-简述"><a href="#Promise-简述" class="headerlink" title="Promise 简述"></a>Promise 简述</h3><p>ES2015 (ES6)标准化和引入了 Promise 对象，它是异步编程的一种解决方案</p><p>简单来说就是用同步的方式写异步的代码，可用来解决回调问题</p><h3 id="Promise-特点"><a href="#Promise-特点" class="headerlink" title="Promise 特点"></a>Promise 特点</h3><h4 id="特点一"><a href="#特点一" class="headerlink" title="特点一"></a>特点一</h4><p>Promise，承诺执行，Promise 对象的状态是不受外界影响的</p><p>Promise 对象代表一个异步操作，它有三种状态</p><ul><li><p>进行中 (Pending)</p></li><li><p>已完成 (Resolved/Fulfilled)</p></li><li><p>已失败 (Rejected)</p></li></ul><p>只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态</p><p>这就是 Promise 这个名字的由来，它的英语意思就是<code>承诺</code>，表示其他手段无法改变</p><h4 id="特点二"><a href="#特点二" class="headerlink" title="特点二"></a>特点二</h4><p>Promise 对象状态一旦改变，就不会再变</p><p>Promise 对象的状态改变，只有两种可能</p><ul><li><p>从 Pending 变为 Resolved</p></li><li><p>从 Pending 变为 Rejected</p></li></ul><p>只要这两种情况发生，状态就凝固，不会再变了，会一直保持这个结果</p><h3 id="Promise-使用"><a href="#Promise-使用" class="headerlink" title="Promise 使用"></a>Promise 使用</h3><p>Promise 是一个构造函数，我们可以通过<code>new</code>关键字来创建一个 Promise 实例，也可以直接使用 Promise 的一些静态方法</p><h4 id="new-一个-Promise-实例"><a href="#new-一个-Promise-实例" class="headerlink" title="new 一个 Promise 实例"></a>new 一个 Promise 实例</h4><p><strong>语法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>( <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>&#123;...&#125;);<br></code></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn1</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-keyword">let</span> num = <span class="hljs-built_in">Math</span>.ceil(<span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">10</span>)<br>      <span class="hljs-keyword">if</span> (num &lt; <span class="hljs-number">5</span>) &#123;<br>        resolve(num)<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        reject(<span class="hljs-string">&quot;数字太大&quot;</span>)<br>      &#125;<br>    &#125;, <span class="hljs-number">2000</span>)<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>如上所示，我们使用<code>new</code>关键字创建了一个 promise 实例，并在函数 fn1 中<code>return</code>了出来</p><p><code>new Promise</code>创建了一个 promise 实例，Promise 构造函数会把一个叫做处理器函数(executor function)的函数作为它的参数</p><p>处理器函数接收两个参数分别是<code>resolve</code>和<code>reject</code>，这两个参数也是两个回调函数</p><p><code>resolve</code> 函数在异步操作成功时调用，并将异步操作的结果，作为参数传递出去</p><p><code>reject</code> 函数在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去</p><p>简单理解就是一个是成功回调，一个是失败回调</p><h4 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then()"></a>Promise.prototype.then()</h4><p>Promise 对象有一个原型方法<code>then</code></p><p>Promise 实例生成以后，可以用<code>then</code>方法指定<code>resolved</code>状态和<code>reject</code>状态的回调函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">Promise</span>.prototype.then(onFulfilled[, onRejected])<br></code></pre></td></tr></table></figure><p><code>then</code>方法接收两个回调 onFulfilled 和 onRejected</p><ul><li><p>onFulfilled-可选</p><ul><li>当 Promise 变成已完成状态(fulfilled)时调用的回调函数</li><li>该函数有一个参数，即接受的最终结果(the fulfillment value)</li><li>如果该参数不是函数，则会在内部被替换为 <code>(x) =&gt; x</code>，即原样返回 promise 最终结果的函数</li></ul></li><li><p>onRejected-可选</p><ul><li>当 Promise 变成接受状态或拒绝状态(rejected)时调用的回调函数</li><li>该函数有一个参数，即拒绝的原因(rejection reason)</li><li>如果该参数不是函数，则会在内部被替换为一个 <code>Thrower</code> 函数(it throws an error it received as argument)</li></ul></li></ul><p><code>then</code>方法在接收一个 promise 实例后会返回一个新的 Promise 实例(并不是原来那个 Promise 实例)，且原来的 promise 实例的返回值将作为参数传入这个新 Promise 的<code>resolve</code>函数</p><p>那么既然<code>then</code>方法返回一个新的 promise 实例，所以我们可以接着使用<code>then</code>方法，即链式调用，也被称为 **复合(composition)**操作</p><p>接上面的示例，函数 fn1 会返回一个 promise 实例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">fn1().then(<br>  <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(data)<br>  &#125;,<br>  <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(err)<br>  &#125;<br>)<br></code></pre></td></tr></table></figure><p>如上所示，我们使用了<code>then</code>方法的两个参数</p><p>第一个参数回调我们很常用，其实就是 Promise 变成已完成状态且拿到传递的值</p><p>第二个参数回调就是 Promise 变成接受状态或拒绝状态且拿到错误参数，我们可能用的少，一般都是用<code>catch</code>方法，<code>then</code>方法的第二个参数 onRejected 和<code>catch</code>还是有一些细微区别的，下面会提到</p><p>根据 Promises/A+中对<code>then</code>方法的定义，我们来看<code>then</code>方法的特点</p><p><strong>首先<code>then</code> 方法必须返回一个 <code>promise</code> 对象(划重点)</strong></p><p>链式调用的原理，不论是何种情况 then 方法都会返回一个新的 Promise 对象，这样才会有下个 then 方法</p><p><strong>如果<code>then</code>方法中返回的是一个普通值(如 Number、String 等)就使用此值包装成一个新的 Promise 对象返回</strong></p><p>就像下面这个例子，<code>then</code>方法接收 Promise 对象，<code>then</code>方法中返回一个普通值时，下一个<code>then</code>中是可以接到的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  resolve(<span class="hljs-number">1</span>)<br>&#125;)<br><br>p.then(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> <span class="hljs-comment">// 返回了一个普通值</span><br>&#125;).then(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(data) <span class="hljs-comment">// 2</span><br>&#125;)<br></code></pre></td></tr></table></figure><p><strong>如果<code>then</code>方法中没有<code>return</code>语句，就返回一个用 Undefined 包装的 Promise 对象</strong></p><p>如下面例子的输出结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  resolve(<span class="hljs-number">1</span>)<br>&#125;)<br><br>p.then(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 无return语句</span><br>&#125;).then(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(data) <span class="hljs-comment">// undefined</span><br>&#125;)<br></code></pre></td></tr></table></figure><p><strong>如果<code>then</code>方法中出现异常，则调用失败态方法(reject)跳转到下一个<code>then</code>的 onRejected</strong></p><p><code>then</code>方法的第二个参数 onRejected 是监测不到当前<code>then</code>方法回调异常的，规范中定义当前<code>then</code>方法出现异常则调用失败态方法(reject)流转到下一个<code>then</code>的 onRejected</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  resolve(<span class="hljs-number">1</span>)<br>&#125;)<br><br>p.then(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> <span class="hljs-number">2</span>)<br>  .then(<br>    <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;this is err&quot;</span><br>    &#125;,<br>    <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;err1:&quot;</span> + err)<br>    &#125;<br>  )<br>  .then(<br>    <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>      <span class="hljs-built_in">console</span>.log(data)<br>    &#125;,<br>    <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;err2:&quot;</span> + err) <span class="hljs-comment">// err2:this is err</span><br>    &#125;<br>  )<br></code></pre></td></tr></table></figure><p><strong>如果<code>then</code>方法没有传入任何回调，则继续向下传递(即所谓的值穿透)</strong></p><p>下面示例，在第一个<code>then</code>方法之后连续调用了两个空的<code>then</code>方法 ，没有传入任何回调函数，也没有返回值，此时 Promise 会将值一直向下传递，直到接收处理，这就是所谓的值穿透</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  resolve(<span class="hljs-number">1</span>)<br>&#125;)<br><br>p.then(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> <span class="hljs-number">2</span>)<br>  .then()<br>  .then()<br>  .then(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(data) <span class="hljs-comment">// 2</span><br>  &#125;)<br></code></pre></td></tr></table></figure><p><strong>如果<code>then</code>方法中返回了一个 Promise 对象，那就以这个对象为准，返回它的结果</strong></p><p>话不多说，来看示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  resolve(<span class="hljs-number">1</span>)<br>&#125;)<br><br>p.then(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    resolve(<span class="hljs-number">2</span>)<br>  &#125;)<br>&#125;).then(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(data) <span class="hljs-comment">// 2</span><br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h4><p>除了原型方法<code>then</code>之外，Promise 对象还有一个<code>catch</code>的原型方法</p><p><code>catch</code>方法可以用于 promise 组合中的错误处理，此方法返回一个 Promise，并且处理拒绝的情况</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">p.catch(onRejected)<br><br>p.catch(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">reason</span>) </span>&#123;<br>  <span class="hljs-comment">// 拒绝</span><br>&#125;)<br></code></pre></td></tr></table></figure><ul><li>onRejected<ul><li>当 Promise 被 rejected 时，被调用的一个回调函数，该函数拥有一个参数为失败原因或错误信息</li></ul></li></ul><p>简单理解就是捕获异常，promise 组合中抛出了错误或 promise 组合中出现 rejected 会被捕获</p><p>同样接最上面的示例，还使用 fn1 函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">fn1()<br>  .then(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(data)<br>  &#125;)<br>  .catch(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(err)<br>  &#125;)<br></code></pre></td></tr></table></figure><p>使用这种方式捕获错误或失败是不是比<code>then</code>方法的第二个参数看着舒服了点呢，毕竟 Promise 就是链式到底</p><p>同样也需要注意一点，<code>catch</code>方法也返回一个新的 promise 实例，如果 <code>onRejected</code>回调抛出一个错误或返回一个本身失败的 Promise ，通过 <code>catch</code> 返回的 Promise 会被 rejected，否则，它就是一个成功的(resolved)promise 实例</p><p>和上面的<code>then</code>方法中的第二个参数几乎是一致的，我们看例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">fn1()<br>  .catch(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(err)<br>    <span class="hljs-keyword">return</span> err<br>  &#125;)<br>  .then(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(data)<br>  &#125;)<br>  .catch(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(err)<br>  &#125;)<br></code></pre></td></tr></table></figure><p>上面的 fn1 函数有一半的几率返回一个 rejected，当返回一个 rejected 时下面的<code>then</code>方法回调中同样会输出，因为我们在第一个<code>catch</code>中只 return 了错误信息，并没有抛出错误或者返回一个失败 promise，所以第一个<code>catch</code>执行返回的 promise 对象是 resolveing</p><h4 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally()"></a>Promise.prototype.finally()</h4><p>finally，英文是<code>最后</code>的意思，此方法是<code>ES2018</code>的标准</p><p>原型方法<code>finally</code>，我们使用的可能不多，语法如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">p.finally(onFinally)<br><br>p.finally(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// 返回状态为(resolved 或 rejected)</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>一句话即可解释<code>finally</code>，在 promise 结束时，不管成功还是失败都将执行其<code>onFinally</code>回调，该回调无参数</p><p>适用于同样的语句需要在<code>then()</code>和<code>catch()</code>中各写一次的情况</p><h4 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h4><p>一句话概括 Promise.resolve()方法，接收一个值，将现有对象转为 Promise 对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">Promise</span>.resolve(value)<br></code></pre></td></tr></table></figure><p>如下所示，该值可为任意类型，也可是一个 Promise 对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">123</span>)<br><br><span class="hljs-built_in">Promise</span>.resolve(p).then(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(value) <span class="hljs-comment">// 123</span><br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h4><p><code>Promise.reject()</code>方法同上面<code>Promise.resolve()</code>一样，只不过是返回一个带有拒绝原因的<code>Promise</code>对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">Promise</span>.reject(<span class="hljs-number">123</span>)<br>  .then(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(data)<br>  &#125;)<br>  .catch(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;err:&quot;</span> + err)<br>  &#125;)<br><br><span class="hljs-comment">// err:123</span><br></code></pre></td></tr></table></figure><h4 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h4><p><code>Promise.all(iterable)</code>用于将多个 Promise 实例包装成一个新的 Promise 实例，参数为一组 Promise 实例组成的数组</p><p>iterable 类型为 ES6 标准引入，代表可迭代对象，<code>Array</code>、<code>Map</code>和<code>Set</code>都属于<code>iterable</code>类型 ，iterable 下面我们会讲到，这里我们就先把这个参数理解成数组就可以，稍后配合下面的 iterable 来理解</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> p1 = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">let</span> p2 = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">2</span>)<br><span class="hljs-keyword">let</span> p3 = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">3</span>)<br><br><span class="hljs-keyword">let</span> p = <span class="hljs-built_in">Promise</span>.all([p1, p2, p3])<br><br>p.then(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(data) <span class="hljs-comment">// [1,2,3]</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>如上所示，当 p1, p2, p3 状态都 Resolved 的时候，p 的状态才会 Resolved</p><p>只要有一个实例 Rejected ，此时第一个被 Rejected 的实例返回值就会传递给 P 的回调函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> p1 = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">let</span> p2 = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">2</span>)<br><span class="hljs-keyword">let</span> p3 = <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-number">3</span>)<br><br><span class="hljs-keyword">let</span> p = <span class="hljs-built_in">Promise</span>.all([p1, p2, p3])<br>p.then(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(data)<br>&#125;).catch(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;err:&quot;</span> + err) <span class="hljs-comment">// 3</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>应用场景在我们有一个接口，需要其他两个或多个接口返回的数据作为参数时会多一些</p><h4 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h4><p><code>Promise.race(iterable)</code>和上面<code>Promise.all(iterable)</code>类似</p><p><code>all</code>方法是迭代对象中状态全部改变才会执行</p><p><code>race</code>方法正好相反，只要迭代对象中有一个状态改变了，它的状态就跟着改变，并将那个改变状态实例的返回值传递给回调函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">1000</span>, <span class="hljs-string">&quot;1&quot;</span>)<br>&#125;)<br><br><span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">500</span>, <span class="hljs-string">&quot;2&quot;</span>)<br>&#125;)<br><br><span class="hljs-built_in">Promise</span>.race([p1, p2]).then(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(value) <span class="hljs-comment">// 2</span><br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="Promise-try"><a href="#Promise-try" class="headerlink" title="Promise.try()"></a>Promise.try()</h4><p>开发中，经常遇到一种情况：不知道或不想区分，函数 fn 是同步函数还是异步函数，但想用 Promise 来处理它</p><p>因为这样就可以不管 fn 是不是异步操作，都用 then 方法指定下一步流程，用 catch 方法处理 fn 抛出的错误</p><p>我们可能会使用<code>Promise.resolve</code>把它转换成 Promise 对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> fn = <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;fn&quot;</span>)<br><span class="hljs-built_in">Promise</span>.resolve(fn).then(<span class="hljs-function">(<span class="hljs-params">cb</span>) =&gt;</span> cb())<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;hahaha&quot;</span>)<br><br><span class="hljs-comment">// hahaha</span><br><span class="hljs-comment">// fn</span><br></code></pre></td></tr></table></figure><p>但是这样有一个问题，如果函数 fn 是同步的，那么这波操作会把它转成异步，如上输出</p><p>那么有没有一种方法，让同步函数同步执行，异步函数异步执行，并且让它们具有统一的 API 呢？当然可以</p><p>我们可以这样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> fn = <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;fn&quot;</span>)<br>;(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> resolve(fn())))()<br>  .then(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">222</span>)<br>  &#125;)<br>  .catch(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(err)<br>  &#125;)<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;111&quot;</span>)<br><br><span class="hljs-comment">// fn</span><br><span class="hljs-comment">// 111</span><br><span class="hljs-comment">// 222</span><br></code></pre></td></tr></table></figure><p>也可以这样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> fn = <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;fn&quot;</span>)<br>;(<span class="hljs-keyword">async</span> () =&gt; fn())()<br>  .then(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">222</span>)<br>  &#125;)<br>  .catch(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(err)<br>  &#125;)<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;111&quot;</span>)<br><br><span class="hljs-comment">// fn</span><br><span class="hljs-comment">// 111</span><br><span class="hljs-comment">// 222</span><br></code></pre></td></tr></table></figure><p>但是，代码有点诡异，不优雅</p><p>来看使用<code>try</code>方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> fn = <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;fn&quot;</span>)<br><span class="hljs-built_in">Promise</span>.try(fn)<br>  .then(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">222</span>)<br>  &#125;)<br>  .catch(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(err)<br>  &#125;)<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;111&quot;</span>)<br><br><span class="hljs-comment">// fn</span><br><span class="hljs-comment">// 111</span><br><span class="hljs-comment">// 222</span><br></code></pre></td></tr></table></figure><p>如上所示，简洁明了，还是很实用的</p><p>其实，<code>Promise.try</code>就是模拟 try 代码块，就像<code>promise.catch</code>模拟的是 catch 代码块</p><p>最后 <code>Promise.try</code> 并不是 Javascript 的一部分</p><p>早在 16 年有过这个提案，有兴趣的同学可以了解下，现在也没下文了，并没有被纳入标准</p><p>如果想要使用的话，需要使用 Promise 库 Bluebird、Q 等，或引入 Polyfill</p><p>虽然没有被纳入标准，但并不代表它不好用，大家自行体验</p><p>想要了解更多此方法推荐大家看参考链接【4】【5】</p><h4 id="onRejected-和-catch-区别"><a href="#onRejected-和-catch-区别" class="headerlink" title="onRejected 和 catch 区别"></a>onRejected 和 catch 区别</h4><p>上面提到了<code>promise.then(onFulfilled, onRejected)</code>中的第二个参数 onRejected 和<code>catch</code></p><p>看到这大家可能会问，同样都是捕获异常它们的区别在哪</p><p>其实<code>promise.then(onFulfilled, onRejected)</code> 在 <code>onFulfilled</code>回调中发生异常的话，在<code>onRejected</code>中是捕获不到这个异常的，使用<code>catch</code>可以捕获到前面的 onFulfilled 的异常</p><p>其实这不算个缺点，我们完全可以在末尾多加一个<code>then</code>从而达到和<code>catch</code>相同的作用，如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">Promise</span>.reject(<span class="hljs-number">1</span>)<br>  .then(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;我是对的&quot;</span>)<br>  &#125;)<br>  .then(<span class="hljs-literal">null</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;err:&quot;</span> + err) <span class="hljs-comment">// err:1</span><br>  &#125;)<br><br><span class="hljs-comment">// 等价于</span><br><br><span class="hljs-built_in">Promise</span>.reject(<span class="hljs-number">1</span>)<br>  .then(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;我是对的&quot;</span>)<br>  &#125;)<br>  .catch(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;err:&quot;</span> + err) <span class="hljs-comment">// err:1</span><br>  &#125;)<br></code></pre></td></tr></table></figure><p>就这么点区别，不过大部分人都喜欢直接使用<code>catch</code>罢了</p><h4 id="then-中抛错未处理"><a href="#then-中抛错未处理" class="headerlink" title="then 中抛错未处理"></a>then 中抛错未处理</h4><p>如果在 then 中抛错，而没有对错误进行处理(catch)，那么会一直保持 reject 状态，直到 catch 了错误</p><p>我们来看一段代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">Promise</span>.resolve()<br>  .then(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(a)<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Task 1&quot;</span>)<br>  &#125;)<br>  .then(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Task 2&quot;</span>)<br>  &#125;)<br>  .catch(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;err:&quot;</span> + err)<br>  &#125;)<br>  .then(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;finaltask&quot;</span>)<br>  &#125;)<br><br><span class="hljs-comment">// err:ReferenceError: a is not defined</span><br><span class="hljs-comment">// finaltask</span><br></code></pre></td></tr></table></figure><p>我们看上面代码，我们在第一个<code>then</code>中输出了一个未声明的变量</p><p>输出结果先走了<code>catch</code>然后走了最后一个<code>then</code>，第一个<code>then</code>中抛出错误并跳过了第二个<code>then</code></p><p>也就是说如果我们没有处理这个错误(无 catch)的话，就不会往下执行了</p><p>可参考下图</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20200201231714043.png" alt="image-20200201231714043"></p><p>promise 的缺点之一就是无法让 promise 中断，利用这个特性可以让 Promise 中断执行，也算一种办法吧</p><h4 id="异步回调中抛错-catch-捕捉不到"><a href="#异步回调中抛错-catch-捕捉不到" class="headerlink" title="异步回调中抛错 catch 捕捉不到"></a>异步回调中抛错 catch 捕捉不到</h4><p>首先我们看在 Promise 对象的处理器函数中直接抛出错误</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;这是一个错误&quot;</span>)<br>&#125;)<br>p.catch(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(error)<br>&#125;)<br></code></pre></td></tr></table></figure><p>按照上述内容来看，在 Promise 对象的处理器函数中直接抛出错误，<code>catch</code>是可以捕捉到的</p><p>在下面代码，在 Promise 对象的处理器函数中模拟一个异步抛错</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;这是一个错误&quot;</span>)<br>  &#125;, <span class="hljs-number">0</span>)<br>&#125;)<br>p.catch(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(error)<br>&#125;)<br></code></pre></td></tr></table></figure><p>这种情况<code>catch</code>是捕捉不到的，这是为什么呢？先想后看，再做不难</p><p><strong>原因</strong></p><p>JS 事件循环列表有宏任务与微任务之分，setTimeOut 是宏任务， promise 是微任务，执行顺序不同</p><p>那么这段代码的执行顺序是：</p><ol><li>代码执行栈进入 promise 触发 setTimeOut，setTimeOut 回调函数入宏任务队列</li><li>代码执行 promise 的 catch 方法，入微任务队列，此时 setTimeOut 回调还没有执行</li><li>执行栈检查发现当前微任务队列执行完毕，开始执行宏任务队列</li><li>执行<code>throw new Error(&#39;这是一个错误&#39;)</code> 此时这个异常其实是在 promise 外部抛出的</li></ol><p><strong>解决</strong></p><p>使用<code>try catch</code>捕获异常主动触发<code>reject</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;这是一个错误&quot;</span>)<br>    &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>      reject(e)<br>    &#125;<br>  &#125;, <span class="hljs-number">0</span>)<br>&#125;)<br>p.catch(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(error)<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="手写-Promise—符合-Promises-A-规范"><a href="#手写-Promise—符合-Promises-A-规范" class="headerlink" title="手写 Promise—符合 Promises/A+规范"></a>手写 Promise—符合 Promises/A+规范</h3><h4 id="为什么要手写-Promise"><a href="#为什么要手写-Promise" class="headerlink" title="为什么要手写 Promise"></a>为什么要手写 Promise</h4><p>Promise 源码逻辑相对来说不算简单，可能我们只会使用，并不清楚其原理</p><p>自己实现一遍会加深我们对 Promise 的理解，也可以加强我们 JS 的功底</p><p>更何况手写实现 Promise 是一道前端经典的面试题，此处必然不用多说</p><h4 id="Promises-A"><a href="#Promises-A" class="headerlink" title="Promises/A+"></a>Promises/A+</h4><p>了解了 Promise 的基础用法后，我们来一步步倒推实现 Promise</p><p>Promises/A+标准是一个开放、健全且通用的 JavaScript Promise 标准，由开发者制定，供开发者参考</p><p>很多 Promise 三方库都是按照 Promises/A+标准实现的</p><p>so，此次实现我们严格 Promises/A+标准，包括完成后我们会使用开源社区提供的测试包来测试</p><p>简单来说，测试通过的话，足以证明代码符合 Promises/A+标准，是合法的、完全可以上线提供给他人使用的</p><p>更多 Promises/A+标准请看参考链接【6】【7】</p><h4 id="构造方法核心基础搭建"><a href="#构造方法核心基础搭建" class="headerlink" title="构造方法核心基础搭建"></a>构造方法核心基础搭建</h4><p>Promise 的用法上面已经详细讲了，如果阅读仔细的话，我们会知道</p><ul><li>Promise 有三种状态进行中 (Pending)、已完成 (Resolved/Fulfilled)和已失败 (Rejected)</li><li>Promise 是一个构造方法，实例化 Promise 时传入一个函数作为处理器<ul><li>处理器函数有两个参数(resolve 和 reject)分别将结果变为成功态和失败态</li><li>Promise 对象执行成功了要有一个结果，通过 resolve 传递出去，失败的话失败原因通过 reject 传递出入</li></ul></li><li>Promise 的原型上定义着 then 方法</li></ul><p>那么根据我们上面的这些已知需求我们可以写出一个基础的结构(写法千千万，喜欢 class 也可以用 class)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Promise</span>(<span class="hljs-params">executor</span>) </span>&#123;<br>  <span class="hljs-comment">// 状态描述 pending resolved rejected</span><br>  <span class="hljs-built_in">this</span>.state = <span class="hljs-string">&quot;pending&quot;</span><br>  <span class="hljs-comment">// 成功结果</span><br>  <span class="hljs-built_in">this</span>.value = <span class="hljs-literal">undefined</span><br>  <span class="hljs-comment">// 失败原因</span><br>  <span class="hljs-built_in">this</span>.reason = <span class="hljs-literal">undefined</span><br><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolve</span>(<span class="hljs-params">value</span>) </span>&#123;&#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reject</span>(<span class="hljs-params">reason</span>) </span>&#123;&#125;<br>&#125;<br><br><span class="hljs-built_in">Promise</span>.prototype.then = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">onFulfilled, onRejected</span>) </span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>如上所示，我们创建了一个 Promise 构造方法，<code>state</code>属性保存了 Promise 对象的状态，使用<code>value</code>属性保存 Promise 对象执行成功的结果，失败原因使用<code>reason</code>属性保存，这些命名完全贴合 Promises/A+标准</p><p>接着我们在构造函数中创建了<code>resolve</code>和<code>reject</code>两个方法，然后在构造函数的原型上创建了一个<code>then</code>方法，以备待用</p><h4 id="初始化实例-executor-立即执行"><a href="#初始化实例-executor-立即执行" class="headerlink" title="初始化实例 executor 立即执行"></a>初始化实例 executor 立即执行</h4><p>我们知道，在创建一个 Promise 实例时，处理器函数(executor)是会立即执行的，所以我们更改代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Promise</span>(<span class="hljs-params">executor</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.state = <span class="hljs-string">&quot;pending&quot;</span><br>  <span class="hljs-built_in">this</span>.value = <span class="hljs-literal">undefined</span><br>  <span class="hljs-built_in">this</span>.reason = <span class="hljs-literal">undefined</span><br><br>  <span class="hljs-comment">// 让其处理器函数立即执行</span><br>  <span class="hljs-keyword">try</span> &#123;<br>    executor(resolve, reject)<br>  &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>    reject(err)<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolve</span>(<span class="hljs-params">value</span>) </span>&#123;&#125;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reject</span>(<span class="hljs-params">reason</span>) </span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="resolve-amp-reject-回调实现"><a href="#resolve-amp-reject-回调实现" class="headerlink" title="resolve&amp;reject 回调实现"></a>resolve&amp;reject 回调实现</h4><p>Promises/A+规范中规定，当 Promise 对象已经由 pending 状态改变为成功态(resolved)或失败态(rejected)后不可再次更改状态，也就是说成功或失败后状态不可更新已经凝固</p><p>因此我们更新状态时要判断，如果当前状态是 pending(等待态)才可更新，由此我们来完善<code>resolve</code>和<code>reject</code>方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> _this = <span class="hljs-built_in">this</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolve</span>(<span class="hljs-params">value</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (_this.state === <span class="hljs-string">&quot;pending&quot;</span>) &#123;<br>    _this.value = value<br>    _this.state = <span class="hljs-string">&quot;resolved&quot;</span><br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reject</span>(<span class="hljs-params">reason</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (_this.state === <span class="hljs-string">&quot;pending&quot;</span>) &#123;<br>    _this.reason = reason<br>    _this.state = <span class="hljs-string">&quot;rejected&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上所示，首先我们在 Promise 构造函数内部用变量<code>_this</code>托管构造函数的<code>this</code></p><p>接着我们在<code>resolve</code>和<code>reject</code>函数中分别加入了判断，因为只有当前态是 pending 才可进行状态更改操作</p><p>同时将成功结果和失败原因都保存到对应的属性上</p><p>然后将 state 属性置为更新后的状态</p><h4 id="then-方法基础实现"><a href="#then-方法基础实现" class="headerlink" title="then 方法基础实现"></a>then 方法基础实现</h4><p>接着我们来简单实现<code>then</code>方法</p><p>首先<code>then</code>方法有两个回调，当 Promise 的状态发生改变，成功或失败会分别调用<code>then</code>方法的两个回调</p><p>所以，then 方法的实现看起来挺简单，根据 state 状态来调用不同的回调函数即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">Promise</span>.prototype.then = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">onFulfilled, onRejected</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.state === <span class="hljs-string">&quot;resolved&quot;</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> onFulfilled === <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>      onFulfilled(<span class="hljs-built_in">this</span>.value)<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.state === <span class="hljs-string">&quot;rejected&quot;</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> onRejected === <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>      onRejected(<span class="hljs-built_in">this</span>.reason)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上所示，由于<code>onFulfilled &amp; onRejected</code>两个参数都不是必选参，所以我们在判断状态后又判断了参数类型，当参数不为函数类型，就不执行，因为在 Promises/A+规范中定义非函数类型可忽略</p><h4 id="让-Promise-支持异步"><a href="#让-Promise-支持异步" class="headerlink" title="让 Promise 支持异步"></a>让 Promise 支持异步</h4><p>写到这里，我们可能会觉得，咦？Promise 实现起来也不难嘛，这么快就有模有样了，我们来简单测试下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  resolve(<span class="hljs-number">1</span>)<br>&#125;)<br><br>p.then(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(data)) <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><p>嗯，符合预期，再来试下异步代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    resolve(<span class="hljs-number">1</span>);<br>  &#125;，<span class="hljs-number">1000</span>);<br>&#125;)<br><br>p.then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(data)) <span class="hljs-comment">// 无输出</span><br></code></pre></td></tr></table></figure><p>问题来了，Promise 一个异步解决方案被我们写的不支持异步。。。</p><p>我们来分析下，本来是等 1000ms 后执行<code>then</code>方法，运行上面代码发现没有结果，哪里有问题呢？</p><p>setTimeout 函数让<code>resolve</code>变成了异步执行，有延迟，调用<code>then</code>方法的时候，此刻状态还是等待态(pending)，<code>then</code>方法即没有调用<code>onFulfilled</code>也没有调用<code>onRejected</code></p><p>嗯，清楚原因我们开始改造，如果是你，你会如何解决呢，此处可思考 40 秒，想一个可实施的大致思路</p><p><strong>小提示：</strong> 可以参考上文的发布订阅模式，如果 40 秒还没有思路，嗯，有待提高</p><p>|</p><p>|</p><p>–&gt;为了让您小小活动一下左脑并活跃下气氛，我也是煞费苦心(**ps:**都看到这了，不点个赞鼓励下就太没劲了噻 😄)</p><p>|</p><p>|</p><p>回归正题，我们来解决这个问题</p><p>我们可以参照发布订阅模式，在执行<code>then</code>方法时如果还在等待态(pending)，就把回调函数临时寄存到队列(就是一个数组)里，当状态发生改变时依次从数组中取出执行就好了</p><p>思路有了，我们来实现下</p><p>首先，我们要在构造方法中新增两个 Array 类型的数组，用于存放成功和失败的回调函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Promise</span>(<span class="hljs-params">executor</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> _this = <span class="hljs-built_in">this</span><br>  <span class="hljs-built_in">this</span>.state = <span class="hljs-string">&quot;pending&quot;</span><br>  <span class="hljs-built_in">this</span>.value = <span class="hljs-literal">undefined</span><br>  <span class="hljs-built_in">this</span>.reason = <span class="hljs-literal">undefined</span><br>  <span class="hljs-comment">// 保存成功回调</span><br>  <span class="hljs-built_in">this</span>.onResolvedCallbacks = []<br>  <span class="hljs-comment">// 保存失败回调</span><br>  <span class="hljs-built_in">this</span>.onRejectedCallbacks = []<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们还需要改善<code>then</code>方法，在<code>then</code>方法执行时如果状态是等待态，就将其回调函数存入对应数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">Promise</span>.prototype.then = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">onFulfilled, onRejected</span>) </span>&#123;<br>  <span class="hljs-comment">// 新增等待态判断，此时异步代码还未走完，回调入数组队列</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.state === <span class="hljs-string">&quot;pending&quot;</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> onFulfilled === <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>      <span class="hljs-built_in">this</span>.onResolvedCallbacks.push(onFulfilled)<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> onRejected === <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>      <span class="hljs-built_in">this</span>.onRejectedCallbacks.push(onRejected)<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 以下为之前代码块</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.state === <span class="hljs-string">&quot;resolved&quot;</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> onFulfilled === <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>      onFulfilled(<span class="hljs-built_in">this</span>.value)<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.state === <span class="hljs-string">&quot;rejected&quot;</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> onRejected === <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>      onRejected(<span class="hljs-built_in">this</span>.reason)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上所示，我们改写<code>then</code>方法，除了判断成功态(resolved)、失败态(rejected)，我们又加了一个等待态(pending)判断，当状态为等待态时，异步代码还没有走完，那么我们把对应的回调先存入准备好的数组中即可</p><p>最那么，就差最后一步执行了，我们在<code>resolve</code>和<code>reject</code>方法中调用即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolve</span>(<span class="hljs-params">value</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (_this.state === <span class="hljs-string">&quot;pending&quot;</span>) &#123;<br>    _this.value = value<br>    <span class="hljs-comment">// 遍历执行成功回调</span><br>    _this.onResolvedCallbacks.forEach(<span class="hljs-function">(<span class="hljs-params">cb</span>) =&gt;</span> cb(value))<br>    _this.state = <span class="hljs-string">&quot;resolved&quot;</span><br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reject</span>(<span class="hljs-params">reason</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (_this.state === <span class="hljs-string">&quot;pending&quot;</span>) &#123;<br>    _this.reason = reason<br>    <span class="hljs-comment">// 遍历执行失败回调</span><br>    _this.onRejectedCallbacks.forEach(<span class="hljs-function">(<span class="hljs-params">cb</span>) =&gt;</span> cb(reason))<br>    _this.state = <span class="hljs-string">&quot;rejected&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>到了这里，我们已经实现了 Promise 的异步解决，赶快测试下</p><h4 id="实现-Promise-经典的链式调用"><a href="#实现-Promise-经典的链式调用" class="headerlink" title="实现 Promise 经典的链式调用"></a>实现 Promise 经典的链式调用</h4><p>Promise 的<code>then</code>方法可以链式调用，这也是 Promise 的精华之一，在实现起来也算是比较复杂的地方了</p><p>首先我们要理清楚<code>then</code>的需求是什么，这需要仔细看 Promises/A+规范中对<code>then</code>方法的返回值定义及 Promise 解决过程，当然你如果仔细阅读了上文<code>then</code>方法的使用大概也清楚了，我们在这里再次总结下</p><ul><li><p><strong>首先<code>then</code> 方法必须返回一个 <code>promise</code> 对象(划重点)</strong></p></li><li><p><strong>如果<code>then</code>方法中返回的是一个普通值(如 Number、String 等)就使用此值包装成一个新的 Promise 对象返回</strong></p></li><li><p><strong>如果<code>then</code>方法中没有<code>return</code>语句，就返回一个用 Undefined 包装的 Promise 对象</strong></p></li><li><p><strong>如果<code>then</code>方法中出现异常，则调用失败态方法(reject)跳转到下一个<code>then</code>的 onRejected</strong></p></li><li><p><strong>如果<code>then</code>方法没有传入任何回调，则继续向下传递(值穿透)</strong></p></li><li><p><strong>如果<code>then</code>方法中返回了一个 Promise 对象，那就以这个对象为准，返回它的结果</strong></p></li></ul><p>嗯，到此我们需求已经明确，开始代码实现</p><p>需求中说如果<code>then</code>方法没有传入任何回调，则继续向下传递，但是每个<code>then</code>中又返回一个新的 Promise，也就是说当<code>then</code>方法中没有回调时，我们需要把接收到的值继续向下传递，这个其实好办，只需要在判断回调参数不为函数时我们把他变成回调函数返回普通值即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">Promise</span>.prototype.then = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">onFulfilled, onRejected</span>) </span>&#123;<br>  onFulfilled =<br>    <span class="hljs-keyword">typeof</span> onFulfilled === <span class="hljs-string">&quot;function&quot;</span> ? onFulfilled : <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> value<br>  onRejected =<br>    <span class="hljs-keyword">typeof</span> onRejected === <span class="hljs-string">&quot;function&quot;</span><br>      ? onRejected<br>      : <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>          <span class="hljs-keyword">throw</span> err<br>        &#125;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们上面<code>then</code>实现中，在每个可执行处都加了参数是否为函数的类型校验，但是我们这里在<code>then</code>方法开头统一做了校验，就不需要参数校验了</p><p>现在的<code>then</code>方法变成了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">Promise</span>.prototype.then = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">onFulfilled, onRejected</span>) </span>&#123;<br>  onFulfilled =<br>    <span class="hljs-keyword">typeof</span> onFulfilled === <span class="hljs-string">&quot;function&quot;</span> ? onFulfilled : <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> value<br>  onRejected =<br>    <span class="hljs-keyword">typeof</span> onRejected === <span class="hljs-string">&quot;function&quot;</span><br>      ? onRejected<br>      : <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>          <span class="hljs-keyword">throw</span> err<br>        &#125;<br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.state === <span class="hljs-string">&quot;pending&quot;</span>) &#123;<br>    <span class="hljs-built_in">this</span>.onResolvedCallbacks.push(onFulfilled)<br>    <span class="hljs-built_in">this</span>.onRejectedCallbacks.push(onRejected)<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.state === <span class="hljs-string">&quot;resolved&quot;</span>) &#123;<br>    onFulfilled(<span class="hljs-built_in">this</span>.value)<br>  &#125;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.state === <span class="hljs-string">&quot;rejected&quot;</span>) &#123;<br>    onRejected(<span class="hljs-built_in">this</span>.reason)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着来</p><p>既然每个<code>thne</code>都反回一个新的 Promise，那么我们就先在<code>then</code>中创建一个 Promise 实例返回，开始改造</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">Promise</span>.prototype.then = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">onFulfilled, onRejected</span>) </span>&#123;<br>  onFulfilled =<br>    <span class="hljs-keyword">typeof</span> onFulfilled === <span class="hljs-string">&quot;function&quot;</span> ? onFulfilled : <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> value<br>  onRejected =<br>    <span class="hljs-keyword">typeof</span> onRejected === <span class="hljs-string">&quot;function&quot;</span><br>      ? onRejected<br>      : <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>          <span class="hljs-keyword">throw</span> err<br>        &#125;<br><br>  <span class="hljs-keyword">let</span> promise2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.state === <span class="hljs-string">&quot;pending&quot;</span>) &#123;<br>      <span class="hljs-built_in">this</span>.onResolvedCallbacks.push(onFulfilled)<br>      <span class="hljs-built_in">this</span>.onRejectedCallbacks.push(onRejected)<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.state === <span class="hljs-string">&quot;resolved&quot;</span>) &#123;<br>      onFulfilled(<span class="hljs-built_in">this</span>.value)<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.state === <span class="hljs-string">&quot;rejected&quot;</span>) &#123;<br>      onRejected(<span class="hljs-built_in">this</span>.reason)<br>    &#125;<br>  &#125;)<br>  <span class="hljs-keyword">return</span> promise2<br>&#125;<br></code></pre></td></tr></table></figure><p>我们在<code>then</code>方法中先实例化了一个 Promise 对象并返回，我们把原来写的代码放到该实例的处理器函数中</p><p>我们把原来写的代码放到该实例的处理器函数中</p><p>接着在每个执行函数处使用<code>try..catch</code>语法，try 中<code>resolve</code>执行结果，catch 中<code>reject</code>异常，原来的<code>then</code>方法中有 resolved、rejected 和 pending 三种逻辑判断，如下</p><p>在 resolved 状态判断时，rejected 和 resolved 逻辑一致</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.state === <span class="hljs-string">&quot;resolved&quot;</span>) &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 拿到返回值resolve出去</span><br>    <span class="hljs-keyword">let</span> x = onFulfilled(<span class="hljs-built_in">this</span>.value)<br>    resolve(x)<br>  &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>    <span class="hljs-comment">// catch捕获异常reject抛出</span><br>    reject(e)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>pending 状态判断，逻辑也和 resolved 相似，但是由于此处为了处理异步，我们在这里做了 push 操作，所以我们 push 时在 onFulfilled 和 onRejected 回调外面再套一个回调做操作即可，都是 JS 惯用小套路，不过分解释</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.state === <span class="hljs-string">&quot;pending&quot;</span>) &#123;<br>  <span class="hljs-comment">// push(onFulfilled)</span><br>  <span class="hljs-comment">// push(()=&gt;&#123; onFulfilled() &#125;)</span><br>  <span class="hljs-comment">// 上面两种执行效果一致，后者可在回调中加一些其他功能，如下</span><br>  <span class="hljs-built_in">this</span>.onResolvedCallbacks.push(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">let</span> x = onFulfilled(<span class="hljs-built_in">this</span>.value)<br>      resolve(x)<br>    &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>      reject(e)<br>    &#125;<br>  &#125;)<br>  <span class="hljs-built_in">this</span>.onRejectedCallbacks.push(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">let</span> x = onRejected(<span class="hljs-built_in">this</span>.value)<br>      resolve(x)<br>    &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>      reject(e)<br>    &#125;<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>再接下来我们开始处理根据上一个<code>then</code>方法的返回值来生成新 Promise 对象，这块逻辑复杂些，规范中可以抽离出一个方法来做这件事，我们来照做</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 解析then返回值与新Promise对象</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Object&#125;</span> </span>新的Promise对象，就是我们创建的promise2实例</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;*&#125;</span> </span>x 上一个then的返回值</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Function&#125;</span> </span>resolve promise2处理器函数的resolve</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Function&#125;</span> </span>reject promise2处理器函数的reject</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolvePromise</span>(<span class="hljs-params">promise2, x, resolve, reject</span>) </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们来一步步分析完善 resolvePromise 函数</p><p><strong>避免循环引用，当 then 的返回值与新生成的 Promise 对象为同一个(引用地址相同)，则抛出 TypeError 错误</strong></p><p>例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> promise2 = p.then(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> promise2<br>&#125;)<br><br><span class="hljs-comment">// TypeError: Chaining cycle detected for promise #&lt;Promise&gt;</span><br></code></pre></td></tr></table></figure><p>如果返回了自己的 Promise 对象，状态永远为等待态(pending)，再也无法成为 resolved 或是 rejected，程序就死掉了，因此要先处理它</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolvePromise</span>(<span class="hljs-params">promise2, x, resolve, reject</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (promise2 === x) &#123;<br>    reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&quot;请避免Promise循环引用&quot;</span>))<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>判断 x 类型，分情况处理</strong></p><p>当 x 是一个 Promise，就执行它，成功即成功，失败即失败，如果<code>x</code>是一个对象或是函数，再进一步处理它，否则就是一个普通值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolvePromise</span>(<span class="hljs-params">promise2, x, resolve, reject</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (promise2 === x) &#123;<br>    reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&quot;请避免Promise循环引用&quot;</span>))<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (x !== <span class="hljs-literal">null</span> &amp;&amp; (<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&quot;object&quot;</span> || <span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&quot;function&quot;</span>)) &#123;<br>    <span class="hljs-comment">// 可能是个对象或是函数</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 是个普通值</span><br>    resolve(x)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果 x 是个对象，尝试将对象上的 then 方法取出来，此时如果报错，那就将 promise2 转为失败态</p><p>在这里 catch 防止报错是因为 Promise 有很多实现，假设另一个人实现的 Promise 对象使用<code>Object.defineProperty()</code>在取值时抛错，我们可以防止代码出现 bug</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// resolvePromise方法内部片段</span><br><br><span class="hljs-keyword">if</span> (x !== <span class="hljs-literal">null</span> &amp;&amp; (<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&quot;object&quot;</span> || <span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&quot;function&quot;</span>)) &#123;<br>  <span class="hljs-comment">// 可能是个对象或是函数</span><br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 尝试取出then方法引用</span><br>    <span class="hljs-keyword">let</span> then = x.then<br>  &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>    reject(e)<br>  &#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-comment">// 是个普通值</span><br>  resolve(x)<br>&#125;<br></code></pre></td></tr></table></figure><p>如果对象中有<code>then</code>，且<code>then</code>是函数类型，就可以认为是一个 Promise 对象，之后，使用<code>x</code>作为其 this 来调用执行<code>then</code>方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// resolvePromise方法内部片段</span><br><br><span class="hljs-keyword">if</span> (x !== <span class="hljs-literal">null</span> &amp;&amp; (<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&quot;object&quot;</span> || <span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&quot;function&quot;</span>)) &#123;<br>  <span class="hljs-comment">// 可能是个对象或是函数</span><br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 尝试取出then方法引用</span><br>    <span class="hljs-keyword">let</span> then = x.then<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> then === <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>      <span class="hljs-comment">// then是function，那么执行Promise</span><br>      then.call(<br>        x,<br>        <span class="hljs-function">(<span class="hljs-params">y</span>) =&gt;</span> &#123;<br>          resolve(y)<br>        &#125;,<br>        <span class="hljs-function">(<span class="hljs-params">r</span>) =&gt;</span> &#123;<br>          reject(r)<br>        &#125;<br>      )<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      resolve(x)<br>    &#125;<br>  &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>    reject(e)<br>  &#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-comment">// 是个普通值</span><br>  resolve(x)<br>&#125;<br></code></pre></td></tr></table></figure><p>此时，我们还要考虑到一种情况，如果 Promise 对象转为成功态或是失败时传入的还是一个 Promise 对象，此时应该继续执行，直到最后的 Promise 执行完，例如下面这种</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">1</span>).then(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// resolve传入的还是Promise</span><br>    resolve(<br>      <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        resolve(<span class="hljs-number">2</span>)<br>      &#125;)<br>    )<br>  &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><p>解决这种情况，我们可以采用递归，把调用 resolve 改写成递归执行 resolvePromise，这样直到解析 Promise 成一个普通值才会终止</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// resolvePromise方法内部片段</span><br><span class="hljs-keyword">if</span> (x !== <span class="hljs-literal">null</span> &amp;&amp; (<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&quot;object&quot;</span> || <span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&quot;function&quot;</span>)) &#123;<br>  <span class="hljs-comment">// 可能是个对象或是函数</span><br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">let</span> then = x.then<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> then === <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>      then.call(<br>        x,<br>        <span class="hljs-function">(<span class="hljs-params">y</span>) =&gt;</span> &#123;<br>          <span class="hljs-comment">// 递归调用，传入y若是Promise对象，继续循环</span><br>          resolvePromise(promise2, y, resolve, reject)<br>        &#125;,<br>        <span class="hljs-function">(<span class="hljs-params">r</span>) =&gt;</span> &#123;<br>          reject(r)<br>        &#125;<br>      )<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      resolve(x)<br>    &#125;<br>  &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>    reject(e)<br>  &#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-comment">// 普通值结束递归</span><br>  resolve(x)<br>&#125;<br></code></pre></td></tr></table></figure><p>规范中定义，如果 resolvePromise 和 rejectPromise 都被调用，或者多次调用同一个参数，第一个调用优先，任何进一步的调用都将被忽略，为了让成功和失败只能调用一个，我们接着完善，设定一个 called 来防止多次调用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// resolvePromise方法内部片段</span><br><span class="hljs-keyword">let</span> called<br><span class="hljs-keyword">if</span> (x !== <span class="hljs-literal">null</span> &amp;&amp; (<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&quot;object&quot;</span> || <span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&quot;function&quot;</span>)) &#123;<br>  <span class="hljs-comment">// 可能是个对象或是函数</span><br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">let</span> then = x.then<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> then === <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>      then.call(<br>        x,<br>        <span class="hljs-function">(<span class="hljs-params">y</span>) =&gt;</span> &#123;<br>          <span class="hljs-keyword">if</span> (called) <span class="hljs-keyword">return</span><br>          called = <span class="hljs-literal">true</span><br>          <span class="hljs-comment">// 递归调用，传入y若是Promise对象，继续循环</span><br>          resolvePromise(promise2, y, resolve, reject)<br>        &#125;,<br>        <span class="hljs-function">(<span class="hljs-params">r</span>) =&gt;</span> &#123;<br>          <span class="hljs-keyword">if</span> (called) <span class="hljs-keyword">return</span><br>          called = <span class="hljs-literal">true</span><br>          reject(r)<br>        &#125;<br>      )<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      resolve(x)<br>    &#125;<br>  &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>    <span class="hljs-keyword">if</span> (called) <span class="hljs-keyword">return</span><br>    called = <span class="hljs-literal">true</span><br>    reject(e)<br>  &#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-comment">// 普通值结束递归</span><br>  resolve(x)<br>&#125;<br></code></pre></td></tr></table></figure><p>到此，我们算是实现好了<code>resolvePromise</code>方法，我们来调用它实现完整的<code>then</code>方法，在原来的原型方法<code>then</code>中我们<code>return</code>了一个 promise2，这个实例处理器函数的三种状态判断中把<code>resolve</code>处替换成<code>resolvePromise</code>方法即可</p><p>那么，此时<code>then</code>方法实现完成了吗？</p><p>当然还没有，我们都知道，Promise 中处理器函数是同步执行，而<code>then</code>方法是异步，但是我们完成这个还是同步</p><p>解决这个问题其实也很简单，仿照市面上大多数 Promise 库的做法，使用 setTimeout 模拟，我们在<code>then</code>方法内执行处的所有地方使用 setTimeout 变为异步即可(只是这样做和浏览器自带的 Promises 唯一的区别就是浏览器的 Promise..then 是微任务，我们用 setTimeout 实现是宏任务)，不过这也是大多数 Promise 库的做法，如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">let</span> x = onFulfilled(value)<br>    resolvePromise(promise2, x, resolve, reject)<br>  &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>    reject(e)<br>  &#125;<br>&#125;, <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>现在我们的终极版<code>then</code>方法就大功告成了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">Promise</span>.prototype.then = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">onFulfilled, onRejected</span>) </span>&#123;<br>  onFulfilled =<br>    <span class="hljs-keyword">typeof</span> onFulfilled === <span class="hljs-string">&quot;function&quot;</span> ? onFulfilled : <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> value<br>  onRejected =<br>    <span class="hljs-keyword">typeof</span> onRejected === <span class="hljs-string">&quot;function&quot;</span><br>      ? onRejected<br>      : <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>          <span class="hljs-keyword">throw</span> err<br>        &#125;<br><br>  <span class="hljs-keyword">let</span> promise2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 等待态判断，此时异步代码还未走完，回调入数组队列</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.state === <span class="hljs-string">&quot;pending&quot;</span>) &#123;<br>      <span class="hljs-built_in">this</span>.onResolvedCallbacks.push(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>          <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">let</span> x = onFulfilled(<span class="hljs-built_in">this</span>.value)<br>            resolvePromise(promise2, x, resolve, reject)<br>          &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>            reject(e)<br>          &#125;<br>        &#125;, <span class="hljs-number">0</span>)<br>      &#125;)<br><br>      <span class="hljs-built_in">this</span>.onRejectedCallbacks.push(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>          <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">let</span> x = onRejected(<span class="hljs-built_in">this</span>.value)<br>            resolvePromise(promise2, x, resolve, reject)<br>          &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>            reject(e)<br>          &#125;<br>        &#125;, <span class="hljs-number">0</span>)<br>      &#125;)<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.state === <span class="hljs-string">&quot;resolved&quot;</span>) &#123;<br>      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-keyword">let</span> x = onFulfilled(<span class="hljs-built_in">this</span>.value)<br>          resolvePromise(promise2, x, resolve, reject)<br>        &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>          reject(e)<br>        &#125;<br>      &#125;, <span class="hljs-number">0</span>)<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.state === <span class="hljs-string">&quot;rejected&quot;</span>) &#123;<br>      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-keyword">let</span> x = onRejected(<span class="hljs-built_in">this</span>.reason)<br>          resolvePromise(promise2, x, resolve, reject)<br>        &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>          reject(e)<br>        &#125;<br>      &#125;, <span class="hljs-number">0</span>)<br>    &#125;<br>  &#125;)<br>  <span class="hljs-keyword">return</span> promise2<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="catch-实现"><a href="#catch-实现" class="headerlink" title="catch 实现"></a>catch 实现</h4><p>实现了最复杂的<code>then</code>方法后，<code>catch</code>实现非常简单，一看就懂了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">Promise</span>.prototype.catch = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">onRejected</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.then(<span class="hljs-literal">null</span>, onRejected)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="代码测试"><a href="#代码测试" class="headerlink" title="代码测试"></a>代码测试</h4><p>开源社区提供了一个包用于测试我们的代码是否符合 Promises/A+规范：<code>promises-aplus-tests</code></p><p>首先我们要为该测试包提供一个<code>deferred</code>钩子，用于测试</p><p>如下，将下面代码防止我们的<code>Promise.js</code>文件末尾即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// promises-aplus-tests测试</span><br><span class="hljs-built_in">Promise</span>.defer = <span class="hljs-built_in">Promise</span>.deferred = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> defer = &#123;&#125;<br>  defer.promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    defer.resolve = resolve<br>    defer.reject = reject<br>  &#125;)<br>  <span class="hljs-keyword">return</span> defer<br>&#125;<br><span class="hljs-keyword">try</span> &#123;<br>  <span class="hljs-built_in">module</span>.exports = <span class="hljs-built_in">Promise</span><br>&#125; <span class="hljs-keyword">catch</span> (e) &#123;&#125;<br></code></pre></td></tr></table></figure><p>接着，安装这个包</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">npm install promises-aplus-tests -D<br></code></pre></td></tr></table></figure><p>执行测试</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">npx promises-aplus-tests <span class="hljs-built_in">Promise</span>.js<br></code></pre></td></tr></table></figure><p>静等片刻，如果控制台没有爆红就是成功了，符合规范，如图所示</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20200206222942803.png" alt="image-20200206222942803"></p><h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><p>篇幅已经很长了，后续还有其他内容，所以就实现了比较核心的 Promise 及 then 和 catch 方法</p><p>其他的 resolve/reject/race/all 等比较简单，不在这里描述了</p><p>给大家贴个我这边 Promise 多个方法实现的地址，大家有兴趣自行看代码吧，注释写的很详细了，也就大概 200 多行代码</p><ul><li>Github：<a href="https://github.com/isboyjc/promise">https://github.com/isboyjc/promise</a></li></ul><h3 id="Promise-优-缺"><a href="#Promise-优-缺" class="headerlink" title="Promise 优/缺"></a>Promise 优/缺</h3><p><strong>优点</strong></p><p>Promise 用同步的方式写异步的代码，避免了层层嵌套的回调函数</p><p>Promise 对象提供了统一的接口，使得控制异步操作更加容易</p><p>链式操作，可以在 then 中继续写 Promise 对象并返回，然后继续调用 then 来进行回调操作</p><p><strong>缺点</strong></p><p>Promise 对象一旦新建就会立即执行，无法中途取消</p><p>若不设置回调函数，Promise 内部会抛出错误，不会流到外部</p><p>当处于 pending 状态时，无法得知当前处于哪一阶段</p><p>用多了 Promise 后代码一眼看上去都是 promise 的 API，而且链式语法总觉得不好看，不优雅</p><h2 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h2><p>Generator 是协程在 ES6 的实现，最大的特点就是可以交出函数的执行权</p><p>我们可以通过 yield 关键字，把函数的执行流挂起，为改变执行流程提供了可能，从而为异步编程提供解决方案</p><p>Generator 的英文是生成器</p><p>想要了解生成器(Generator)，还是绕不过迭代器(Iterator)这个概念，我们先来简单介绍下</p><h3 id="迭代器-Iterator"><a href="#迭代器-Iterator" class="headerlink" title="迭代器(Iterator)"></a>迭代器(Iterator)</h3><h4 id="Iterator-简介"><a href="#Iterator-简介" class="headerlink" title="Iterator 简介"></a>Iterator 简介</h4><p>迭代器是一种接口，也可以说是一种规范</p><p>js 中不同的数据类型如(Array/Object/Set)等等遍历方式都各有不同，比如对象遍历我们会使用<code>for..in..</code>，数组可以使用<code>for循环/for..in../forEach</code>等等</p><p>那么有没有统一的方式遍历这些数据呢？这就是迭代器存在的意义，它可以提供统一的遍历数据的方式，只要在想要遍历的数据结构中添加一个支持迭代器的属性即可</p><h4 id="Iterator-语法"><a href="#Iterator-语法" class="headerlink" title="Iterator 语法"></a>Iterator 语法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;<br>  [<span class="hljs-built_in">Symbol</span>.iterator]: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;,<br>&#125;<br></code></pre></td></tr></table></figure><p><code>[Symbol.iterator]</code> 属性名是固定的写法，只要拥有了该属性的对象，就能够用迭代器的方式进行遍历</p><p>迭代器的遍历方法是首先获得一个迭代器的指针，初始时该指针指向第一条数据之前</p><p>接着通过调用 <code>next</code> 方法，改变指针的指向，让其指向下一条数据</p><p>每一次的 <code>next</code> 都会返回一个对象，该对象有两个属性</p><ul><li><p>value 代表想要获取的数据</p></li><li><p>done 布尔值，false 表示当前指针指向的数据有值，true 表示遍历已经结束</p></li></ul><h4 id="Iterator-详解"><a href="#Iterator-详解" class="headerlink" title="Iterator 详解"></a>Iterator 详解</h4><p>在 JS 中，<code>Array/Set/Map/String</code>都默认支持迭代器</p><p>由于数组和集合都支持迭代器，所以它们都可以用同一种方式来遍历</p><p>es6 中提供了一种新的循环方法叫做<code>for-of</code>，它实际上就是使用迭代器来进行遍历</p><p>换句话说只有支持了迭代器的数据结构才能使用<code>for-of</code>循环</p><p><strong>数组中使用迭代器遍历</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [&#123; <span class="hljs-attr">num</span>: <span class="hljs-number">1</span> &#125;, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><span class="hljs-keyword">let</span> it = arr[<span class="hljs-built_in">Symbol</span>.iterator]() <span class="hljs-comment">// 获取数组中的迭代器</span><br><span class="hljs-built_in">console</span>.log(it.next()) <span class="hljs-comment">// &#123; value: Object &#123; num: 1 &#125;, done: false &#125;</span><br><span class="hljs-built_in">console</span>.log(it.next()) <span class="hljs-comment">// &#123; value: 2, done: false &#125;</span><br><span class="hljs-built_in">console</span>.log(it.next()) <span class="hljs-comment">// &#123; value: 3, done: false &#125;</span><br><span class="hljs-built_in">console</span>.log(it.next()) <span class="hljs-comment">// &#123; value: undefined, done: true &#125;</span><br></code></pre></td></tr></table></figure><p>数组是支持迭代器遍历的，所以可以直接获取其迭代器，集合也是一样</p><p><strong>集合中使用迭代器遍历</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> list = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<br><span class="hljs-keyword">let</span> it = list.entries() <span class="hljs-comment">// 获取set集合中自带的的迭代器</span><br><span class="hljs-built_in">console</span>.log(it.next()) <span class="hljs-comment">// &#123; value: [ 1, 1 ], done: false &#125;</span><br><span class="hljs-built_in">console</span>.log(it.next()) <span class="hljs-comment">// &#123; value: [ 3, 3 ], done: false &#125;</span><br><span class="hljs-built_in">console</span>.log(it.next()) <span class="hljs-comment">// &#123; value: [ 2, 2 ], done: false &#125;</span><br><span class="hljs-built_in">console</span>.log(it.next()) <span class="hljs-comment">// &#123; value: undefined, done: true &#125;</span><br></code></pre></td></tr></table></figure><p>集合与数组不同的是，我们可以使用 Set 中的<code>entries</code>方法获取迭代器</p><p>Set 集合中每次遍历出来的值是一个数组，里面的第一和第二个元素都是一样的</p><p><strong>自定义对象中使用迭代器遍历</strong></p><p>首先自定义的对象没有迭代器属性，所以不支持迭代器迭代，我们也都知道<code>for..of</code>是无法遍历对象的，原因就在这里，因为<code>for..of</code>是使用迭代器迭代，所以对象不能用<code>for..of</code></p><p>既然知道是因为自定义对象无迭代器属性，那么我们可以为它加上<code>Symbol.iterator</code>这样一个属性，并为它实现一个迭代器方法，如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;tom&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,<br>  <span class="hljs-attr">gender</span>: <span class="hljs-string">&quot;男&quot;</span>,<br>  <span class="hljs-attr">intro</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;my name is &quot;</span> + <span class="hljs-built_in">this</span>.name)<br>  &#125;,<br>  [<span class="hljs-built_in">Symbol</span>.iterator]: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span><br>    <span class="hljs-comment">// 获取当前对象的所有属性并形成一个数组</span><br>    <span class="hljs-keyword">let</span> keys = <span class="hljs-built_in">Object</span>.keys(<span class="hljs-built_in">this</span>)<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">next</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> &#123;<br>          <span class="hljs-comment">// 外部每次执行next都能得到数组中的第i个元素</span><br>          <span class="hljs-attr">value</span>: keys[i++],<br>          <span class="hljs-comment">// 如果数组的数据已经遍历完则返回true</span><br>          <span class="hljs-attr">done</span>: i &gt; keys.length,<br>        &#125;<br>      &#125;,<br>    &#125;<br>  &#125;,<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> attr <span class="hljs-keyword">of</span> obj) &#123;<br>  <span class="hljs-built_in">console</span>.log(attr)<br>&#125;<br></code></pre></td></tr></table></figure><p>如上所示，加上<code>[Symbol.iterator]</code>这个迭代器属性我们自定义了一个迭代器方法，就可以使用<code>for..of</code>方法了</p><h4 id="Iterator-作用"><a href="#Iterator-作用" class="headerlink" title="Iterator 作用"></a>Iterator 作用</h4><p>Iterator 的作用有三个：</p><ul><li>为各种数据结构，提供一个统一的、简便的访问接口</li><li>使得数据结构的成员能够按某种次序排列</li><li>ES6 创造了一种新的遍历命令<code>for..of</code>循环，Iterator 接口主要供<code>for..of</code>消费</li></ul><p>Iterator 我们就介绍到这里，到这就理解上文 Iterator 参数是什么了吧，就是代表一个有迭代器属性的参数</p><h3 id="初识-Generator"><a href="#初识-Generator" class="headerlink" title="初识 Generator"></a>初识 Generator</h3><p>Generator 其实也是一个函数，只不过是一个特殊的函数</p><p>普通函数，你运行了这个函数，函数内部不会停，直到这个函数结束</p><p>Generator 这个函数特殊之处就是，中间可以停</p><h4 id="Generator-函数特点"><a href="#Generator-函数特点" class="headerlink" title="Generator 函数特点"></a>Generator 函数特点</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">generatorFn</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;a&quot;</span>)<br>  <span class="hljs-keyword">yield</span> <span class="hljs-string">&quot;1&quot;</span><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;b&quot;</span>)<br>  <span class="hljs-keyword">yield</span> <span class="hljs-string">&quot;2&quot;</span><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;c&quot;</span>)<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;3&quot;</span><br>&#125;<br><br><span class="hljs-keyword">let</span> it = generatorFn()<br>it.next()<br>it.next()<br>it.next()<br>it.next()<br></code></pre></td></tr></table></figure><p>上面这个示例就是一个 Generator 函数，首先我们观察它的特点，一个一个进行分析</p><ul><li>不同于普通函数，Generator 函数在<code>function</code>后面，函数名之前有个<code>*</code><ul><li><code>*</code>用来表示函数为 Generator 函数</li><li>写法很多，<code>function* fn()</code>、<code>function*fn()</code>和<code>function *fn()</code>都可以</li></ul></li><li>函数内部有<code>yield</code>字段<ul><li><code>yield</code>用来定义函数内部的状态，并让出执行权</li><li>这个关键字只能出现在生成器函数体内，但是生成器中也可以没有 yield 关键字，函数遇到 yield 的时候会暂停，并把 yield 后面的表达式结果抛出去</li></ul></li><li>调用后其函数返回值使用了<code>next</code>方法<ul><li>调用 Generator 函数和调用普通函数一样，在函数名后面加上()即可</li><li>Generator 函数不会像普通函数一样立即执行，而是返回一个指向内部状态对象的指针</li><li>所以要调用迭代器对象 Iterator 的 <code>next</code> 方法，指针就会从函数头部或者上一次停下来的地方开始执行</li><li><code>next</code> 方法其实就是将代码的控制权交还给生成器函数</li></ul></li></ul><h4 id="分析执行过程"><a href="#分析执行过程" class="headerlink" title="分析执行过程"></a>分析执行过程</h4><p>接着我们来分析它的执行过程，线来看它的打印结果，还是上面那个例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> it = generatorFn()<br>it.next()<br><span class="hljs-comment">// a</span><br><span class="hljs-comment">// &#123;value: &quot;1&quot;, done: false&#125;</span><br><br>it.next()<br><span class="hljs-comment">// b</span><br><span class="hljs-comment">// &#123;value: &quot;1&quot;, done: false&#125;</span><br><br>it.next()<br><span class="hljs-comment">// c</span><br><span class="hljs-comment">// &#123;value: &quot;1&quot;, done: true&#125;</span><br><br>it.next()<br><span class="hljs-comment">// &#123;value: undefined, done: true&#125;</span><br></code></pre></td></tr></table></figure><p>首先，Generator 函数执行，返回了一个指向内部状态对象的指针，此时没有任何输出</p><p>第一次调用<code>next</code>方法，从 Generator 函数的头部开始执行，先是打印了 a ，执行到<code>yield</code>就停下来，并将<code>yield</code>后边表达式的值 ‘1’，作为返回对象的 value 属性值，此时函数还没有执行完， 返回对象的 done 属性值是 false</p><p>第二次调用<code>next</code>方法时，同上步</p><p>第三次调用<code>next</code>方法时，先是打印了 c ，然后执行了函数的返回操作，并将 return 后面的表达式的值，作为返回对象的 value 属性值，此时函数已经结束，所以 done 属性值为 true</p><p>第四次调用<code>next</code>方法时， 此时函数已经执行完了，所以返回 value 属性值是 undefined，done 属性值是 true ，如果执行第三步时，没有 return 语句的话，就直接返回 <code>&#123;value: undefined, done: true&#125;</code></p><p>简单的理解，Generator 函数<code>yield</code>放到哪里它就停到哪里，调用时使用<code>next</code>方法踹一步就走一步</p><h4 id="next-参数传递"><a href="#next-参数传递" class="headerlink" title="next 参数传递"></a>next 参数传递</h4><p><code>yield</code>是有返回值的，<code>next</code>方法直接调用不传入参数的时候，<code>yield</code> 表达式的返回值是 undefined</p><p>当 next 传入参数的时候，该参数会作为<strong>上一步</strong><code>yield</code>的返回值</p><p>我们通过示例来理解</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">geFn</span>(<span class="hljs-params"></span>) </span>&#123;<br>  cosnole.log(<span class="hljs-string">&quot;start&quot;</span>)<br>  <span class="hljs-keyword">let</span> a = <span class="hljs-keyword">yield</span> <span class="hljs-string">&quot;1&quot;</span><br><br>  <span class="hljs-built_in">console</span>.log(a)<br>  <span class="hljs-keyword">let</span> b = <span class="hljs-keyword">yield</span> <span class="hljs-string">&quot;2&quot;</span><br><br>  <span class="hljs-built_in">console</span>.log(b)<br>  <span class="hljs-keyword">let</span> c = <span class="hljs-keyword">yield</span> <span class="hljs-string">&quot;3&quot;</span><br><br>  <span class="hljs-built_in">console</span>.log(c)<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">4</span><br>&#125;<br><br><span class="hljs-keyword">let</span> it = geFn()<br>it.next()<br><span class="hljs-comment">// start</span><br><span class="hljs-comment">// &#123; value:1, done: false &#125;</span><br><br>it1.next()<br><span class="hljs-comment">// undefined   未传值，所以a=undefined</span><br><span class="hljs-comment">// &#123; value:2, done: false &#125;</span><br><br>it.next(<span class="hljs-string">&quot;hahaha&quot;</span>)<br><span class="hljs-comment">// hahaha     传值，所以b=hahaha</span><br><span class="hljs-comment">// &#123; value:3, done: false &#125;</span><br><br>it.next(<span class="hljs-string">&quot;omg&quot;</span>)<br><span class="hljs-comment">// omg 传值，所以c=omg</span><br><span class="hljs-comment">// &#123;value: 4, done: true&#125;</span><br></code></pre></td></tr></table></figure><p>由于 <code>next</code> 方法的参数表示上一个 <code>yield</code> 语句的返回值，所以第一次使用 <code>next</code> 方法时，不能带有参数</p><p>V8 引擎会直接忽略第一次使用 <code>next</code> 方法时的参数，只有从第二次使用 <code>next</code> 方法开始，参数才是有效的</p><p>没有接到传值时，<code>yield</code>语句的返回值就是 undefined，正如上面示例输出那样</p><p>通过 <code>next</code> 方法的参数，就有办法在 Generator 函数开始运行之后，继续向函数体内部注入值，这代表了我们可以在 Generator 函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为</p><h4 id="再次理解-yield"><a href="#再次理解-yield" class="headerlink" title="再次理解 yield"></a>再次理解 yield</h4><p>我们再来看一段代码，帮助我们理解<code>yield</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">geFn</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;start&quot;</span>)<br>  <span class="hljs-keyword">let</span> a = <span class="hljs-keyword">yield</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;1&quot;</span>)<br>  <span class="hljs-built_in">console</span>.log(a)<br>  <span class="hljs-keyword">let</span> b = <span class="hljs-keyword">yield</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;2&quot;</span>)<br>  <span class="hljs-built_in">console</span>.log(b)<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;3&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">let</span> it = geFn()<br>it.next()<br><span class="hljs-comment">// start</span><br><span class="hljs-comment">// 1</span><br><span class="hljs-comment">// &#123;value: 1, done: false&#125;</span><br><br>it.next(<span class="hljs-string">&quot;我是a&quot;</span>)<br><span class="hljs-comment">// 我是a</span><br><span class="hljs-comment">// 2</span><br><span class="hljs-comment">// &#123;value: 2, done: false&#125;</span><br><br>it.next(<span class="hljs-string">&quot;我是b&quot;</span>)<br><span class="hljs-comment">// 我是b</span><br><span class="hljs-comment">// 3</span><br><span class="hljs-comment">// &#123;value: 3, done: true&#125;</span><br></code></pre></td></tr></table></figure><p>通过<code>next</code>调用我们可以看到，第一次调用就输出了<code>start &amp; 1</code> ，意味着<code>yield</code>停止时，后面代码是执行了的</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20200207234938429.png" alt="image-20200207234938429"></p><p>如上图所示，如果将说<code>yield</code>比做一道墙，那么墙右边和上面是一块，墙左边和下面是一块，这样说应该够直白了吧</p><h4 id="for-of-遍历-Generator"><a href="#for-of-遍历-Generator" class="headerlink" title="for..of 遍历 Generator"></a>for..of 遍历 Generator</h4><p>上文我们就知道了<code>for...of</code>内部实现就是在使用迭代器迭代，那么<code>for...of</code>循环直接用在 Generator 遍历器上岂不是完美</p><p>是的，它可以自动遍历 Generator 函数，而且此时不再需要调用 next 方法，一旦 next 方法的返回对象的 done 属性为 true，<code>for...of</code>循环就会中止，且不包含该返回对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span><br>  <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span><br>  <span class="hljs-keyword">yield</span> <span class="hljs-number">3</span><br>  <span class="hljs-keyword">yield</span> <span class="hljs-number">4</span><br>  <span class="hljs-keyword">yield</span> <span class="hljs-number">5</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">6</span><br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> v <span class="hljs-keyword">of</span> foo()) &#123;<br>  <span class="hljs-built_in">console</span>.log(v)<br>&#125;<br><span class="hljs-comment">// 1 2 3 4 5</span><br></code></pre></td></tr></table></figure><h4 id="yield-表达式"><a href="#yield-表达式" class="headerlink" title="yield* 表达式"></a>yield* 表达式</h4><p>在<code>yield</code>命令后面加上星号，表明它返回的是一个遍历器，这被称为<code>yield*</code>表达式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">yield</span> <span class="hljs-string">&quot;foo1&quot;</span><br>  <span class="hljs-keyword">yield</span> <span class="hljs-string">&quot;foo2&quot;</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">yield</span> <span class="hljs-string">&quot;bar1&quot;</span><br>  <span class="hljs-keyword">yield</span>* foo()<br>  <span class="hljs-keyword">yield</span> <span class="hljs-string">&quot;bar2&quot;</span><br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> val <span class="hljs-keyword">of</span> bar()) &#123;<br>  <span class="hljs-built_in">console</span>.log(val)<br>&#125;<br><br><span class="hljs-comment">// bar1 foo1 foo2 bar2</span><br></code></pre></td></tr></table></figure><p><code>yield</code>命令后面如果不加星号，返回的是整个数组，加了星号就表示返回的是数组的遍历器</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">gen1</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">yield</span> [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>]<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> val <span class="hljs-keyword">of</span> gen1()) &#123;<br>  <span class="hljs-built_in">console</span>.log(a)<br>&#125;<br><span class="hljs-comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br><br><span class="hljs-comment">// ------------------- 上下分割</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">gen2</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">yield</span>* [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>]<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> val <span class="hljs-keyword">of</span> gen2()) &#123;<br>  <span class="hljs-built_in">console</span>.log(a)<br>&#125;<br><span class="hljs-comment">// a b c</span><br></code></pre></td></tr></table></figure><h4 id="Generator-中的-return"><a href="#Generator-中的-return" class="headerlink" title="Generator 中的 return"></a>Generator 中的 return</h4><p>return 方法返回给定值，并结束遍历 Generator 函数</p><p>当 return 无值时，就返回 undefined，来看例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span><br>  <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span><br>  <span class="hljs-keyword">yield</span> <span class="hljs-number">3</span><br>&#125;<br><br><span class="hljs-keyword">var</span> f = foo()<br>f.next()<br><span class="hljs-comment">// &#123;value: 1, done: false&#125;</span><br><br>f.return(<span class="hljs-string">&quot;hahaha&quot;</span>)<br><span class="hljs-comment">// 由于调用了return方法，所以遍历已结束，done变true</span><br><span class="hljs-comment">// &#123;value: &quot;hahaha&quot;, done: true&#125;</span><br><br>f.next()<br><span class="hljs-comment">// &#123;value: undefined, done: true&#125;</span><br></code></pre></td></tr></table></figure><h4 id="Generator-错误处理-throw"><a href="#Generator-错误处理-throw" class="headerlink" title="Generator 错误处理 throw"></a>Generator 错误处理 throw</h4><p><code>throw</code>方法可以再 Generator 函数体外面抛出异常，再函数体内部捕获，听着是很好理解</p><p>这里一不小心还是挺容易入坑的，我们来看几个例子吧</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-string">&quot;hahaha&quot;</span><br>  &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;inside error: &quot;</span> + err)<br>  &#125;<br>&#125;<br><span class="hljs-keyword">var</span> f = foo()<br><span class="hljs-keyword">try</span> &#123;<br>  it.throw(<span class="hljs-string">&quot;this is err&quot;</span>)<br>&#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;out error: &quot;</span> + err)<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码会输出哪个错误呢？</p><p>其实答案很简单，上述代码会输出<code>out error：this is err</code></p><p>因为调用<code>throw</code>的时候，我们并没有执行<code>next</code>方法，这个时候内部的<code>try&#123;&#125;catch&#123;&#125;</code>代码都还没执行，因此只会被外面捕捉</p><p>所以说，我们只需要在调用<code>throw</code>之前，先调用一遍<code>next</code>，这个时候函数体内部已经执行了<code>try&#123;&#125;catch&#123;&#125;</code>，那么执行到<code>throw</code>时，内外都有错误捕捉，**<code>throw</code>方法会先被内部捕捉**，从而打印<code>inside error：this is err</code></p><p>除此，**<code>throw</code>方法会附带执行下一个<code>yield</code>**，我们来看示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> foo = <span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;1&quot;</span>)<br>    <span class="hljs-keyword">yield</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;2&quot;</span>)<br>  &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;inside err&quot;</span>)<br>  &#125;<br>  <span class="hljs-keyword">yield</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;3&quot;</span>)<br>  <span class="hljs-keyword">yield</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;4&quot;</span>)<br>&#125;<br><span class="hljs-keyword">var</span> g = foo()<br>g.next()<br>g.throw()<br>g.next()<br></code></pre></td></tr></table></figure><p>我们来看上述代码的执行过程</p><p>首先执行第一个<code>next</code>方法，进入<code>try()catch()</code>，输出 1</p><p>接着，执行<code>throw</code>方法，内部捕捉到，输出<code>inside err</code>，此时<code>try()catch()</code>代码块已经执行了<code>catch</code>，<code>try()catch()</code>代码块已经结束了，所以附带执行一个<code>yield</code>会继续向下找，所以再输出 3</p><p>最后执行<code>next</code>方法，输出 4</p><p>最终输出结果为<code>1 3 4</code></p><h3 id="Generator-扩充"><a href="#Generator-扩充" class="headerlink" title="Generator 扩充"></a>Generator 扩充</h3><p>在 Generator 开头有一句话，不知道大家理解没有</p><ul><li>Generator 是协程在 ES6 的实现，最大的特点就是可以交出函数的执行权</li></ul><h4 id="什么是协程？"><a href="#什么是协程？" class="headerlink" title="什么是协程？"></a>什么是协程？</h4><p>这里使用阮一峰老师的文章参考链接【8】中对协程的解释并略带修改及补充</p><p>进程和线程大家应该都清楚，那么协程是什么呢</p><p>不知道大家知不知道用户空间线程，其实就是一种由程序员自己写程序来管理他的调度的线程，对内核来说不可见</p><p>协程(coroutine)，可以理解就是一种“用户空间线程”，也可理解为多个“线程”相互协作，完成异步任务</p><p>由于线程是操作系统的最小执行单元，因此也可以得出，协程是基于线程实现的，不过它要比线程要轻很多</p><p>协程，有几个特点：</p><ul><li>协同，因为是由程序员自己写的调度策略，其通过协作而不是抢占来进行切换</li><li>在用户态完成创建，切换和销毁</li><li>编程角度上看，协程的思想本质上就是控制流的主动让出(yield)和恢复(resume)机制</li></ul><p>它的运行流程如下</p><ul><li>协程 A 开始执行</li><li>协程 A 执行到一半，暂停执行，执行的权利转交给协程 B。</li><li>一段时间后 B 交还执行权</li><li>协程 A 重得执行权，继续执行</li></ul><p>上面的协程 A 就是一个异步任务，因为在执行过程中执行权被 B 抢了，被迫分成两步完成</p><p>举例来说，读取文件的协程写法如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asnycJob</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// ...其他代码</span><br>  <span class="hljs-keyword">var</span> f = <span class="hljs-keyword">yield</span> readFile(fileA);<br>  <span class="hljs-comment">// ...其他代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码的函数 asyncJob 是一个协程，其中的 <code>yield</code> 命令，它表示执行到此处，执行权将交给其他协程，也就是说，<code>yield</code>命令是异步两个阶段的分界线</p><p>协程遇到 <code>yield</code> 命令就暂停，等到执行权返回，再从暂停的地方继续往后执行，它的最大优点，就是代码的写法非常像同步操作，只多了一个<code>yield</code>命令</p><h4 id="Generator-与协程"><a href="#Generator-与协程" class="headerlink" title="Generator 与协程"></a>Generator 与协程</h4><p>JS 是单线程的，ES6 中的 Generator 的实现，类似于开了多线程，但是依然同时只能进行一个线程，不过可以切换</p><p>就像汽车在公路上行驶，js 公路只是单行道(主线程)，但是有很多车道(辅助线程)都可以汇入车流(异步任务完成后回调进入主线程的任务队列)</p><p>而 Generator 把 js 公路变成了多车道(协程实现)，但是同一时间只有一个车道上的车能开(所以依然是单线程)，不过可以自由变道(移交控制权)</p><h4 id="Generator-之-Thunk-函数"><a href="#Generator-之-Thunk-函数" class="headerlink" title="Generator 之 Thunk 函数"></a>Generator 之 Thunk 函数</h4><p>thunk 函数的诞生源于一个编译器设计的问题：<code>求值策略</code>，即函数的参数到底应该何时求值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params">n</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> n * <span class="hljs-number">10</span><br>&#125;<br>fn(x + <span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><p>如上所示，其中 fn 方法调用时<code>x+5</code>这个表达式应该什么时候求值，有两种思路</p><ul><li>**传值调用(call by value)**，先计算<code>x+5</code>的值，再将这个值 <code>6</code> 传入函数 fn，例如 c 语言，这种做法的好处是实现比较简单，但是有可能会造成性能损失(例如一个函数传入了两个参数，第二个参数是一个表达式，但是函数体内没有用到这个参数，那么先计算出值就会损耗性能且无意义)</li><li>**传名调用(call by name)**，即直接将表达式<code>x+5</code>传入函数体，只在用到它的时候求值</li></ul><p>Thunk 函数的定义，就是传名调用的一种实现策略，用来替换某个表达式，实现思路其实也很简单</p><p>先将参数放到一个临时函数之中，再将这个临时函数传入函数体，就像下面这样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params">m</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> m * <span class="hljs-number">2</span><br>&#125;<br>fn(x + <span class="hljs-number">5</span>)<br><br><span class="hljs-comment">// thunk实现思路</span><br><span class="hljs-keyword">var</span> thunk = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> x + <span class="hljs-number">5</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params">thunk</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> thunk() * <span class="hljs-number">2</span><br>&#125;<br></code></pre></td></tr></table></figure><p>JS 是传值调用，它的 Thunck 函数含义有所不同</p><p>在 JS 中，Thunk 函数替换的不是表达式，是对函数珂里化的一种运用，简单来说，就是把是多参数函数替换成一个只接受回调函数作为参数的单参数函数，我们来看下它的简单实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js">fs.readFile(fileName, callback)<br><br><span class="hljs-keyword">const</span> Thunk = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fn</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">callback</span>) </span>&#123;<br>      <span class="hljs-keyword">return</span> fn.call(<span class="hljs-built_in">this</span>, ...args, callback)<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用上面的Thunk转化器，生成fs.readFile的Thunk函数</span><br><span class="hljs-keyword">var</span> readFileThunk = Thunk(fs.readFile)<br>readFileThunk(fileName)(callback)<br></code></pre></td></tr></table></figure><p>如果在生产环境要使用 Thunk 函数的话，使用 Thunkify 模块就可以，其实它核心源码就是上面我们写的 Thunk，Thunkify 里多了一个检查机制而已，比较简单，可自行百度 Thunkify 模块了解</p><p>Thunk 这东西在 ES6 前其实没有太大用处，但是在 Generator 函数出来后，Thunk 函数就可以派上用场了，它可以用于 Generator 函数的自动流程管理，接收和交换程序的执行权</p><p>我们来实现一个基于 Thunk 函数的 Generator 自动执行器</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 基于Thunk函数的Genertor函数自动执行器</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">run</span>(<span class="hljs-params">fn</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> gen = fn()<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">next</span>(<span class="hljs-params">err, data</span>) </span>&#123;<br>    <span class="hljs-comment">// 将指针移动到Generator函数的下一步</span><br>    <span class="hljs-keyword">let</span> result = gen.next(data)<br>    <span class="hljs-comment">// 判断是否结束</span><br>    <span class="hljs-keyword">if</span> (result.done) <span class="hljs-keyword">return</span><br>    <span class="hljs-comment">// 递归,把next放进.value中</span><br>    result.value(next)<br>  &#125;<br>  next()<br>&#125;<br><br><span class="hljs-comment">// 模拟异步方法</span><br><span class="hljs-keyword">let</span> sleep = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">n, callback</span>) </span>&#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(n)<br>    callback &amp;&amp; callback(n)<br>  &#125;, n)<br>&#125;<br><br><span class="hljs-comment">// 模拟异步方法进行Thunk转换</span><br><span class="hljs-keyword">let</span> sleepThunk = Thunk(sleep)<br><br><span class="hljs-comment">// Generator函数</span><br><span class="hljs-keyword">let</span> gen = <span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> f1 = <span class="hljs-keyword">yield</span> sleepThunk(<span class="hljs-number">1000</span>)<br>  <span class="hljs-keyword">let</span> f2 = <span class="hljs-keyword">yield</span> sleepThunk(<span class="hljs-number">1500</span>)<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-keyword">let</span> fn = <span class="hljs-keyword">yield</span> sleepThunk(<span class="hljs-number">2000</span>)<br>&#125;<br><br><span class="hljs-comment">// 调用Genertor函数自动执行器</span><br>run(gen)<br></code></pre></td></tr></table></figure><p>上面代码的 run 函数，就是一个 Generator 函数的自动执行器，内部的 next 函数就是 Thunk 的回调函数</p><p>next 函数先将指针移到 Generator 函数的下一步(gen.next 方法)</p><p>然后判断 Generator 函数是否结束(result.done 属性)</p><p>如果没结束，就将 next 函数再传入 Thunk 函数(result.value 属性)，否则就直接退出</p><p>代码中模拟了一个异步操作<code>sleep</code>方法，并将其转化为了 Thunk 方法(使用上文我们实现的那个简易版 Thunk)</p><p>函数 gen 封装了 n 个异步操作，只要执行 run 函数，这些操作就会自动完成</p><p>这样一来，异步操作不仅可以写得像同步操作，而且一行代码就可以执行，极其方便</p><p>不过相信大家也看到了，这种自动执行器传入的 Generator 函数，<strong>yield 方法后面必须是一个 Thunk 函数</strong></p><p>——–👇——–</p><p>Thunk 就简单介绍到这里了，更多 Thunk 相关推荐看阮一峰文参考链接【9】</p><p>我们只需要明白 Thunk 是什么，它和 Generator 有什么关系就可以</p><h4 id="Generator-之-co-函数库"><a href="#Generator-之-co-函数库" class="headerlink" title="Generator 之 co 函数库"></a>Generator 之 co 函数库</h4><p>co 函数库是著名程序员 TJ Holowaychuk 于 2013 年 6 月发布的一个小工具，用于 Generator 函数的自动执行</p><p><a href="https://github.com/tj/co">co 函数库传送门</a></p><p>co 函数库其实就是将两种自动执行器(Thunk 函数和 Promise 对象)，包装成一个库，所以说使用 co 的前提条件是，Generator 函数的 yield 命令后面，只能是 Thunk 函数或 Promise 对象</p><p>co 函数会返回一个 Promise，所以我们可以后接<code>then</code>等方法</p><p>基于 Thunk 函数的自动执行器上面介绍了下，那么基于 Promise 的其实也差不多，我们简单实现下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 基于Promise函数的Genertor函数自动执行器</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">run</span>(<span class="hljs-params">gen</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> g = gen()<br><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">next</span>(<span class="hljs-params">data</span>) </span>&#123;<br>    <span class="hljs-comment">// 将指针移动到Generator函数的下一步</span><br>    <span class="hljs-keyword">let</span> result = g.next(data)<br>    <span class="hljs-comment">// 判断是否结束，结束返回value，value是一个Promise</span><br>    <span class="hljs-keyword">if</span> (result.done) <span class="hljs-keyword">return</span> result.value<br>    <span class="hljs-comment">// 递归</span><br>    result.value.then(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>      next(data)<br>    &#125;)<br>  &#125;<br>  next()<br>&#125;<br><br><span class="hljs-comment">// 模拟异步方法进行Promise转换</span><br><span class="hljs-keyword">let</span> sleepPromise = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">n</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-built_in">console</span>.log(n)<br>      resolve(n)<br>    &#125;, n)<br>  &#125;)<br>&#125;<br><br><span class="hljs-comment">// Generator函数</span><br><span class="hljs-keyword">let</span> gen = <span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> f1 = <span class="hljs-keyword">yield</span> sleepPromise(<span class="hljs-number">1000</span>)<br>  <span class="hljs-keyword">let</span> f2 = <span class="hljs-keyword">yield</span> sleepPromise(<span class="hljs-number">1500</span>)<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-keyword">let</span> fn = <span class="hljs-keyword">yield</span> sleepPromise(<span class="hljs-number">2000</span>)<br>&#125;<br><br><span class="hljs-comment">// 调用Genertor函数自动执行器</span><br>run(gen)<br></code></pre></td></tr></table></figure><p>如上代码，和 Thunk 函数那里区别就是 yield 后面一个跟 Thunk 函数，一个跟 Promise 对象</p><p>如果 Thunk 自执行器你理解了，Promise 使用也 ok 的话，这块代码看看就懂了，也没啥解释的</p><p>接下来我们来看看 co 库的源码</p><p>co 函数库的源码也很简单，只有几十行代码</p><p>首先，co 函数接受 Generator 函数作为参数，返回一个 Promise 对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">co</span>(<span class="hljs-params">gen</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> ctx = <span class="hljs-built_in">this</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>在返回的 Promise 对象里面，co 先检查参数 gen 是否为 Generator 函数</p><p>如果是，就执行该函数，得到一个内部指针对象</p><p>如果不是就返回，并将 Promise 对象的状态改为 resolved</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">co</span>(<span class="hljs-params">gen</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> ctx = <span class="hljs-built_in">this</span><br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> gen === <span class="hljs-string">&quot;function&quot;</span>) gen = gen.call(ctx)<br>    <span class="hljs-keyword">if</span> (!gen || <span class="hljs-keyword">typeof</span> gen.next !== <span class="hljs-string">&quot;function&quot;</span>) <span class="hljs-keyword">return</span> resolve(gen)<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>接着，co 将 Generator 函数的内部指针对象的 next 方法，包装成 onFulefilled 函数</p><p>主要是为了能够捕捉抛出的错误</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">co</span>(<span class="hljs-params">gen</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> ctx = <span class="hljs-built_in">this</span><br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> gen === <span class="hljs-string">&quot;function&quot;</span>) gen = gen.call(ctx)<br>    <span class="hljs-keyword">if</span> (!gen || <span class="hljs-keyword">typeof</span> gen.next !== <span class="hljs-string">&quot;function&quot;</span>) <span class="hljs-keyword">return</span> resolve(gen)<br><br>    onFulfilled()<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onFulfilled</span>(<span class="hljs-params">res</span>) </span>&#123;<br>      <span class="hljs-keyword">var</span> ret<br>      <span class="hljs-keyword">try</span> &#123;<br>        ret = gen.next(res)<br>      &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>        <span class="hljs-keyword">return</span> reject(e)<br>      &#125;<br>      next(ret)<br>    &#125;<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，就是关键的 next 函数，它会反复调用自身</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">next</span>(<span class="hljs-params">ret</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (ret.done) <span class="hljs-keyword">return</span> resolve(ret.value)<br>  <span class="hljs-keyword">var</span> value = toPromise.call(ctx, ret.value)<br>  <span class="hljs-keyword">if</span> (value &amp;&amp; isPromise(value)) <span class="hljs-keyword">return</span> value.then(onFulfilled, onRejected)<br>  <span class="hljs-keyword">return</span> onRejected(<span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&#x27;You may only yield a function, promise, generator, array, or object, but the following object was passed: &quot;&#x27;</span> + <span class="hljs-built_in">String</span>(ret.value) + <span class="hljs-string">&#x27;&quot;&#x27;</span>))<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p><code>next</code>方法中，第一行，检查当前是否为 Generator 函数的最后一步，如果是就返回</p><p>第二行，确保每一步的返回值，是 Promise 对象</p><p>第三行，使用 then 方法，为返回值加上回调函数，然后通过 onFulfilled 函数再次调用 next 函数</p><p>第四行，在参数不符合要求的情况下(参数非 Thunk 函数和 Promise 对象)，将 Promise 对象的状态改为 rejected，从而终止执行</p><p>co 支持并发的异步操作，即允许某些操作同时进行，等到它们全部完成，才进行下一步，我们可以并发的操作放在数组或对象里面，如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 数组的写法</span><br>co(<span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> res = <span class="hljs-keyword">yield</span> [<span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">1</span>), <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">2</span>)]<br>  <span class="hljs-built_in">console</span>.log(res)<br>&#125;).catch(onerror)<br><br><span class="hljs-comment">// 对象的写法</span><br>co(<span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> res = <span class="hljs-keyword">yield</span> &#123;<br>    <span class="hljs-number">1</span>: <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">1</span>),<br>    <span class="hljs-number">2</span>: <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">2</span>),<br>  &#125;<br>  <span class="hljs-built_in">console</span>.log(res)<br>&#125;).catch(onerror)<br></code></pre></td></tr></table></figure><p>——-👇——-</p><p>以上就是 co 的内容了，这里提及只是为了让大家了解 co 这种函数库，虽然目前用的不多，但是对我们理解 Generator 有帮助，即使这里有些迷糊，也无伤大雅，知道 co 是什么，co 的自动执行原理大概是怎么实现的就行</p><p>这块和 Thunk 一样，也是参考阮一峰老师的文章，所以有兴趣的话可以看下参考链接【10】</p><h3 id="Generator-优-缺"><a href="#Generator-优-缺" class="headerlink" title="Generator 优/缺"></a>Generator 优/缺</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>优雅的流程控制方式，可以让函数可中断执行，在某些特殊需求里还是很实用的</p><p>使用过 React-dva 的同学可能会更有感触一些</p><p>之前 Node 的 koa 框架也用 Generator，不过后来被 async/await 替代了</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>Generator 函数的执行必须靠执行器，所以才有了 co 函数库，但 co 模块约定，yield 命令后面只能是 Thunk 函数或 Promise 对象，只针对异步处理来说，还是不太方便</p><h2 id="Async-Await"><a href="#Async-Await" class="headerlink" title="Async/Await"></a>Async/Await</h2><h3 id="Async-和-Await-简介"><a href="#Async-和-Await-简介" class="headerlink" title="Async 和 Await 简介"></a>Async 和 Await 简介</h3><p>ES2017 标准引入了 <code>async</code> 函数，使得异步操作变得更加方便</p><p>JS 异步编程解决方案的历程，从经典的回调函数到事件监听，再到 <code>Promise</code> ，再到 <code>Generator</code> ，再到我们要说的 <code>Async/Await</code> ，可谓艰辛</p><p><code>Async/Await</code> 的出现，被很多人认为是 JS 异步操作的最终且最优雅的解决方案</p><p><code>Async/Await</code> 大家都经常使用，也都知道它是 <code>Generator</code> 的语法糖</p><p>其实我觉得 <code>Async/Await = Generator + Promise</code> 这个解释更适合</p><p><code>async</code> 是异步的意思，而 <code>await</code> 是 <code>async wait</code> 的简写，即异步等待</p><p>所以从语义上就很好理解 <code>async</code> 用于声明一个 <code>function</code> 是异步的，<code>await</code> 用于等待一个异步方法执行完成</p><p>另外 <code>await</code> 只能出现在 <code>async</code> 函数中</p><p>闲聊至此，接下来还是简单介绍下使用</p><h3 id="Async-在做什么"><a href="#Async-在做什么" class="headerlink" title="Async 在做什么"></a>Async 在做什么</h3><p>我们来看一个例子理解</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;this is async&quot;</span><br>&#125;<br><span class="hljs-keyword">const</span> res = test()<br><span class="hljs-built_in">console</span>.log(res)<br><span class="hljs-comment">// Promise &#123;&lt;resolved&gt;: &quot;this is async&quot;&#125;</span><br></code></pre></td></tr></table></figure><p>可以看到，输出的是一个 Promise 对象</p><p>所以，<code>async</code> 函数返回的是一个 Promise 对象，如果在 <code>async</code> 函数中直接 return 一个直接量，<code>async</code> 会把这个直接量通过 <code>PromIse.resolve()</code> 封装成 Promise 对象返回</p><p>既然 <code>async</code> 返回一个 Promise，那么我们也可以用 <code>then</code> 链来处理这个 Promise 对象，如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">test().then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(res)<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="Await-在等待什么"><a href="#Await-在等待什么" class="headerlink" title="Await 在等待什么"></a>Await 在等待什么</h3><p>我们常说<code>await</code> 是在等待一个异步完成， 其实按照语法说明， <code>await</code> 等待的是一个表达式，这个表达式的计算结果是 Promise 对象或者其它值(换句话说，就是没有特殊限定，啥都行)</p><ul><li><code>await</code> 后面不是 Promise 对象，直接执行</li><li><code>await</code> 后面是 Promise 对象会阻塞后面的代码，Promise 对象 <code>resolve</code>，然后得到 <code>resolve</code> 的值，作为 <code>await</code> 表达式的运算结果</li><li><code>await</code> 只能在 <code>async</code> 函数中使用</li></ul><p>使用比较简单，大家也经常用就不多说了</p><p>简单说一下为什 <code>await</code> 必须要在 <code>async</code> 函数中使用</p><p>其实很简单， <code>await</code> 会阻塞后面代码，如果允许我们直接使用 <code>await</code> 的话，假如我们使用<code>await</code>等待一个消耗时间比较长的异步请求，那代码直接就阻塞不往下执行了，只能等待 <code>await</code> 拿到结果才会执行下面的代码，那不乱套了</p><p>而 <code>async</code> 函数调用不会造成阻塞，因为它内部所有的阻塞都被封装在一个 Promise 对象中异步执行，所以才规定 <code>await</code> 必须在 <code>async</code> 函数中</p><h3 id="处理异常"><a href="#处理异常" class="headerlink" title="处理异常"></a>处理异常</h3><p>promise 正常 resolve，那么 await 会返回这个结果，但是在 reject 的情况下会抛出一个错误</p><p>所以我们直接把 <code>await</code> 代码块写到 <code>try()catch()</code> 中捕获错误即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">let</span> res = <span class="hljs-keyword">await</span> ajax()<br>    <span class="hljs-built_in">console</span>.log(res)<br>  &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>    <span class="hljs-built_in">console</span>.log(err)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="没有对比没有伤害"><a href="#没有对比没有伤害" class="headerlink" title="没有对比没有伤害"></a>没有对比没有伤害</h3><p>我们经常会遇到这种业务，多个请求，每个请求依赖于上一个请求的结果</p><p>我们用 setTimeout 模拟异步操作，用 Promise 和 Async/Await 分别来实现下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">analogAsync</span>(<span class="hljs-params">n</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> resolve(n + <span class="hljs-number">500</span>), n)<br>  &#125;)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn1</span>(<span class="hljs-params">n</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`step1 with <span class="hljs-subst">$&#123;n&#125;</span>`</span>)<br>  <span class="hljs-keyword">return</span> analogAsync(n)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn2</span>(<span class="hljs-params">n</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`step2 with <span class="hljs-subst">$&#123;n&#125;</span>`</span>)<br>  <span class="hljs-keyword">return</span> analogAsync(n)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn3</span>(<span class="hljs-params">n</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`step3 with <span class="hljs-subst">$&#123;n&#125;</span>`</span>)<br>  <span class="hljs-keyword">return</span> analogAsync(n)<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 Promise</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> time1 = <span class="hljs-number">0</span><br>  fn1(time1)<br>    .then(<span class="hljs-function">(<span class="hljs-params">time2</span>) =&gt;</span> fn2(time2))<br>    .then(<span class="hljs-function">(<span class="hljs-params">time3</span>) =&gt;</span> fn3(time3))<br>    .then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`result is <span class="hljs-subst">$&#123;res&#125;</span>`</span>)<br>    &#125;)<br>&#125;<br><br>fn()<br></code></pre></td></tr></table></figure><p>使用 Async/Await</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> time1 = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">let</span> time2 = <span class="hljs-keyword">await</span> fn1(time1)<br>  <span class="hljs-keyword">let</span> time3 = <span class="hljs-keyword">await</span> fn2(time2)<br>  <span class="hljs-keyword">let</span> res = <span class="hljs-keyword">await</span> fn3(time3)<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`result is <span class="hljs-subst">$&#123;res&#125;</span>`</span>)<br>&#125;<br><br>fn()<br></code></pre></td></tr></table></figure><p>输出结果和上面用 Promise 实现是一样的，但这个 <code>aaync/await</code> 代码结构看起来清晰得多，几乎跟同步写法一样，十分优雅</p><p>我们再来看下面这个小例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// Generator</span><br><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">gen</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> f1 = <span class="hljs-keyword">yield</span> ajax()<br>  <span class="hljs-keyword">let</span> f2 = <span class="hljs-keyword">yield</span> ajax()<br>&#125;<br>gen()<br><br><span class="hljs-comment">// async/await</span><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asyncAjax</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> f1 = <span class="hljs-keyword">await</span> ajax()<br>  <span class="hljs-keyword">let</span> f2 = <span class="hljs-keyword">await</span> ajax()<br>&#125;<br>asyncAjax()<br></code></pre></td></tr></table></figure><p>这两块代码看着是不是几乎一样</p><p>上面函数为 Generator 函数执行两个 ajax，下面函数为 async/await 执行</p><p>比较可发现，两个函数其实是一样的，<code>async</code> 不过是把 Generator 函数的 <code>*</code> 号换成 <code>async</code>，<code>yield</code> 换成 <code>await</code></p><p>那么这两个函数在调用时，Generator 函数需要手动调用 <code>next</code> 方法或者使用 co 函数库才可执行，而下面的<code>async</code> 函数直接就按顺序执行完成了，使用非常方便</p><p>异步编程追求的是，让它更像同步编程， <code>Async/Await</code> 完美诠释了这一点</p><p>到这里我们其实就不难看出 <code>Async/Await</code> 已经完虐了 <code>Generator</code> 和 <code>Promise</code></p><p>对比来看我们发现，Async 函数自带执行器</p><h3 id="Async-Await-优-缺"><a href="#Async-Await-优-缺" class="headerlink" title="Async/Await 优/缺"></a>Async/Await 优/缺</h3><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><p>内置执行器， Generator 函数的执行必须靠执行器，所以才有了 co 函数库，而 <code>async</code> 函数自带执行器，也就是说，<code>async</code> 函数的执行，与普通函数一模一样，只要一行</p><p>更好的语义，<code>async</code> 和 <code>await</code>，比起 <code>*</code> 和 <code>yield</code>，语义更清楚了，<code>async</code> 表示函数里有异步操作，<code>await</code> 表示紧跟在后面的表达式需要等待结果</p><p>更广的适用性，co 函数库约定，<code>yield</code> 命令后面只能是 Thunk 函数或 Promise 对象，而 <code>async</code> 函数的 <code>await</code> 命令后面，可以跟 Promise 对象和原始类型的值(数值、字符串和布尔值，但这时等同于同步操作)</p><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><p>滥用 <code>await</code> 可能会导致性能问题，因为 <code>await</code> 会阻塞代码，也许之后的异步代码并不依赖于前者，但仍然需要等待前者完成，导致代码失去了并发性</p><h2 id="异步解决方案对比"><a href="#异步解决方案对比" class="headerlink" title="异步解决方案对比"></a>异步解决方案对比</h2><p>别看了，我没有总结对比</p><p>其实相对来说已经写的很详细了，能讲出来的才算是自己的，大家可根据每种方案列出的优缺点加上自己的理解做个对比或着说总结，毕竟你都看到这了，也不妄花费这么长时间来阅读这两万字的干帖子，总归要有些收获的</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>水平有限，欢迎指错</p><p>码字不易，大家有收获别忘了点个赞鼓励下</p><p>搜索【不正经的前端】或直接扫码可以关注公众号看到更多的精彩文章，也有一些群友提供的学习视频、资源干货什么的免费拿</p><p>也可以直接加我微信，进交流群学习交流</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/qqz.png"></p><blockquote><p>参考</p><ol><li><a href="%5Bhttp://www.ruanyifeng.com/blog/2012/12/asynchronous%EF%BC%BFjavascript.html%5D(http://www.ruanyifeng.com/blog/2012/12/asynchronous%EF%BC%BFjavascript.html)">Javascript 异步编程的 4 种方法-阮一峰</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promise-MDN</a></li><li><a href="https://www.liaoxuefeng.com/wiki/1022910821149312/1023024358748480">iterable-廖雪峰</a></li><li><a href="http://cryto.net/~joepie91/blog/2016/05/11/what-is-promise-try-and-why-does-it-matter/">What is Promise.try, and why does it matter?</a></li><li><a href="https://segmentfault.com/a/1190000018586947">什么是 Promise.try，为什么它这么重要？-参考 4 译</a></li><li><a href="https://promisesaplus.com/">Promise/A+规范-英原文</a></li><li><a href="http://www.ituring.com.cn/article/66566">Promise/A+规范-中文译</a></li><li><a href="http://www.ruanyifeng.com/blog/2015/04/generator.html">Generator 函数的含义与用法-阮一峰</a></li><li><a href="http://www.ruanyifeng.com/blog/2015/05/thunk.html">Thunk 函数的含义和用法-阮一峰</a></li><li><a href="http://www.ruanyifeng.com/blog/2015/05/co.html">co 函数库的含义和用法-阮一峰</a></li></ol></blockquote>]]></content>
    
    
    <categories>
      
      <category>硬核JS系列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「硬核 JS」一次搞懂 JS 运行机制</title>
    <link href="/blog/2020/01/18/js/%E3%80%8C%E7%A1%AC%E6%A0%B8JS%E3%80%8D%E4%B8%80%E6%AC%A1%E6%90%9E%E6%87%82JS%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/"/>
    <url>/blog/2020/01/18/js/%E3%80%8C%E7%A1%AC%E6%A0%B8JS%E3%80%8D%E4%B8%80%E6%AC%A1%E6%90%9E%E6%87%82JS%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>从开始做前端到目前为止，陆续看了很多帖子讲 JS 运行机制，看过不久就忘了，还是自己理一遍好些</p><p>通过码字使自己对 JS 运行机制相关内容更加深刻(自己用心写过的贴子，内容也会牢记于心)</p><p>顺道给大家看看(我太难了，深夜码字，反复修改，说这么多就是想请你点个赞在看)</p><p>参考了很多资料(帖子)，取其精华，去其糟糠，都在文末，可自行了解</p><p>是时候搞一波我大 js 了</p><p>从零到一百再到一，从多方面了解 JS 的运行机制，体会更深刻，请认真读下去</p><p>本文大致分为以下这样的步骤来帮助我们由广入深更加清晰的了解 JS 运行机制</p><ul><li>首先我们要了解进程和线程的概念</li><li>其次我们要知道浏览器的进程线程常识</li><li>再然后通过 Event Loop、宏任务(macrotask)微任务(microtask)来看浏览器的几个线程间是怎样配合的</li><li>再然后通过例子来印证我们的猜想</li><li>最后提下 NodeJS 的运行机制</li></ul><h2 id="灵魂一问"><a href="#灵魂一问" class="headerlink" title="灵魂一问"></a>灵魂一问</h2><p>JS 运行机制在平常前端面试时不管是笔试题还是面试题命中率都极高</p><p>说到 JS 运行机制，你知道多少</p><p>看到这大家可能会说：JS 运行机制嘛，很简单，事件循环、宏微任务那点东西</p><p>是的，作为一名前端我们都了解，但是如果这真的面试问到了这个地方，你真的可以答好吗(灵魂一问 🤔️)</p><p><strong>不管你对 JS 了解多少，到这里大家不防先停止一下阅读，假设你目前在面试，面试官让你阐述下 JS 运行机制，思考下你的答案，用 20 秒的时间(面试时 20s 已经很长了)，然后带着答案再接着往下看，有人曾经说过：<code>没有思考的阅读纯粹是消磨时间罢了</code>，这话很好(因为是我说的，皮一下 😄)</strong></p><p>也有很多刚开始接触 JS 的同学会被<code>任务队列 执行栈 微任务 宏任务</code>这些高大上点的名字搞的很懵</p><p>接下来，我们来细致的梳理一遍你就可以清晰的了解它们了</p><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><h3 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程"></a>什么是进程</h3><p>我们都知道，<code>CPU</code>是计算机的核心，承担所有的计算任务</p><p>官网说法，<code>进程</code>是<code>CPU</code>资源分配的最小单位</p><p>字面意思就是进行中的程序，我将它理解为一个可以独立运行且拥有自己的资源空间的任务程序</p><p><code>进程</code>包括运行中的程序和程序所使用到的内存和系统资源</p><p><code>CPU</code>可以有很多进程，我们的电脑每打开一个软件就会产生一个或多个<code>进程</code>，为什么电脑运行的软件多就会卡，是因为<code>CPU</code>给每个<code>进程</code>分配资源空间，但是一个<code>CPU</code>一共就那么多资源，分出去越多，越卡，每个<code>进程</code>之间是相互独立的，<code>CPU</code>在运行一个<code>进程</code>时，其他的进程处于非运行状态，<code>CPU</code>使用 <a href="%5Bhttps://baike.baidu.com/item/%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC%E8%B0%83%E5%BA%A6%5D(https://baike.baidu.com/item/%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC%E8%B0%83%E5%BA%A6)">时间片轮转调度算法</a> 来实现同时运行多个<code>进程</code></p><h3 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h3><p><code>线程</code>是<code>CPU</code>调度的最小单位</p><p><code>线程</code>是建立在<code>进程</code>的基础上的一次程序运行单位，通俗点解释<code>线程</code>就是程序中的一个执行流，一个<code>进程</code>可以有多个<code>线程</code></p><p>一个<code>进程</code>中只有一个执行流称作<code>单线程</code>，即程序执行时，所走的程序路径按照连续顺序排下来，前面的必须处理好，后面的才会执行</p><p>一个<code>进程</code>中有多个执行流称作<code>多线程</code>，即在一个程序中可以同时运行多个不同的<code>线程</code>来执行不同的任务，<br>也就是说允许单个程序创建多个并行执行的<code>线程</code>来完成各自的任务</p><h3 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h3><p>进程是操作系统分配资源的最小单位，线程是程序执行的最小单位</p><p>一个进程由一个或多个线程组成，线程可以理解为是一个进程中代码的不同执行路线</p><p>进程之间相互独立，但同一进程下的各个线程间共享程序的内存空间(包括代码段、数据集、堆等)及一些进程级的资源(如打开文件和信号)</p><p>调度和切换：线程上下文切换比进程上下文切换要快得多</p><h3 id="多进程和多线程"><a href="#多进程和多线程" class="headerlink" title="多进程和多线程"></a>多进程和多线程</h3><p><strong>多进程：</strong>多进程指的是在同一个时间里，同一个计算机系统中如果允许两个或两个以上的进程处于运行状态。多进程带来的好处是明显的，比如大家可以在网易云听歌的同时打开编辑器敲代码，编辑器和网易云的进程之间不会相互干扰</p><p><strong>多线程：</strong>多线程是指程序中包含多个执行流，即在一个程序中可以同时运行多个不同的线程来执行不同的任务，也就是说允许单个程序创建多个并行执行的线程来完成各自的任务</p><h2 id="JS-为什么是单线程"><a href="#JS-为什么是单线程" class="headerlink" title="JS 为什么是单线程"></a>JS 为什么是单线程</h2><p>JS 的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript 的主要用途是与用户互动，以及操作 DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定 JavaScript 同时有两个线程，一个线程在某个 DOM 节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？</p><p>还有人说 js 还有 Worker 线程，对的，为了利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程，但是子线程是完 全受主线程控制的，而且不得操作 DOM</p><p>所以，这个标准并没有改变 JavaScript 是单线程的本质</p><p>了解了进程和线程之后，接下来看看浏览器解析，浏览器之间也是有些许差距的，不过大致是差不多的，下文我们皆用市场占有比例最大的 Chrome 为例</p><h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><h3 id="浏览器是多进程的"><a href="#浏览器是多进程的" class="headerlink" title="浏览器是多进程的"></a>浏览器是多进程的</h3><p>作为前端，免不了和浏览器打交道，浏览器是多进程的，拿 Chrome 来说，我们每打开一个 Tab 页就会产生一个进程，我们使用 Chrome 打开很多标签页不关，电脑会越来越卡，不说其他，首先就很耗 CPU</p><h3 id="浏览器包含哪些进程"><a href="#浏览器包含哪些进程" class="headerlink" title="浏览器包含哪些进程"></a>浏览器包含哪些进程</h3><ul><li><p>Browser 进程</p><ul><li>浏览器的主进程(负责协调、主控)，该进程只有一个</li><li>负责浏览器界面显示，与用户交互。如前进，后退等</li><li>负责各个页面的管理，创建和销毁其他进程</li><li>将渲染(Renderer)进程得到的内存中的 Bitmap(位图)，绘制到用户界面上</li><li>网络资源的管理，下载等</li></ul></li><li><p>第三方插件进程</p><ul><li>每种类型的插件对应一个进程，当使用该插件时才创建</li></ul></li><li><p>GPU 进程</p><ul><li>该进程也只有一个，用于 3D 绘制等等</li></ul></li><li><p>渲染进程(重)</p><ul><li>即通常所说的浏览器内核(Renderer 进程，内部是多线程)</li><li>每个 Tab 页面都有一个渲染进程，互不影响</li><li>主要作用为页面渲染，脚本执行，事件处理等</li></ul></li></ul><h3 id="为什么浏览器要多进程"><a href="#为什么浏览器要多进程" class="headerlink" title="为什么浏览器要多进程"></a>为什么浏览器要多进程</h3><p>我们假设浏览器是单进程，那么某个 Tab 页崩溃了，就影响了整个浏览器，体验有多差</p><p>同理如果插件崩溃了也会影响整个浏览器</p><p>当然多进程还有其它的诸多优势，不过多阐述</p><p>浏览器进程有很多，每个进程又有很多线程，都会占用内存</p><p>这也意味着内存等资源消耗会很大，有点拿空间换时间的意思</p><p>到此可不只是为了让我们理解为何 Chrome 运行时间长了电脑会卡，哈哈，第一个重点来了</p><h3 id="简述渲染进程-Renderer-重"><a href="#简述渲染进程-Renderer-重" class="headerlink" title="简述渲染进程 Renderer(重)"></a>简述渲染进程 Renderer(重)</h3><p>页面的渲染，JS 的执行，事件的循环，都在渲染进程内执行，所以我们要重点了解渲染进程</p><p>渲染进程是多线程的，我们来看渲染进程的一些常用较为主要的线程</p><h3 id="渲染进程-Renderer-的主要线程"><a href="#渲染进程-Renderer-的主要线程" class="headerlink" title="渲染进程 Renderer 的主要线程"></a>渲染进程 Renderer 的主要线程</h3><h4 id="GUI-渲染线程"><a href="#GUI-渲染线程" class="headerlink" title="GUI 渲染线程"></a>GUI 渲染线程</h4><ul><li>负责渲染浏览器界面，解析 HTML，CSS，构建 DOM 树和 RenderObject 树，布局和绘制等<ul><li>解析 html 代码(HTML 代码本质是字符串)转化为浏览器认识的节点，生成 DOM 树，也就是 DOM Tree</li><li>解析 css，生成 CSSOM(CSS 规则树)</li><li>把 DOM Tree 和 CSSOM 结合，生成 Rendering Tree(渲染树)</li></ul></li><li>当我们修改了一些元素的颜色或者背景色，页面就会重绘(Repaint)</li><li>当我们修改元素的尺寸，页面就会回流(Reflow)</li><li>当页面需要 Repaing 和 Reflow 时 GUI 线程执行，绘制页面</li><li>回流(Reflow)比重绘(Repaint)的成本要高，我们要尽量避免 Reflow 和 Repaint</li><li>GUI 渲染线程与 JS 引擎线程是互斥的<ul><li>当 JS 引擎执行时 GUI 线程会被挂起(相当于被冻结了)</li><li>GUI 更新会被保存在一个队列中等到 JS 引擎空闲时立即被执行</li></ul></li></ul><h4 id="JS-引擎线程"><a href="#JS-引擎线程" class="headerlink" title="JS 引擎线程"></a>JS 引擎线程</h4><ul><li>JS 引擎线程就是 JS 内核，负责处理 Javascript 脚本程序(例如 V8 引擎)</li><li>JS 引擎线程负责解析 Javascript 脚本，运行代码</li><li>JS 引擎一直等待着任务队列中任务的到来，然后加以处理<ul><li>浏览器同时只能有一个 JS 引擎线程在运行 JS 程序，所以 js 是单线程运行的</li><li>一个 Tab 页(renderer 进程)中无论什么时候都只有一个 JS 线程在运行 JS 程序</li></ul></li><li>GUI 渲染线程与 JS 引擎线程是互斥的，js 引擎线程会阻塞 GUI 渲染线程<ul><li>就是我们常遇到的 JS 执行时间过长，造成页面的渲染不连贯，导致页面渲染加载阻塞(就是加载慢)</li><li>例如浏览器渲染的时候遇到<code>&lt;script&gt;</code>标签，就会停止 GUI 的渲染，然后 js 引擎线程开始工作，执行里面的 js 代码，等 js 执行完毕，js 引擎线程停止工作，GUI 继续渲染下面的内容。所以如果 js 执行时间太长就会造成页面卡顿的情况</li></ul></li></ul><h4 id="事件触发线程"><a href="#事件触发线程" class="headerlink" title="事件触发线程"></a>事件触发线程</h4><ul><li>属于浏览器而不是 JS 引擎，用来控制事件循环，并且管理着一个事件队列(task queue)</li><li>当 js 执行碰到事件绑定和一些异步操作(如 setTimeOut，也可来自浏览器内核的其他线程，如鼠标点击、AJAX 异步请求等)，会走事件触发线程将对应的事件添加到对应的线程中(比如定时器操作，便把定时器事件添加到定时器线程)，等异步事件有了结果，便把他们的回调操作添加到事件队列，等待 js 引擎线程空闲时来处理。</li><li>当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待 JS 引擎的处理</li><li>因为 JS 是单线程，所以这些待处理队列中的事件都得排队等待 JS 引擎处理</li></ul><h4 id="定时触发器线程"><a href="#定时触发器线程" class="headerlink" title="定时触发器线程"></a>定时触发器线程</h4><ul><li><code>setInterval</code>与<code>setTimeout</code>所在线程</li><li>浏览器定时计数器并不是由 JavaScript 引擎计数的(因为 JavaScript 引擎是单线程的，如果处于阻塞线程状态就会影响记计时的准确)</li><li>通过单独线程来计时并触发定时(计时完毕后，添加到事件触发线程的事件队列中，等待 JS 引擎空闲后执行)，这个线程就是定时触发器线程，也叫定时器线程</li><li>W3C 在 HTML 标准中规定，规定要求<code>setTimeout</code>中低于 4ms 的时间间隔算为 4ms</li></ul><h4 id="异步-http-请求线程"><a href="#异步-http-请求线程" class="headerlink" title="异步 http 请求线程"></a>异步 http 请求线程</h4><ul><li>在 XMLHttpRequest 在连接后是通过浏览器新开一个线程请求</li><li>将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中再由 JavaScript 引擎执行</li><li>简单说就是当执行到一个 http 异步请求时，就把异步请求事件添加到异步请求线程，等收到响应(准确来说应该是 http 状态变化)，再把回调函数添加到事件队列，等待 js 引擎线程来执行</li></ul><p>了解了上面这些基础后，接下来我们开始进入今天的正题</p><h2 id="事件循环-Event-Loop-初探"><a href="#事件循环-Event-Loop-初探" class="headerlink" title="事件循环(Event Loop)初探"></a>事件循环(Event Loop)初探</h2><p>首先要知道，JS 分为同步任务和异步任务</p><p>同步任务都在主线程(这里的主线程就是 JS 引擎线程)上执行，会形成一个<code>执行栈</code></p><p>主线程之外，事件触发线程管理着一个<code>任务队列</code>，只要异步任务有了运行结果，就在<code>任务队列</code>之中放一个事件回调</p><p>一旦<code>执行栈</code>中的所有同步任务执行完毕(也就是 JS 引擎线程空闲了)，系统就会读取<code>任务队列</code>，将可运行的异步任务(任务队列中的事件回调，只要任务队列中有事件回调，就说明可以执行)添加到执行栈中，开始执行</p><p>我们来看一段简单的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> setTimeoutCallBack = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;我是定时器回调&quot;</span>)<br>&#125;<br><span class="hljs-keyword">let</span> httpCallback = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;我是http请求回调&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// 同步任务</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;我是同步任务1&quot;</span>)<br><br><span class="hljs-comment">// 异步定时任务</span><br><span class="hljs-built_in">setTimeout</span>(setTimeoutCallBack, <span class="hljs-number">1000</span>)<br><br><span class="hljs-comment">// 异步http请求任务</span><br>ajax.get(<span class="hljs-string">&quot;/info&quot;</span>, httpCallback)<br><br><span class="hljs-comment">// 同步任务</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;我是同步任务2&quot;</span>)<br></code></pre></td></tr></table></figure><p>上述代码执行过程</p><p>JS 是按照顺序从上往下依次执行的，可以先理解为这段代码时的执行环境就是主线程，也就是也就是当前执行栈</p><p>首先，执行<code>console.log(&#39;我是同步任务1&#39;)</code></p><p>接着，执行到<code>setTimeout</code>时，会移交给<code>定时器线程</code>，通知<code>定时器线程</code> 1s 后将 <code>setTimeoutCallBack</code> 这个回调交给<code>事件触发线程</code>处理，在 1s 后<code>事件触发线程</code>会收到 <code>setTimeoutCallBack</code> 这个回调并把它加入到<code>事件触发线程</code>所管理的事件队列中等待执行</p><p>接着，执行 http 请求，会移交给<code>异步http请求线程</code>发送网络请求，请求成功后将 <code>httpCallback</code> 这个回调交由事件触发线程处理，<code>事件触发线程</code>收到 <code>httpCallback</code> 这个回调后把它加入到<code>事件触发线程</code>所管理的事件队列中等待执行</p><p>再接着执行<code>console.log(&#39;我是同步任务2&#39;)</code>1</p><p>至此主线程执行栈中执行完毕，<code>JS引擎线程</code>已经空闲，开始向<code>事件触发线程</code>发起询问，询问<code>事件触发线程</code>的事件队列中是否有需要执行的回调函数，如果有将事件队列中的回调事件加入执行栈中，开始执行回调，如果事件队列中没有回调，<code>JS引擎线程</code>会一直发起询问，直到有为止</p><p>到了这里我们发现，浏览器上的所有线程的工作都很单一且独立，非常符合单一原则</p><p>定时触发线程只管理定时器且只关注定时不关心结果，定时结束就把回调扔给事件触发线程</p><p>异步 http 请求线程只管理 http 请求同样不关心结果，请求结束把回调扔给事件触发线程</p><p>事件触发线程只关心异步回调入事件队列</p><p>而我们 JS 引擎线程只会执行执行栈中的事件，执行栈中的代码执行完毕，就会读取事件队列中的事件并添加到执行栈中继续执行，这样反反复复就是我们所谓的<strong>事件循环(Event Loop)</strong></p><p><strong>图解</strong></p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/Xnip2020-01-14_09-51-281.jpg" alt="Xnip2020-01-14_09-51-28"></p><p>首先，执行栈开始顺序执行</p><p>判断是否为同步，异步则进入异步线程，最终事件回调给事件触发线程的任务队列等待执行，同步继续执行</p><p>执行栈空，询问任务队列中是否有事件回调</p><p>任务队列中有事件回调则把回调加入执行栈末尾继续从第一步开始执行</p><p>任务队列中没有事件回调则不停发起询问</p><h2 id="宏任务-macrotask-amp-微任务-microtask"><a href="#宏任务-macrotask-amp-微任务-microtask" class="headerlink" title="宏任务(macrotask) &amp; 微任务(microtask)"></a>宏任务(macrotask) &amp; 微任务(microtask)</h2><h3 id="宏任务-macrotask"><a href="#宏任务-macrotask" class="headerlink" title="宏任务(macrotask)"></a>宏任务(macrotask)</h3><p>在 ECMAScript 中，<code>macrotask</code>也被称为<code>task</code></p><p>我们可以将每次执行栈执行的代码当做是一个宏任务(包括每次从事件队列中获取一个事件回调并放到执行栈中执行)， 每一个宏任务会从头到尾执行完毕，不会执行其他</p><p>由于<code>JS引擎线程</code>和<code>GUI渲染线程</code>是互斥的关系，浏览器为了能够使<code>宏任务</code>和<code>DOM任务</code>有序的进行，会在一个<code>宏任务</code>执行结果后，在下一个<code>宏任务</code>执行前，<code>GUI渲染线程</code>开始工作，对页面进行渲染</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">宏任务 -&gt; GUI渲染 -&gt; 宏任务 -&gt; ...<br></code></pre></td></tr></table></figure><p>常见的宏任务</p><ul><li>主代码块</li><li>setTimeout</li><li>setInterval</li><li>setImmediate ()-Node</li><li>requestAnimationFrame ()-浏览器</li></ul><h3 id="微任务-microtask"><a href="#微任务-microtask" class="headerlink" title="微任务(microtask)"></a>微任务(microtask)</h3><p>ES6 新引入了 Promise 标准，同时浏览器实现上多了一个<code>microtask</code>微任务概念，在 ECMAScript 中，<code>microtask</code>也被称为<code>jobs</code></p><p>我们已经知道<code>宏任务</code>结束后，会执行渲染，然后执行下一个<code>宏任务</code>， 而微任务可以理解成在当前<code>宏任务</code>执行后立即执行的任务</p><p>当一个<code>宏任务</code>执行完，会在渲染前，将执行期间所产生的所有<code>微任务</code>都执行完</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">宏任务 -&gt; 微任务 -&gt; GUI渲染 -&gt; 宏任务 -&gt; ...<br></code></pre></td></tr></table></figure><p>常见微任务</p><ul><li>process.nextTick ()-Node</li><li>Promise.then()</li><li>catch</li><li>finally</li><li>Object.observe</li><li>MutationObserver</li></ul><h3 id="简单区分宏任务与微任务"><a href="#简单区分宏任务与微任务" class="headerlink" title="简单区分宏任务与微任务"></a>简单区分宏任务与微任务</h3><p>看了上述宏任务微任务的解释你可能还不太清楚，没关系，往下看，先记住那些常见的宏微任务即可</p><p>我们通过几个例子来看，这几个例子思路来自掘金<code>云中君</code>的文章参考链接【14】，通过渲染背景颜色来区分宏任务和微任务，很直观，我觉得很有意思，所以这里也用这种例子</p><p>找一个空白的页面，在 console 中输入以下代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">document</span>.body.style = <span class="hljs-string">&quot;background:black&quot;</span><br><span class="hljs-built_in">document</span>.body.style = <span class="hljs-string">&quot;background:red&quot;</span><br><span class="hljs-built_in">document</span>.body.style = <span class="hljs-string">&quot;background:blue&quot;</span><br><span class="hljs-built_in">document</span>.body.style = <span class="hljs-string">&quot;background:pink&quot;</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/Jan-12-2020__01-05-49.gif" alt="Jan-12-2020 01-05-49"></p><p>我们看到上面动图背景直接渲染了粉红色，根据上文里讲浏览器会先执行完一个宏任务，再执行当前执行栈的所有微任务，然后移交 GUI 渲染，上面四行代码均属于同一次宏任务，全部执行完才会执行渲染，渲染时<code>GUI线程</code>会将所有 UI 改动优化合并，所以视觉上，只会看到页面变成粉红色</p><p>再接着看</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">document</span>.body.style = <span class="hljs-string">&quot;background:blue&quot;</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-built_in">document</span>.body.style = <span class="hljs-string">&quot;background:black&quot;</span><br>&#125;, <span class="hljs-number">200</span>)<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/Jan-12-2020__01-28-41.gif" alt="Jan-12-2020 01-28-41"></p><p>上述代码中，页面会先卡一下蓝色，再变成黑色背景，页面上写的是 200 毫秒，大家可以把它当成 0 毫秒，因为 0 毫秒的话由于浏览器渲染太快，录屏不好捕捉，我又没啥录屏慢放的工具，大家可以自行测试的，结果也是一样，最安全的方法是写一个<code>index.html</code>文件，在这个文件中插入上面的 js 脚本，然后浏览器打开，谷歌下使用控制台中<code>performance</code>功能查看一帧一帧的加载最为恰当，不过这样录屏不好录所以。。。</p><p>回归正题，之所以会卡一下蓝色，是因为以上代码属于两次<code>宏任务</code>，第一次<code>宏任务</code>执行的代码是将背景变成蓝色，然后触发渲染，将页面变成蓝色，再触发第二次宏任务将背景变成黑色</p><p>再来看</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">document</span>.body.style = <span class="hljs-string">&quot;background:blue&quot;</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>)<br><span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>)<br>  <span class="hljs-built_in">document</span>.body.style = <span class="hljs-string">&quot;background:pink&quot;</span><br>&#125;)<br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/Jan-12-202__01-31-42.gif" alt="Jan-12-2020 01-31-42"></p><p>控制台输出 1 3 2 , 是因为 promise 对象的 then 方法的回调函数是异步执行，所以 2 最后输出</p><p>页面的背景色直接变成粉色，没有经过蓝色的阶段，是因为，我们在宏任务中将背景设置为蓝色，但在进行渲染前执行了微任务， 在微任务中将背景变成了粉色，然后才执行的渲染</p><h3 id="微任务宏任务注意点"><a href="#微任务宏任务注意点" class="headerlink" title="微任务宏任务注意点"></a>微任务宏任务注意点</h3><ul><li><p>浏览器会先执行一个宏任务，紧接着执行当前执行栈产生的微任务，再进行渲染，然后再执行下一个宏任务</p><p>微任务和宏任务不在一个任务队列，不在一个任务队列</p><ul><li>例如<code>setTimeout</code>是一个宏任务，它的事件回调在宏任务队列，<code>Promise.then()</code>是一个微任务，它的事件回调在微任务队列，二者并不是一个任务队列</li><li>以 Chrome 为例，有关渲染的都是在渲染进程中执行，渲染进程中的任务（DOM 树构建，js 解析…等等）需要主线程执行的任务都会在主线程中执行，而浏览器维护了一套事件循环机制，主线程上的任务都会放到消息队列中执行，主线程会循环消息队列，并从头部取出任务进行执行，如果执行过程中产生其他任务需要主线程执行的，渲染进程中的其他线程会把该任务塞入到消息队列的尾部，消息队列中的任务都是宏任务</li><li>微任务是如何产生的呢？当执行到 script 脚本的时候，js 引擎会为全局创建一个执行上下文，在该执行上下文中维护了一个微任务队列，当遇到微任务，就会把微任务回调放在微队列中，当所有的 js 代码执行完毕，在退出全局上下文之前引擎会去检查该队列，有回调就执行，没有就退出执行上下文，这也就是为什么微任务要早于宏任务，也是大家常说的，每个宏任务都有一个微任务队列（由于定时器是浏览器的 API，所以定时器是宏任务，在 js 中遇到定时器会也是放入到浏览器的队列中）</li></ul></li></ul><p>此时，你可能还很迷惑，没关系，请接着往下看</p><h3 id="图解宏任务和微任务"><a href="#图解宏任务和微任务" class="headerlink" title="图解宏任务和微任务"></a>图解宏任务和微任务</h3><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/Xnip2020-01-14_00-58-171.jpg" alt="Xnip2020-01-14_00-58-17"></p><p>首先执行一个宏任务，执行结束后判断是否存在微任务</p><p>有微任务先执行所有的微任务，再渲染，没有微任务则直接渲染</p><p>然后再接着执行下一个宏任务</p><h2 id="图解完整的-Event-Loop"><a href="#图解完整的-Event-Loop" class="headerlink" title="图解完整的 Event Loop"></a>图解完整的 Event Loop</h2><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/Xnip2020-01-14_17-20-441.jpg" alt="Xnip2020-01-14_17-20-44"></p><p>首先，整体的 script(作为第一个宏任务)开始执行的时候，会把所有代码分为<code>同步任务</code>、<code>异步任务</code>两部分</p><p>同步任务会直接进入主线程依次执行</p><p>异步任务会再分为宏任务和微任务</p><p>宏任务进入到 Event Table 中，并在里面注册回调函数，每当指定的事件完成时，Event Table 会将这个函数移到 Event Queue 中</p><p>微任务也会进入到另一个 Event Table 中，并在里面注册回调函数，每当指定的事件完成时，Event Table 会将这个函数移到 Event Queue 中</p><p>当主线程内的任务执行完毕，主线程为空时，会检查微任务的 Event Queue，如果有任务，就全部执行，如果没有就执行下一个宏任务</p><p>上述过程会不断重复，这就是 Event Loop，比较完整的事件循环</p><h2 id="关于-Promise"><a href="#关于-Promise" class="headerlink" title="关于 Promise"></a>关于 Promise</h2><p><code>new Promise(() =&gt; &#123;&#125;).then()</code> ，我们来看这样一个 Promise 代码</p><p>前面的 <code>new Promise()</code> 这一部分是一个构造函数，这是一个同步任务</p><p>后面的 <code>.then()</code> 才是一个异步微任务，这一点是非常重要的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>)<br>  resolve()<br>&#125;).then(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>)<br>&#125;)<br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p>上面代码输出<code>1 3 2</code></p><h2 id="关于-async-await-函数"><a href="#关于-async-await-函数" class="headerlink" title="关于 async/await 函数"></a>关于 async/await 函数</h2><p>async/await 本质上还是基于 Promise 的一些封装，而 Promise 是属于微任务的一种</p><p>所以在使用 await 关键字与 Promise.then 效果类似</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-number">4</span>))<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>)<br>  <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.resolve()<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>)<br>&#125;<br><br>test()<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>上述代码输出<code>1 2 3 4</code></p><p>可以理解为，<code>await</code> 以前的代码，相当于与 <code>new Promise</code> 的同步代码，<code>await</code> 以后的代码相当于 <code>Promise.then</code>的异步</p><h2 id="举栗印证"><a href="#举栗印证" class="headerlink" title="举栗印证"></a>举栗印证</h2><p>首先给大家来一个比较直观的动图</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/Jan-14-2020__00-03-22.gif" alt="Jan-14-2020 00-03-22"></p><p>之所以放这个动图，就是为了向大家推荐这篇好文，动图录屏自参考链接【1】</p><p>极力推荐大家看看这篇帖子，非常 nice，分步动画生动且直观，有时间的话可以自己去体验下</p><p>不过在看这个帖子之前你要先了解下运行机制会更好读懂些</p><p>接下来这个来自网上随意找的一个比较简单的面试题，求输出结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>)<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">// timer1</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>)<br>  &#125;, <span class="hljs-number">1000</span>)<br>&#125;<br><br>test()<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// timer2</span><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>)<br>&#125;)<br><br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">4</span>)<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">// timer3</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">5</span>)<br>  &#125;, <span class="hljs-number">100</span>)<br>  resolve()<br>&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">// timer4</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">6</span>)<br>  &#125;, <span class="hljs-number">0</span>)<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">7</span>)<br>&#125;)<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">8</span>)<br></code></pre></td></tr></table></figure><p>结合我们上述的 JS 运行机制再来看这道题就简单明了的多了</p><p>JS 是顺序从上而下执行</p><p>执行到 test()，test 方法为同步，直接执行，<code>console.log(1)</code>打印 1</p><p>test 方法中 setTimeout 为异步宏任务，回调我们把它记做 timer1 放入宏任务队列</p><p>接着执行，test 方法下面有一个 setTimeout 为异步宏任务，回调我们把它记做 timer2 放入宏任务队列</p><p>接着执行 promise，new Promise 是同步任务，直接执行，打印 4</p><p>new Promise 里面的 setTimeout 是异步宏任务，回调我们记做 timer3 放到宏任务队列</p><p>Promise.then 是微任务，放到微任务队列</p><p>console.log(8)是同步任务，直接执行，打印 8</p><p>主线程任务执行完毕，检查微任务队列中有 Promise.then</p><p>开始执行微任务，发现有 setTimeout 是异步宏任务，记做 timer4 放到宏任务队列</p><p>微任务队列中的 console.log(7)是同步任务，直接执行，打印 7</p><p>微任务执行完毕，第一次循环结束</p><p>检查宏任务队列，里面有 timer1、timer2、timer3、timer4，四个定时器宏任务，按照定时器延迟时间得到可以执行的顺序，即 Event Queue：timer2、timer4、timer3、timer1，依次拿出放入执行栈末尾执行**(插播一条：浏览器 event loop 的 Macrotask queue，就是宏任务队列在每次循环中只会读取一个任务)**</p><p>执行 timer2，console.log(3)为同步任务，直接执行，打印 3</p><p>检查没有微任务，第二次 Event Loop 结束</p><p>执行 timer4，console.log(6)为同步任务，直接执行，打印 6</p><p>检查没有微任务，第三次 Event Loop 结束</p><p>执行 timer3，console.log(5)同步任务，直接执行，打印 5</p><p>检查没有微任务，第四次 Event Loop 结束</p><p>执行 timer1，console.log(2)同步任务，直接执行，打印 2</p><p>检查没有微任务，也没有宏任务，第五次 Event Loop 结束</p><p>结果：1，4，8，7，3，6，5，2</p><h2 id="提一下-NodeJS-中的运行机制"><a href="#提一下-NodeJS-中的运行机制" class="headerlink" title="提一下 NodeJS 中的运行机制"></a>提一下 NodeJS 中的运行机制</h2><p>上面的一切都是针对于浏览器的 EventLoop</p><p>虽然 NodeJS 中的 JavaScript 运行环境也是 V8，也是单线程，但是，还是有一些与浏览器中的表现是不一样的</p><p>其实 nodejs 与浏览器的区别，就是 nodejs 的宏任务分好几种类型，而这好几种又有不同的任务队列，而不同的任务队列又有顺序区别，而微任务是穿插在每一种宏任务之间的</p><p>在 node 环境下，process.nextTick 的优先级高于 Promise，可以简单理解为在宏任务结束后会先执行微任务队列中的 nextTickQueue 部分，然后才会执行微任务中的 Promise 部分</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/Xnip2020-01-18_14-50-011.jpg" alt="Xnip2020-01-18_14-50-01"></p><p>上图来自 NodeJS 官网</p><p>如上图所示，nodejs 的宏任务分好几种类型，我们只简单介绍大体内容了解，不详细解释，不然又是啰哩啰嗦一大篇</p><p>NodeJS 的 Event Loop 相对比较麻烦</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js">Node会先执行所有类型为 timers 的 MacroTask，然后执行所有的 MicroTask(NextTick例外)<br><br>进入 poll 阶段，执行几乎所有 MacroTask，然后执行所有的 MicroTask<br><br>再执行所有类型为 check 的 MacroTask，然后执行所有的 MicroTask<br><br>再执行所有类型为 close callbacks 的 MacroTask，然后执行所有的 MicroTask<br><br>至此，完成一个 Tick，回到 timers 阶段<br><br>……<br><br>如此反复，无穷无尽……<br></code></pre></td></tr></table></figure><p>反观浏览器中 Event Loop 就比较容易理解</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">先执行一个 MacroTask，然后执行所有的 MicroTask<br><br>再执行一个 MacroTask，然后执行所有的 MicroTask<br><br>……<br><br>如此反复，无穷无尽……<br></code></pre></td></tr></table></figure><p>好了，关于 Node 中各个类型阶段的解析，这里就不过多说明了，自己查阅资料吧，这里就是简单提一下，NodeJS 的 Event Loop 解释起来比浏览器这繁杂，这里就只做个对比</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>上面的流程图都是自己画的，所以有点 low，见谅</p><p>水平有限，欢迎指错</p><p>码字不易，看完对你有帮助请点赞，有疑问请评论提出</p><p>最近拾起了一个被冻结的公众号，又重新搞了下</p><p>欢迎大家关注【不正经的前端】，加我，加群，或者拿一些资料都可以的，时不时发一些优质原创</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/qqz.png"></p><blockquote><p>参考</p><ol><li><p><a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/?utm_source=html5weekly">Tasks, microtasks, queues and schedules - 重点推荐阅读</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/32751855">聊聊 JavaScript 与浏览器的那些事 - 引擎与线程</a></p></li><li><p><a href="https://www.cnblogs.com/lhb25/p/how-browsers-work.html">前端文摘：深入解析浏览器的幕后工作原理</a></p></li><li><p><a href="https://www.imweb.io/topic/58e3bfa845e5c13468f567d5">浏览器进程？线程？傻傻分不清楚！</a></p></li><li><p><a href="https://www.cnblogs.com/iovec/p/7904416.html">从输入 cnblogs.com 到博客园首页完全展示发生了什么</a></p></li><li><p><a href="https://www.cnblogs.com/wyaocn/p/5761163.html">前端必读：浏览器内部工作原理</a></p></li><li><p><a href="http://www.ruanyifeng.com/blog/2013/10/event_loop.html">什么是 Event Loop？</a></p></li><li><p><a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html">JavaScript 运行机制详解：再谈 Event Loop</a></p></li><li><p><a href="https://blog.csdn.net/u012134199/article/details/46290465">单线程与多线程的区别</a></p></li><li><p><a href="https://blog.csdn.net/qiuchangjun/article/details/79761242">浏览器进程/线程模型及 JS 运行机制</a></p></li><li><p><a href="https://www.jianshu.com/p/1e455a9226ce">浏览器的运行机制—2.浏览器都包含哪些进程？</a></p></li><li><p><a href="https://segmentfault.com/a/1190000004292479">JS 一定要放在 Body 的最底部么？聊聊浏览器的渲染机制</a></p></li><li><p><a href="https://juejin.im/post/5a6547d0f265da3e283a1df7#heading-25">从浏览器多进程到 JS 单线程，JS 运行机制最全面的一次梳理</a></p></li><li><p><a href="https://juejin.im/post/5d5b4c2df265da03dd3d73e5#heading-4">「前端进阶」从多线程到 Event Loop 全面梳理</a></p></li><li><p><a href="https://segmentfault.com/a/1190000013119813">Js 基础知识（四） - js 运行原理与机制</a></p></li><li><p><a href="https://juejin.im/post/59e85eebf265da430d571f89">这一次，彻底弄懂 JavaScript 执行机制</a></p></li><li><p><a href="https://juejin.im/post/5b543e26e51d4518f54404e4">前端性能优化：细说浏览器渲染的重排与重绘</a></p></li><li><p><a href="https://juejin.im/post/5d136700f265da1b7c6128db">10 分钟看懂浏览器的渲染过程及优化</a></p></li></ol></blockquote>]]></content>
    
    
    <categories>
      
      <category>硬核JS系列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一个前端的安利</title>
    <link href="/blog/2019/12/23/other/%E4%B8%80%E4%B8%AA%E5%89%8D%E7%AB%AF%E7%9A%84%E5%AE%89%E5%88%A9/"/>
    <url>/blog/2019/12/23/other/%E4%B8%80%E4%B8%AA%E5%89%8D%E7%AB%AF%E7%9A%84%E5%AE%89%E5%88%A9/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>此文安利内容皆是我在使用的，我之所用，皆为精品，哈哈，并不是胡乱分享，觉得十分好用，就分享下，所以虽有花哨，却也实用</p><h2 id="Chrome-插件"><a href="#Chrome-插件" class="headerlink" title="Chrome 插件"></a>Chrome 插件</h2><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>作为一个正八经的前端，与 chrome 打交道必不可少，chrome 扩展程序有很多，实用且好玩，之前有段不务正业的时光，每天闲下来就喜欢找各种扩展，看着好玩就安装使用，不好用就卸载，后来还去看了看 chrome 扩展开发，还写了几个小扩展 demo，学习技术的动力是升职加薪，是不被淘汰，并不是不喜欢，只是技术是饭碗，所以久而久之，学习技术变成了理所当然，但是插件脚本这些花里胡哨的则是兴趣，接下来为大家安利我目前觉得很 nice 的几款 chrome 扩展</p><h3 id="No-1-GoogleHelper"><a href="#No-1-GoogleHelper" class="headerlink" title="No.1 GoogleHelper"></a>No.1 GoogleHelper</h3><p>谷歌上网助手，我就以 Helper 简称了，Helper 是专门为科研、外贸、跨境电商、海淘人员、开发人员服务的上网加速工具，chrome 内核浏览器专用!可以解决 chrome 扩展无法自动更新的问题，同时可&gt;以访问谷歌 google 搜索，gmail 邮箱，google+等谷歌产品</p><p>上面是官方解释，通俗来说，我们是不能访问谷歌的，需要翻墙，我们访问外网大多数其实只是使用谷歌搜索，或者是看国外的一些网站，翻墙好麻烦，作为 21 世纪有志青年，我们响应祖国的号召，科学文明上网，我们不翻墙，通过 helper 这个浏览器插件就可以让我们访问谷歌，查看外网的一些资源，这就足够了</p><h5 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h5><p>安装谷歌插件没有翻墙的情况下我们我们进不去谷歌商店</p><p>所以可以直接搜索这个插件的官网下载 <a href="http://googlehelper.net/">GoogleHelper 传送门</a></p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other//image-20191221105008522.png" alt="image-20191221105008522"></p><p>如上所示，直接下载即可</p><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><p>2018 年 6 月 13 日起,谷歌最新的 Chrome 7 不再支持 CRX 手动安装方法，这样导致国内用户无法顺利安装 Chrome 扩展，大陆用户又无法访问 Chrome 应用商店，Helper 提供了源码安装方式</p><p>这样导致国内用户无法顺利安装 Chrome 扩展</p><p>大陆用户又无法访问 Chrome 应用商店</p><p>它提供了源码安装方式</p><p><strong>1.</strong> 打开你的 Chrome 浏览器的 更多工具&gt;扩展程序页面 ， 或者直接在网址输入: chrome://extensions/</p><p>**2. **在扩展程序右上角打开开发者选项，然后在此页面左上角点击 “添加已解压的扩展程序”</p><p>**3. **选择刚下载包里的 <code>ghelper_source</code> 目录</p><p>**4. **确认后就行了，装上源码包方式后，先登录，没有账号就注册下，免费的</p><p><strong>5.</strong> 最后回到第一步，进扩展程序页面，找到 helper 插件，点击插件详情，找到 <code>允许访问文件网址</code> 选项勾选同意</p><p><strong>6.</strong> 然后就能愉快访问谷歌了</p><h5 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h5><p>我也用过其他的 chrome 上网加速插件，但是一番对比下来，还是 helper 好用</p><h3 id="No-2-OneTab-amp-OneTab-Plus"><a href="#No-2-OneTab-amp-OneTab-Plus" class="headerlink" title="No.2 OneTab &amp; OneTab Plus"></a>No.2 OneTab &amp; OneTab Plus</h3><p>你是否经常因为打开的标签页太多，过于混乱而感到头疼，作为一个前端，每天打开无数的标签，有的是开发预览，有的是技术博客，管理起来是很麻烦的</p><p>OneTab Plus，一秒上手的傻瓜式操作，轻松管理所有标签页</p><p>之前我是使用 OneTab 的，很简洁，就是不太好看，后来看到了 OneTab Plus，OneTab Plus 毕竟是出自 Infinity 的产品，审美一直都是在线</p><p>安装的话，有了上面的 helper 插件，我们就可以直接在谷歌商店中搜索扩展安装了</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other//image-20191221114152092.png" alt="image-20191221114152092"></p><p>点击添加至 chrome 即可一键安装</p><p>支持的功能有很多，整合标签组，分类归档等等，界面干净整洁，这里不介绍使用了，就是傻瓜式操作，安装一试便知</p><p>可能有些人觉得这种管理标签的插件不是必要的，但是我觉得不妨安装试一试，还是很香的</p><h3 id="No-3-FeHelper"><a href="#No-3-FeHelper" class="headerlink" title="No.3 FeHelper"></a>No.3 FeHelper</h3><p>FeHelper 中文名为 WEB 前端助手，All In One 的一个工具，包含多个独立小应用，比如：Json 工具、代码美化、代码压缩、二维码、Postman、markdown、网页油猴、便签笔记、信息加密与解密、随机密码生成、Crontab 等等</p><p>如下图</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other//image-20191221140814282.png" alt="image-20191221140814282"></p><p>FeHelper 的这些功能都很常用，总的来说，说是前端必备神器也不为过，所以强烈推荐，装上它还是很有用的</p><p>安装的话也同上，有了 helper 后直接去谷歌商店搜索 FeHelper 安装即可，使用简单，自己摸索吧</p><p>下图为商店中 FeHelper</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other//image-20191221141220058.png" alt="image-20191221141220058"></p><h3 id="No-4-Vimium"><a href="#No-4-Vimium" class="headerlink" title="No.4 Vimium"></a>No.4 Vimium</h3><h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><p>Vimium 是 Vim 和 Chromium 的结合，Vim 是 linux 中让你脱离鼠标编辑文本的利器，同样 Vimium 是让你脱离鼠标就能上网的终极利器，不用移动鼠标就能跳转页面，切换标签，打开历史记录，打开书签等等，这比传统的鼠键结合的方式要快得多</p><p>总之，Vimium 是极客必备，它可以让我们在浏览器中解放鼠标，效率与装逼集为一体，优雅而酷炫</p><p>作为一个经常和浏览器打交道的前端，这东西用之后有如神助，就很棒，极力推荐前端开发们使用，所以文中会细致介绍下</p><h5 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h5><p>安装也同上，都是浏览器扩展插件嘛，有了 helper 后直接去谷歌商店搜索 Vimium 一键添加即可，就是下图这个</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other//image-20191221144435965.png" alt="image-20191221144435965"></p><h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><p>首先确保安装成功，浏览器地址栏右侧已经有了小图标</p><p>我们在浏览器打开一个新的标签页，搜索 vimium 回车，按下<code>f</code>键，当前页面的所有链接处都会分配快捷键，这也是最常用的 vimium 快捷键，效果如下图</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other//image-20191221155430821.png" alt="image-20191221155430821"></p><p>分配的快捷键最多两个字符，也就是说我们最多只需按三下键盘，无需鼠标，想去哪就去哪</p><p>我们想要搜索内容时，只需按下<code>o</code>键，输入内容即可看到结果，同地址栏搜索一样方便简洁，想要在新标签页打开只需按下大写的<code>O</code>，搜索界面如下</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other//image-20191222234639120.png" alt="image-20191222234639120"></p><p>我是一个喜欢把看到的好帖子收藏下来的人，所有收藏我都存在了谷歌书签，我自认为我的标签分类也算比较细致了，如下图</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other//image-20191221161303845.png" alt="image-20191221161303845"></p><p>但是久而久之，收藏的东西太多了，不好查找，Vimium 可以非常方便的帮我们查找标签页的内容</p><p>只需按下<code>b</code>键，即可模糊搜索收藏的标签页内容，界面效果和<code>o</code>键搜索一致，大写<code>B</code>键也是在新标签页打开，相信对喜欢收藏帖子加标签的人来说很实用，如下图</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other//image-20191222234855365.png" alt="image-20191222234855365"></p><h5 id="快捷键一览"><a href="#快捷键一览" class="headerlink" title="快捷键一览"></a>快捷键一览</h5><p>愉快的使用 Vimium，下面这些快捷键必不可少，使用过 Linux 的 vim 的同学会感到毫无压力，没有使用过的同学记住常用的就 OK 了，当然这些快捷键都可以更改，但是建议不要更改，用熟后 linux 的 vim 也是这些操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js">j：向下细微滚动窗口<br>k：向上细微滚动窗口<br>J：(Shift+j的意思，以下大写全部表示加Shift) 下一个标签页<br>K：上一个标签页<br>d：向下滚动半个屏幕<br>u：向上移动半个屏幕<br>g+g：同连续按两下g，回到顶部<br>G：到达页面底部<br>H：后退<br>L：前进<br>f：将当前网页上的所有可见链接/输入框分配一个快捷键，输入后就可以打开或者跳转到对应的输入框<br>F：同f，只不过是将在新窗口中打开页面<br>g+i：将光标 定位到输入框，如果有多个可以按Tab键切换<br>b：搜索书签，当前页面打开<br>B：搜索书签，新标签页打开<br>x：关闭当前页面<br>X：恢复刚刚关闭的页面<br>o：相当于Chrome中的地址栏，搜索并在当前窗口打开，Chrome在全屏时也可使用<br>O：同o，只不过是可以在新窗口中打开，很nice，Chrome在全屏时也可使用<br>g+s：查看网页的源代码<br>r：重新载入当前网页<br></code></pre></td></tr></table></figure><p><strong>注：</strong>浏览器自有页面该插件不可用，如控制台、默认的新标签页等等</p><h5 id="最后-1"><a href="#最后-1" class="headerlink" title="最后"></a>最后</h5><p>没什么可说的，真是装逼神器，赶紧安装试试，安装后你可以尝试下不使用鼠标，仅使用键盘给这篇帖子评论个消息或者点个赞 😄</p><h3 id="No-5-Saladict"><a href="#No-5-Saladict" class="headerlink" title="No.5 Saladict"></a>No.5 Saladict</h3><p>Saladict 沙拉查词是一款专业划词翻译扩展，为交叉阅读而生。大量权威词典涵盖中英日韩法德西语，支持复杂的划词操作、网页翻译、生词本与 PDF 浏览</p><p>以上是官方解释，我认为，它的划词翻译最好，在浏览器中我们阅读外文，你是不是经常点谷歌翻译，谷歌翻译把整个网页翻译为中文，这样做我认为不太好，经常这样搞，英文水平永远也提不上去，而划词翻译不同，我们可以尝试阅读英文文档，遇到不会的直接选中单词或句子进行翻译，慢慢的英文水准就会有所提高</p><p>对比其他划词翻译插件我选择 Saladict 的原因有两点</p><p>1.界面相对漂亮，使用方便，作为前端，我认为它的交互体验非常 nice</p><p>2.多渠道翻译更为精确</p><p>如下图所示</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other//image-20191221200333962.png" alt="image-20191221200333962"></p><p>我们选中一句话或者一个单词，就会在对应位置自动弹出一个小图标，点击图标即可弹出对应多版本的翻译，使用及其方便，更多功能可安装后自行体验</p><p>沙拉查词的功能也很多，不过我只用这一个简单翻译的功能，想了解更多可以查看 saladict 的官方文档<a href="https://saladict.crimx.com/manual.html">saladict 传送门</a></p><p>安装方式还是从谷歌商店搜索 Saladict 一键安装即可，该插件如下</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20191221220245249.png" alt="image-20191221220245249"></p><h3 id="No-6-Octotree"><a href="#No-6-Octotree" class="headerlink" title="No.6 Octotree"></a>No.6 Octotree</h3><p>Octotree 是一款针对 github 的插件，通常我们在浏览 github 时查看一个文件要进去，想查看其他文件就要返回在点入文件，比较麻烦，安装此插件，在我们浏览 github 时，它会为我们生成一个树形结构的侧边栏，这样我们在查看 github 项目时就不用点入点出，极为方便，如下图</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20191221221253478.png" alt="image-20191221221253478"></p><p>此插件功能强大，但是如要使用更多功能，就需收费了，这点我觉得不太好，不过我们在不注册会员的情况下也可以使用它的树状侧边栏，如果你只需一个方便的侧边栏，那使用它就再好不过了</p><p>安装同上，谷歌商店中搜索扩展名 Octotree，如下图，一键安装使用</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20191221221700133.png" alt="image-20191221221700133"></p><h3 id="No-7-Sourcegraph"><a href="#No-7-Sourcegraph" class="headerlink" title="No.7 Sourcegraph"></a>No.7 Sourcegraph</h3><h5 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h5><p>Sourcegraph 又是一款为 github 而生的强大插件，它是一款可以为 Github 上的代码添加了即时文档和类型提示，并为每一个标识符添加了跳转到定义处的链接的 Chrome 扩展，它允许你像使用一个很好的 IDE 那样浏览源代码</p><p>我们看官方对它的解释</p><p>你可以从代码仓库和安装包甚至是函数里搜索代码，同时也可以直接点击被完全创建了链接的代码来阅读文档、跳转到变量定义或者马上找到可用的 Demo。总而言之，你可以在你的 web 浏览器上完成这一切，而不需要配置任何编辑器。由 Sourcegraph 出品的这款 Chrome 插件，可以非常方便的浏览和搜索 Github 上的代码，持跨 repository 搜索、跳转到定义、查找引用等功能，宛若一个功能强大的 IDE。核心功能如跳转到定义(Go-to-definition)——浏览文件或查看 pull 请求时，将鼠标悬停在代码上可以查看文档提示，单击即可跳转到定义、查找引用或全文搜索</p><p>可能有人还是不了解它的强大，这样说吧，我们把 github 的项目克隆下来，在 VSCode 打开查看，和直接在 github 上打开感觉如何，这根本就不用比较，github 上浏览项目代码很不方便，你只能像看文档一样查看，就像一个函数，我们要找这个函数定义所在，编译器里 command+鼠标左击直接就进入函数内部了，github 上是肯定不行的，而 Sourcegraph 可以帮你办到，说它是一款极简的线上 IDE 也不为过</p><h5 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h5><p>安装如上一样，谷歌商店搜索扩展 Sourcegraph 安装即可，如下即是</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20191221223305327.png" alt="image-20191221223305327"></p><h5 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h5><p>安装好该插件后，我们再打开 github 项目，就会看到项目中出现了一个图标如下</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20191221223418443.png" alt="image-20191221223418443"></p><p>点击该图标即可体验在线 IDE 的强大，它可以为我们浏览 github 优秀项目提供很大的助力</p><p>点击图标后进入界面如下</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20191221223552397.png" alt="image-20191221223552397"></p><p>可能到了这里，有人会问，既然有 Sourcegraph，那还要 Octotree 何用，Octotree 的侧边栏，Sourcegraph 也有</p><h5 id="Octotree-VS-Sourcegraph"><a href="#Octotree-VS-Sourcegraph" class="headerlink" title="Octotree VS Sourcegraph"></a>Octotree VS Sourcegraph</h5><p>Octotree 不需要跳转页面，就在 github 当前页面生成侧边栏，点击也是跳到对应的 github 地址下，使用极为方便，而 Sourcegraph 不同，它功能太过强大，所以打开会跳转到 Sourcegraph.com 上，打开速度和体验会稍稍有些不好，但是胜在功能强大</p><p>其实我之所以装两个，原因很简单，因为两者都可以用的上，一般我只是简单查看 github 项目时会使用 Octotree，比较快捷，但是我想要深究其中一些内容，又不想克隆到本地时，会使用 Sourcegraph，因为它更强大，函数查找，跳转定义简直不要太爽</p><p>有人可能说装这么多插件就算了，功能重叠的也装，这不是要累死谷歌，不急，看完你就知道了，咱有对策</p><h3 id="No-8-GitZip"><a href="#No-8-GitZip" class="headerlink" title="No.8 GitZip"></a>No.8 GitZip</h3><p>GitZip，全名为 GitZip for github，又是一款 github 神器，只要我们经常混迹 github，那么它就更不可或缺了</p><p>我们都知道，要克隆一个仓库中的文件，我们要把整个仓库克隆下来，这点很不爽，毕竟一个仓库这么大，可能我只需要其中一两个文件，全部克隆过于麻烦</p><p>GitZip，有了它，你就不必烦恼这个问题</p><h5 id="安装-3"><a href="#安装-3" class="headerlink" title="安装"></a>安装</h5><p>谷歌应用商店中搜索 GitZip，点击添加扩展即可，如下</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20191221225332815.png" alt="image-20191221225332815"></p><h5 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h5><p>找到一个 github 项目，这里以 vue 为例，我只想下载 vue 项目中的 src 文件夹，双击选中即可，如下图</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20191221225536343.png" alt="image-20191221225536343"></p><p>我们只需要双击选中想要下载的文件夹或文件，左侧会出现对号代表选中，网页右下角会出现下载的箭头图标，我们点击箭头，即可打包下载选中文件</p><p>第一次使用此插件时，内心真的是翻江倒海，虽然功能并不强大，这个小功能正是我所需要的</p><h3 id="No-9-GitHub-Hovercard"><a href="#No-9-GitHub-Hovercard" class="headerlink" title="No.9 GitHub Hovercard"></a>No.9 GitHub Hovercard</h3><h5 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h5><p>GitHub Hovercard，一听名字就又是一款 github 相关的插件，它的作用是-&gt;鼠标悬停快速预览</p><p>浏览 Github 时我们浏览一个项目、一个用户的信息、或者一个 issue，只能点击进去查看详情，如果经常浏览 github 的话，就有些麻烦了</p><p>GitHub Hovercard 这个插件可以让我们快速浏览项目信息/用户信息/项目讨论，只需要把鼠标悬停在想要查看的用户|项目|issue 上就可以查看了，十分方便</p><h5 id="使用-3"><a href="#使用-3" class="headerlink" title="使用"></a>使用</h5><p>下面是使用的一些截图</p><p>悬停在项目上时如下</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20191222011553442.png" alt="image-20191222011553442"></p><p>悬停在用户上时如下</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20191222011743118.png" alt="image-20191222011743118"></p><p>悬停在 issue 上时</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20191222011925152.png" alt="image-20191222011925152"></p><p>悬浮在提交记录上时</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20191222012141465.png" alt="image-20191222012141465"></p><p>总之，该插件对我们快速浏览项目帮助很大，我们每次要看一个详细信息就不用点击进去了，非常方便</p><h5 id="安装-4"><a href="#安装-4" class="headerlink" title="安装"></a>安装</h5><p>谷歌商店搜索扩展名 GitHub Hovercard 添加至扩展即可，该插件如下</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20191222012618349.png" alt="image-20191222012618349"></p><h3 id="No-10-React-Developer-Tools"><a href="#No-10-React-Developer-Tools" class="headerlink" title="No.10 React Developer Tools"></a>No.10 React Developer Tools</h3><p>React Developer Tools 这个就不介绍了，React 调试插件，前端都知道</p><h3 id="No-11-Vue-js-devtools"><a href="#No-11-Vue-js-devtools" class="headerlink" title="No.11 Vue.js devtools"></a>No.11 Vue.js devtools</h3><p>Vue.js devtools 同 React Developer Tools 一样，vue 调试插件，都是开发必备的，作为前端应该都知道，不介绍了</p><h3 id="No-12-Postman"><a href="#No-12-Postman" class="headerlink" title="No.12 Postman"></a>No.12 Postman</h3><p>没错，就是 postman，之所以安装 postman 浏览器扩展，就是不想装 Postman 桌面程序</p><p>不要装错呦，看下图</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20191222181152773.png" alt="image-20191222181152773"></p><p>要安装地球 logo 的这款</p><p>网页中使用该扩展的界面如下</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20191222181256454.png" alt="image-20191222181256454"></p><p>使用就不介绍了，大家都会用</p><h3 id="No-13-掘金"><a href="#No-13-掘金" class="headerlink" title="No.13 掘金"></a>No.13 掘金</h3><p>掘金 chrome 扩展插件，大家在掘金首页上应该见过它，在那下载安装就成</p><p>为什么推荐它呢，可能有些人看到过它，只不过没注意，我之前偶尔空闲，看了一下官方的介绍，觉得好用，就装了，装之后体验非常棒，就一直留着了，功能很实用，界面很简洁</p><p>它会在你打开一个新的标签页时打开掘金插件定制好的内容聚合页面，你依然可以在地址栏搜索内容，不过映入眼帘的不再是空白的百度或谷歌，而是下图</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20191221230457980.png" alt="image-20191221230457980"></p><p>如上图所示，打开一个新标签页，左侧会为你显示掘金的近期优质帖子，右边我们可以设置成 github 热门排行，当然这是我的选择，它不只是针对前端，后端和产品等不同人员皆可，自己选择感兴趣的东西即可</p><p>试想，每打开一个新的标签页，当日的 github 热门排行和掘金优质量帖子都会映入眼帘，我们可以在不知不觉中看到热门项目，帖子，如果感兴趣就点进去瞅瞅，这种内容聚合的创意我觉得很赞，大大节省了我刻意刷这些东西的时间</p><h3 id="No-14-Tampermonkey"><a href="#No-14-Tampermonkey" class="headerlink" title="No.14 Tampermonkey"></a>No.14 Tampermonkey</h3><h4 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h4><p>Tampermonkey，大名顶顶的油猴，一个强大的脚本管理扩展，说是谷歌扩展中最强大插件也不为过，这个插件不装上都对不住那些熬夜写脚本的开发者们，你可能听说过油猴，但是因为看到脚本感到距离遥远望而却步，其实它的操作非常简单，只要经过简单设置，下载一些现成脚本，就可以实现超级实用的功能，你可能知道它，你也可能不知道它，不管怎样，今天看到之后，装上它就对了</p><h4 id="安装-5"><a href="#安装-5" class="headerlink" title="安装"></a>安装</h4><p>谷歌应用商店搜索 Tampermonkey 扩展安装，该插件如下</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20191222013358211.png" alt="image-20191222013358211"></p><h4 id="使用-4"><a href="#使用-4" class="headerlink" title="使用"></a>使用</h4><p>只是安装油猴并无太大作用，重点是通过它管理脚本，此插件太好用了，所以一定要给大家安利上，尽量描述的详细些</p><p>安装油猴后，在浏览器地址栏右侧就会出现油猴的小图标，左击它，会有如下列表</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20191222013747416.png" alt="image-20191222013747416"></p><h5 id="获取脚本渠道"><a href="#获取脚本渠道" class="headerlink" title="获取脚本渠道"></a>获取脚本渠道</h5><p>首先我们要找几个脚本装一下，点击获取新脚本，会有如下页面</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20191222014025775.png" alt="image-20191222014025775"></p><p>这里我们获取脚本的渠道有四，我们来看对比</p><ul><li>GreasyFork<ul><li>GreasyFork 是最受欢迎的后起之秀，它由 Jason Barnabe 创建</li><li>Jason Barnabe 同时也是 <a href="https://userstyles.org/">Stylish</a> 网站的创办者，在其储存库中有大量的脚本资源</li><li>这个库也是我们首推的脚本库，里面插件超级多，关键是可选择中文</li><li>下文安装脚本会以此脚本库做示例</li></ul></li><li>OpenUserJS<ul><li>GreasyFork 之后开始创办</li><li>它由 Sizzle McTwizzle 创建,同样地,在其储存库中也拥有大量的脚本资源</li><li>他是英文的</li></ul></li><li>Userscripts.org<ul><li>老牌脚本库，不过现在不更新了，不推荐使用</li></ul></li><li>GitHub/Gist<ul><li>当然也可以在 github 或 gist 中搜索脚本资源使用，我是没从这找过，我一般都用 GreasyFork</li></ul></li></ul><h5 id="GreasyFork-中下载脚本"><a href="#GreasyFork-中下载脚本" class="headerlink" title="GreasyFork 中下载脚本"></a>GreasyFork 中下载脚本</h5><p>我一般都在 GreasyFork 中找脚本下着玩，里面的脚本足够用了</p><p>点击获取新脚本后，我们找到 GreasyFork 点击进入如下</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20191222014935554.png" alt="image-20191222014935554"></p><p>我们点击右上角脚本列表，会看到无数的脚本资源，如下图</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20191222015035399.png" alt="image-20191222015035399"></p><p>你也可以直接在搜索中输入关键字搜索脚本，我先随意下载一个做示例，就列表第一个吧，点击进入脚本详情</p><p>脚本的详情页会有对应的脚本使用介绍，看下就会用了</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20191222015203894.png" alt="image-20191222015203894"></p><p>点击安装此脚本</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20191222015240191.png" alt="image-20191222015240191"></p><p>再次点击安装即可，安装之后我们再次点击浏览器地址栏右侧油猴图标</p><p>选择管理面板点击进入，此时我们的油猴中就安装上一个脚本了，如下</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20191222015550494.png" alt="image-20191222015550494"></p><p>如上图所示，我装的脚本不多，但是都挺好用的，推荐给大家</p><ul><li><p>id 为 5 的是下载图库素材的脚本</p><ul><li>使用它之后下载图片资源，嘿嘿，那还开什么千图网 vip</li></ul></li><li><p>id 为 1 的百度谷歌去广告的脚本</p><ul><li>使用它之后，那百度和谷歌被净化的只剩文字，非常舒服</li><li>还可以自己定制样式</li></ul></li><li><p>id 为 2 的是 CSDN 博客免登陆，去广告，净化剪贴板的脚本</p><ul><li>CSDN 广告太多了，而且看博客时想复制代码粘贴老是携带 CSDN 注入的信息</li><li>用了此脚本之后，嘿嘿</li></ul></li><li><p>id 为 3 的是百度文档免费下载，粘贴的脚本</p><ul><li>有时候我们会找一些文档素材，百度文档不能复制，下载要会员</li><li>有了此插件后，想复制下载，easy</li></ul></li><li><p>id 为 4 的是视频 vip 解析脚本</p><ul><li>还开什么视频 vip，想看啥，直接脚本搜即可</li></ul></li></ul><h4 id="最后-2"><a href="#最后-2" class="headerlink" title="最后"></a>最后</h4><p>上面说这些玩法是非常普通的，Tampermonkey 脚本管理工具玩法很多，脚本一途博大精深，有兴趣的话大家可以自己写脚本玩</p><p>下载的脚本安装后如何使用，一般在安装脚本的详情页会有对应的脚本使用介绍</p><p>脚本并不是都可用的，有些脚本收费，有的脚本则不可用</p><p>我下载的脚本并不多，更多好玩的脚本等着你去发掘</p><p>大家如果安装油猴了，到时候找到什么好玩免费的脚本，别忘了安利给我，先谢过</p><h3 id="No-15-SimpleExtManager"><a href="#No-15-SimpleExtManager" class="headerlink" title="No.15 SimpleExtManager"></a>No.15 SimpleExtManager</h3><p>SimpleExtManager，将此扩展放到最后，意味着它是压轴的，上面说了这么多插件，有 15 款，都是我正在使用的，可能大家会说装这么多扩展，本来谷歌就吃内存，全都安装下来还能扛的住吗？</p><p>有些扩展我们只在特殊的场景下才会使用，但是我们启用禁用一个扩展需要到扩展中心，很麻烦</p><p>SimpleExtManager 就是解决之道</p><p>它是一款快捷管理扩展的扩展插件，你可以使用该插件便捷管理扩展，快速打开扩展或关闭扩展</p><h5 id="安装-6"><a href="#安装-6" class="headerlink" title="安装"></a>安装</h5><p>还是老样子，谷歌应用商店直接搜索扩展 SimpleExtManager 一键添加即可，该扩展在商店中如下</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20191222114846108.png" alt="image-20191222114846108"></p><h5 id="使用-5"><a href="#使用-5" class="headerlink" title="使用"></a>使用</h5><p>使用也非常简单</p><p>我们只需要点击地址栏对应的 SimpleExtManager 图标即可看到我们所有的扩展</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20191222114950097.png" alt="image-20191222114950097"></p><p>如上图所示，禁用扩展直接取消选中即可，启用就勾选，还可快捷删除扩展</p><p>界面着实有点 low，不过胜在简单实用</p><h3 id="No-16-The-Great-Suspender"><a href="#No-16-The-Great-Suspender" class="headerlink" title="No.16 The Great Suspender"></a>No.16 The Great Suspender</h3><p>在使用浏览器的过程中，我们很可能会打开很多页面，而且会越来越多，是很消耗内存的，谷歌吃内存就是这</p><p>上面 SimpleExtManager 插件可以帮助我们管理扩展插件以优化 chrome 资源占用</p><p>The Great Suspender 这个插件，它则可以自动冻结一定时间内没有使用到的页面，从而较少内存消耗</p><p>居家必备的神器，用了它之后，你的 chrome 内存占用会减少很多的</p><p>这款插件长下面这个样子</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20191222175527666.png" alt="image-20191222175527666"></p><p>使用很简单，你只需勾选冻结设置就可以了，冻结的网站如下图</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20191222215920409.png" alt="image-20191222215920409"></p><p>解冻也非常方便，点击网站任意一处即可解冻</p><p>安装直接在谷歌应用商店搜索该扩展名字 The Great Suspender 即可</p><p>###小结</p><p>访问谷歌用 helper</p><p>高效管理标签使用 OneTab Plus</p><p>前端常用小工具 FeHelper 都有，Postman 网页端接口测试</p><p>不用鼠标，高效使用谷歌用 Vimium</p><p>划词翻译用 saladict</p><p>玩转 Github，Octotree / Sourcegraph / GitZip / Github Hovercard 四神器</p><p>Vue 开发用 Vue Devtools，react 开发用 React Developer Tools</p><p>掘金插件省去刻意查找的时间</p><p>Tampermonkey 油猴插件更是随心所欲，脚本爽到飞起</p><p>SimpleExtManager+The Great Suspender 让你的 chrome 运行如丝般顺滑</p><p>以上就是我安装并使用的 16 款非常 nice 的 chrome 扩展，大家如有更好的，请安利给我</p><h2 id="代码片段截图"><a href="#代码片段截图" class="headerlink" title="代码片段截图"></a>代码片段截图</h2><h3 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h3><p>早在之前，我看到别人分享的代码片段截图非常漂亮，如下图这种</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/code.png" alt="code"></p><p>这种代码片段我之前一直以为是 Mac 专享，后来入手了 Mac 之后发现也没这功能啊，再到后来才知道，这并不是 Mac 专享，有两种办法皆可生成这种风格代码片段截图</p><h3 id="No-1-Carbon"><a href="#No-1-Carbon" class="headerlink" title="No.1 Carbon"></a>No.1 Carbon</h3><p><a href="https://carbon.now.sh/">Carbon</a>是一个可以把你的代码转成一张精美海报的工具，让你的代码分享颜值爆表</p><p>Carbon 可以轻松将源代码创建成简洁美观的图像分享出去，支持自定义图片的语法主题，窗口样式</p><p>以下是官网图，使用简单</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20191222171426229.png" alt="image-20191222171426229"></p><p>可借助这个网站生成漂亮的代码片段图片</p><h3 id="No-2-VS-Code-plugin-CodeSnap"><a href="#No-2-VS-Code-plugin-CodeSnap" class="headerlink" title="No.2 VS Code plugin CodeSnap"></a>No.2 VS Code plugin CodeSnap</h3><p>上述 Carbon 可以帮助我们生成漂亮的代码片段图片，但是使用它要打开网站 copy 代码，比较麻烦，我们会想，在编辑器中写的代码，能不能截图直接在编译器中完成，随之截图带上的也是我们编译器的主题样式，答案当然是可以的</p><p>VS Code 有一款插件，叫 CodeSnap，直接搜索该扩展安装即可，使用也简单</p><p>windows：<code>ctrl+shift+p</code></p><p>mac：<code>command+shift+p</code></p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20191222172647359.png" alt="image-20191222172647359"></p><p>直接输入 codesnap 回车即可</p><p>然后选中你想截图的代码片段</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20191222172818160.png" alt="image-20191222172818160"></p><p>插件生成的图片面板下有一个圆圈，点击即可保存图片，这种片段截图在编译器中，方便快捷，还可以保留编译器的样式，当然既然是 vscode 扩展，mac 和 windows 都可用</p><h2 id="在线工具"><a href="#在线工具" class="headerlink" title="在线工具"></a>在线工具</h2><h3 id="No-1-Processon"><a href="#No-1-Processon" class="headerlink" title="No.1 Processon"></a>No.1 Processon</h3><p>市面上的思维导图工具繁多，像百度脑图，xmind，mindmaster 等等，但是他们都得下载客户端，而且有的还收费</p><p>Processon 是一款免费在线的专业流程图和思维导图制作工具，官网如下</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20191222214812008.png" alt="image-20191222214812008"></p><p>Processon 这个东西知道的人应该挺多的，因为它优点太多了</p><ul><li>在线工具，自然就有了跨平台的特性</li><li>在线存储</li><li>操作简单，0 学习成本，可制作图形巨多</li><li>可多人协作</li></ul><p>来看一款做好的思维脑图模板</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20191222200937011.png" alt="image-20191222200937011"></p><p>在线存储，我们还可以将做好的脑图分享给其他人，颜值巨高，试试就知道了 <a href="https://www.processon.com/">Processon 传送门</a></p><h3 id="No-2-Codeshare"><a href="#No-2-Codeshare" class="headerlink" title="No.2 Codeshare"></a>No.2 Codeshare</h3><p><a href="https://codeshare.io/">Codeshare</a> 是一款在线代码编辑器，用于采访，故障排除，教学等</p><p>它最主要的功能是可以与开发人员实时共享代码，还可以共享视频，十分方便</p><p>官网界面如下</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20191222214518356.png" alt="image-20191222214518356"></p><h3 id="No-3-Gaoding-com"><a href="#No-3-Gaoding-com" class="headerlink" title="No.3 Gaoding.com"></a>No.3 Gaoding.com</h3><p>搞定设计旗下出品 搞定抠图，在线抠图，这个网站抠图巨快，算法贼 6，使用很方便</p><p>抠图的话就不用使用 PS 了，PS 太复杂，抠图太慢</p><p><a href="https://www.gaoding.com/koutu/">Gaoding.com 传送门</a></p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20191222221502009.png" alt="image-20191222221502009"></p><h3 id="No-4-remove-bg"><a href="#No-4-remove-bg" class="headerlink" title="No.4 remove.bg"></a>No.4 remove.bg</h3><p>Gaoding 是在线抠图工具，而 remove.bg 不同，remove.bg 从名字就可以看出作用，删除背景，上传一张图片，一键去除背景，一些简单的背景去除我们可以直接使用此站，复杂一些的就使用 Gaoding 手动抠，还是那两个字，方便</p><p><a href="https://www.remove.bg/">remove.bg 传送门</a></p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/20200407144913.png" alt="image-20191222221148849"></p><h3 id="No-5-无版权图片"><a href="#No-5-无版权图片" class="headerlink" title="No.5 无版权图片"></a>No.5 无版权图片</h3><p>无版权的图片资源，里面不乏一些精美图片，我一般没事会逛逛，找一些高清壁纸，好看的图片来收藏</p><p><a href="https://www.sitebuilderreport.com/">sitebuilderrepor</a></p><p><a href="https://www.pexels.com/">pexels</a></p><h3 id="No-6-Shodan"><a href="#No-6-Shodan" class="headerlink" title="No.6 Shodan"></a>No.6 Shodan</h3><p>最后给大家说一个搜索引擎 Shodan，被喻为“最可怕”的搜索引擎</p><p>Shodan 上搜索出来的不只是单纯的信息，而是所有接入互联网的设备，如你的手机、电脑、摄像头等等</p><p>大家如果有兴趣，可以自行了解下玩法，它可以让你更加深刻的认识网络</p><p><a href="https://www.shodan.io/">Shodan 传送门</a></p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/20200407144753.png" alt="image-20191222222953478"></p><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>以上就是我这次的分享了，都是我经常使用的小东西，还有一些不经常使用的，比较偏门，就没放上去</p><p>我觉得每一个前端都会收藏一些稀奇古怪的玩意，大家不妨分享出来，互惠互利</p><p>大家要是有好玩的东西，又懒得码字，你直接评论或者私我，我去研究研究，回头补充上</p><p>发完这个帖子，接下来就开使写技术帖了，平常也喜欢写技术贴，存了很多的半篇半篇的帖子，觉得写的不太好，就不想发，也没时间完善，久而久之，半篇幅的帖子越来越多，不能这样颓废了</p><p>趁还年轻，趁着啥啥都还新鲜的劲头，加油</p>]]></content>
    
    
    <categories>
      
      <category>Web相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Chrome</tag>
      
      <tag>Vscode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue 项目中优雅使用 icon</title>
    <link href="/blog/2019/11/16/vue/Vue%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BC%98%E9%9B%85%E4%BD%BF%E7%94%A8icon/"/>
    <url>/blog/2019/11/16/vue/Vue%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BC%98%E9%9B%85%E4%BD%BF%E7%94%A8icon/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue-项目中优雅使用-icon"><a href="#Vue-项目中优雅使用-icon" class="headerlink" title="Vue 项目中优雅使用 icon"></a>Vue 项目中优雅使用 icon</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>icon 在我们前端日常开发中是很常用的，它有很多种使用方式，时至今日，它的使用方式经过了很多种演变，本文会为大家介绍 icon 的一些历史演变，分析一下这几种使用方式的优劣，我们将采用<code>svg sprites</code>这种方式使用 icon，演示代码使用 vue+vue-cli3+，看完之后，你会发现这种使用方式完全称得上优雅二字</p><h3 id="追溯历史"><a href="#追溯历史" class="headerlink" title="追溯历史"></a>追溯历史</h3><h4 id="Img-标签引入"><a href="#Img-标签引入" class="headerlink" title="Img 标签引入"></a>Img 标签引入</h4><p>最早我们使用图标时只是单纯 img 标签引入图片，个人感觉也还好</p><p>但是这样网页上会有很多 img 图标的资源请求，这是它最大的缺点</p><h4 id="雪碧图-css-sprites"><a href="#雪碧图-css-sprites" class="headerlink" title="雪碧图(css sprites)"></a>雪碧图(css sprites)</h4><p>后来我们为了优化资源请求开始使用 CSS 雪碧图(css sprites)</p><p>CSS Sprites 在国内很多人叫 css 精灵/css 雪碧图(啥都行)，是一种网页图片应用处理方式。它允许你将一个页面涉及到的所有零星图片都包含到一张大图中去，这样一来，当访问该页面时，载入的图片就不会像以前那样一幅一幅地慢慢显示出来了。加速的关键，不是降低质量，而是减少个数</p><p>CSS Sprites 其实就是把网页中一些背景图片整合到一张图片文件中，再利用 CSS 的<code>background-image background- repeat background-position</code>的组合进行背景定位，<code>background-position</code>可以用数字精确的定位出背景图片的位置</p><p>利用 CSS Sprites 能很好地减少网页的 http 请求，从而大大的提高页面的性能，这也是 CSS Sprites 最大的优点</p><p>同时它的缺点也很明显，CSS Sprites 在开发的时候比较麻烦，需要计算基准位置来进行定位，维护的时候往往改动一个图标我们就得改整个雪碧图，一不小心就搞得整个网页的图标错位了</p><h4 id="font-库"><a href="#font-库" class="headerlink" title="font 库"></a>font 库</h4><p>再到后来就出现了 font 库，也就是字体图标库，它出现给了我们开发很大便利，使用起来也非常方便，字体图标为什么方便，因为我们可以直接从市面上的 font 字体图标库里找图标，直接使用，还可以很好的控制一些基础样式</p><p>国内估计使用量最大也是最全的图标库我觉得就是阿里矢量图标库(iconfont)了，各种图标简直不要太多，最重要的是开源免费</p><p>拿 iconfont 来说，它有三种使用方式，分别是<code>unicode，font-class，symbol</code>，都非常简单</p><p>当然，没有使用过的小伙伴直接百度搜索关键词 iconfont 使用，相信看一看就会了</p><p>接下来我们来看下这三种方式的优缺点(官方的)：</p><h3 id="font-使用方式对比"><a href="#font-使用方式对比" class="headerlink" title="font 使用方式对比"></a>font 使用方式对比</h3><h4 id="unicode-引用"><a href="#unicode-引用" class="headerlink" title="unicode 引用"></a>unicode 引用</h4><hr><p>unicode 是字体在网页端最原始的应用方式，特点是：</p><ul><li>兼容性最好，支持 ie6+，及所有现代浏览器。</li><li>支持按字体的方式去动态调整图标大小，颜色等等。</li><li>但是因为是字体，所以不支持多色。只能使用平台里单色的图标，就算项目里有多色图标也会自动去色。</li></ul><blockquote><p>注意：新版 iconfont 支持多色图标，这些多色图标在 unicode 模式下将不能使用，如果有需求建议使用 symbol 的引用方式</p></blockquote><p>unicode 使用步骤如下：</p><h5 id="第一步：拷贝项目下面生成的-font-face"><a href="#第一步：拷贝项目下面生成的-font-face" class="headerlink" title="第一步：拷贝项目下面生成的 font-face"></a>第一步：拷贝项目下面生成的 font-face</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">@font-face &#123;font-family: <span class="hljs-string">&#x27;iconfont&#x27;</span>;<br>    src: url(<span class="hljs-string">&#x27;iconfont.eot&#x27;</span>);<br>    src: url(<span class="hljs-string">&#x27;iconfont.eot?#iefix&#x27;</span>) format(<span class="hljs-string">&#x27;embedded-opentype&#x27;</span>),<br>    url(<span class="hljs-string">&#x27;iconfont.woff&#x27;</span>) format(<span class="hljs-string">&#x27;woff&#x27;</span>),<br>    url(<span class="hljs-string">&#x27;iconfont.ttf&#x27;</span>) format(<span class="hljs-string">&#x27;truetype&#x27;</span>),<br>    url(<span class="hljs-string">&#x27;iconfont.svg#iconfont&#x27;</span>) format(<span class="hljs-string">&#x27;svg&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="第二步：定义使用-iconfont-的样式"><a href="#第二步：定义使用-iconfont-的样式" class="headerlink" title="第二步：定义使用 iconfont 的样式"></a>第二步：定义使用 iconfont 的样式</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">.iconfont&#123;<br>    font-family:<span class="hljs-string">&quot;iconfont&quot;</span> !important;<br>    font-size:16px;font-style:normal;<br>    -webkit-font-smoothing: antialiased;<br>    -webkit-text-stroke-width: <span class="hljs-number">0.</span>2px;<br>    -moz-osx-font-smoothing: grayscale;&#125;<br></code></pre></td></tr></table></figure><h5 id="第三步：挑选相应图标并获取字体编码，应用于页面"><a href="#第三步：挑选相应图标并获取字体编码，应用于页面" class="headerlink" title="第三步：挑选相应图标并获取字体编码，应用于页面"></a>第三步：挑选相应图标并获取字体编码，应用于页面</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;i <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;iconfont&quot;</span>&gt;&amp;#x33;&lt;/i&gt;<br></code></pre></td></tr></table></figure><h4 id="font-class-引用"><a href="#font-class-引用" class="headerlink" title="font-class 引用"></a>font-class 引用</h4><hr><p>font-class 是 unicode 使用方式的一种变种，主要是解决 unicode 书写不直观，语意不明确的问题。</p><p>与 unicode 使用方式相比，具有如下特点：</p><ul><li>兼容性良好，支持 ie8+，及所有现代浏览器。</li><li>相比于 unicode 语意明确，书写更直观。可以很容易分辨这个 icon 是什么。</li><li>因为使用 class 来定义图标，所以当要替换图标时，只需要修改 class 里面的 unicode 引用。</li><li>不过因为本质上还是使用的字体，所以多色图标还是不支持的。</li></ul><p>使用步骤如下：</p><h5 id="第一步：拷贝项目下面生成的-fontclass-代码："><a href="#第一步：拷贝项目下面生成的-fontclass-代码：" class="headerlink" title="第一步：拷贝项目下面生成的 fontclass 代码："></a>第一步：拷贝项目下面生成的 fontclass 代码：</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//at.alicdn.com/t/font_8d5l8fzk5b87iudi.css</span><br></code></pre></td></tr></table></figure><h5 id="第二步：挑选相应图标并获取类名，应用于页面："><a href="#第二步：挑选相应图标并获取类名，应用于页面：" class="headerlink" title="第二步：挑选相应图标并获取类名，应用于页面："></a>第二步：挑选相应图标并获取类名，应用于页面：</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;<span class="hljs-selector-tag">i</span> class=&quot;iconfont <span class="hljs-attribute">icon</span>-xxx&quot;&gt;&lt;/<span class="hljs-selector-tag">i</span>&gt;<br></code></pre></td></tr></table></figure><h4 id="symbol-引用"><a href="#symbol-引用" class="headerlink" title="symbol 引用"></a>symbol 引用</h4><hr><p>这是一种全新的使用方式，应该说这才是未来的主流，也是平台目前推荐的用法。这种用法其实是做了一个 svg 的集合，与上面两种相比具有如下特点：</p><ul><li>支持多色图标了，不再受单色限制。</li><li>通过一些技巧，支持像字体那样，通过<code>font-size</code>,<code>color</code>来调整样式。</li><li>兼容性较差，支持 ie9+,及现代浏览器。</li><li>浏览器渲染 svg 的性能一般，还不如 png。</li></ul><p>使用步骤如下：</p><h5 id="第一步：拷贝项目下面生成的-symbol-代码："><a href="#第一步：拷贝项目下面生成的-symbol-代码：" class="headerlink" title="第一步：拷贝项目下面生成的 symbol 代码："></a>第一步：拷贝项目下面生成的 symbol 代码：</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//at.alicdn.com/t/font_8d5l8fzk5b87iudi.js</span><br></code></pre></td></tr></table></figure><h5 id="第二步：加入通用-css-代码（引入一次就行）："><a href="#第二步：加入通用-css-代码（引入一次就行）：" class="headerlink" title="第二步：加入通用 css 代码（引入一次就行）："></a>第二步：加入通用 css 代码（引入一次就行）：</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;style type=<span class="hljs-string">&quot;text/css&quot;</span>&gt;<br>    .icon &#123;<br>       <span class="hljs-attr">width</span>: 1em; height: 1em;<br>       vertical-align: -<span class="hljs-number">0.</span>15em;<br>       fill: currentColor;<br>       overflow: hidden;<br>    &#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><h5 id="第三步：挑选相应图标并获取类名，应用于页面："><a href="#第三步：挑选相应图标并获取类名，应用于页面：" class="headerlink" title="第三步：挑选相应图标并获取类名，应用于页面："></a>第三步：挑选相应图标并获取类名，应用于页面：</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;svg <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;icon&quot;</span> aria-hidden=<span class="hljs-string">&quot;true&quot;</span>&gt;<br>  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">use</span> <span class="hljs-attr">xlink:href</span>=<span class="hljs-string">&quot;#icon-xxx&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">use</span>&gt;</span></span><br>&lt;/svg&gt;<br></code></pre></td></tr></table></figure><p>以上三种使用姿势的优缺点相信大家都了解了，symbol 这中使用方式就是本文的正题了，其实之前我是一直都使用 font-class 这种方式的(大家估计用这个的也很多)，但是它有点麻烦，因为我每次迭代项目时，修改或者添加图标都要去重新下载一份新的包，还不支持多色图标，但是现在我觉决定换了它，因为 get 到了一种更好的方式，它就是 symbol</p><p>symbol 它支持多色图标，兼容性到 ie9+，这也没什么，毕竟某 e 浏览器差不多凉透了，浏览器渲染 svg 性能这个也可以不用担心，早在 14 年张鑫旭的一篇帖子 <a href="http://www.zhangxinxu.com/wordpress/2014/07/introduce-svg-sprite-technology/?spm=a313x.7781069.1998910419.50">SVG Sprite 介绍</a> 完美诠释了 svg sprite 的工作方式，并且对其很看好，或许这就是大佬的眼光吧 - _ -</p><p>单纯使用 iconfont 官方那种 symbol 方式其实是有点 low 的，实际开发中我们可以结合项目，让他变得简单，接下来我们就要进入本文正题，优雅使用 icon 了，哈哈哈，码这么多字，我太难了</p><h3 id="项目中优雅使用-icon"><a href="#项目中优雅使用-icon" class="headerlink" title="项目中优雅使用 icon"></a>项目中优雅使用 icon</h3><h5 id="搭建环境获取图标"><a href="#搭建环境获取图标" class="headerlink" title="搭建环境获取图标"></a>搭建环境获取图标</h5><p>我们使用 vue-cli3 搭建项目</p><p>怎么样才算优雅，首先我们在 src 目录下新建<code>icons/</code>文件夹，在<code>icons/</code>文件夹下建<code>svg/</code>文件夹，将来我们项目中的 svg 图标都会统一放在这里</p><p>接下来我们在官网搞来一个 svg 图标</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20191116165415085.png" alt="image-20191116165415085"></p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20191116165528974.png" alt="image-20191116165528974"></p><p>点击 svg 下载到<code>icons/svg</code>目录下修改文件名为<code>qq.svg</code>，或者是在<code>icons/svg</code>目录下新建一个<code>qq.svg</code>文件，把复制的 svg 代码放进去也可以</p><p>这样就获取到了一个图标，很 easy</p><h5 id="处理-svg-图标"><a href="#处理-svg-图标" class="headerlink" title="处理 svg 图标"></a>处理 svg 图标</h5><p>vue-cli 对 svg 文件有默认的<code>url-loader</code> 处理，我们要使用 svg 图标需单独进行配置</p><p>下载一个插件<code>svg-sprite-loader</code>来单独处理我们的 svg 图标，它是一个 webpack loader，支持将多个 svg 打包成 svg sprites</p><p>npm 下载</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">npm install svg-sprite-loader -D<br></code></pre></td></tr></table></figure><p>yarn 下载</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">yarn add svg-sprite-loader -D<br></code></pre></td></tr></table></figure><p>我们要怎么使用它呢，首先我们不能覆盖原有的 svg 解析 loader，我们只需要把<code>icons/svg</code>这个文件夹下的 svg 文件解析打包即可，我们在<code>vue.config.js</code>中 chainWebpack 函数中配置，来看代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 内置路径包</span><br><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;path&quot;</span>)<br><br><span class="hljs-comment">// 定义resolve方法，获取绝对路径</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolve</span>(<span class="hljs-params">dir</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> path.join(__dirname, dir)<br>&#125;<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-comment">// 一个函数，会接收一个基于 webpack-chain 的 ChainableConfig 实例</span><br>  <span class="hljs-comment">// 允许对内部的 webpack 配置进行更细粒度的修改</span><br>  <span class="hljs-attr">chainWebpack</span>: <span class="hljs-function">(<span class="hljs-params">config</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 配置svg默认规则排除icons目录中svg文件处理</span><br>    config.module.rule(<span class="hljs-string">&quot;svg&quot;</span>).exclude.add(resolve(<span class="hljs-string">&quot;src/icons&quot;</span>)).end()<br><br>    <span class="hljs-comment">// 新增icons规则，设置svg-sprite-loader处理icons目录中svg文件</span><br>    config.module<br>      .rule(<span class="hljs-string">&quot;icons&quot;</span>)<br>      .test(<span class="hljs-regexp">/\.svg$/</span>)<br>      .include.add(resolve(<span class="hljs-string">&quot;src/icons&quot;</span>))<br>      .end()<br>      .use(<span class="hljs-string">&quot;svg-sprite-loader&quot;</span>)<br>      .loader(<span class="hljs-string">&quot;svg-sprite-loader&quot;</span>)<br>      .options(&#123; <span class="hljs-attr">symbolId</span>: <span class="hljs-string">&quot;icon-[name]&quot;</span> &#125;)<br>      .end()<br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><p>如果我们不清楚 cli 的默认配置，怕改错，可通过 vue inspect 审查 webpack 内部配置，详细请看： <a href="*https://cli.vuejs.org/zh/guide/webpack.html#%E5%AE%A1%E6%9F%A5%E9%A1%B9%E7%9B%AE%E7%9A%84-webpack-%E9%85%8D%E7%BD%AE*">inspect 使用</a></p><p>上面代码中我们使用了 webpack 的链式高级用法来处理 loader，首先排除了默认 svg 的 loader 对我们<code>icons/</code>目录下 svg 文件的处理，然后新增了一个规则让<code>svg-sprite-loader</code>处理我们<code>icons/</code>文件夹下的 svg 文件，最后我们设置了<code>icon-</code>加上经过处理的 svg 文件名作为 symbolId，也就是说我们在使用<code>qq.svg</code>时可以直接在 use 标签使用<code>#icon-qq</code>，关于链式操作不了解的小伙伴可以看: <a href="%5Bhttps://cli.vuejs.org/zh/guide/webpack.html#%E9%93%BE%E5%BC%8F%E6%93%8D%E4%BD%9C-%E9%AB%98%E7%BA%A7%5D(https://cli.vuejs.org/zh/guide/webpack.html#%E9%93%BE%E5%BC%8F%E6%93%8D%E4%BD%9C-%E9%AB%98%E7%BA%A7)">链式操作(高级)</a></p><p>代码中我们引入了<code>path</code>这样一个内置的包，定义了一个<code>resolve</code>方法，该方法主要是来获取文件绝对路径的，我们把使用路径的地方都使用该方法转为绝对路径，当然使用相对路径也是可以的，但是不太安全，平台解析相对路径有差异性，所以绝对路径是最安全的</p><h5 id="svg-sprites-图标使用"><a href="#svg-sprites-图标使用" class="headerlink" title="svg sprites 图标使用"></a>svg sprites 图标使用</h5><p>现在我们就可以在你想使用图标的位置使用了，使用方式如下</p><p>在<code>main.js</code>中引入(全局引入)要使用的图标文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;@/icons/svg/qq.svg&quot;</span><br></code></pre></td></tr></table></figure><p>模版中使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;svg&gt;<br>  &lt;use xlink:href=&quot;#icon-qq&quot;&gt;&lt;/use&gt;<br>&lt;/svg&gt;<br></code></pre></td></tr></table></figure><p>你以为这就完了？不，还远远不够，这样使用一个图标就得引入文件一次也太麻烦了，接着看下文</p><h5 id="进阶-svg-文件自动引入"><a href="#进阶-svg-文件自动引入" class="headerlink" title="进阶-svg 文件自动引入"></a>进阶-svg 文件自动引入</h5><p>知道为什么在<code>icons/</code>文件夹下还有一个存放 svg 文件的<code>svg/</code>文件夹吗，就是为了这一步自动化引入准备的，我们在<code>icons/</code>文件夹下新建<code>index.js</code>文件，两行代码搞定，内容如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// icons图标自动加载</span><br><span class="hljs-keyword">const</span> req = <span class="hljs-built_in">require</span>.context(<span class="hljs-string">&quot;./svg&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-regexp">/\.svg$/</span>)<br>req.keys().map(req)<br></code></pre></td></tr></table></figure><p>上面代码中我们使用<code>require.context</code>设置了当前目录下的<code>./svg</code>文件为上下文，使用正则匹配了它需要检测的文件名，这样它就会在当前目录的 svg 文件夹下去匹配符合规则的文件名</p><p>然后我们使用<code>req.keys</code>拿到所有文件名数组，再使用 map 遍历加载 req 方法，这样当该文件被调用时会遍历加载所有匹配到的文件，这就很 nice 了</p><p>看看我们改进后的使用方法：</p><p>注释掉之前的代码，在<code>main.js</code>中引入<code>icons/index.js</code>文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;@/icons/index.js&quot;</span><br></code></pre></td></tr></table></figure><p>模板中使用和上面一样，不过这次改进当我们再次下载了一个 svg 图标时，不用再引入一遍图标 svg 了，因为我们做了自动化，<code>icons/svg/</code>下的 svg 后缀图标文件都可被自动引入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;svg&gt;<br>  &lt;use xlink:href=&quot;#icon-qq&quot;&gt;&lt;/use&gt;<br>&lt;/svg&gt;<br><br>&lt;svg&gt;<br>  &lt;use xlink:href=&quot;#icon-wx&quot;&gt;&lt;/use&gt;<br>&lt;/svg&gt;<br>...<br></code></pre></td></tr></table></figure><p>是不是很方便，你以为结束了？不，我们还可以再简化，因为每次使用都得 svg 标签包着 use 太麻烦了，写着也不太雅观，我们继续简化，一定要看起来使用起来都十分优雅</p><h5 id="再进阶-SvgIcon-组件"><a href="#再进阶-SvgIcon-组件" class="headerlink" title="再进阶-SvgIcon 组件"></a>再进阶-SvgIcon 组件</h5><p>在<code>components/</code>目录下新建<code>SvgIcon/index.vue</code>文件，我们写一个 svgicon 组件，封装一下再全局注册，这样使用起来就会很方便了！</p><p>svg-icon 组件代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;svg :class=&quot;svgClass&quot; aria-hidden=&quot;true&quot; v-on=&quot;$listeners&quot;&gt;<br>    &lt;use :xlink:href=&quot;iconName&quot; /&gt;<br>  &lt;/svg&gt;<br>&lt;/template&gt;<br>&lt;script&gt;<br>export default &#123;<br>  name: &quot;SvgIcon&quot;,<br>  props: &#123;<br>    iconClass: &#123;<br>      type: String,<br>      required: true,<br>    &#125;,<br>    className: &#123;<br>      type: String,<br>      default: &quot;&quot;,<br>    &#125;,<br>  &#125;,<br>  computed: &#123;<br>    iconName() &#123;<br>      return `#icon-$&#123;this.iconClass&#125;`<br>    &#125;,<br>    svgClass() &#123;<br>      if (this.className) &#123;<br>        return &quot;svg-icon &quot; + this.className<br>      &#125; else &#123;<br>        return &quot;svg-icon&quot;<br>      &#125;<br>    &#125;,<br>  &#125;,<br>&#125;<br>&lt;/script&gt;<br>&lt;style scoped&gt;<br>.svg-icon &#123;<br>  width: 1em;<br>  height: 1em;<br>  vertical-align: -0.15em;<br>  fill: currentColor;<br>  overflow: hidden;<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><p>当然组件内部我们还可以根据自身项目情况进行扩展，我这边写了基础的配置</p><p>组件写好了之后我们在<code>icons/index.js</code>中进行全局注册，这样我们只引入这一个文件就可以达到自动加载和组件注册两个功能</p><p><code>icons/index.js</code>改进如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span><br><span class="hljs-keyword">import</span> SvgIcon <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@/components/SvgIcon&quot;</span><br><br><span class="hljs-comment">// icons图标自动加载</span><br><span class="hljs-keyword">const</span> req = <span class="hljs-built_in">require</span>.context(<span class="hljs-string">&quot;./svg&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-regexp">/\.svg$/</span>)<br>req.keys().map(req)<br><br><span class="hljs-comment">// 全局注册svg-icon组件</span><br>Vue.component(<span class="hljs-string">&quot;svg-icon&quot;</span>, SvgIcon)<br></code></pre></td></tr></table></figure><p>最后就是我们的使用了，在<code>main.js</code>文件引入<code>icons/index.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;@/icons/index.js&quot;</span><br></code></pre></td></tr></table></figure><p>再来看看我们使用图标的方法，组件中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;svg-icon icon-class=&quot;qq&quot; class-name=&quot;qq-style&quot;&gt;&lt;/svg-icon&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><p>看，我们只用在<code>icon-class</code>中传入要使用的图标文件名就可以了，当然<code>class-name</code>还可以传入一个类，进行一些简单的样式修改，是不是很优雅，你 get 到了吗？</p><h3 id="Vue-Awesome"><a href="#Vue-Awesome" class="headerlink" title="Vue-Awesome"></a>Vue-Awesome</h3><p>从掘友那了解到了<a href="https://github.com/Justineo/vue-awesome">vue-awesome</a>，体验了一番，很 nice，内置了<a href="https://fontawesome.com/">fontawesome</a>字体图标库</p><p>好像也没啥可对比的，svg 图标引入原理差不多，vue-awesome 除了内置了 fontawesome 图标库之外也可以自己引入图标使用，做了很全面的封装，针对图标由很多功能，所以使用的话会体积会稍大</p><p>不过个人觉得，有了 iconfont 图标库，好像没有太大必要去再用 fontawesome，fontawesome 也并不是全免费，而且国外站点访问很慢，iconfont 毕竟是阿里出的，很全，针对 icon 的话我们可能并不需要太多功能，所以上面我们自己配置的话清晰明了，就已经够用，自己写的话熟悉流程 10 分钟搭一个，实在不够用，我们可以在组件花些功夫，自己做封装的话针对性强，定制性当然是看我们自己需要了，最靠谱的是使用轮子不如造轮子，哈哈</p><p>vue-awesome 是很好的，我们可以从中借鉴一些思路用于自己开发 icon 组件也是不错的，比如那些功能，我们都可以一一实现下，重要的是过程，哈哈</p><blockquote><p>参考文章：</p><p><a href="http://www.zhangxinxu.com/wordpress/2014/07/introduce-svg-sprite-technology/?spm=a313x.7781069.1998910419.50">未来必热：SVG Sprites 技术介绍-张鑫旭</a></p><p><a href="https://juejin.im/post/59bb864b5188257e7a427c09">手摸手，带你优雅的使用 icon-掘金</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Vue相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue 基础面试题</title>
    <link href="/blog/2019/06/10/vue/Vue%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/blog/2019/06/10/vue/Vue%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="1-MVVM-amp-amp-MVC"><a href="#1-MVVM-amp-amp-MVC" class="headerlink" title="1. MVVM&amp;&amp;MVC"></a>1. MVVM&amp;&amp;MVC</h3><h4 id="1-1-MVVM"><a href="#1-1-MVVM" class="headerlink" title="1.1 MVVM"></a>1.1 MVVM</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">MVVM -&gt; Model-View-ViewModel<br>Model 代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑。<br>View 代表UI组件，它负责将数据模型转化成UI展现出来。<br>ViewModel 监听模型数据的改变和控制视图行为、处理用户交互，简单理解就是一个同步View 和 Model的对象，连接Model和View。<br>在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互，Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。<br>ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。<br></code></pre></td></tr></table></figure><h4 id="1-2-MVC"><a href="#1-2-MVC" class="headerlink" title="1.2 MVC"></a>1.2 MVC</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JS">MVC是Model-View- Controller的简写，即模型-视图-控制器，M和V和MVVM中的M和V是一样的，C是Controller即页面义务逻辑<br>使用MVC的目的就是为了M和V代码分离。MVVM的VM并不是完全取代C，VM存在的目的是抽离C中的业务逻辑<br></code></pre></td></tr></table></figure><h4 id="1-3-MVVM-amp-amp-MVC-区别"><a href="#1-3-MVVM-amp-amp-MVC-区别" class="headerlink" title="1.3 MVVM&amp;&amp;MVC 区别"></a>1.3 MVVM&amp;&amp;MVC 区别</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">MVC是单向的数据传递。MVVM是双向数据绑定，主要解决了MVC中大量的DOM操作使页面的渲染性能降低，加载速度变慢，影响用户体验<br></code></pre></td></tr></table></figure><h3 id="2-Vue-生命周期"><a href="#2-Vue-生命周期" class="headerlink" title="2. Vue 生命周期"></a>2. Vue 生命周期</h3><h4 id="2-1-什么是生命周期"><a href="#2-1-什么是生命周期" class="headerlink" title="2.1 什么是生命周期"></a>2.1 什么是生命周期</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">Vue 实例从创建到销毁的过程，就是生命周期。从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、销毁等一系列过程，称之为 Vue 的生命周期<br></code></pre></td></tr></table></figure><h4 id="2-2-生命周期的作用"><a href="#2-2-生命周期的作用" class="headerlink" title="2.2 生命周期的作用"></a>2.2 生命周期的作用</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">生命周期中有多个事件钩子，在控制整个Vue实例的过程时更容易形成好的逻辑<br></code></pre></td></tr></table></figure><h4 id="2-3-生命周期阶段"><a href="#2-3-生命周期阶段" class="headerlink" title="2.3 生命周期阶段"></a>2.3 生命周期阶段</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">它可以总共分为<span class="hljs-number">8</span>个阶段：创建前/后, 载入前/后,更新前/后,销毁前/销毁后<br><br>beforeCreate （创建前） 在数据观测和初始化事件还未开始<br>created     （创建后） 完成数据观测，属性和方法的运算，初始化事件，$el属性还没有显示出来<br>beforeMount  （载入前） 在挂载开始之前被调用，相关的render函数首次被调用。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。注意此时还没有挂载html到页面上。<br>mounted      （载入后） 在el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html页面中。此过程中进行ajax交互。<br>beforeUpdate （更新前） 在数据更新之前调用，发生在虚拟DOM重新渲染和打补丁之前。可以在该钩子中进一步地更改状态，不会触发附加的重渲染过程。<br>updated      （更新后） 在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。<br>beforeDestroy（销毁前） 在实例销毁之前调用。实例仍然完全可用。<br>destroyed    （销毁后） 在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。<br></code></pre></td></tr></table></figure><h4 id="2-4-第一次加载会触发哪些钩子"><a href="#2-4-第一次加载会触发哪些钩子" class="headerlink" title="2.4 第一次加载会触发哪些钩子"></a>2.4 第一次加载会触发哪些钩子</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">会触发beforeCreate, created, beforeMount, mounted<br></code></pre></td></tr></table></figure><h4 id="2-5-DOM-渲染在哪个周期中就已经完成"><a href="#2-5-DOM-渲染在哪个周期中就已经完成" class="headerlink" title="2.5 DOM 渲染在哪个周期中就已经完成"></a>2.5 DOM 渲染在哪个周期中就已经完成</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">DOM 渲染在 mounted 中就已经完成<br></code></pre></td></tr></table></figure><h3 id="3-双向绑定原理"><a href="#3-双向绑定原理" class="headerlink" title="3. 双向绑定原理"></a>3. 双向绑定原理</h3><h4 id="3-1-原理"><a href="#3-1-原理" class="headerlink" title="3.1 原理"></a>3.1 原理</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">Object</span>.defineProperty()<br><br>vue实现数据双向绑定主要是：采用数据劫持结合发布者-订阅者模式的方式，通过<span class="hljs-built_in">Object</span>.defineProperty（）来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应监听回调。当把一个普通 Javascript 对象传给 Vue 实例来作为它的 data 选项时，Vue 将遍历它的属性，用 <span class="hljs-built_in">Object</span>.defineProperty 将它们转为 getter/setter。用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。<br><br>vue的数据双向绑定 将MVVM作为数据绑定的入口，整合Observer，Compile和Watcher三者，通过Observer来监听自己的model的数据变化，通过Compile来解析编译模板指令（vue中是用来解析 &#123;&#123;&#125;&#125;），最终利用watcher搭起observer和Compile之间的通信桥梁，达到数据变化 —&gt;视图更新；视图交互变化（input）—&gt;数据model变更双向绑定效果<br></code></pre></td></tr></table></figure><h4 id="3-2-js-实现双向数据绑定"><a href="#3-2-js-实现双向数据绑定" class="headerlink" title="3.2 js 实现双向数据绑定"></a>3.2 js 实现双向数据绑定</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;txt&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;show&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span><br><span class="javascript">  <span class="hljs-keyword">var</span> obj = &#123;&#125;</span><br><span class="javascript">  <span class="hljs-built_in">Object</span>.defineProperty(obj, <span class="hljs-string">&quot;txt&quot;</span>, &#123;</span><br><span class="javascript">    <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">      <span class="hljs-keyword">return</span> obj</span><br><span class="javascript">    &#125;,</span><br><span class="javascript">    <span class="hljs-attr">set</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">newValue</span>) </span>&#123;</span><br><span class="javascript">      <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;txt&quot;</span>).value = newValue</span><br><span class="javascript">      <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;show&quot;</span>).innerHTML = newValue</span><br><span class="javascript">    &#125;,</span><br><span class="javascript">  &#125;)</span><br><span class="javascript">  <span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&quot;keyup&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;</span><br><span class="javascript">    obj.txt = e.target.value</span><br><span class="javascript">  &#125;)</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="4-Vue-组件传参"><a href="#4-Vue-组件传参" class="headerlink" title="4. Vue 组件传参"></a>4. Vue 组件传参</h3><h4 id="4-1-父与子传参"><a href="#4-1-父与子传参" class="headerlink" title="4.1 父与子传参"></a>4.1 父与子传参</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">子组件通过props方法接受数据<br></code></pre></td></tr></table></figure><h4 id="4-2-子与父传参"><a href="#4-2-子与父传参" class="headerlink" title="4.2 子与父传参"></a>4.2 子与父传参</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">$emit方法传递参数<br></code></pre></td></tr></table></figure><h4 id="4-3-非父子-amp-amp-兄弟间传参"><a href="#4-3-非父子-amp-amp-兄弟间传参" class="headerlink" title="4.3 非父子&amp;&amp;兄弟间传参"></a>4.3 非父子&amp;&amp;兄弟间传参</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">eventBus，创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。项目比较小时，这个比较合适。<br>也可以直接使用用VUEX，具体来说看需求<br></code></pre></td></tr></table></figure><h3 id="5-Vue-路由"><a href="#5-Vue-路由" class="headerlink" title="5. Vue 路由"></a>5. Vue 路由</h3><h4 id="5-1-路由跳转"><a href="#5-1-路由跳转" class="headerlink" title="5.1 路由跳转"></a>5.1 路由跳转</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">声明式(标签式)<br>&lt;router-link :to=<span class="hljs-string">&quot;index&quot;</span>&gt;<br><br>编程式<br>router.push(&#123;<span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/&#x27;</span>,<span class="hljs-attr">query</span>:&#123;&#125;&#125;)<br></code></pre></td></tr></table></figure><h4 id="5-2-路由实现：hash-模式-和-history-模式"><a href="#5-2-路由实现：hash-模式-和-history-模式" class="headerlink" title="5.2 路由实现：hash 模式 和 history 模式"></a>5.2 路由实现：hash 模式 和 history 模式</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">hash模式：<br>在浏览器中符号“#”，#以及#后面的字符称之为hash，用<span class="hljs-built_in">window</span>.location.hash读取；<br>特点：hash虽然在URL中，但不被包括在HTTP请求中；用来指导浏览器动作，对服务端安全无用，hash不会重加载页面。<br>hash 模式下，仅 hash 符号之前的内容会被包含在请求中，如 http:<span class="hljs-comment">//www.xxx.com，因此对于后端来说，即使没有做到对路由的全覆盖，也不会返回 404 错误。</span><br><br>history模式：<br>history采用HTML5的新特性；且提供了两个新方法：pushState（），replaceState（）可以对浏览器历史记录栈进行修改，以及popState事件的监听到状态变更。<br>history 模式下，前端的 URL 必须和实际向后端发起请求的 URL 一致，如 http:<span class="hljs-comment">//www.xxx.com/items/id。后端如果缺少对 /items/id 的路由处理，将返回 404 错误。Vue-Router 官网里如此描述：“不过这种模式要玩好，还需要后台配置支持……所以呢，你要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。”</span><br></code></pre></td></tr></table></figure><h4 id="5-3-Vue-路由守卫-路由钩子"><a href="#5-3-Vue-路由守卫-路由钩子" class="headerlink" title="5.3 Vue 路由守卫(路由钩子)"></a>5.3 Vue 路由守卫(路由钩子)</h4><p>全局守卫</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js">beforeEach，afterEach 路由钩子函数，也叫路由守卫<br><br>beforeEach 全局前置守卫，当一个导航触发时，全局前置守卫按照创建顺序调用<br>参数：<br>to：route即将要进入的目标路由对象<br><span class="hljs-keyword">from</span>：route当前导航正要离开的路由<br>next：<span class="hljs-function"><span class="hljs-keyword">function</span>一定要调用该方法<span class="hljs-title">resolve</span>这个钩子。执行效果依赖<span class="hljs-title">next</span>方法的调用参数。可以控制网页的跳转</span><br><span class="hljs-function"><span class="hljs-title">next</span>(<span class="hljs-params"></span>)：跳转下一个页面</span><br><span class="hljs-function"><span class="hljs-title">next</span>(<span class="hljs-params"><span class="hljs-literal">false</span></span>): 中断当前的导航，返回原来页面</span><br><span class="hljs-function"><span class="hljs-title">next</span>(<span class="hljs-params">&#123;path:<span class="hljs-string">&#x27;/&#x27;</span>&#125;</span>)：跳转到一个不同的地址，当前的导航被中断，进行一个新的导航</span><br><span class="hljs-function">注意：一定要调用<span class="hljs-title">next</span>(<span class="hljs-params"></span>),否则钩子就不会被 <span class="hljs-title">resolved</span>，页面会卡在那，一般用于对路由跳转前进行拦截</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">afterEach</span> 全局后置钩子</span><br><span class="hljs-function"><span class="hljs-title">router</span>.<span class="hljs-title">afterEach</span>(<span class="hljs-params">(to, <span class="hljs-keyword">from</span>) =&gt; &#123;&#125;</span>)</span><br><span class="hljs-function">和前置守卫不同的是，这些钩子不会接受 <span class="hljs-title">next</span> 函数也不会改变导航本身</span><br></code></pre></td></tr></table></figure><p>局部(组件)守卫</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">组件中路由钩子<br><span class="hljs-function"><span class="hljs-title">beforeRouteEnter</span>(<span class="hljs-params">to,<span class="hljs-keyword">from</span>,next</span>)</span>&#123;&#125; 路由跳转时<br>注：此钩子在beforeCreate之前执行，但是next在组件mounted周期之后,无法直接调用<span class="hljs-built_in">this</span>访问组件实例，可用next访问vm实例，修改数据<br><br><span class="hljs-function"><span class="hljs-title">beforeRouteLeave</span>(<span class="hljs-params">to,<span class="hljs-keyword">from</span>,next</span>)</span>&#123;...next()&#125; 离开路由时<br>注意：可以直接访问<span class="hljs-built_in">this</span>,next不可回调<br><br>beforeRouteUpdate 路由切换时<br></code></pre></td></tr></table></figure><h4 id="5-4-动态渲染路由-addRoutes"><a href="#5-4-动态渲染路由-addRoutes" class="headerlink" title="5.4 动态渲染路由 addRoutes"></a>5.4 动态渲染路由 addRoutes</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">addRoutes<br>用于动态添加路由<br><br>常用场景：页面级权限控制，服务端存储路由对象，登录后页面加载时根据不同权限动态渲染路由<br></code></pre></td></tr></table></figure><h3 id="6-Vue-计算属性"><a href="#6-Vue-计算属性" class="headerlink" title="6. Vue 计算属性"></a>6. Vue 计算属性</h3><h4 id="6-1-为什么使用计算属性-优点"><a href="#6-1-为什么使用计算属性-优点" class="headerlink" title="6.1 为什么使用计算属性(优点)"></a>6.1 为什么使用计算属性(优点)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">模板中放入太多的逻辑会让模板过重且难以维护，在需要对数据进行复杂处理，且可能多次使用的情况下，尽量采取计算属性的方式<br>优点：<br><span class="hljs-number">1.</span> 使得数据处理结构清晰<br><span class="hljs-number">2.</span> 依赖于数据，数据更新，处理结果自动更新<br><span class="hljs-number">3.</span> 计算属性内部<span class="hljs-built_in">this</span>指向vm实例<br><span class="hljs-number">4.</span> 在template调用时，直接写计算属性名即可<br><span class="hljs-number">5.</span> methods不管依赖的数据变不变，都会重新计算，computed依赖数据不变时缓存中获取，不会重新计算<br></code></pre></td></tr></table></figure><h3 id="7-Vuex"><a href="#7-Vuex" class="headerlink" title="7. Vuex"></a>7. Vuex</h3><h4 id="7-1-简述"><a href="#7-1-简述" class="headerlink" title="7.1 简述"></a>7.1 简述</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">vue中状态管理器，实现组件间的数据共享<br>通过状态（数据源）集中管理驱动组件的变化，应用级的状态集中放在store中； 改变状态的方式是提交mutations，这是个同步的事物； 异步逻辑应该封装在action中<br>在main.js引入store，注入。新建了一个目录store，... <span class="hljs-keyword">export</span><br></code></pre></td></tr></table></figure><h3 id="8-浅谈-keep-alive"><a href="#8-浅谈-keep-alive" class="headerlink" title="8. 浅谈 keep-alive"></a>8. 浅谈 keep-alive</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">keep-alive是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染，相当于强缓存<br>vue <span class="hljs-number">2.1</span><span class="hljs-number">.0</span> 版本之后，keep-alive新加入了两个属性: include(包含的组件缓存) 与 exclude(排除的组件不缓存，优先级大于include)<br><br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">keep-alive</span> <span class="hljs-attr">include</span>=<span class="hljs-string">&quot;include_components&quot;</span> <span class="hljs-attr">exclude</span>=<span class="hljs-string">&quot;exclude_components&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">component</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 该组件是否缓存取决于include和exclude属性 --&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">keep-alive</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">keep-alive</span></span><br><span class="hljs-tag">  &gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">router-view</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;”$route.meta.keepAlive”&quot;</span>&gt;</span>&lt;/router-view<br>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">keep-alive</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">router-view</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;”$route.meta.keepAlive”&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span><br></code></pre></td></tr></table></figure><p>参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">include - 字符串或正则表达式，只有名称匹配的组件会被缓存<br>exclude - 字符串或正则表达式，任何名称匹配的组件都不会被缓存<br>include 和 exclude 的属性允许组件有条件地缓存。二者都可以用“，”分隔字符串、正则表达式、数组。当使用正则或者是数组时，要使用v-bind<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 逗号分隔字符串，只有组件a与b被缓存。 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">keep-alive</span> <span class="hljs-attr">include</span>=<span class="hljs-string">&quot;a,b&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">component</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">keep-alive</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 正则表达式 (需要使用 v-bind，符合匹配规则的都会被缓存) --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">keep-alive</span> <span class="hljs-attr">:include</span>=<span class="hljs-string">&quot;/a|b/&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">component</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">keep-alive</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- Array (需要使用 v-bind，被包含的都会被缓存) --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">keep-alive</span> <span class="hljs-attr">:include</span>=<span class="hljs-string">&quot;[&#x27;a&#x27;, &#x27;b&#x27;]&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">component</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">keep-alive</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="9-Vue-自定义指令"><a href="#9-Vue-自定义指令" class="headerlink" title="9. Vue 自定义指令"></a>9. Vue 自定义指令</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">vue.directive,可以写在组件内部，也可以写在外部作为全局的使用<br>它的钩子有bind，inserted，update等<br></code></pre></td></tr></table></figure><h3 id="10-Vue-两大核心是什么"><a href="#10-Vue-两大核心是什么" class="headerlink" title="10. Vue 两大核心是什么"></a>10. Vue 两大核心是什么</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">1.</span> 数据驱动<br><span class="hljs-number">2.</span> 组件系统<br></code></pre></td></tr></table></figure><h3 id="11-route-和-router-的区别"><a href="#11-route-和-router-的区别" class="headerlink" title="11. $route 和$router 的区别"></a>11. $route 和$router 的区别</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">$route是&lt;路由信息对象&gt;，包括path，params，hash，query，fullPath，matched，name等路由信息参数<br><br>$router是&lt;路由实例&gt;对象包括了路由的跳转方法，钩子函数等<br></code></pre></td></tr></table></figure><h3 id="12-Vue-常用修饰符"><a href="#12-Vue-常用修饰符" class="headerlink" title="12. Vue 常用修饰符"></a>12. Vue 常用修饰符</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">.prevent: 提交事件不再重载页面<br>.stop   : 阻止单击事件冒泡<br>.self   : 当事件发生在该元素本身而不是子元素的时候会触发<br>.capture: 事件侦听，事件发生的时候会调用<br></code></pre></td></tr></table></figure><h3 id="13-Vue-中-v-on-怎样绑定多个事件"><a href="#13-Vue-中-v-on-怎样绑定多个事件" class="headerlink" title="13. Vue 中 v-on 怎样绑定多个事件"></a>13. Vue 中 v-on 怎样绑定多个事件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">方法名后加 () =&gt; 调用方法 多个方法用 ; 隔开<br>例：<br>&lt;div @click=<span class="hljs-string">&quot;one();two();three()&quot;</span>&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure><h3 id="14-vue-中-key-值的作用"><a href="#14-vue-中-key-值的作用" class="headerlink" title="14. vue 中 key 值的作用"></a>14. vue 中 key 值的作用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">当 Vue.js 用 v-<span class="hljs-keyword">for</span> 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。key的作用主要是为了高效的更新虚拟DOM<br><br>简单来说：为了避免重复渲染，高效更新渲染DOM<br></code></pre></td></tr></table></figure><h3 id="15-Vue-中-css-怎样只在当前组件起作用"><a href="#15-Vue-中-css-怎样只在当前组件起作用" class="headerlink" title="15. Vue 中 css 怎样只在当前组件起作用"></a>15. Vue 中 css 怎样只在当前组件起作用</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">style标签中写入scoped即可 例如：<span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="16-v-if-和-v-show-区别"><a href="#16-v-if-和-v-show-区别" class="headerlink" title="16. v-if 和 v-show 区别"></a>16. v-if 和 v-show 区别</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">v-<span class="hljs-keyword">if</span>按照条件是否渲染，如果为<span class="hljs-literal">false</span>不会渲染<br><br>v-show是相当于display的block或none，为<span class="hljs-literal">false</span>是还是会渲染，只不过隐藏了<br></code></pre></td></tr></table></figure><h3 id="17-为什么避免-v-if-和-v-for-用在一起"><a href="#17-为什么避免-v-if-和-v-for-用在一起" class="headerlink" title="17. 为什么避免 v-if 和 v-for 用在一起"></a>17. 为什么避免 v-if 和 v-for 用在一起</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">vue处理指令时，v-<span class="hljs-keyword">for</span>比v-<span class="hljs-keyword">if</span>具有更高的优先级，通过v-<span class="hljs-keyword">if</span>移动到容器的元素，不会在重复遍历列表中的每个值，取而代之的是，我们只检查它一次，且不会v-<span class="hljs-keyword">if</span>为否的时候运算v-<span class="hljs-keyword">for</span><br></code></pre></td></tr></table></figure><h3 id="18-单页面-SPA-和多页面的区别-优缺点"><a href="#18-单页面-SPA-和多页面的区别-优缺点" class="headerlink" title="18. 单页面(SPA)和多页面的区别(优缺点)"></a>18. 单页面(SPA)和多页面的区别(优缺点)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">单页面：<br>整个项目中只有一个完整的HTML页面，其它<span class="hljs-string">&quot;页面&quot;</span>只是一段HTML片断而已<br>优: 请求少<br>缺: 不利于搜索引擎优化，首次加载时间长<br>页面跳转本质：把当前DOM树中某个DIV删除，下载并挂载另一个div片断<br><br>多页面：<br>项目中有多个独立的完整的HTML页面<br>缺: 请求次数多，效率低<br>页面跳转本质: 删除旧的DOM树，重新下载新的DOM树<br></code></pre></td></tr></table></figure><h3 id="19-Vue-的优缺点是什么"><a href="#19-Vue-的优缺点是什么" class="headerlink" title="19. Vue 的优缺点是什么"></a>19. Vue 的优缺点是什么</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">优点：低耦合，可重用性，独立开发，可测试，渐进式<br><br>缺点：不利于SEO，社区维护力度不强，相比还不够成熟<br></code></pre></td></tr></table></figure><h3 id="20-vue-和-react-区别"><a href="#20-vue-和-react-区别" class="headerlink" title="20. vue 和 react 区别"></a>20. vue 和 react 区别</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">相同点：<br>都鼓励组件化，都有props的概念，都有自己的构建工具，React与Vue只有框架的骨架，其他的功能如路由、状态管理等是框架分离的组件<br><br>不同点：<br>React：单向数据流，语法—JSX，在React中你需要使用setState()方法去更新状态<br>Vue：双向数据流，语法--HTML，state对象并不是必须的，数据由data属性在Vue对象中进行管理。适用于小型应用，对于大型应用而言不太适合<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GIT常用命令</title>
    <link href="/blog/2019/04/12/other/GIT%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/blog/2019/04/12/other/GIT%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h3 id="SSH-公钥"><a href="#SSH-公钥" class="headerlink" title="SSH 公钥"></a>SSH 公钥</h3><h5 id="查看本机-ssh-公钥"><a href="#查看本机-ssh-公钥" class="headerlink" title="查看本机 ssh 公钥"></a>查看本机 ssh 公钥</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">1.</span> 打开git bash窗口<br><br><span class="hljs-number">2.</span> 进入.ssh目录： cd ~/.ssh<br><br><span class="hljs-number">3.</span> 查看.ssh文件下有无id_rsa.pub文件：ls<br><br><span class="hljs-number">4.</span> 查看公钥：cat id_rsa.pub  或者  vim id_rsa.pub<br><br>上述步骤合为一步: cat ~<span class="hljs-regexp">/.ssh/i</span>d_rsa.pub<br></code></pre></td></tr></table></figure><h5 id="生成本机-ssh-公钥"><a href="#生成本机-ssh-公钥" class="headerlink" title="生成本机 ssh 公钥"></a>生成本机 ssh 公钥</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">1.</span> 命令行下输入: ssh-keygen<br><br><span class="hljs-number">2.</span> 确认存放公钥的地址，默认就是上面说的路径，直接enter键确认<br><br><span class="hljs-number">3.</span> 输入密码和确认密码，如果不想设置密码直接不输入内容 按enter键<br><br><span class="hljs-number">4.</span> 重复上面查看公钥步骤<br></code></pre></td></tr></table></figure><h5 id="git-中字母代表"><a href="#git-中字母代表" class="headerlink" title="git 中字母代表"></a>git 中字母代表</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">A     # 增加的文件<br>C       # 文件的一个新拷贝<br>D       # 删除的一个文件<br>M       # 文件的内容或者mode被修改了<br>R       # 文件名被修改了<br>T       # 文件类型被修改了<br>U       # 文件没有被合并(需要完成合并才能进行提交)<br>X       # 未知状态(git的bug , 可以向git提交bug report)<br></code></pre></td></tr></table></figure><h3 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h3><h5 id="查询本机已配置参数"><a href="#查询本机已配置参数" class="headerlink" title="查询本机已配置参数"></a>查询本机已配置参数</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">git config --list<br></code></pre></td></tr></table></figure><h5 id="签名级别"><a href="#签名级别" class="headerlink" title="签名级别"></a>签名级别</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">system <span class="hljs-comment">// 所有用户(本系统)</span><br><span class="hljs-built_in">global</span> <span class="hljs-comment">// 全局</span><br>local <span class="hljs-comment">// 本地(默认)</span><br></code></pre></td></tr></table></figure><h5 id="配置签名–用户名和邮箱"><a href="#配置签名–用户名和邮箱" class="headerlink" title="配置签名–用户名和邮箱"></a>配置签名–用户名和邮箱</h5><p>Git 提交前，必须配置签名, 即用户名和邮箱 信息会永久保存到历史记录</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">项目级别<br>git config user.name [AAA]<br>git config user.email [邮箱地址]<br><br>系统级别<br>git config --<span class="hljs-built_in">global</span> user.name <span class="hljs-string">&quot;aaa&quot;</span><br>git config --<span class="hljs-built_in">global</span> user.email <span class="hljs-number">111</span>@qq.com<br></code></pre></td></tr></table></figure><h5 id="签名信息位置"><a href="#签名信息位置" class="headerlink" title="签名信息位置"></a>签名信息位置</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">cat.git / config<br></code></pre></td></tr></table></figure><h3 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h3><h5 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">mkdir 新目录名     <span class="hljs-comment">// 创建一个新目录</span><br>cd 新目录名        <span class="hljs-comment">// 进入新目录下</span><br>pwd               <span class="hljs-comment">// 显示当前路径</span><br></code></pre></td></tr></table></figure><h5 id="初始化版本库"><a href="#初始化版本库" class="headerlink" title="初始化版本库"></a>初始化版本库</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">git init<br></code></pre></td></tr></table></figure><h5 id="查看-git-文件"><a href="#查看-git-文件" class="headerlink" title="查看.git 文件"></a>查看.git 文件</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">ls - ah<br></code></pre></td></tr></table></figure><h5 id="添加到仓库暂存区"><a href="#添加到仓库暂存区" class="headerlink" title="添加到仓库暂存区"></a>添加到仓库暂存区</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">git add a.txt index.html<br></code></pre></td></tr></table></figure><h5 id="提交到本地仓库"><a href="#提交到本地仓库" class="headerlink" title="提交到本地仓库"></a>提交到本地仓库</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">git commit -m <span class="hljs-string">&quot;提交说明&quot;</span><br></code></pre></td></tr></table></figure><h5 id="查看当前仓库工作区的状态"><a href="#查看当前仓库工作区的状态" class="headerlink" title="查看当前仓库工作区的状态"></a>查看当前仓库工作区的状态</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">git status<br></code></pre></td></tr></table></figure><h5 id="比较修改的差异"><a href="#比较修改的差异" class="headerlink" title="比较修改的差异"></a>比较修改的差异</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">git diff<br></code></pre></td></tr></table></figure><h5 id="查看提交日志"><a href="#查看提交日志" class="headerlink" title="查看提交日志"></a>查看提交日志</h5><p>16 进制字符串代表 commit id</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">git log                                         <span class="hljs-comment">// 按提交时间列出所有的更新,显示完整信息</span><br>git log --pretty=oneline  <span class="hljs-comment">// 将每个提交放在一行显示,显示完整commit id</span><br>git log --oneline <span class="hljs-comment">// 将每个提交放在一行显示,显示不完整commit id</span><br>git reflog (HEAD@&#123;移动到当前版本&#125;)       <span class="hljs-comment">// 查看之前版本的log,包括删除的,可查找历史commitID</span><br></code></pre></td></tr></table></figure><h5 id="版本回滚"><a href="#版本回滚" class="headerlink" title="版本回滚"></a>版本回滚</h5><p>上一版本<code>HEAD^</code>，上上一版本<code>HEAD^^</code> ，上 100<code>HEAD~100</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">git reset --hard HEAD^<br></code></pre></td></tr></table></figure><h5 id="撤回回滚"><a href="#撤回回滚" class="headerlink" title="撤回回滚"></a>撤回回滚</h5><p>没关闭命令行,a8543 为回退前文件 commitID,只需要前几位就行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">git reset --hard a8543<br></code></pre></td></tr></table></figure><h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><h5 id="克隆项目"><a href="#克隆项目" class="headerlink" title="克隆项目"></a>克隆项目</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">git clone <span class="hljs-string">&#x27;仓库地址&#x27;</span><br></code></pre></td></tr></table></figure><h5 id="关联远程仓库"><a href="#关联远程仓库" class="headerlink" title="关联远程仓库"></a>关联远程仓库</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">git remote add <span class="hljs-string">&#x27;仓库地址&#x27;</span><br></code></pre></td></tr></table></figure><h5 id="查看关联远程库"><a href="#查看关联远程库" class="headerlink" title="查看关联远程库"></a>查看关联远程库</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">git remote -v<br></code></pre></td></tr></table></figure><h5 id="修改关联远程库"><a href="#修改关联远程库" class="headerlink" title="修改关联远程库"></a>修改关联远程库</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">git remote set-url origin <span class="hljs-string">&#x27;仓库地址&#x27;</span><br></code></pre></td></tr></table></figure><h5 id="推送远程仓库"><a href="#推送远程仓库" class="headerlink" title="推送远程仓库"></a>推送远程仓库</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">git push -u origin master   <span class="hljs-comment">// 第一次推送</span><br>git push origin master      <span class="hljs-comment">// 再次推送</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Web相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript常用内置API</title>
    <link href="/blog/2019/03/10/js/JavaScript%E5%B8%B8%E7%94%A8%E5%86%85%E7%BD%AEAPI/"/>
    <url>/blog/2019/03/10/js/JavaScript%E5%B8%B8%E7%94%A8%E5%86%85%E7%BD%AEAPI/</url>
    
    <content type="html"><![CDATA[<h3 id="JS-简述"><a href="#JS-简述" class="headerlink" title="JS 简述"></a>JS 简述</h3><h5 id="三大对象"><a href="#三大对象" class="headerlink" title="三大对象"></a>三大对象</h5><h6 id="本地对象"><a href="#本地对象" class="headerlink" title="本地对象"></a>本地对象</h6><ul><li>与宿主无关，独立于宿主环境的 ECMAScript 实现提供的对象</li><li>简单来说，本地对象就是 <code>ECMA-262</code> 定义的类（引用类型）</li><li>这些引用类型在运行过程中需要通过 <code>new</code> 来创建所需的实例对象</li></ul><p>包括：</p><p>引用类型：<code>Object</code>、<code>Function</code>、<code>Array</code>、<code>Date</code>、<code>RegExp</code></p><p>基本包装类型：<code>String</code>、<code>Boolean</code>、<code>Number</code></p><p>其他类型：<code>Error</code>、<code>EvalError</code>、<code>RangeError</code>、<code>ReferenceError</code>、<code>SyntaxError</code>、<code>TypeError</code>、<code>URIError</code>等</p><h6 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h6><ul><li>与宿主无关，独立于宿主环境的 ECMAScript 实现提供的对象，在 ECMAScript 程序开始执行时出现</li><li>在 <code>ECMAScript</code> 程序开始执行前就存在，本身就是实例化内置对象，开发者无需再去实例化</li><li>内置对象是本地对象的子集</li><li>很多时候，会直接把本地对象和内置对象统称为内置对象，也被叫做单体内置对象</li></ul><p>包含：</p><p><code>Global</code>和<code>Math</code></p><p><code>ECMAScript5</code>中增添了<code>JSON</code>这个存在于全局的内置对象</p><h6 id="宿主对象"><a href="#宿主对象" class="headerlink" title="宿主对象"></a>宿主对象</h6><ul><li>由 ECMAScript 实现的宿主环境提供的对象，包含两大类，一个是宿主提供，一个是自定义类对象</li><li>所有非本地对象都属于宿主对象</li><li>对于嵌入到网页中的 JS 来说，其宿主对象就是浏览器提供的对象，浏览器对象有很多，如<code>Window</code>和<code>Document</code>等</li><li>所有的<code>DOM</code>和<code>BOM</code>对象都属于宿主对象</li></ul><p>包括：</p><ol><li><p>宿主提供的对象</p><p>a. BOM&amp;DOM 等</p></li><li><p>自定义对象</p><p>a. 对象直接量（字面量）</p><p>b. new 操作符跟构造函数</p><p>c. function 对象</p></li></ol><h5 id="两大属性"><a href="#两大属性" class="headerlink" title="两大属性"></a>两大属性</h5><h6 id="自有-实例-属性"><a href="#自有-实例-属性" class="headerlink" title="自有(实例)属性"></a>自有(实例)属性</h6><p>也可叫实例属性：指对象自身的属性，也就是直接在对象中定义的属性</p><h6 id="私有-原型-属性"><a href="#私有-原型-属性" class="headerlink" title="私有(原型)属性"></a>私有(原型)属性</h6><p>也可叫原型属性：指对象从原型中继承的属性，也就是在对象的原型对象中定义的属性</p><h3 id="String-对象"><a href="#String-对象" class="headerlink" title="String 对象"></a>String 对象</h3><h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><h6 id="str-length"><a href="#str-length" class="headerlink" title="str.length"></a>str.length</h6><p>返回字符串的长度</p><h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><h6 id="charAt"><a href="#charAt" class="headerlink" title="charAt()"></a>charAt()</h6><p>功能：返回指定位置的字符</p><p>参数：必须，为目标字符的下标位置</p><blockquote><p>若参数 index 不在 0 与 string.length 之间，该方法将返回一个空字符串</p></blockquote><h6 id="charCodeAt"><a href="#charCodeAt" class="headerlink" title="charCodeAt()"></a>charCodeAt()</h6><p>功能：返回在指定位置的字符的 Unicode 编码</p><p>参数：必须，为目标字符的下标位置</p><blockquote><p>若参数 index 不在 0 与 string.length 之间，该方法将返回 NaN</p></blockquote><h6 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf()"></a>indexOf()</h6><p>功能：检索字符串，返回指定子字符串在字符串中首次出现的位置。</p><p>参数 1：检索目标子字符串，必须</p><p>参数 2：在字符串中开始检索的位置，可选。省略该参数，则将从字符串的首字符开始检索</p><blockquote><p>indexOf() 方法对大小写敏感</p><p>如果要检索的字符串值没有出现，则该方法返回 -1</p></blockquote><h6 id="lastIndexOf"><a href="#lastIndexOf" class="headerlink" title="lastIndexOf()"></a>lastIndexOf()</h6><p>功能：从后向前搜索字符串，返回指定子字符串在字符串中首次出现的位置</p><p>参数 1：检索目标子字符串，必须</p><p>参数 2：在字符串中开始检索的位置，可选。省略该参数，则将从字符串的最后一个字符开始检索</p><h6 id="match"><a href="#match" class="headerlink" title="match()"></a>match()</h6><p>功能：返回指定位置的字符</p><p>参数：必须，规定要检索的字符串值或待匹配的 RegExp 对象</p><p>返回值：存放匹配结果的数组。该数组的内容依赖于 regexp 是否具有全局标志 g</p><blockquote><p>regexp 没有 g，match() 方法只执行一次匹配，如果没有找到任何匹配的文本， match() 将返回 null，否则，它将返回一个数组，其中存放了与它找到的匹配文本有关的信息，该数组的第 0 个元素存放的是匹配文本，返回的数组还含有两个对象属性：index 属性为 stringObject 中的索引，input 属性是对 stringObject 的引用</p><p>regexp 具有标志 g，则 match() 方法将执行全局检索，找到 stringObject 中的所有匹配子字符串。若没有找到子串，返回 null。如果找到了一个或多个匹配子串，则返回一个数组。返回数组元素中存放的是 stringObject 中所有的匹配子串，没有 index 属性或 input 属性</p></blockquote><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> s = <span class="hljs-string">&quot;hello23 world23&quot;</span><br><span class="hljs-built_in">console</span>.log(s.match(<span class="hljs-regexp">/\d&#123;2&#125;/</span>)) <span class="hljs-comment">//[ &#x27;23&#x27;, index: 5, input: &#x27;hello21 world21&#x27; ]</span><br><br><span class="hljs-keyword">let</span> s = <span class="hljs-string">&quot;hello23 world23&quot;</span><br><span class="hljs-built_in">console</span>.log(s.match(<span class="hljs-regexp">/\d&#123;2&#125;/g</span>)) <span class="hljs-comment">//[ &#x27;23&#x27;, &#x27;23&#x27; ]</span><br></code></pre></td></tr></table></figure><h6 id="replace"><a href="#replace" class="headerlink" title="replace()"></a>replace()</h6><p>功能：在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。</p><p>参数 1：regexp/substr，必须，规定子字符串或要匹配的 RegExp 对象</p><p>参数 2：replacement，必须，用于替换的字符串值</p><p>返回值：替换后的一个新字符串</p><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> s = <span class="hljs-string">&quot;hello world hello&quot;</span><br><span class="hljs-built_in">console</span>.log(s.replace(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;hi&quot;</span>)) <span class="hljs-comment">//hi world hello</span><br><span class="hljs-built_in">console</span>.log(s.replace(<span class="hljs-regexp">/hello/</span>, <span class="hljs-string">&quot;hi&quot;</span>)) <span class="hljs-comment">//hi world hello</span><br><span class="hljs-built_in">console</span>.log(s.replace(<span class="hljs-regexp">/hello/g</span>, <span class="hljs-string">&quot;hi&quot;</span>)) <span class="hljs-comment">//hi world hi</span><br></code></pre></td></tr></table></figure><blockquote><p>方法返回一个新字符串，不会修改原字符串</p></blockquote><h6 id="search"><a href="#search" class="headerlink" title="search()"></a>search()</h6><p>功能：检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串</p><p>参数：regexp/substr，必须，规定子字符串或要匹配的 RegExp 对象</p><p>返回值：原字符串中第一次匹配到目标字符串的起始位置</p><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> s = <span class="hljs-string">&quot;hello world hello&quot;</span><br><span class="hljs-built_in">console</span>.log(s.search(<span class="hljs-string">&quot;hello&quot;</span>)) <span class="hljs-comment">//0</span><br><span class="hljs-built_in">console</span>.log(s.search(<span class="hljs-regexp">/hello/g</span>)) <span class="hljs-comment">//0</span><br><span class="hljs-built_in">console</span>.log(s.search(<span class="hljs-regexp">/hello2/</span>)) <span class="hljs-comment">//-1</span><br></code></pre></td></tr></table></figure><blockquote><p>方法不执行全局匹配，它将忽略标志 g。也就是说，它只匹配一次。若没匹配到结果，则返回-1</p></blockquote><p>toLowerCase()</p><p>功能：把字符串转换为小写</p><p>返回值：一个新字符串</p><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> s = <span class="hljs-string">&quot;Hello World&quot;</span><br><span class="hljs-built_in">console</span>.log(s.toLowerCase()) <span class="hljs-comment">//hello world</span><br></code></pre></td></tr></table></figure><p>toUpperCase()</p><p>功能：把字符串转换为大写</p><p>返回值：一个新字符串</p><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> s = <span class="hljs-string">&quot;Hello World&quot;</span><br><span class="hljs-built_in">console</span>.log(s.toUpperCase()) <span class="hljs-comment">//HELLO WORLD</span><br></code></pre></td></tr></table></figure><h6 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h6><p>功能：用于连接两个或多个字符串</p><p>语法：stringObject.concat(stringX,stringX,…,stringX)</p><p>返回值：衔接后的新字符串</p><blockquote><p>concat 方法不会修改原字符串</p><p>stringObject.concat() 与 Array.concat() 很相似</p><p>通常使用 “ + “ 运算符来进行字符串的连接运算通常会更简便一些</p></blockquote><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> s1 = <span class="hljs-string">&quot;hello &quot;</span><br><span class="hljs-keyword">var</span> s2 = <span class="hljs-string">&quot;world &quot;</span><br><span class="hljs-keyword">var</span> s3 = <span class="hljs-string">&quot;001&quot;</span><br><span class="hljs-built_in">console</span>.log(s1.concat(s2, s3)) <span class="hljs-comment">//hello world 001</span><br></code></pre></td></tr></table></figure><h6 id="split"><a href="#split" class="headerlink" title="split()"></a>split()</h6><p>功能：把一个字符串分割成字符串数组，Array.join( ) 的逆操作</p><p>参数 1：separator，必须，字符串或正则表达式，从该参数指定的地方分割原字符串</p><p>参数 2：howmany，可选，指定返回数组的最大长度</p><p>返回值：一个字符串数组</p><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> s = <span class="hljs-string">&quot;he llo&quot;</span><br><span class="hljs-built_in">console</span>.log(s.split(<span class="hljs-string">&quot;&quot;</span>)) <span class="hljs-comment">//[ &#x27;h&#x27;, &#x27;e&#x27;, &#x27; &#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27; ]</span><br><span class="hljs-built_in">console</span>.log(s.split(<span class="hljs-string">&quot; &quot;</span>)) <span class="hljs-comment">//[ &#x27;he&#x27;, &#x27;llo&#x27; ]</span><br><span class="hljs-built_in">console</span>.log(s.split(<span class="hljs-string">&quot;l&quot;</span>)) <span class="hljs-comment">//[&quot;he &quot;, &quot;&quot;, &quot;o&quot;]</span><br></code></pre></td></tr></table></figure><h6 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h6><p>功能：截取字符串的某个部分</p><p>参数 1：截取的起始位置，必须</p><p>参数 2：截取的结束位置，可选</p><p>返回值：截取部分，一个新的字符串</p><blockquote><p>String.slice() 与 Array.slice() 相似</p><p>slice 方法的两个参数接受负值，若为负数，则该参数规定的是从字符串的尾部开始算起的位置。也就是说，-1 指字符串的最后一个字符，-2 指倒数第二个字符，以此类推。 未指定第二个参数，则默认截取至字符串的末尾。 slice 方法不修改原字符串</p></blockquote><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> s = <span class="hljs-string">&quot;he llo&quot;</span><br><span class="hljs-built_in">console</span>.log(s.slice(<span class="hljs-number">3</span>)) <span class="hljs-comment">//llo</span><br><span class="hljs-built_in">console</span>.log(s.slice(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>)) <span class="hljs-comment">//e ll</span><br><span class="hljs-built_in">console</span>.log(s.slice(-<span class="hljs-number">5</span>)) <span class="hljs-comment">//e llo</span><br><span class="hljs-built_in">console</span>.log(s.slice(-<span class="hljs-number">5</span>, -<span class="hljs-number">1</span>)) <span class="hljs-comment">//e ll</span><br></code></pre></td></tr></table></figure><h6 id="substr"><a href="#substr" class="headerlink" title="substr()"></a>substr()</h6><p>功能：截取从指定下标开始的指定数目的字符</p><p>参数 1：start，必须，截取的起始位置，接受负值</p><p>参数 2：length，可选，截取字符串的长度，未指定，则默认截取到原字符串的末尾</p><p>返回值：截取部分，一个新的字符串</p><blockquote><p>ECMAscript 中未对该方法进行标准化，不建议使用</p></blockquote><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> s = <span class="hljs-string">&quot;he llo&quot;</span><br><span class="hljs-built_in">console</span>.log(s.substr(<span class="hljs-number">3</span>)) <span class="hljs-comment">//llo</span><br><span class="hljs-built_in">console</span>.log(s.substr(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>)) <span class="hljs-comment">//ll</span><br><span class="hljs-built_in">console</span>.log(s.substr(-<span class="hljs-number">3</span>, <span class="hljs-number">2</span>)) <span class="hljs-comment">//ll</span><br></code></pre></td></tr></table></figure><h6 id="substring"><a href="#substring" class="headerlink" title="substring()"></a>substring()</h6><p>功能：截取字符串中介于两个指定下标之间的字符</p><p>参数 1：start，必须，截取的起始位置</p><p>参数 2：end，可选，截取的结束位置，未指定，则默认截取到原字符串的末尾</p><p>返回值：截取部分，一个新的字符串</p><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> s = <span class="hljs-string">&quot;he llo&quot;</span><br><span class="hljs-built_in">console</span>.log(s.substring(<span class="hljs-number">3</span>)) <span class="hljs-comment">//llo</span><br><span class="hljs-built_in">console</span>.log(s.substring(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>)) <span class="hljs-comment">//ll</span><br><span class="hljs-built_in">console</span>.log(s.substring(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>)) <span class="hljs-comment">//ll</span><br><span class="hljs-built_in">console</span>.log(s.substring(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>)) <span class="hljs-comment">//&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><blockquote><p>与 slice() 和 substr() 方法不同的是，substring() 不接受负的参数</p><p>如果参数 start 与 stop 相等，那么该方法返回的一个空串</p><p>如果 start 比 stop 大，那么该方法在提取子串之前会先交换这两个参数</p></blockquote><h6 id="trim"><a href="#trim" class="headerlink" title="trim()"></a>trim()</h6><p>功能：去除字符串的头尾空格</p><h3 id="Array-对象"><a href="#Array-对象" class="headerlink" title="Array 对象"></a>Array 对象</h3><h5 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h5><h6 id="length"><a href="#length" class="headerlink" title="length"></a>length</h6><p>返回数组中元素的数目</p><blockquote><p>设置 length 属性可改变数组的大小。如果设置的值比其当前值小，数组将被截断，其尾部的元素将丢失。如果设置的值比它的当前值大，数组将增大，新的元素被添加到数组的尾部，它们的值为 undefined</p></blockquote><h6 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h6><p>数组对象构造器，返回对创建此对象的数组函数的引用</p><h6 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h6><p>数组对象原型，用于向对象添加属性和方法</p><h5 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h5><h6 id="concat-1"><a href="#concat-1" class="headerlink" title="concat()"></a>concat()</h6><p>用于拼接数组，不会改变原有数组</p><blockquote><p>如果要进行 concat() 操作的参数是数组，那么添加的是数组中的元素，而不是数组</p></blockquote><h6 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h6><p>把数组中的所有元素放入一个字符串，元素是通过指定的分隔符进行分隔的</p><blockquote><p>若省略了分隔符参数，则默认使用逗号作为分隔符</p></blockquote><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>arr.join() <span class="hljs-comment">// &#x27;1,2,3&#x27;</span><br>arr.join(<span class="hljs-number">0</span>) <span class="hljs-comment">// &#x27;10203&#x27;</span><br></code></pre></td></tr></table></figure><h6 id="push"><a href="#push" class="headerlink" title="push()"></a>push()</h6><p>向数组的末尾添加一个或多个元素，返回新的数组长度</p><h6 id="pop"><a href="#pop" class="headerlink" title="pop()"></a>pop()</h6><p>用于删除数组的最后一个元素，把数组长度减 1，返回被删除元素</p><blockquote><p>如果数组已经为空，则 pop() 不改变数组，并返回 undefined</p></blockquote><h6 id="shift"><a href="#shift" class="headerlink" title="shift()"></a>shift()</h6><p>用于把数组的第一个元素从其中删除，并返回被移除的这个元素</p><blockquote><p>如果数组是空的，那么 shift() 方法将不进行任何操作，返回 undefined</p><p>该方法直接修改原数组</p></blockquote><h6 id="unshift"><a href="#unshift" class="headerlink" title="unshift()"></a>unshift()</h6><p>向数组的开头添加一个或更多元素，并返回新的数组长度</p><blockquote><p>该方法直接修改原数组</p></blockquote><h6 id="reverse"><a href="#reverse" class="headerlink" title="reverse()"></a>reverse()</h6><p>用于反转数组中元素顺序</p><p>该方法直接修改原数组，不会创建新数组</p><h6 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h6><p>用于对数组的元素进行排序</p><p>该排序直接修改原数组</p><p>该方法接受一个可选参数，若未使用参数，将按字母顺序对数组元素进行排序，说得更精确点，是按照字符编码的顺序进行排序。要实现这一点，首先应把数组的元素都转换成字符串（如有必要），以便进行比较。</p><p>如果想按照其他标准进行排序，就需要提供比较函数，该函数要比较两个值，然后返回一个用于说明这两个值的相对顺序的数字。比较函数应该具有两个参数 a 和 b，其返回值如下：</p><ul><li>若 a 小于 b，排序后 a 应该在 b 之前，则返回一个小于 0 的值</li><li>若 a 等于 b，则返回 0。</li><li>若 a 大于 b，则返回一个大于 0 的值</li></ul><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js">arr1 = [<span class="hljs-string">&quot;tom&quot;</span>, <span class="hljs-string">&quot;array&quot;</span>, <span class="hljs-string">&quot;obj&quot;</span>, <span class="hljs-string">&quot;string&quot;</span>, <span class="hljs-string">&quot;bool&quot;</span>]<br>arr1.sort() <span class="hljs-comment">// [&quot;array&quot;, &quot;bool&quot;, &quot;obj&quot;, &quot;string&quot;, &quot;tom&quot;] 按照字母顺序</span><br><br>arr2 = [<span class="hljs-number">1</span>, <span class="hljs-number">20</span>, <span class="hljs-number">90</span>, <span class="hljs-number">21</span>, <span class="hljs-number">1000</span>, <span class="hljs-number">300</span>]<br>arr2.sort() <span class="hljs-comment">// [1, 1000, 20, 21, 300, 90]</span><br><br>arr2.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> a - b<br>&#125;) <span class="hljs-comment">// [1, 20, 21, 90, 300, 1000]</span><br><br>arr2.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> b - a<br>&#125;) <span class="hljs-comment">// [1000, 300, 90, 21, 20, 1]</span><br></code></pre></td></tr></table></figure><h6 id="slice-1"><a href="#slice-1" class="headerlink" title="slice()"></a>slice()</h6><p>参数：start [,end]</p><p>截取原数组从 start 到 end 位置（不包含它）元素组成的子数组</p><blockquote><p>该方法返回一个新数组，不会修改原数组</p><p>若未指定 end 参数，那么截取 start 直到原数组最后一个元素（包含它）</p></blockquote><h6 id="splice"><a href="#splice" class="headerlink" title="splice()"></a>splice()</h6><p>参数：index,howmany [,item1,item2…]</p><p>删除从 index 处开始的 hownamy 个元素，并且用可选参数列表中声明的一个或多个值来替换那些被删除的元素</p><blockquote><p>该方法返回的是含有被删除的元素组成的数组，若无被删元素，则返回空数组。</p><p>若参数只有 index，那么原数组将从 index 开始删除直至结尾。</p><p>该方法直接修改原数组</p></blockquote><h6 id="includes"><a href="#includes" class="headerlink" title="includes()"></a>includes()</h6><p>参数:1:必须,要判断的元素 2:可选,表示判断的起始位置,可为负数</p><p>返回值:true||false</p><blockquote><p>ES6 数组方法</p><p>判断数组是否包含某一元素</p><p>它直接返回 true 或者 false 表示是否包含元素，对 NaN 一样能有有效</p></blockquote><h6 id="forEach-v-i-a-gt"><a href="#forEach-v-i-a-gt" class="headerlink" title="forEach((v,i,a)=&gt;{})"></a>forEach((v,i,a)=&gt;{})</h6><p>作用：让数组的每一项都执行一次给定的 callback</p><p>参数：callback v 表示当前项的值，i 表示当前索引，a 表示数组本身</p><blockquote><p>forEach 遍历的范围在第一次调用 callback 前就会确定。调用 forEach 后添加到数组中的项不会被 callback 访问到。如果已经存在的值被改变，则传递给 callback 的值是 forEach 遍历到他们那一刻的值。已删除的项不会被遍历到</p></blockquote><h6 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h6><p>参数：map(callback, thisValue)</p><blockquote><p>callback 为必须项，(currentValue,index,arr)=&gt;{}</p><p><em>currentValue</em> 必须。当前元素的值</p><p><em>index</em> 可选。当前元素的索引值</p><p><em>arr</em> 可选。当前元素属于的数组对象</p><p>thisValue 可选。对象作为该执行回调时使用，传递给函数，用作 “this” 的值。 如果省略了 thisValue，或者传入 null、undefined，那么回调函数的 this 为全局对象</p></blockquote><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> numbers = [<span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">16</span>, <span class="hljs-number">25</span>]<br>numbers.map(<span class="hljs-built_in">Math</span>.sqrt) <span class="hljs-comment">// 2,3,4,5</span><br></code></pre></td></tr></table></figure><h3 id="Number-对象"><a href="#Number-对象" class="headerlink" title="Number 对象"></a>Number 对象</h3><h5 id="toExponential"><a href="#toExponential" class="headerlink" title="toExponential()"></a>toExponential()</h5><p>把对象的值转换为指数计数法</p><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> num = <span class="hljs-number">5.56789</span><br><span class="hljs-keyword">var</span> n = num.toExponential() <span class="hljs-comment">// 5.56789e+0</span><br></code></pre></td></tr></table></figure><h5 id="toFixed"><a href="#toFixed" class="headerlink" title="toFixed()"></a>toFixed()</h5><p>把数字转换为字符串，结果的小数点后有指定位数的数字</p><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> num = <span class="hljs-number">5.56789</span><br><span class="hljs-keyword">var</span> n = num.toFixed(<span class="hljs-number">2</span>) <span class="hljs-comment">// 5.57</span><br></code></pre></td></tr></table></figure><h5 id="toPrecision"><a href="#toPrecision" class="headerlink" title="toPrecision()"></a>toPrecision()</h5><p>把数字格式化为指定的长度</p><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> num = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Number</span>(<span class="hljs-number">13.3714</span>)<br><span class="hljs-keyword">var</span> n = num.toPrecision(<span class="hljs-number">2</span>) <span class="hljs-comment">// 13</span><br></code></pre></td></tr></table></figure><h3 id="JSON-对象"><a href="#JSON-对象" class="headerlink" title="JSON 对象"></a>JSON 对象</h3><h5 id="JSON-parse"><a href="#JSON-parse" class="headerlink" title="JSON.parse()"></a>JSON.parse()</h5><p>功能：将字符串反序列化成对象</p><p>参数：JSON 字符串</p><p>返回值：对象</p><h5 id="JSON-stringify"><a href="#JSON-stringify" class="headerlink" title="JSON.stringify()"></a>JSON.stringify()</h5><p>功能：将一个对象解析为 JSON 字符串</p><p>参数：对象</p><p>返回值：JSON 字符串</p><blockquote><p>该字符串应该符合 JSON 格式，并且可以被 JSON.parse 方法还原</p><p>JSON.stringify(obj, selectedProperties)还可以接受一个数组</p><p>作为第二个参数，指定需要转成字符串的属性</p><p>还可以接受第三个参数，用于增加返回的 JSON 字符串的可读性</p><p>如果是数字，表示每个属性前面添加的空格（最多不超过 10 个）</p><p>如果是字符串（不超过 10 个字符），则该字符串会添加在每行前面</p></blockquote><h3 id="Math-对象"><a href="#Math-对象" class="headerlink" title="Math 对象"></a>Math 对象</h3><h5 id="属性-2"><a href="#属性-2" class="headerlink" title="属性"></a>属性</h5><h6 id="Math-E"><a href="#Math-E" class="headerlink" title="Math.E"></a>Math.E</h6><p>常数 e</p><h6 id="Math-LN2"><a href="#Math-LN2" class="headerlink" title="Math.LN2"></a>Math.LN2</h6><p>2 的自然对数</p><h6 id="Math-LN10"><a href="#Math-LN10" class="headerlink" title="Math.LN10"></a>Math.LN10</h6><p>10 的自然对数</p><h6 id="Math-LOG2E"><a href="#Math-LOG2E" class="headerlink" title="Math.LOG2E"></a>Math.LOG2E</h6><p>以 2 为底的 e 的对数</p><h6 id="Math-LOG10E"><a href="#Math-LOG10E" class="headerlink" title="Math.LOG10E"></a>Math.LOG10E</h6><p>以 10 为底的 e 的对数</p><h6 id="Math-PI"><a href="#Math-PI" class="headerlink" title="Math.PI"></a>Math.PI</h6><p>常数 Pi</p><h6 id="Math-SQRT1-2"><a href="#Math-SQRT1-2" class="headerlink" title="Math.SQRT1_2"></a>Math.SQRT1_2</h6><p>0.5 的平方根</p><h6 id="Math-SQRT2"><a href="#Math-SQRT2" class="headerlink" title="Math.SQRT2"></a>Math.SQRT2</h6><p>2 的平方根</p><h5 id="数学方法"><a href="#数学方法" class="headerlink" title="数学方法"></a>数学方法</h5><h6 id="Math-abs"><a href="#Math-abs" class="headerlink" title="Math.abs()"></a>Math.abs()</h6><p>返回参数的绝对值</p><h6 id="Math-ceil"><a href="#Math-ceil" class="headerlink" title="Math.ceil()"></a>Math.ceil()</h6><p>向上取整，接受一个参数，返回大于该参数的最小整数</p><h6 id="Math-floor"><a href="#Math-floor" class="headerlink" title="Math.floor()"></a>Math.floor()</h6><p>向下取整</p><h6 id="Math-max-n-n1-…"><a href="#Math-max-n-n1-…" class="headerlink" title="Math.max(n,n1,…)"></a>Math.max(n,n1,…)</h6><p>可接受多个参数，返回最大值</p><h6 id="Math-min-n-n1"><a href="#Math-min-n-n1" class="headerlink" title="Math.min(n,n1,..)"></a>Math.min(n,n1,..)</h6><p>可接受多个参数，返回最小值</p><h6 id="Math-pow-n-e"><a href="#Math-pow-n-e" class="headerlink" title="Math.pow(n,e)"></a>Math.pow(n,e)</h6><p>指数运算, 返回以第一个参数为底数、第二个参数为幂的指数值</p><h6 id="Math-sqrt"><a href="#Math-sqrt" class="headerlink" title="Math.sqrt()"></a>Math.sqrt()</h6><p>返回参数值的平方根。如果参数是一个负值，则返回 NaN</p><h6 id="Math-log"><a href="#Math-log" class="headerlink" title="Math.log()"></a>Math.log()</h6><p>返回以 e 为底的自然对数值</p><h6 id="Math-exp"><a href="#Math-exp" class="headerlink" title="Math.exp()"></a>Math.exp()</h6><p>返回 e 的指数，也就是常数 e 的参数次方</p><h6 id="Math-round"><a href="#Math-round" class="headerlink" title="Math.round()"></a>Math.round()</h6><p>四舍五入</p><h6 id="Math-random"><a href="#Math-random" class="headerlink" title="Math.random()"></a>Math.random()</h6><p>返回 0 到 1 之间的一个伪随机数，可能等于 0，但是一定小于 1。</p><h5 id="三角函数方法"><a href="#三角函数方法" class="headerlink" title="三角函数方法"></a>三角函数方法</h5><h6 id="Math-sin"><a href="#Math-sin" class="headerlink" title="Math.sin()"></a>Math.sin()</h6><p>返回参数的正弦</p><h6 id="Math-cos"><a href="#Math-cos" class="headerlink" title="Math.cos()"></a>Math.cos()</h6><p>返回参数的余弦</p><h6 id="Math-tan"><a href="#Math-tan" class="headerlink" title="Math.tan()"></a>Math.tan()</h6><p>返回参数的正切</p><h6 id="Math-asin"><a href="#Math-asin" class="headerlink" title="Math.asin()"></a>Math.asin()</h6><p>返回参数的反正弦（弧度值）</p><h6 id="Math-acos"><a href="#Math-acos" class="headerlink" title="Math.acos()"></a>Math.acos()</h6><p>返回参数的反余弦（弧度值）</p><h6 id="Math-atan"><a href="#Math-atan" class="headerlink" title="Math.atan()"></a>Math.atan()</h6><p>返回参数的反正切（弧度值）</p><h3 id="Date-对象"><a href="#Date-对象" class="headerlink" title="Date 对象"></a>Date 对象</h3><h5 id="Date"><a href="#Date" class="headerlink" title="Date()"></a>Date()</h5><p>返回当日的日期和时间</p><h5 id="getDate"><a href="#getDate" class="headerlink" title="getDate()"></a>getDate()</h5><p>从 Date 对象返回一个月中的某一天 (1 ~ 31)</p><h5 id="getDay"><a href="#getDay" class="headerlink" title="getDay()"></a>getDay()</h5><p>从 Date 对象返回一周中的某一天 (0 ~ 6)</p><h5 id="getMonth"><a href="#getMonth" class="headerlink" title="getMonth()"></a>getMonth()</h5><p>从 Date 对象返回月份 (0 ~ 11)</p><h5 id="getFullYear"><a href="#getFullYear" class="headerlink" title="getFullYear()"></a>getFullYear()</h5><p>从 Date 对象以四位数字返回年份</p><h5 id="getYear"><a href="#getYear" class="headerlink" title="getYear()"></a>getYear()</h5><p>ECMAScript v3 开始，JavaScript 的实现就不再使用该方法， 请使用 getFullYear() 方法代替</p><h5 id="getHours"><a href="#getHours" class="headerlink" title="getHours()"></a>getHours()</h5><p>返回 Date 对象的小时 (0 ~ 23)</p><h5 id="getMinutes"><a href="#getMinutes" class="headerlink" title="getMinutes()"></a>getMinutes()</h5><p>返回 Date 对象的分钟 (0 ~ 59)</p><h5 id="getSeconds"><a href="#getSeconds" class="headerlink" title="getSeconds()"></a>getSeconds()</h5><p>返回 Date 对象的秒数 (0 ~ 59)</p><h5 id="getMilliseconds"><a href="#getMilliseconds" class="headerlink" title="getMilliseconds()"></a>getMilliseconds()</h5><p>返回 Date 对象的毫秒(0 ~ 999)</p><h5 id="getTime"><a href="#getTime" class="headerlink" title="getTime()"></a>getTime()</h5><p>返回 1970 年 1 月 1 日至今的毫秒数</p><h5 id="getTimezoneOffset"><a href="#getTimezoneOffset" class="headerlink" title="getTimezoneOffset()"></a>getTimezoneOffset()</h5><p>返回本地时间与格林威治标准时间 (GMT) 的分钟差</p><h5 id="getUTCDate"><a href="#getUTCDate" class="headerlink" title="getUTCDate()"></a>getUTCDate()</h5><p>根据世界时从 Date 对象返回月中的一天 (1 ~ 31)</p><h5 id="getUTCDay"><a href="#getUTCDay" class="headerlink" title="getUTCDay()"></a>getUTCDay()</h5><p>根据世界时从 Date 对象返回周中的一天 (0 ~ 6)</p><h5 id="getUTCMonth"><a href="#getUTCMonth" class="headerlink" title="getUTCMonth()"></a>getUTCMonth()</h5><p>根据世界时从 Date 对象返回月份 (0 ~ 11)</p><h5 id="getUTCFullYear"><a href="#getUTCFullYear" class="headerlink" title="getUTCFullYear()"></a>getUTCFullYear()</h5><p>根据世界时从 Date 对象返回四位数的年份</p><h5 id="getUTCHours"><a href="#getUTCHours" class="headerlink" title="getUTCHours()"></a>getUTCHours()</h5><p>根据世界时返回 Date 对象的小时 (0 ~ 23)</p><h5 id="getUTCMinutes"><a href="#getUTCMinutes" class="headerlink" title="getUTCMinutes()"></a>getUTCMinutes()</h5><p>根据世界时返回 Date 对象的分钟 (0 ~ 59)</p><h5 id="getUTCSeconds"><a href="#getUTCSeconds" class="headerlink" title="getUTCSeconds()"></a>getUTCSeconds()</h5><p>根据世界时返回 Date 对象的秒钟 (0 ~ 59)</p><h5 id="getUTCMilliseconds"><a href="#getUTCMilliseconds" class="headerlink" title="getUTCMilliseconds()"></a>getUTCMilliseconds()</h5><p>根据世界时返回 Date 对象的毫秒(0 ~ 999)</p><h5 id="parse"><a href="#parse" class="headerlink" title="parse()"></a>parse()</h5><p>返回 1970 年 1 月 1 日午夜到指定日期（字符串）的毫秒数</p><h5 id="setDate"><a href="#setDate" class="headerlink" title="setDate()"></a>setDate()</h5><p>设置 Date 对象中月的某一天 (1 ~ 31)</p><h5 id="setMonth"><a href="#setMonth" class="headerlink" title="setMonth()"></a>setMonth()</h5><p>设置 Date 对象中月份 (0 ~ 11)</p><h5 id="setFullYear"><a href="#setFullYear" class="headerlink" title="setFullYear()"></a>setFullYear()</h5><p>设置 Date 对象中的年份（四位数字）</p><h5 id="setYear"><a href="#setYear" class="headerlink" title="setYear()"></a>setYear()</h5><p>请使用 setFullYear() 方法代替</p><h5 id="setHours"><a href="#setHours" class="headerlink" title="setHours()"></a>setHours()</h5><p>设置 Date 对象中的小时 (0 ~ 23)</p><h5 id="setMinutes"><a href="#setMinutes" class="headerlink" title="setMinutes()"></a>setMinutes()</h5><p>设置 Date 对象中的分钟 (0 ~ 59)</p><h5 id="setSeconds"><a href="#setSeconds" class="headerlink" title="setSeconds()"></a>setSeconds()</h5><p>设置 Date 对象中的秒钟 (0 ~ 59)</p><h5 id="setMilliseconds"><a href="#setMilliseconds" class="headerlink" title="setMilliseconds()"></a>setMilliseconds()</h5><p>设置 Date 对象中的毫秒 (0 ~ 999)</p><h5 id="setTime"><a href="#setTime" class="headerlink" title="setTime()"></a>setTime()</h5><p>以毫秒设置 Date 对象</p><h5 id="setUTCDate"><a href="#setUTCDate" class="headerlink" title="setUTCDate()"></a>setUTCDate()</h5><p>根据世界时设置 Date 对象中月份的一天 (1 ~ 31)</p><h5 id="setUTCMonth"><a href="#setUTCMonth" class="headerlink" title="setUTCMonth()"></a>setUTCMonth()</h5><p>根据世界时设置 Date 对象中的月份 (0 ~ 11)</p><h5 id="setUTCFullYear"><a href="#setUTCFullYear" class="headerlink" title="setUTCFullYear()"></a>setUTCFullYear()</h5><p>根据世界时设置 Date 对象中的年份（四位数字）</p><h5 id="setUTCHours"><a href="#setUTCHours" class="headerlink" title="setUTCHours()"></a>setUTCHours()</h5><p>根据世界时设置 Date 对象中的小时 (0 ~ 23)</p><h5 id="setUTCMinutes"><a href="#setUTCMinutes" class="headerlink" title="setUTCMinutes()"></a>setUTCMinutes()</h5><p>根据世界时设置 Date 对象中的分钟 (0 ~ 59)</p><h5 id="setUTCSeconds"><a href="#setUTCSeconds" class="headerlink" title="setUTCSeconds()"></a>setUTCSeconds()</h5><p>根据世界时设置 Date 对象中的秒钟 (0 ~ 59)</p><h5 id="setUTCMilliseconds"><a href="#setUTCMilliseconds" class="headerlink" title="setUTCMilliseconds()"></a>setUTCMilliseconds()</h5><p>根据世界时设置 Date 对象中的毫秒 (0 ~ 999)</p><h5 id="toSource"><a href="#toSource" class="headerlink" title="toSource()"></a>toSource()</h5><p>返回该对象的源代码</p><h5 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h5><p>把 Date 对象转换为字符串</p><h5 id="toTimeString"><a href="#toTimeString" class="headerlink" title="toTimeString()"></a>toTimeString()</h5><p>把 Date 对象的时间部分转换为字符串</p><h5 id="toDateString"><a href="#toDateString" class="headerlink" title="toDateString()"></a>toDateString()</h5><p>把 Date 对象的日期部分转换为字符串</p><h5 id="toGMTString"><a href="#toGMTString" class="headerlink" title="toGMTString()"></a>toGMTString()</h5><p>请使用 toUTCString() 方法代替</p><h5 id="toUTCString"><a href="#toUTCString" class="headerlink" title="toUTCString()"></a>toUTCString()</h5><p>根据世界时，把 Date 对象转换为字符串</p><h5 id="toLocaleString-NaN"><a href="#toLocaleString-NaN" class="headerlink" title="toLocaleString()"></a>toLocaleString()</h5><p>根据本地时间格式，把 Date 对象转换为字符串</p><h5 id="toLocaleTimeString"><a href="#toLocaleTimeString" class="headerlink" title="toLocaleTimeString()"></a>toLocaleTimeString()</h5><p>根据本地时间格式，把 Date 对象的时间部分转换为字符串</p><h5 id="toLocaleDateString"><a href="#toLocaleDateString" class="headerlink" title="toLocaleDateString()"></a>toLocaleDateString()</h5><p>根据本地时间格式，把 Date 对象的日期部分转换为字符串</p><h5 id="UTC"><a href="#UTC" class="headerlink" title="UTC()"></a>UTC()</h5><p>根据世界时返回 1970 年 1 月 1 日 到指定日期的毫秒数</p><h5 id="valueOf-NaN"><a href="#valueOf-NaN" class="headerlink" title="valueOf()"></a>valueOf()</h5><p>返回 Date 对象的原始值</p><h3 id="Global-对象"><a href="#Global-对象" class="headerlink" title="Global 对象"></a>Global 对象</h3><blockquote><p>全局对象只是一个对象，而不是类。既没有构造函数，也无法实例化一个新的全局对象</p></blockquote><h5 id="属性-3"><a href="#属性-3" class="headerlink" title="属性"></a>属性</h5><h6 id="Infinity"><a href="#Infinity" class="headerlink" title="Infinity"></a>Infinity</h6><p>代表正的无穷大的数值</p><h6 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h6><p>代表非数字</p><h6 id="Undefined"><a href="#Undefined" class="headerlink" title="Undefined"></a>Undefined</h6><p>代表未定义的值</p><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a<br><span class="hljs-keyword">var</span> b = <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-keyword">var</span> c = <span class="hljs-literal">null</span><br><br><span class="hljs-built_in">console</span>.log(a === <span class="hljs-literal">undefined</span>) <span class="hljs-comment">//true</span><br><span class="hljs-built_in">console</span>.log(b === <span class="hljs-literal">undefined</span>) <span class="hljs-comment">//false</span><br><span class="hljs-built_in">console</span>.log(c == <span class="hljs-literal">undefined</span>) <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><h5 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h5><h6 id="encodeURI-URIString"><a href="#encodeURI-URIString" class="headerlink" title="encodeURI(URIString)"></a>encodeURI(URIString)</h6><p>功能：将字符串作为 URI 进行编码，返回值为 URIstring 的副本</p><p>参数：URIString(必须)，一个待编码的字符串</p><blockquote><p>该方法不会对 ASCII 字母和数字进行编码，也不会对这些 ASCII 标点符号进行编码： - _ . ! ~ * ‘ ( ) 。</p><p>该方法的目的是对 URI 进行完整的编码，因此对以下在 URI 中具有特殊含义的 ASCII 标点符号，encodeURI() 函数是不会进行转义的：;/?:@&amp;=+$,#</p><p>如果 URI 组件中含有分隔符，比如 ? 和 #，则应当使用 encodeURIComponent() 方法分别对各组件进行编码</p></blockquote><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">encodeURI</span>(<span class="hljs-string">&quot;http://www.baidu.com/my m?:@&amp;=+$#&quot;</span>))<br><span class="hljs-comment">// http://www.baidu.com/my%20m?:@&amp;=+$#</span><br></code></pre></td></tr></table></figure><h6 id="decodeURI"><a href="#decodeURI" class="headerlink" title="decodeURI()"></a>decodeURI()</h6><p>功能：上述解码</p><h6 id="encodeURIComponent-URIString"><a href="#encodeURIComponent-URIString" class="headerlink" title="encodeURIComponent(URIString)"></a>encodeURIComponent(URIString)</h6><p>功能：将字符串作为 URI 组件进行编码，返回值为 URIstring 的副本</p><p>参数：URIString(必须)，一个待编码的字符串</p><blockquote><p>该方法不会对 ASCII 字母和数字进行编码，也不会对这些 ASCII 标点符号进行编码： - _ . ! ~ * ‘ ( )</p><p>其他字符（比如 ：;/?:@&amp;=+$,# 这些用于分隔 URI 组件的标点符号），都是由一个或多个十六进制的转义序列替换的</p></blockquote><blockquote><p>encodeURI 和 encodeURIComponent 的区别：</p><p>它们都是编码 URL，唯一区别就是编码的字符范围，其中 encodeURI 方法不会对下列字符编码 ASCII 字母、数字、<del>!@#$&amp;_()=:/,;?+’<br>encodeURIComponent 方法不会对下列字符编码 ASCII 字母、数字、</del>!_()’<br>所以 encodeURIComponent 比 encodeURI 编码的范围更大。<br>实际例子来说，encodeURIComponent 会把 http:// 编码成 http%3A%2F%2F 而 encodeURI 却不会。</p></blockquote><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">encodeURI</span>(<span class="hljs-string">&#x27;http://www.baidu.com/home/some other thing&#x27;</span>)<br><span class="hljs-comment">//编码后为：http://www.baidu.com/home/some%20other%20thing 空格被编码成了%20</span><br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">encodeURIComponent</span>(<span class="hljs-string">&#x27;http://www.baidu.com/home/some other thing&#x27;</span>))<br><span class="hljs-comment">//http%3A%2F%2Fwww.baidu.com%2Fhome%2Fsome%20other%20thing    &quot;/&quot;被编码，无法使用</span><br><br><span class="hljs-keyword">var</span> param = <span class="hljs-string">&quot;http://www.baidu.com/home/&quot;</span> <span class="hljs-comment">//param为参数</span><br>param = <span class="hljs-built_in">encodeURIComponent</span>(param)<br><span class="hljs-keyword">var</span> url = <span class="hljs-string">&quot;http://www.baidu.com?next=&quot;</span> + param<br><span class="hljs-built_in">console</span>.log(url) <span class="hljs-comment">//&#x27;http://www.baidu.com?next=http%3A%2F%2Fwww.baidu.com%2Fhome%2F&#x27;</span><br><span class="hljs-comment">// 参数中的 &quot;/&quot; 被编码了，如果用encodeURI会出问题，因为后面的/是需要编码的</span><br></code></pre></td></tr></table></figure><h6 id="decodeURIComponent"><a href="#decodeURIComponent" class="headerlink" title="decodeURIComponent()"></a>decodeURIComponent()</h6><p>功能：上述解码</p><h6 id="escape-string"><a href="#escape-string" class="headerlink" title="escape(string)"></a>escape(string)</h6><p>功能：对字符串进行编码，把中文变乱码</p><blockquote><p>会转义除了<code>@*_+-./</code>以外的所有字符</p><p>已经从 Web 标准中废弃。绝大多数情况都可以使用<code>encodeURI</code>和<code>encodeURIComponent</code>来代替</p></blockquote><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> aaa = <span class="hljs-string">&quot;中国123,&quot;</span><br><span class="hljs-built_in">escape</span>(aaa) <span class="hljs-comment">// &quot;%u4E2D%u56FD123%2C&quot;</span><br></code></pre></td></tr></table></figure><h6 id="unescape"><a href="#unescape" class="headerlink" title="unescape()"></a>unescape()</h6><p>功能：上述反编译</p><h6 id="parseInt-string-radix"><a href="#parseInt-string-radix" class="headerlink" title="parseInt(string,radix)"></a>parseInt(string,radix)</h6><p>功能：解析一个字符串，并返回一个整数。</p><p>参数：</p><ul><li>string(必须)：待解析的字符串</li><li>radix(可选)：表示要解析的数字的基数。该值介于 2 ~ 36 之间，如果该参数小于 2 或者大于 36，则 parseInt() 将返回 NaN</li></ul><blockquote><p>开头和结尾的空格是允许的</p><p>如果字符串的第一个字符不能被转换为数字，那么 parseFloat() 会返回 NaN</p><p>当参数  <em>radix</em>  的值为 0，或没有设置该参数时，parseInt() 会根据  <em>string</em>  来判断数字的基数 。如果 string 以 “0x” 开头，parseInt() 会把 string 的其余部分解析为十六进制的整数。如果 string 以 0 开头，那么 ECMAScript v3 允许 parseInt() 的一个实现把其后的字符解析为八进制或十六进制的数字。如果 string 以 1 ~ 9 的数字开头，parseInt() 将把它解析为十进制的整数</p></blockquote><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;10&quot;</span>) <span class="hljs-comment">//返回 10</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;19&quot;</span>, <span class="hljs-number">10</span>) <span class="hljs-comment">//返回 19 (10+9)</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;11&quot;</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">//返回 3 (2+1)</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;17&quot;</span>, <span class="hljs-number">8</span>) <span class="hljs-comment">//返回 15 (8+7)</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;1f&quot;</span>, <span class="hljs-number">16</span>) <span class="hljs-comment">//返回 31 (16+15)</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;010&quot;</span>) <span class="hljs-comment">//未定：返回 10 或 8</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;0x0011&quot;</span>) <span class="hljs-comment">//17</span><br></code></pre></td></tr></table></figure><h6 id="parseFloat-string"><a href="#parseFloat-string" class="headerlink" title="parseFloat(string)"></a>parseFloat(string)</h6><p>功能：解析一个字符串，并返回一个浮点数</p><p>参数：string(必须)，待解析的字符串</p><blockquote><p>该函数指定字符串中的首个字符是否是数字。如果是，则对字符串进行解析，直到到达数字的末端为止</p></blockquote><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&quot;10&quot;</span>) <span class="hljs-comment">//10</span><br><span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&quot;10.00&quot;</span>) <span class="hljs-comment">//10</span><br><span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&quot;10.33&quot;</span>) <span class="hljs-comment">//10.33</span><br><span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&quot; 60 &quot;</span>) <span class="hljs-comment">//60 首尾空格会忽略</span><br><span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&quot;23 34 45&quot;</span>) <span class="hljs-comment">//23 中间空格不会忽略，会中断</span><br><span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&quot;23 years&quot;</span>) <span class="hljs-comment">//23</span><br><span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&quot;i am 23&quot;</span>) <span class="hljs-comment">//NaN</span><br></code></pre></td></tr></table></figure><h6 id="isFinite-number"><a href="#isFinite-number" class="headerlink" title="isFinite(number)"></a>isFinite(number)</h6><p>功能：用于检查其参数是否是无穷大</p><p>参数：</p><ul><li>number(必须)：待检测数字<br>如果 number 是有限数字（或可转换为有限数字），那么返回 true。否则，如果 number 是 NaN（非数字），或者是正、负无穷大的数，则返回 false</li></ul><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">isFinite</span>(<span class="hljs-number">123</span>)) <span class="hljs-comment">//true</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">isFinite</span>(-<span class="hljs-number">1.23</span>)) <span class="hljs-comment">//true</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">isFinite</span>(<span class="hljs-number">6</span> - <span class="hljs-number">3</span>)) <span class="hljs-comment">//true</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">isFinite</span>(<span class="hljs-number">0</span>)) <span class="hljs-comment">//true</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">isFinite</span>(<span class="hljs-number">0</span> / <span class="hljs-number">0</span>)) <span class="hljs-comment">//false</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">isFinite</span>(<span class="hljs-string">&quot;Hello&quot;</span>)) <span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure><h6 id="isNaN-number"><a href="#isNaN-number" class="headerlink" title="isNaN(number)"></a>isNaN(number)</h6><p>功能：用于检查其参数是否为非数字值</p><p>参数：</p><ul><li>number(必须)：待检测数字<br>如果 number 是非数字值 NaN（或者能被转换成 NaN），返回 true，否则返回 false</li></ul><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">isNaN</span>(<span class="hljs-number">123</span>)) <span class="hljs-comment">//false</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">isNaN</span>(-<span class="hljs-number">1.23</span>)) <span class="hljs-comment">//false</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">isNaN</span>(<span class="hljs-number">6</span> - <span class="hljs-number">3</span>)) <span class="hljs-comment">//false</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">isNaN</span>(<span class="hljs-number">0</span>)) <span class="hljs-comment">//false</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">isNaN</span>(<span class="hljs-number">0</span> / <span class="hljs-number">0</span>)) <span class="hljs-comment">//true</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">isNaN</span>(<span class="hljs-string">&quot;Hello&quot;</span>)) <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><h6 id="Number-object"><a href="#Number-object" class="headerlink" title="Number(object)"></a>Number(object)</h6><p>功能：把对象的值转换为数字</p><p>参数：</p><ul><li>object(必须)：待转换的对象<br>如果参数是 Date 对象，Number() 返回从 1970 年 1 月 1 日至今的毫秒数，即时间戳。如果对象的值无法转换为数字，那么 Number() 函数返回 NaN</li></ul><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>(<span class="hljs-literal">true</span>)) <span class="hljs-comment">// 1</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>(<span class="hljs-literal">false</span>)) <span class="hljs-comment">// 0</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>())) <span class="hljs-comment">// 1506266494726</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>(<span class="hljs-string">&quot;999&quot;</span>)) <span class="hljs-comment">// 999</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>(<span class="hljs-string">&quot;999 888&quot;</span>)) <span class="hljs-comment">// NaN</span><br></code></pre></td></tr></table></figure><h6 id="String-object"><a href="#String-object" class="headerlink" title="String(object)"></a>String(object)</h6><p>功能：把对象的值转换为字符串</p><p>参数：object(必须)，待转换的对象</p><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">String</span>(<span class="hljs-literal">true</span>)) <span class="hljs-comment">// &#x27;true&#x27;</span><br></code></pre></td></tr></table></figure><h6 id="getClass"><a href="#getClass" class="headerlink" title="getClass()"></a>getClass()</h6><p>返回一个 JavaObject 的 JavaClass</p><h6 id="eval-string"><a href="#eval-string" class="headerlink" title="eval(string)"></a>eval(string)</h6><p>功能：可计算某个字符串，并执行其中的的 JavaScript 代码</p><p>参数：必需，要计算的字符串，其中含有要计算的 JavaScript 表达式或要执行的语句</p><p>返回值：通过计算 string 得到的值</p><h3 id="Console-对象"><a href="#Console-对象" class="headerlink" title="Console 对象"></a>Console 对象</h3><h5 id="console-log-text-text2-…"><a href="#console-log-text-text2-…" class="headerlink" title="console.log(text,text2,…)"></a>console.log(text,text2,…)</h5><p>用于在 console 窗口输出信息</p><blockquote><p>它可以接受多个参数，将它们的结果连接起来输出</p><p>如果第一个参数是格式字符串（使用了格式占位符）</p><p>console.log 方法将依次用后面的参数替换占位符，然后再进行输出</p></blockquote><h5 id="console-info"><a href="#console-info" class="headerlink" title="console.info()"></a>console.info()</h5><p>在 console 窗口输出信息，同时，会在输出信息的前面，加上一个蓝色图标</p><h5 id="console-debug"><a href="#console-debug" class="headerlink" title="console.debug()"></a>console.debug()</h5><p>在 console 窗口输出信息，同时，会在输出信息的前面，加上一个蓝色图标</p><h5 id="console-warn"><a href="#console-warn" class="headerlink" title="console.warn()"></a>console.warn()</h5><p>输出信息时，在最前面加一个黄色三角，表示警告</p><h5 id="console-error"><a href="#console-error" class="headerlink" title="console.error()"></a>console.error()</h5><p>输出信息时，在最前面加一个红色的叉，表示出错，同时会显示错误发生的堆栈</p><h5 id="console-table"><a href="#console-table" class="headerlink" title="console.table()"></a>console.table()</h5><p>可以将复合类型的数据转为表格显示</p><h5 id="console-count"><a href="#console-count" class="headerlink" title="console.count()"></a>console.count()</h5><p>用于计数，输出它被调用了多少次</p><h5 id="console-dir"><a href="#console-dir" class="headerlink" title="console.dir()"></a>console.dir()</h5><p>用来对一个对象进行检查（inspect），并以易于阅读和打印的格式显示</p><h5 id="console-dirxml"><a href="#console-dirxml" class="headerlink" title="console.dirxml()"></a>console.dirxml()</h5><p>用于以目录树的形式，显示 DOM 节点</p><h5 id="console-assert"><a href="#console-assert" class="headerlink" title="console.assert()"></a>console.assert()</h5><p>接受两个参数，第一个参数是表达式，第二个参数是字符串</p><blockquote><p>只有当第一个参数为 false，才会输出第二个参数，否则不会有任何结果</p></blockquote><h5 id="console-time"><a href="#console-time" class="headerlink" title="console.time()"></a>console.time()</h5><h5 id="console-timeEnd"><a href="#console-timeEnd" class="headerlink" title="console.timeEnd()"></a>console.timeEnd()</h5><p>这两个方法用于计时，可以算出一个操作所花费的准确时间</p><blockquote><p>time 方法表示计时开始，timeEnd 方法表示计时结束, 它们的参数是计时器的名称</p><p>调用 timeEnd 方法之后，console 窗口会显示“计时器名称: 所耗费的时间”</p></blockquote><h5 id="console-profile"><a href="#console-profile" class="headerlink" title="console.profile()"></a>console.profile()</h5><p>用来新建一个性能测试器（profile），它的参数是性能测试器的名字</p><h5 id="console-profileEnd"><a href="#console-profileEnd" class="headerlink" title="console.profileEnd()"></a>console.profileEnd()</h5><p>用来结束正在运行的性能测试器</p><h5 id="console-group"><a href="#console-group" class="headerlink" title="console.group()"></a>console.group()</h5><h5 id="console-groupend"><a href="#console-groupend" class="headerlink" title="console.groupend()"></a>console.groupend()</h5><p>上面这两个方法用于将显示的信息分组。它只在输出大量信息时有用，分在一组的信息，可以用鼠标折叠/展开</p><h5 id="console-groupCollapsed"><a href="#console-groupCollapsed" class="headerlink" title="console.groupCollapsed()"></a>console.groupCollapsed()</h5><p>用于将显示的信息分组，该组的内容，在第一次显示时是收起的（collapsed），而不是展开的</p><h5 id="console-trace"><a href="#console-trace" class="headerlink" title="console.trace()"></a>console.trace()</h5><p>显示当前执行的代码在堆栈中的调用路径</p><h5 id="console-clear"><a href="#console-clear" class="headerlink" title="console.clear()"></a>console.clear()</h5><p>用于清除当前控制台的所有输出，将光标回置到第一行</p><blockquote><p>本文参考：</p><p><a href="https://segmentfault.com/a/1190000011467723#articleHeader1">https://segmentfault.com/a/1190000011467723#articleHeader1</a></p><p><a href="https://www.runoob.com/js/js-tutorial.html">https://www.runoob.com/js/js-tutorial.html</a></p><p>您可以克隆到本地，随时随地翻阅，md 格式文档，推荐使用 typora</p><p>本文是为了熟悉下 JS 的 API 所写，只是些常用的，不如手册全面</p><p>如需全面的 api 文档，请移步菜鸟教程等 JS 手册</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue-cli2.0构建流程</title>
    <link href="/blog/2018/10/12/vue/Vue-cli2.0%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B/"/>
    <url>/blog/2018/10/12/vue/Vue-cli2.0%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>学习 vue 时，总觉得 vue-cli 搭建很复杂，其实也不过如此，使用别人搭建好的包在打包时总会报一些莫名其妙的错误，还是自己动手比较可靠，就像我总觉得我自己写的代码是最好的^_^</p><p>首先，检测 NodeJS 环境</p><p>Windows+R 快捷键打开 cmd 输入以下命令</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">node - v<br></code></pre></td></tr></table></figure><p>如果出现 NodeJS 的版本号，表示你已经安装了 NodeJS</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/01.PNG"></p><p>反之就是没有安装 NodeJS 了</p><p>安装 NodeJS 请走官网传送门</p><p><a href="https://nodejs.org/zh-cn/">传送门—NodeJS 安装</a></p><p>接下来就正式进入今天的主题脚手架搭建了</p><p>你可以使用 npm 安装，npm 安装速度慢些（因为服务器在国外），你也可以使用淘宝的镜像安装</p><p>安装淘宝镜像，打开 cmd 命令框，输入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">npm install -g cnpm –registry=https:<span class="hljs-comment">//registry.npm.taobao.org</span><br></code></pre></td></tr></table></figure><p>安装淘宝镜像之后把命令中的 npm 变成 cnpm 就可以了，我这里使用的是 npm 安装 (因为我觉得也慢不了多少)</p><p>全局安装 Vue 脚手架</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">npm install -g vue-cli<br></code></pre></td></tr></table></figure><p>安装成功之后 cd 进你的项目文件夹目录</p><p>初始化项目</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">vue-init &lt;template-name&gt; [project-name]<br># &lt;template-name&gt; —— 打包工具<br># [project-name]  —— 项目名称<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/02.PNG"></p><p>回答完问题稍等片刻，初始化成功之后就会显示以下内容</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/03.PNG"></p><p>然后根据提示 cd 进你的项目目录</p><p>输入<code>npm run dev</code>运行项目，如下</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/04.PNG"></p><p>这个时候就可以在浏览器输入 <code>http://localhost:8080</code> ，出现以下界面脚手架搭建成功</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/05.PNG"></p><p>以上就是 vue-cli 搭建的全部过程</p><p>脚手架项目结构</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js">├── build/                      # webpack 编译配置文件: 开发环境与生产环境<br>│   └── ...<br>├── config/<br>│   ├── index.js                # 项目核心配置<br>│   └── ...<br>├ ── node_module/               # 项目中安装的依赖包<br>   ── src/<br>│   ├── main.js                 # 项目入口文件<br>│   ├── App.vue                 # 项目入口vue组件<br>│   ├── components/             # 组件<br>│   │   └── ...<br>│   └── assets/                 # 资源文件，一般放一些静态资源<br>│       └── ...<br>├── <span class="hljs-keyword">static</span>/                     # 纯静态资源 (打包时不会编译，会直接拷贝到dist/<span class="hljs-keyword">static</span>/里面)<br>├── test/<br>│   └── unit/                   # 单元测试<br>│   │   ├── specs/              # 测试规范<br>│   │   ├── index.js            # 测试入口文件<br>│   │   └── karma.conf.js       # 测试运行配置文件<br>│   └── e2e/                    # 端到端测试<br>│   │   ├── specs/              # 测试规范<br>│   │   ├── custom-assertions/  # 端到端测试自定义断言<br>│   │   ├── runner.js           # 运行测试的脚本<br>│   │   └── nightwatch.conf.js  # 运行测试的配置文件<br>├── .babelrc                    # babel 配置文件<br>├── .editorconfig               # 编辑配置文件<br>├── .gitignore                  # 用来过滤一些版本控制的文件，比如node_modules文件夹<br>├── index.html                  # index.html 项目模板入口文件<br>└── package.json                # 项目文件，记载项目依赖及项目说明（重）<br>└── README.md                   # 说明文档，介绍自己的项目，markdown语法书写<br></code></pre></td></tr></table></figure><p>最后项目打包请输入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">npm run bulid<br></code></pre></td></tr></table></figure><p>打包完成后会在项目目录下生成一个 dist 文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">├── dist/<br>│   ├── index.js                # 项目入口文件<br>│   └── <span class="hljs-keyword">static</span>   # 静态资源及打包后的一些js/css文件<br></code></pre></td></tr></table></figure><p>详情待续。。。</p><p>最后：喜欢前端，欢迎探讨！！！</p>]]></content>
    
    
    <categories>
      
      <category>Vue相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>被摒弃的jQuery</title>
    <link href="/blog/2018/09/26/other/%E8%A2%AB%E6%91%92%E5%BC%83%E7%9A%84jQuery/"/>
    <url>/blog/2018/09/26/other/%E8%A2%AB%E6%91%92%E5%BC%83%E7%9A%84jQuery/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr><p>今年 IT 界发生了很多大事，无意间看到<code>jQ</code>的信息后，我决定码了这篇文章</p><p>首先回顾一下今年的大事(-_-)</p><p>十岁的 GitHub 作为全球最大开源代码托管网站，可谓是全球程序员的一片圣地，但是，今年 6 月，微软以 75 亿美元（折合人民币 480 亿 ）的价格收购了 Github</p><p>根据 cnBeta 新闻，在 GitHub 新闻发布之后，GitLab 收到了超过 14300 个独立访问者，这些开发者在 GitLab.com 上开设了超过 10 万个新的存储库</p><p>很多人因为 GitHub 被微软收购从而转去 GitLab，但是大家都没有想过 GitHub 的这种状况和 Google 投资了竞争对手的 GitLab 没有关系吗</p><p>想着也真是搞笑！</p><p>全球最大的闭源软件公司微软(Mircosoft)对于全球最大的开源软件社区 GitHub 的贡献最多</p><p>手握最大开源数据库 MySQL 和开源编程语言 Java 的 Oracle 是开源死敌</p><p>时代性的开源编程语言 Java 的老大 Oracle 在向非付费用户开枪了</p><p>全球最大源代码托管网站 Github 也被微软帝国收购</p><p>Google 也投资了 GitLab</p><p>开源缔造了 IT 时代，如果开源被把控。。。</p><p>目前，GitHub 一切正常，不知未来如何。。。</p><hr><p>喷了一下(~ _ ~)，以上不是本文主体，进入正题，在微软收购 GitHub 后，表示不打算在 GitHub 上做太多改变，且以开发者为中心的初心不会改变，会积极地拥抱开源 ，52 天后，也就是 7 月份，Github 做出一些微软特色的改变，这之中最重要的是 GitHub 网站<strong>重构过程中放弃了 jQuery</strong>，没有再次使用其他任何框架去代替它，而是使用了原生的 JS ，本文是我个人针对此事的看法:</p><h2 id="jQuery-简介"><a href="#jQuery-简介" class="headerlink" title="jQuery 简介"></a>jQuery 简介</h2><p>jQuery 诞生于 2006 年 8 月，作者 John Resig ，jQuery 倡导写更少的代码，做更多的事情。它封装了 JavaScript 常用的功能代码，提供一种简便的 JavaScript 设计模式，优化 HTML 文档操作、事件处理、动画设计和 Ajax 交互</p><p>jQuery 凭借着 跨浏览器、 简单高效 、稳定可靠 、 插件丰富 这些特性迅速风靡全球</p><p>jQuery 使得操作 DOM、定义动画和实现“AJAX”请求，变得十分简单。简单来说，它使得 Web 开发者可以创建更现代、更动态的效果 ，最重要的是，通过 jQuery 在一种浏览器上实现的功能，基本上也能在其他浏览器上运行</p><p>时至今日，jQuery 仍然在支撑着数以千万计各种规模网站的运作</p><p>但是 jQuery 为什么会被摒弃呢？综合网上以及我自己的看法我认为有以下几点：</p><h2 id="摒弃原因"><a href="#摒弃原因" class="headerlink" title="摒弃原因"></a>摒弃原因</h2><ul><li>原生 Js 的发展，使得原生 API 足够的强大</li><li>jQuery 中的经典<code>$(selector)</code> 可以简单地用<code>querySelectorAll()</code>替换</li><li>CSS 类名切换，可以通过<code>Element.classList</code>实现</li><li>CSS 现在支持在样式表中定义视觉动画，无需使用 JavaScript</li><li>$.ajax 请求可以用 Fetch 标准实现（在不支持的浏览器上可以使用 XHR）</li><li><code>addEventListener()</code>接口已经十分稳定，足以跨平台使用</li><li>jQuery 提供的一些语法糖，已随着 JavaScript 语言的发展，而变得多余</li><li>链式语法并不能满足我们直观地书写代码的需要</li><li>自定义元素技术让用户无需下载、解析或编译任何框架</li><li>原生作为标准，更方便以后维持代码的灵活性</li><li>jQuery 大量 DOM 操作虽然方便，但是会牺牲很多页面的性能</li><li>浏览器兼容问题越来越少 ，如今浏览器 API 及其 polyfill 已经有足够标准化的 Web 应用程序开发</li><li>React、Vue 和 Angularjs 等主流前端框架并不依赖 jQuery，都可以独立使用</li><li>以 DOM 为中心的开发模式过于传统 ，目前复杂页面开发流行的是以数据/状态为中心的开发模式</li><li>前端服务化的趋势，<strong>同构</strong>渲染的问题，也是一个要移除 jQuery 的迫切原因</li></ul><p>同构</p><p>同构指前后端运行同一份代码，后端也可以渲染出页面。React 等流行框架天然支持，已经具有可行性。把现有应用改成同构时，因为代码要运行在服务端，但服务端没有 DOM，所以引用 jQuery 就会报错，在很多场合也要避免直接操作 DOM。</p><h2 id="个人感言"><a href="#个人感言" class="headerlink" title="个人感言"></a>个人感言</h2><p>曾经辉煌的 jQuery 终于走到了可以华丽谢幕的时刻，当然，John Resig 是一个伟大的开发者，jQuery 也是一个伟大的工具，<code>一个伟大的工具是指，它解决的问题不再存在，那么可以功成身退了</code>，这句话我觉得非常好，jQuery 引领了一个前端时代，这是不可否认的</p><p>作为一个前端原生爱好者，个人觉得，随着时代的变迁、技术的进步，jQuery 赖以存在的环境正逐渐消失。jQuery 提供了非常易用的 DOM 操作 API，屏蔽了浏览器差异，虽然极大地提高了开发效率，但这也导致很多前端只懂 jQuery ，而忽略了 js，特别是对于那些对前端深感兴趣的初学者，很多都把重心放在了 jQuery 之类的库上，偏离了本质，等回过头来再研究 js 时，费时不说，还会很不习惯，甚至很难转变，长此以往，不利于 js 语言的蓬勃发展，在我心中，js 和 css 是真正的前端核心，这两样技术，js 主导着核心编程，css 引导我们探索与创造，对我来说，这两样水都很深，很难吃透，在工作中考虑开发效率的话，三大框架精一足以，简洁方便，一些简单的操作，原生即可</p><blockquote><p>本文参考</p><p><a href="https://blog.csdn.net/csdnnews/article/details/83189938">使用了 23 年的 Java 不再免费！</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MjAwODM4MA==&mid=2650698992&idx=1&sn=76bd487d3f044851aaa8da9fc914351d&chksm=bea6052389d18c3523e8024545a81d673c3220c2f21b16f80581fe5bea1d9c44afc849cf8b03&scene=21#wechat_redirect">收购 GitHub 滔天争议后，微软回应一切</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MjM5MjAwODM4MA==&mid=2650701571&idx=1&sn=61b9cf057317fe00b7bcab4a5a00f034&chksm=bea60ed089d187c67557636b61b73f877ddcce5cf4c946cdf7f27278e8dc3c4b60221c67145c&scene=21#wechat_redirect">GitHub 改版并放弃了 jQuery</a></p><p><a href="https://githubengineering.com/removing-jquery-from-github-frontend/">从 GitHub.com 前端删除 jQuery–英文原文</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Web相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jQuery</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue中npm run build报“Error in parsing SVG Unquoted attribute value”</title>
    <link href="/blog/2018/09/11/vue/Error%20in%20parsing%20SVG%20Unquoted%20attribute%20value/"/>
    <url>/blog/2018/09/11/vue/Error%20in%20parsing%20SVG%20Unquoted%20attribute%20value/</url>
    
    <content type="html"><![CDATA[<p>自己做的一个 Vue 项目，在打包时老是报这个错误</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"># <span class="hljs-built_in">Error</span> <span class="hljs-keyword">in</span> parsing SVG: Unquoted attribute value<br></code></pre></td></tr></table></figure><p>查了查网上说的，都说报错原因是压缩和抽离 CSS 的插件中只允许 SVG 使用双引号</p><p>就是项目中外部引入的 CSS 文件里的 SVG 只能是双引号</p><p>我找了好久，这可把我坑坏了。。。</p><p>想想那段时间真是难受。。。</p><p>后来找到了，分享一下，让大家快点脱坑。。。</p><p>首先，如果你项目中使用了 mui 的话应该在这里改</p><p>找到 mui 文件下的 iconfont.css 文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"># mui/css/iconfont.css<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/one.png" alt="001"></p><p>不要以为完了，还有</p><p>找到 mui 文件下的 mui.css 文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"># mui/css/mui.css<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/two.png" alt="002"></p><p>以上两个文件修改了再次 build</p><p>如果还报 SVG 的错误，请查看你所有引入的外部 CSS 文件吧</p><p>如果你确定你引入的 CSS 文件中确实没有 SVG 或者是 SVG 确实是双引号，那就没办法了老兄。。。</p><p>最后：喜欢前端，欢迎探讨！！！</p>]]></content>
    
    
    <categories>
      
      <category>Vue相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
      <tag>Bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue不是内部或外部命令，也不是可执行的程序或批处理文件</title>
    <link href="/blog/2018/09/09/vue/Vue%E4%B8%8D%E6%98%AF%E5%86%85%E9%83%A8%E6%88%96%E5%A4%96%E9%83%A8%E5%91%BD%E4%BB%A4%EF%BC%8C%E4%B9%9F%E4%B8%8D%E6%98%AF%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%9A%84%E7%A8%8B%E5%BA%8F%E6%88%96%E6%89%B9%E5%A4%84%E7%90%86%E6%96%87%E4%BB%B6/"/>
    <url>/blog/2018/09/09/vue/Vue%E4%B8%8D%E6%98%AF%E5%86%85%E9%83%A8%E6%88%96%E5%A4%96%E9%83%A8%E5%91%BD%E4%BB%A4%EF%BC%8C%E4%B9%9F%E4%B8%8D%E6%98%AF%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%9A%84%E7%A8%8B%E5%BA%8F%E6%88%96%E6%89%B9%E5%A4%84%E7%90%86%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>平常我们搭个脚手架，可能分分钟就完事了，但是容易忽略一些细节，比如搭脚手架时 cmd 查 vue 版本号报<code>vue不是内部或外部命令，也不是可执行的程序或批处理文件</code>这种错误，明明 vue 下载了，脚手架下载完了怎么也初始化不了，你遇到过吗？</p><p>如果你确实已经在全局状态下安装了 vue 和 vue-cli，cmd<code>vue -V</code>或<code>vue init</code>还是报这个错，嗯，有必要往下看看！</p><p>解决办法：</p><p>配置 vue 的环境变量</p><ul><li>搜索 vue.cmd 文件，复制该文件地址，待用</li><li>注：如果搜索不到，请再下载一遍 vue。。</li></ul><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/000.png"></p><ul><li>windows 下进入<code>控制面板\系统和安全\系统</code>点击更改设置</li></ul><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/001.png"></p><ul><li>点击高级–环境变量</li></ul><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/002.png"></p><ul><li>新建一个系统变量</li></ul><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/003.png"></p><ul><li>输入变量名为 Path，变量值为刚复制的 vue.cmd 文件路径</li></ul><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/004.png"></p><ul><li>保存重新运行 cmd 输入<code>vue -V</code>即可</li></ul><p>完美结束！！！</p>]]></content>
    
    
    <categories>
      
      <category>Vue相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
      <tag>Bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GitHub 免费搭建个人网站</title>
    <link href="/blog/2018/09/06/other/GitHub%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99/"/>
    <url>/blog/2018/09/06/other/GitHub%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99/</url>
    
    <content type="html"><![CDATA[<p>学习前端的人应该知道，开始学习前端时，心里想的肯定是我一定要给自己做一个的非常棒的网站，学完之后网站做好了，但是要怎么上线呢？？？</p><p>作为一个前端，拥有有自己的个人网站，算是迈出了前端道路的第一步！</p><h4 id="本文目的"><a href="#本文目的" class="headerlink" title="本文目的"></a>本文目的</h4><p>通过<strong>GitHub Pages</strong>免费快速的搭建个人网站，文章随长，其实非常简单，写的详细是为了能够让多数人都能够看得懂</p><h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><h4 id="建站常识"><a href="#建站常识" class="headerlink" title="建站常识"></a>建站常识</h4><p>首先了解常识，建站三部曲：</p><ul><li>网站项目</li><li>服务器</li><li>域名</li></ul><p>简单来说，就是我们要有一个域名，然后绑定服务器，再把网站上传到服务器上，这样就可以通过域名访问我们的网站了</p><p><strong>网站项目</strong>就是你写的网站文件，这个如果不会的话请去学习前端 <a href="http://www.w3school.com.cn/">w3school 传送门</a></p><p><strong>服务器</strong>就是网络中为用户提供服务的专用设备。分为访问、文件、数据库、通信等不同功能的服务器。那么要怎样拥有一个服务器呢，(用钱就好了！！！)，正规途径是在网上买一个服务器，看图</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other//fuwuqi1.png" alt="图1"></p><p>刚开始玩的话买一个空间小的相对便宜的就行，当然有钱请随意！！！</p><p><strong>域名</strong>就是访问网站的网址，怎样获取域名，没错还是用钱，看图</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other//yuming1.png" alt="图2"></p><p>我的域名是在阿里云注册的，域名也是有区别的，后缀不一，长短不一，相对价钱就不一，如我的域名：</p><p><a href="https://isboyjc.top/">isboyjc.top</a></p><p>欢迎访问啊！不要问为什么是<code>.top</code>的后缀，因为<code>.top</code>的域名最贵了，我最有钱，我最任性</p><p>域名注册好之后首先要进行实名认证，然后域名解析、绑定服务器，最后把网站上传服务器，进行网站备案，静候备案成功就可以了（<strong>注</strong>：国内服务器需要备案，国外或香港服务器不用备案，但是相比国内服务器访问速度慢点，因为距离远嘛！）</p><p>这是一个网站上线的基本流程，当然以上不是本文重点，这些只是一些必备的常识，重点在下面</p><h4 id="GitHub-Pages-建站"><a href="#GitHub-Pages-建站" class="headerlink" title="GitHub Pages 建站"></a>GitHub Pages 建站</h4><p>什么是 GitHub Pages？</p><p>我就不照抄官方文档了，想了解请走传送门</p><p><a href="https://pages.github.com/">GitHub Pages 传送门</a></p><p>官方文档比较高大上，简单来说 GitHub Pages 就是一个服务器，但它是免费的！免费的！免费的！重要的事说三遍！它能提供给我们 1G 空间的存储，让你放东西，然后还可以请求到</p><p>当然 GitHub Pages 还有一些其他的东西，不过我们的宗旨是建站，其他不用了解</p><p><strong>重点来了：</strong></p><p>登录<a href="https://github.com/">GitHub.com</a>官网(全英的界面，英语不好的朋友请用谷歌翻译！)</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other//github.PNG"></p><p>登录后点击右上角的加号，进入<code>new repository</code>选项新建一个储存库,看到以下界面</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other//ku.PNG"></p><p>首先输入库名，仓库名字为固定格式</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">你的GitHub名.github.io<br><br><span class="hljs-regexp">//</span> 例：<br><span class="hljs-regexp">//</span> 我的GitHub名字为 isboyjc，所以库名为 isboyjc.github.io<br></code></pre></td></tr></table></figure><p>中间还有个储存库说明，可以不写，储存库说明下有一个自动为你选上的<code>Public</code>选项，意思是公开此储存库（就是别人可以看到并下载你库中的内容，当然可以不公开，但是要收费 7 美金/月，这个完全没有必要，因为 IT 的精华就是开源！当然土豪请随意！）</p><p>最后点击绿色按钮提交创建，提交后如下图</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other//create.PNG"></p><p>点击<code>README</code>进行初始化 README ，就是用<code>markdown</code>语法编写此储存库的具体说明或者说简单的展示，<code>markdown</code>语法十分简单，我也写了相应的<code>markdown</code>语法教程<a href="#">markdown 和 Typora–传送门</a>，有兴趣可以了解一下，当然这里不写也是可以的，直接点击下面绿色按钮提交即可</p><p><img src="../img/anniu.PNG"></p><p>再然后是如下界面：</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other//end.PNG"></p><p>上面图片红色框中依次翻译为：创建新文件、上传文件、查找文件、克隆或下载</p><p>点击<code>Upload files</code>上传文件</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other//endd.PNG"></p><p>点击<code>choose your files</code>选择文件上传，最后绿色按钮提交(<strong>注：</strong>上传的文件为你的网站文件，默认访问<code>index.html</code>文件所以你的网站首页一定要是<code>index.html</code>，css、js、img 文件同 html 文件一同拖拽进去即可，网速慢的话上传速度较慢请耐心等待，上传失败请重新上传)</p><p>这时神奇的一幕就来了，如果你的操作没错，这时你就可以在浏览器输入<code>你的GitHub名.github.io</code>访问你的网站了（<strong>注：</strong>如果你的储存库下没有<code>index.html文件</code>，访问时会自动显示你的<code>README.md</code>文档）！！！如下：</p><p><a href="https://isboyjc.github.io/">https://isboyjc.github.io</a></p><p>这个名字有点长，我想通过自己购买的域名访问怎么办呢？</p><p>接着往下看</p><h4 id="GitHub-Pages-域名绑定"><a href="#GitHub-Pages-域名绑定" class="headerlink" title="GitHub Pages 域名绑定"></a>GitHub Pages 域名绑定</h4><p>首先是域名解析</p><p>进入你的域名控制台，我的域名是阿里云注册的，所以本文以阿里云为例，如下图</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other//con1.PNG"></p><p>点击解析进入解析添加解析，如下图</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other//jiexi.PNG"></p><p><strong>记录类型</strong></p><p>记录类型我们选择<code>CNAME</code>，别名记录，就是把一个域名完完全全设置为另外一个域名的别名</p><p><strong>主机记录</strong></p><p>主机记录就是域名前缀，常见用法有：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs stylus">www：解析后的域名为www<span class="hljs-selector-class">.aliyun</span><span class="hljs-selector-class">.com</span><br><br>@：直接解析主域名 aliyun<span class="hljs-selector-class">.com</span><br><br>*：泛解析，匹配其他所有域名 *<span class="hljs-selector-class">.aliyun</span><span class="hljs-selector-class">.com</span><br><br>mail：将域名解析为mail<span class="hljs-selector-class">.aliyun</span>.com，通常用于解析邮箱服务器<br><br>二级域名：如：abc<span class="hljs-selector-class">.aliyun</span>.com，填写abc<br><br>手机网站：如：m<span class="hljs-selector-class">.aliyun</span>.com，填写m<br><br>显性URL：不支持泛解析（泛解析：将所有子域名解析到同一地址）<br></code></pre></td></tr></table></figure><p>举个例纸，我购买的域名是<code>isboyjc.top</code>我添加了两个域名解析，一个主机记录是<code>@</code>，一个主机记录是<code>www</code>，意思是让我的网站能够分别通过<code>isboyjc.top</code>和<code>www.isboyjc.top</code>访问到</p><p><strong>解析路线</strong></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs armasm">如果只有一个<span class="hljs-built_in">IP</span>地址或CNAME域名，请务必选择【默认】<br><br>默认：必填！未匹配到智能解析线路时，返回【默认】线路设置结果<br><br>境外：向除中国大陆以外的其他国家和地区，返回设置的记录值<br><br>搜索引擎：向搜索引擎爬虫的DNS，返回设置的记录值<br></code></pre></td></tr></table></figure><p><strong>记录值</strong></p><p>因为我们使用的是<code>GitHub Pages</code>服务器，所以记录值填写为之前的仓库名<code>你的GitHub名字.github.io</code>，如果是你自己购买的服务器，解析时记录值应该填写为你的服务器主机地址</p><p><strong>TTL</strong></p><p>TTL 指的是域名解析的生命周期，简单来说它表示 DNS 服务器解析域名时记录在 DNS 服务器上的缓存时间</p><p>什么意思呢，来点题外话，先说下网站的访问流程，你的网站文件存储在数据服务器上，它会有一个 IP 地址，就像门牌号一样，我们在输入域名访问网站时，数据服务器是不认识你这个域名的，它只认识 IP，你的域名会通过 DNS 服务器解析成 IP 值，通过这个门牌号(IP 值)向数据服务器查找你的网站数据并给你返回到浏览器上</p><p>访问网站时，不会每次都到 DNS 服务器域名解析，而是第一次访问时才到 DNS 服务器进行解析，然后解析的结果会缓存到当地的递归 DNS 服务器(缓存服务器)上，当地的第二个用户访问网站时，递归服务器会直接返回解析结果，而不会再向 DNS 服务器请求解析，那多久之后递归服务器才会更新这个解析结果呢？这就是 TTL 来决定的</p><p>如果增大 TTL 值，可以节约域名解析时间，给网站访问加速 ，TTL 值大多都是以秒为单位的，很多的默认值都是 3600，也就是默认缓存 1 小时，这个值有点小了，难道会有人一个小时就改一次域名记录吗</p><p>如果减小 TTL 值，可以减少更换空间时的不可访问时间 ，如果 TTL 值大了，更换新的域名记录时因为 TTL 缓存的问题，结果可能是有的人可能访问到了新服务器，有的人访问走缓存会访问到了旧的服务器</p><p>那么 TTL 值多少才好呢？</p><p>总的来说，你要访问速度，TTL 值就大一点，如果你近期想更换服务器或 IP，为了更换后能尽量解析到新的 IP 上，TTL 值就小一点，说的有点多了，好了，跳过这个话题，回到主题，本文介绍的是个人建站，一般个人网站建议设置 TTL 值为 600，也就是 10 分钟是刚好的！</p><p>上面的东西弄完之后只剩最后一步啦！！！</p><p><strong>在 GitHub 仓库页添加 CNAME 文件</strong></p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other//cname.PNG"></p><p>还是上传文件的这个页面，点击<code>Create new file</code>创建一个新文件，文件名为<code>CNAME</code>，注意是大写，文件内容写你解析的域名，例：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">isboyjc.<span class="hljs-built_in">top</span><br></code></pre></td></tr></table></figure><p>如果你还解析了<code>www</code>的域名,那么你就在文件中写两个域名，例：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">isboyjc<span class="hljs-selector-class">.top</span><br>www<span class="hljs-selector-class">.isboyjc</span>.<span class="hljs-attribute">top</span><br></code></pre></td></tr></table></figure><p>然后点击提交</p><p>最后，在浏览器上输入你的域名访问一下吧！！！</p><p>累死我了，终于写完了！！！</p>]]></content>
    
    
    <categories>
      
      <category>Web相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GitHub</tag>
      
      <tag>建站</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue打包后静态资源路径错误</title>
    <link href="/blog/2018/09/01/vue/Vue%E6%89%93%E5%8C%85%E5%90%8E%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E8%B7%AF%E5%BE%84%E9%94%99%E8%AF%AF/"/>
    <url>/blog/2018/09/01/vue/Vue%E6%89%93%E5%8C%85%E5%90%8E%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E8%B7%AF%E5%BE%84%E9%94%99%E8%AF%AF/</url>
    
    <content type="html"><![CDATA[<p>vue 项目打包完了，dist 文件也生成了，运行一下，又报错了</p><p>错误还不少，报了好多资源路径找不到的错误，大概有两种</p><ul><li>一种是 js 或 css 文件引入路径错误，找不到文件</li><li>一种是 css 中的图片路径错误，找不到图片</li></ul><p>#############################################</p><ul><li>js 或 css 文件引入路径错误解决办法如下：</li></ul><p>不知道大家发现没有，所有的路径错误都是少了个点，例如：</p><p><code>src=/static/js/app.5d7099352641a1a9dd32.js</code></p><p>知道原因了就找解决办法，手动加也行，不过为了每次打包完即用</p><p>在配置文件里改，一劳永逸</p><p>找到<code>config/index.js</code> 配置文件，找<code>build</code>打包对象里的<code>assetsPublicPath</code>属性</p><p>默认值为<code>/</code>，更改为<code>./</code>就好了</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/20190401001.png"></p><ul><li>css 中的图片路径错误，找不到图片解决如下</li></ul><p>在 css 里引入图片路径打包的时候路径会错</p><p>打开<code>build/utils.js</code>文件，把打包 css 文件的配置加一个打包路径即可</p><p>加一行代码，如下</p><p><img src="https://gitee.com/IsboyJC/PictureBed/raw/master/other/20190401002.png"></p>]]></content>
    
    
    <categories>
      
      <category>Vue相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
      <tag>Bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue打包后index.html中无引号</title>
    <link href="/blog/2018/08/26/vue/Vue%E6%89%93%E5%8C%85%E5%90%8Eindex.html%E4%B8%AD%E6%97%A0%E5%BC%95%E5%8F%B7/"/>
    <url>/blog/2018/08/26/vue/Vue%E6%89%93%E5%8C%85%E5%90%8Eindex.html%E4%B8%AD%E6%97%A0%E5%BC%95%E5%8F%B7/</url>
    
    <content type="html"><![CDATA[<p>嗯，历经了千山万水，踩过了无数个坑，终于打包成功了</p><p>点击<code>index.html</code>，报错了，打开代码一看，<code>index.html</code>中路径都不带引号，如下。。。</p><p><code>&lt;link href=/static/css/app.262f48fe370f0ecbe3bd043450d7d62e.css rel=stylesheet&gt;</code></p><p>手动加吧，可行，但是一次又一次打包都手动有点浪费时间</p><p>嗯，聪明人有办法</p><p>找打包配置吧，在<code>build</code>目录下有一个<code>webpack.prod.conf.js</code>文件</p><p>这个文件中搜索<code>minify</code>，这个对象是压缩配置</p><p>在这个对象中有一个叫<code>removeAttributeQuotes</code>的属性，就是删除属性引用的意思</p><p>它的值默认为<code>true</code>，那就直接把他改成<code>false</code>就好了</p><p>现在可以再次<code>build</code>一下试试看了</p><p>如果<code>index.html</code>中还是没有引号，就把<code>minify</code>对象都注释再<code>build</code></p><p>完美解决，perfect！！！</p>]]></content>
    
    
    <categories>
      
      <category>Vue相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
      <tag>Bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>function与感叹号</title>
    <link href="/blog/2018/06/25/js/function&amp;!/"/>
    <url>/blog/2018/06/25/js/function&amp;!/</url>
    
    <content type="html"><![CDATA[<p>相信大家都看到过在很多 js 代码中函数前面会有一个感叹号，这是什么意思呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">!(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  alert(<span class="hljs-string">&quot;我最帅！&quot;</span>)<br>&#125;)() <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>如上所示，这行代码在控制台输出，会执行 alert 语句，并返回 true，这是为什么呢？</p><p>这是一个匿名函数自调，但是它输出了，并且返回了 true，首先，解释下为什么返回 true，这个不难理解，匿名函数的返回值是<code>undefined</code>，感叹号是非的意思，前面加一个非变成<code>!undefined</code>，所以返回 true，不过重点不在这</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;alert(<span class="hljs-string">&#x27;无敌了&#x27;</span>)&#125;()<span class="hljs-comment">// 语法错误</span><br></code></pre></td></tr></table></figure><p>我们都知道，如上所示的这种写法是不对的</p><p>匿名函数自调一般我们都会采用下面两种写法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">;(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  alert(<span class="hljs-string">&quot;嗯，输出了&quot;</span>)<br>&#125;)()<br>;(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  alert(<span class="hljs-string">&quot;嗯，也输出了&quot;</span>)<br>&#125;)()<br></code></pre></td></tr></table></figure><p>那为什么上面把括号换成了感叹号的写法也可以执行匿名函数呢？</p><p>又是什么好处使多数前端攻城狮对这种叹号的方式情有独钟？ 是因为感叹号的一个字符比起括号的两个字符更节省空间吗？</p><p>节省空间显然是没有太大的说服力的，确实累死也节省不了多少内存啊，那又是为了什么呢？</p><p>首先我们来说一下为什么感叹号写法可以执行匿名函数</p><p>其实不管是括号还是感叹号的写法都是为了<strong>让 js 函数声明变成函数表达式</strong></p><p>看下面代码的解析</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-string">&#x27;我又来了&#x27;</span>&#125;()<span class="hljs-comment">// Unexpected token</span><br></code></pre></td></tr></table></figure><p>上述代码报错是为什么呢</p><p>大家都知道，<code>function()&#123;&#125;</code>是函数声明，是一个完整的语句，js 解释器在解释完这个语句后就结束了，结束后会再解析后面的<code>()</code>，而 js 语法中<code>()</code>里面是需要有表达式语句的，这里<code>()</code>里面什么都没有，所以 js 解析就会报语法错误，完整来说，就是前面的<code>function fn()&#123;&#39;我又来了&#39;&#125;</code>这句函数声明语句是没有错误的，报的错是<code>()</code>的错误，不信你可以控制台把这条语句分开输入试试</p><p>结果肯定是函数语句没错，错的是<code>()</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-string">&#x27;没错，又是我&#x27;</span>&#125;()<span class="hljs-comment">// Unexpected token</span><br></code></pre></td></tr></table></figure><p>那这条代码为什么错误呢？如上</p><p>注意这条代码和上面那条是不一样的，这条代码函数没有名字，众所周知，函数只有在函数表达式中才可以匿名，所以这里的错误是因为函数没有名字，之后的<code>()</code>根本就不会执行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> fn = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  alert(<span class="hljs-number">250</span>)<br>&#125;<br>fn()<br></code></pre></td></tr></table></figure><p>这样为什么会执行？如上</p><p>因为变量<code>fn</code>是函数表达式的引用，相当于调用了一个表达式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;<br>  alert(<span class="hljs-string">&quot;哈哈哈&quot;</span>)<br>&#125;<br>fn()<br></code></pre></td></tr></table></figure><p>这样又是为什么可以执行呢？如上</p><p>是因为<code>fn</code>是函数名，它指向了这个函数，在当前的作用域中当然可以调用了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">;(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  alert(<span class="hljs-number">111</span>)<br>&#125;)()<br></code></pre></td></tr></table></figure><p>这样为什么又可以执行呢？如上</p><p>是因为 js 语法中<code>()</code>中只能是表达式，所以上述代码强制让 js 解释器认为里面的函数是一个表达式，所以语句后面加上<code>()</code>就可以执行函数了</p><p>综上所述，想要实现调用一个函数，只需要把函数变成表达式调用就行了</p><p>那么怎样可以把函数变成表达式呢</p><p>当然，括号和文章开头的感叹号都是可以的</p><p>其实有很多种方法都可以把函数变成表达式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js">!(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  alert(<span class="hljs-number">1</span>)<br>&#125;)() + <span class="hljs-comment">// true</span><br>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  alert(<span class="hljs-number">1</span>)<br>&#125;)() - <span class="hljs-comment">// NAN</span><br>  (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    alert(<span class="hljs-number">1</span>)<br>  &#125;)() <span class="hljs-comment">// NAN</span><br><br>~(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  alert(<span class="hljs-number">1</span>)<br>&#125;)() <span class="hljs-comment">// -1</span><br><br><span class="hljs-keyword">new</span> (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  alert(<span class="hljs-number">1</span>)<br>&#125;)() <span class="hljs-comment">// Object</span><br><br><span class="hljs-keyword">delete</span> (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  alert(<span class="hljs-number">1</span>)<br>&#125;)() <span class="hljs-comment">// true</span><br><br><span class="hljs-keyword">void</span> (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  alert(<span class="hljs-number">1</span>)<br>&#125;)()(<br>  <span class="hljs-comment">// undefined</span><br><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    alert(<span class="hljs-number">1</span>)<br>  &#125;<br>)() <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><p>如上所示，这些一元运算符和关键字都可以，括号当然也没问题，并且这些写法都是合法的，唯一不同的是返回值不同罢了，但是我们的宗旨是调用匿名函数，返回值一般情况下是不需要在意的</p><p>最后是关于性能了，这些写法中，除了<code>new</code>的方式最慢(可以理解，对象嘛！！！)，括号和加减号的方式最快，其他都差不多，所以说这几种写法都是可行的，但是为什么那么多的人用感叹号不用速度快又标准的括号呢？</p><p>个人认为 q 前端攻城狮喜欢用感叹号自调用函数的原因有四：</p><ul><li><p>one</p><p>感叹号确实比<code>()</code>简单点</p></li><li><p>two</p><p>感叹号的代码可读性较强</p></li><li><p>three</p><p>个人习惯</p></li><li><p>four</p><p>写代码不喜欢写分号的开发者在函数自调用时通常喜欢用感叹号</p><p>因为感叹号可以让我们自调用函数时不写分号也不报错，它防止了代码在合并的时候发生错误</p><p>不写分号的情况下用()的方式自调用函数会报错，虽然 js 解释器会自动补全分号</p><p>为什么<code>()</code>写法会报错呢，这个问题又牵扯到了 js 代码风格了</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
